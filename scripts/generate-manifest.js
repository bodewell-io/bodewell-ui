// packages/ui/scripts/generate-manifest.js
const fs = require('fs');
const path = require('path');
const doctrine = require('doctrine');

// Function to find all relevant source files
const getSourceFiles = (dir) => {
  let files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });
  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    if (item.isDirectory()) {
      files = [...files, ...getSourceFiles(fullPath)];
    } else if (item.name.endsWith('.tsx') || item.name.endsWith('.ts')) {
      // Exclude test files and storybook files
      if (!item.name.endsWith('.test.tsx') && !item.name.endsWith('.stories.tsx')) {
        files.push(fullPath);
      }
    }
  }
  return files;
};

// Function to parse the JSDoc comments from a file's content
const parseJsDoc = (content) => {
  const docRegex = /\/\*\*\s*@wizard([\s\S]*?)\*\//g;
  const entries = [];
  let match;

  while ((match = docRegex.exec(content)) !== null) {
    const jsdoc = `/**${match[1]}*/`;
    const ast = doctrine.parse(jsdoc, { unwrap: true, sloppy: true });
    
    const entry = {
      name: '',
      description: ast.description || '',
      tags: [],
      category: '',
      props: [],
    };

    for (const tag of ast.tags) {
      switch (tag.title) {
        case 'name':
          entry.name = tag.description;
          break;
        case 'description':
          entry.description = tag.description;
          break;
        case 'tags':
          entry.tags = tag.description.split(',').map(t => t.trim());
          break;
        case 'category':
          entry.category = tag.description;
          break;
        case 'props':
          // Handle multi-line YAML-like props
          entry.props = tag.description.split('\\n- ').map(propStr => {
            if (!propStr.trim()) return null;
            const propLines = propStr.trim().split('\\n');
            const prop = {};
            propLines.forEach(line => {
              const [key, ...valueParts] = line.split(':');
              const value = valueParts.join(':').trim();
              if (key && value) {
                prop[key.trim().replace('-', '')] = value;
              }
            });
            return prop;
          }).filter(Boolean);
          break;
      }
    }
    
    if (entry.name && entry.category) {
      entries.push(entry);
    }
  }

  return entries;
};

// Main function to build and write the manifest
const buildManifest = () => {
  const manifest = {
    components: [],
    layouts: [],
    utils: [],
    hooks: [],
    data: [],
  };

  const srcDir = path.resolve(__dirname, '../src');
  const files = getSourceFiles(srcDir);

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf-8');
    const entries = parseJsDoc(content);
    const filePath = path.relative(path.join(__dirname, '..'), file).replace(/\\\\/g, '/');

    for (const entry of entries) {
      entry.filePath = filePath;
      if (manifest[entry.category]) {
        manifest[entry.category].push(entry);
      } else if (entry.category) {
        // If the category is not a pre-defined key, add it to components as a fallback
        manifest.components.push(entry);
      }
    }
  }

  const manifestContent = `
// This file is auto-generated by scripts/generate-manifest.js
// Do not modify this file directly.

import type { WizardManifest } from './src/types/wizard';

export const wizardManifest: WizardManifest = ${JSON.stringify(manifest, null, 2)} as const;
`;

  fs.writeFileSync(path.resolve(__dirname, '../wizardManifest.ts'), manifestContent.trim());
  console.log('Wizard manifest generated successfully!');
};

// We need to install doctrine: pnpm install -D doctrine @types/doctrine
// For the script to run, we first need to handle the dependencies.
try {
  require('doctrine');
} catch (e) {
  console.error('Doctrine not found. Please run: pnpm add -D doctrine @types/doctrine');
  process.exit(1);
}

buildManifest();