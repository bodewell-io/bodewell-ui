var E1 = Object.defineProperty;
var x1 = (e, t, r) => t in e ? E1(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var me = (e, t, r) => x1(e, typeof t != "symbol" ? t + "" : t, r);
import { jsx as H, jsxs as ve, Fragment as kP } from "react/jsx-runtime";
import * as Y from "react";
import D, { isValidElement as cn, Children as Ws, PureComponent as vn, forwardRef as ns, useRef as re, useImperativeHandle as jg, useState as ee, useCallback as fe, useEffect as gt, useMemo as Ee, cloneElement as Gt, createElement as zc, useContext as bt, createContext as Cn, Component as $t, memo as $r, useLayoutEffect as Vi, createRef as Ko, Fragment as KC } from "react";
import * as A1 from "react-dom";
import qp, { createPortal as xa } from "react-dom";
import { renderToStaticMarkup as D1 } from "react-dom/server";
function VP(e) {
  var t, r, i = "";
  if (typeof e == "string" || typeof e == "number") i += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var n = e.length;
    for (t = 0; t < n; t++) e[t] && (r = VP(e[t])) && (i && (i += " "), i += r);
  } else for (r in e) e[r] && (i && (i += " "), i += r);
  return i;
}
function xe() {
  for (var e, t, r = 0, i = "", n = arguments.length; r < n; r++) (e = arguments[r]) && (t = VP(e)) && (i && (i += " "), i += t);
  return i;
}
var qh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ct(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var T1 = Array.isArray, oi = T1, R1 = typeof qh == "object" && qh && qh.Object === Object && qh, HP = R1, P1 = HP, I1 = typeof self == "object" && self && self.Object === Object && self, O1 = P1 || I1 || Function("return this")(), Zn = O1, M1 = Zn, F1 = M1.Symbol, lh = F1, Sx = lh, BP = Object.prototype, _1 = BP.hasOwnProperty, N1 = BP.toString, nc = Sx ? Sx.toStringTag : void 0;
function L1(e) {
  var t = _1.call(e, nc), r = e[nc];
  try {
    e[nc] = void 0;
    var i = !0;
  } catch {
  }
  var n = N1.call(e);
  return i && (t ? e[nc] = r : delete e[nc]), n;
}
var G1 = L1, k1 = Object.prototype, V1 = k1.toString;
function H1(e) {
  return V1.call(e);
}
var B1 = H1, Ex = lh, W1 = G1, $1 = B1, j1 = "[object Null]", z1 = "[object Undefined]", xx = Ex ? Ex.toStringTag : void 0;
function U1(e) {
  return e == null ? e === void 0 ? z1 : j1 : xx && xx in Object(e) ? W1(e) : $1(e);
}
var Do = U1;
function Y1(e) {
  return e != null && typeof e == "object";
}
var To = Y1, X1 = Do, K1 = To, q1 = "[object Symbol]";
function Z1(e) {
  return typeof e == "symbol" || K1(e) && X1(e) == q1;
}
var Eu = Z1, J1 = oi, Q1 = Eu, ek = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, tk = /^\w*$/;
function rk(e, t) {
  if (J1(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Q1(e) ? !0 : tk.test(e) || !ek.test(e) || t != null && e in Object(t);
}
var xw = rk;
function ik(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var os = ik;
const xu = /* @__PURE__ */ Ct(os);
var nk = Do, ok = os, sk = "[object AsyncFunction]", ak = "[object Function]", lk = "[object GeneratorFunction]", uk = "[object Proxy]";
function ck(e) {
  if (!ok(e))
    return !1;
  var t = nk(e);
  return t == ak || t == lk || t == sk || t == uk;
}
var Aw = ck;
const Le = /* @__PURE__ */ Ct(Aw);
var dk = Zn, hk = dk["__core-js_shared__"], pk = hk, Dv = pk, Ax = function() {
  var e = /[^.]+$/.exec(Dv && Dv.keys && Dv.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function fk(e) {
  return !!Ax && Ax in e;
}
var gk = fk, mk = Function.prototype, vk = mk.toString;
function Ck(e) {
  if (e != null) {
    try {
      return vk.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var WP = Ck, yk = Aw, bk = gk, wk = os, Sk = WP, Ek = /[\\^$.*+?()[\]{}|]/g, xk = /^\[object .+?Constructor\]$/, Ak = Function.prototype, Dk = Object.prototype, Tk = Ak.toString, Rk = Dk.hasOwnProperty, Pk = RegExp(
  "^" + Tk.call(Rk).replace(Ek, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ik(e) {
  if (!wk(e) || bk(e))
    return !1;
  var t = yk(e) ? Pk : xk;
  return t.test(Sk(e));
}
var Ok = Ik;
function Mk(e, t) {
  return e == null ? void 0 : e[t];
}
var Fk = Mk, _k = Ok, Nk = Fk;
function Lk(e, t) {
  var r = Nk(e, t);
  return _k(r) ? r : void 0;
}
var Aa = Lk, Gk = Aa, kk = Gk(Object, "create"), zg = kk, Dx = zg;
function Vk() {
  this.__data__ = Dx ? Dx(null) : {}, this.size = 0;
}
var Hk = Vk;
function Bk(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Wk = Bk, $k = zg, jk = "__lodash_hash_undefined__", zk = Object.prototype, Uk = zk.hasOwnProperty;
function Yk(e) {
  var t = this.__data__;
  if ($k) {
    var r = t[e];
    return r === jk ? void 0 : r;
  }
  return Uk.call(t, e) ? t[e] : void 0;
}
var Xk = Yk, Kk = zg, qk = Object.prototype, Zk = qk.hasOwnProperty;
function Jk(e) {
  var t = this.__data__;
  return Kk ? t[e] !== void 0 : Zk.call(t, e);
}
var Qk = Jk, eV = zg, tV = "__lodash_hash_undefined__";
function rV(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = eV && t === void 0 ? tV : t, this;
}
var iV = rV, nV = Hk, oV = Wk, sV = Xk, aV = Qk, lV = iV;
function Au(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Au.prototype.clear = nV;
Au.prototype.delete = oV;
Au.prototype.get = sV;
Au.prototype.has = aV;
Au.prototype.set = lV;
var uV = Au;
function cV() {
  this.__data__ = [], this.size = 0;
}
var dV = cV;
function hV(e, t) {
  return e === t || e !== e && t !== t;
}
var Dw = hV, pV = Dw;
function fV(e, t) {
  for (var r = e.length; r--; )
    if (pV(e[r][0], t))
      return r;
  return -1;
}
var Ug = fV, gV = Ug, mV = Array.prototype, vV = mV.splice;
function CV(e) {
  var t = this.__data__, r = gV(t, e);
  if (r < 0)
    return !1;
  var i = t.length - 1;
  return r == i ? t.pop() : vV.call(t, r, 1), --this.size, !0;
}
var yV = CV, bV = Ug;
function wV(e) {
  var t = this.__data__, r = bV(t, e);
  return r < 0 ? void 0 : t[r][1];
}
var SV = wV, EV = Ug;
function xV(e) {
  return EV(this.__data__, e) > -1;
}
var AV = xV, DV = Ug;
function TV(e, t) {
  var r = this.__data__, i = DV(r, e);
  return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this;
}
var RV = TV, PV = dV, IV = yV, OV = SV, MV = AV, FV = RV;
function Du(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Du.prototype.clear = PV;
Du.prototype.delete = IV;
Du.prototype.get = OV;
Du.prototype.has = MV;
Du.prototype.set = FV;
var Yg = Du, _V = Aa, NV = Zn, LV = _V(NV, "Map"), Tw = LV, Tx = uV, GV = Yg, kV = Tw;
function VV() {
  this.size = 0, this.__data__ = {
    hash: new Tx(),
    map: new (kV || GV)(),
    string: new Tx()
  };
}
var HV = VV;
function BV(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var WV = BV, $V = WV;
function jV(e, t) {
  var r = e.__data__;
  return $V(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
var Xg = jV, zV = Xg;
function UV(e) {
  var t = zV(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var YV = UV, XV = Xg;
function KV(e) {
  return XV(this, e).get(e);
}
var qV = KV, ZV = Xg;
function JV(e) {
  return ZV(this, e).has(e);
}
var QV = JV, eH = Xg;
function tH(e, t) {
  var r = eH(this, e), i = r.size;
  return r.set(e, t), this.size += r.size == i ? 0 : 1, this;
}
var rH = tH, iH = HV, nH = YV, oH = qV, sH = QV, aH = rH;
function Tu(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Tu.prototype.clear = iH;
Tu.prototype.delete = nH;
Tu.prototype.get = oH;
Tu.prototype.has = sH;
Tu.prototype.set = aH;
var Rw = Tu, $P = Rw, lH = "Expected a function";
function Pw(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(lH);
  var r = function() {
    var i = arguments, n = t ? t.apply(this, i) : i[0], o = r.cache;
    if (o.has(n))
      return o.get(n);
    var s = e.apply(this, i);
    return r.cache = o.set(n, s) || o, s;
  };
  return r.cache = new (Pw.Cache || $P)(), r;
}
Pw.Cache = $P;
var jP = Pw;
const uH = /* @__PURE__ */ Ct(jP);
var cH = jP, dH = 500;
function hH(e) {
  var t = cH(e, function(i) {
    return r.size === dH && r.clear(), i;
  }), r = t.cache;
  return t;
}
var pH = hH, fH = pH, gH = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, mH = /\\(\\)?/g, vH = fH(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(gH, function(r, i, n, o) {
    t.push(n ? o.replace(mH, "$1") : i || r);
  }), t;
}), CH = vH;
function yH(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length, n = Array(i); ++r < i; )
    n[r] = t(e[r], r, e);
  return n;
}
var Iw = yH, Rx = lh, bH = Iw, wH = oi, SH = Eu, Px = Rx ? Rx.prototype : void 0, Ix = Px ? Px.toString : void 0;
function zP(e) {
  if (typeof e == "string")
    return e;
  if (wH(e))
    return bH(e, zP) + "";
  if (SH(e))
    return Ix ? Ix.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var EH = zP, xH = EH;
function AH(e) {
  return e == null ? "" : xH(e);
}
var UP = AH, DH = oi, TH = xw, RH = CH, PH = UP;
function IH(e, t) {
  return DH(e) ? e : TH(e, t) ? [e] : RH(PH(e));
}
var YP = IH, OH = Eu;
function MH(e) {
  if (typeof e == "string" || OH(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var Kg = MH, FH = YP, _H = Kg;
function NH(e, t) {
  t = FH(t, e);
  for (var r = 0, i = t.length; e != null && r < i; )
    e = e[_H(t[r++])];
  return r && r == i ? e : void 0;
}
var Ow = NH, LH = Ow;
function GH(e, t, r) {
  var i = e == null ? void 0 : LH(e, t);
  return i === void 0 ? r : i;
}
var XP = GH;
const vi = /* @__PURE__ */ Ct(XP);
function kH(e) {
  return e == null;
}
var VH = kH;
const ke = /* @__PURE__ */ Ct(VH);
var HH = Do, BH = oi, WH = To, $H = "[object String]";
function jH(e) {
  return typeof e == "string" || !BH(e) && WH(e) && HH(e) == $H;
}
var zH = jH;
const ia = /* @__PURE__ */ Ct(zH);
var qC = { exports: {} }, nt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ox;
function UH() {
  if (Ox) return nt;
  Ox = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), n = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g;
  g = Symbol.for("react.module.reference");
  function m(f) {
    if (typeof f == "object" && f !== null) {
      var C = f.$$typeof;
      switch (C) {
        case e:
          switch (f = f.type, f) {
            case r:
            case n:
            case i:
            case u:
            case c:
              return f;
            default:
              switch (f = f && f.$$typeof, f) {
                case a:
                case s:
                case l:
                case h:
                case d:
                case o:
                  return f;
                default:
                  return C;
              }
          }
        case t:
          return C;
      }
    }
  }
  return nt.ContextConsumer = s, nt.ContextProvider = o, nt.Element = e, nt.ForwardRef = l, nt.Fragment = r, nt.Lazy = h, nt.Memo = d, nt.Portal = t, nt.Profiler = n, nt.StrictMode = i, nt.Suspense = u, nt.SuspenseList = c, nt.isAsyncMode = function() {
    return !1;
  }, nt.isConcurrentMode = function() {
    return !1;
  }, nt.isContextConsumer = function(f) {
    return m(f) === s;
  }, nt.isContextProvider = function(f) {
    return m(f) === o;
  }, nt.isElement = function(f) {
    return typeof f == "object" && f !== null && f.$$typeof === e;
  }, nt.isForwardRef = function(f) {
    return m(f) === l;
  }, nt.isFragment = function(f) {
    return m(f) === r;
  }, nt.isLazy = function(f) {
    return m(f) === h;
  }, nt.isMemo = function(f) {
    return m(f) === d;
  }, nt.isPortal = function(f) {
    return m(f) === t;
  }, nt.isProfiler = function(f) {
    return m(f) === n;
  }, nt.isStrictMode = function(f) {
    return m(f) === i;
  }, nt.isSuspense = function(f) {
    return m(f) === u;
  }, nt.isSuspenseList = function(f) {
    return m(f) === c;
  }, nt.isValidElementType = function(f) {
    return typeof f == "string" || typeof f == "function" || f === r || f === n || f === i || f === u || f === c || f === p || typeof f == "object" && f !== null && (f.$$typeof === h || f.$$typeof === d || f.$$typeof === o || f.$$typeof === s || f.$$typeof === l || f.$$typeof === g || f.getModuleId !== void 0);
  }, nt.typeOf = m, nt;
}
var ot = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mx;
function YH() {
  return Mx || (Mx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), n = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g = !1, m = !1, f = !1, C = !1, w = !1, E;
    E = Symbol.for("react.module.reference");
    function b(X) {
      return !!(typeof X == "string" || typeof X == "function" || X === r || X === n || w || X === i || X === u || X === c || C || X === p || g || m || f || typeof X == "object" && X !== null && (X.$$typeof === h || X.$$typeof === d || X.$$typeof === o || X.$$typeof === s || X.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      X.$$typeof === E || X.getModuleId !== void 0));
    }
    function y(X) {
      if (typeof X == "object" && X !== null) {
        var Te = X.$$typeof;
        switch (Te) {
          case e:
            var He = X.type;
            switch (He) {
              case r:
              case n:
              case i:
              case u:
              case c:
                return He;
              default:
                var je = He && He.$$typeof;
                switch (je) {
                  case a:
                  case s:
                  case l:
                  case h:
                  case d:
                  case o:
                    return je;
                  default:
                    return Te;
                }
            }
          case t:
            return Te;
        }
      }
    }
    var S = s, x = o, R = e, P = l, O = r, I = h, M = d, _ = t, G = n, F = i, N = u, V = c, B = !1, $ = !1;
    function L(X) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function z(X) {
      return $ || ($ = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function j(X) {
      return y(X) === s;
    }
    function U(X) {
      return y(X) === o;
    }
    function oe(X) {
      return typeof X == "object" && X !== null && X.$$typeof === e;
    }
    function ie(X) {
      return y(X) === l;
    }
    function le(X) {
      return y(X) === r;
    }
    function ce(X) {
      return y(X) === h;
    }
    function he(X) {
      return y(X) === d;
    }
    function Z(X) {
      return y(X) === t;
    }
    function se(X) {
      return y(X) === n;
    }
    function ae(X) {
      return y(X) === i;
    }
    function W(X) {
      return y(X) === u;
    }
    function be(X) {
      return y(X) === c;
    }
    ot.ContextConsumer = S, ot.ContextProvider = x, ot.Element = R, ot.ForwardRef = P, ot.Fragment = O, ot.Lazy = I, ot.Memo = M, ot.Portal = _, ot.Profiler = G, ot.StrictMode = F, ot.Suspense = N, ot.SuspenseList = V, ot.isAsyncMode = L, ot.isConcurrentMode = z, ot.isContextConsumer = j, ot.isContextProvider = U, ot.isElement = oe, ot.isForwardRef = ie, ot.isFragment = le, ot.isLazy = ce, ot.isMemo = he, ot.isPortal = Z, ot.isProfiler = se, ot.isStrictMode = ae, ot.isSuspense = W, ot.isSuspenseList = be, ot.isValidElementType = b, ot.typeOf = y;
  }()), ot;
}
process.env.NODE_ENV === "production" ? qC.exports = UH() : qC.exports = YH();
var XH = qC.exports, KH = Do, qH = To, ZH = "[object Number]";
function JH(e) {
  return typeof e == "number" || qH(e) && KH(e) == ZH;
}
var KP = JH;
const QH = /* @__PURE__ */ Ct(KP);
var eB = KP;
function tB(e) {
  return eB(e) && e != +e;
}
var rB = tB;
const uh = /* @__PURE__ */ Ct(rB);
var Nr = function(t) {
  return t === 0 ? 0 : t > 0 ? 1 : -1;
}, _s = function(t) {
  return ia(t) && t.indexOf("%") === t.length - 1;
}, ue = function(t) {
  return QH(t) && !uh(t);
}, iB = function(t) {
  return ke(t);
}, dr = function(t) {
  return ue(t) || ia(t);
}, nB = 0, Ru = function(t) {
  var r = ++nB;
  return "".concat(t || "").concat(r);
}, Lr = function(t, r) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!ue(t) && !ia(t))
    return i;
  var o;
  if (_s(t)) {
    var s = t.indexOf("%");
    o = r * parseFloat(t.slice(0, s)) / 100;
  } else
    o = +t;
  return uh(o) && (o = i), n && o > r && (o = r), o;
}, Bo = function(t) {
  if (!t)
    return null;
  var r = Object.keys(t);
  return r && r.length ? t[r[0]] : null;
}, oB = function(t) {
  if (!Array.isArray(t))
    return !1;
  for (var r = t.length, i = {}, n = 0; n < r; n++)
    if (!i[t[n]])
      i[t[n]] = !0;
    else
      return !0;
  return !1;
}, fi = function(t, r) {
  return ue(t) && ue(r) ? function(i) {
    return t + i * (r - t);
  } : function() {
    return r;
  };
};
function Zp(e, t, r) {
  return !e || !e.length ? null : e.find(function(i) {
    return i && (typeof t == "function" ? t(i) : vi(i, t)) === r;
  });
}
var sB = function(t, r) {
  return ue(t) && ue(r) ? t - r : ia(t) && ia(r) ? t.localeCompare(r) : t instanceof Date && r instanceof Date ? t.getTime() - r.getTime() : String(t).localeCompare(String(r));
};
function pl(e, t) {
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r) && (!{}.hasOwnProperty.call(t, r) || e[r] !== t[r]))
      return !1;
  for (var i in t)
    if ({}.hasOwnProperty.call(t, i) && !{}.hasOwnProperty.call(e, i))
      return !1;
  return !0;
}
function ZC(e) {
  "@babel/helpers - typeof";
  return ZC = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ZC(e);
}
var aB = ["viewBox", "children"], lB = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
], Fx = ["points", "pathLength"], Tv = {
  svg: aB,
  polygon: Fx,
  polyline: Fx
}, Mw = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], Jp = function(t, r) {
  if (!t || typeof t == "function" || typeof t == "boolean")
    return null;
  var i = t;
  if (/* @__PURE__ */ cn(t) && (i = t.props), !xu(i))
    return null;
  var n = {};
  return Object.keys(i).forEach(function(o) {
    Mw.includes(o) && (n[o] = r || function(s) {
      return i[o](i, s);
    });
  }), n;
}, uB = function(t, r, i) {
  return function(n) {
    return t(r, i, n), null;
  };
}, na = function(t, r, i) {
  if (!xu(t) || ZC(t) !== "object")
    return null;
  var n = null;
  return Object.keys(t).forEach(function(o) {
    var s = t[o];
    Mw.includes(o) && typeof s == "function" && (n || (n = {}), n[o] = uB(s, r, i));
  }), n;
}, cB = ["children"], dB = ["children"];
function _x(e, t) {
  if (e == null) return {};
  var r = hB(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function hB(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function JC(e) {
  "@babel/helpers - typeof";
  return JC = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, JC(e);
}
var Nx = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick"
}, lo = function(t) {
  return typeof t == "string" ? t : t ? t.displayName || t.name || "Component" : "";
}, Lx = null, Rv = null, Fw = function e(t) {
  if (t === Lx && Array.isArray(Rv))
    return Rv;
  var r = [];
  return Ws.forEach(t, function(i) {
    ke(i) || (XH.isFragment(i) ? r = r.concat(e(i.props.children)) : r.push(i));
  }), Rv = r, Lx = t, r;
};
function Ci(e, t) {
  var r = [], i = [];
  return Array.isArray(t) ? i = t.map(function(n) {
    return lo(n);
  }) : i = [lo(t)], Fw(e).forEach(function(n) {
    var o = vi(n, "type.displayName") || vi(n, "type.name");
    i.indexOf(o) !== -1 && r.push(n);
  }), r;
}
function hi(e, t) {
  var r = Ci(e, t);
  return r && r[0];
}
var Gx = function(t) {
  if (!t || !t.props)
    return !1;
  var r = t.props, i = r.width, n = r.height;
  return !(!ue(i) || i <= 0 || !ue(n) || n <= 0);
}, pB = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"], fB = function(t) {
  return t && t.type && ia(t.type) && pB.indexOf(t.type) >= 0;
}, gB = function(t) {
  return t && JC(t) === "object" && "clipDot" in t;
}, mB = function(t, r, i, n) {
  var o, s = (o = Tv == null ? void 0 : Tv[n]) !== null && o !== void 0 ? o : [];
  return r.startsWith("data-") || !Le(t) && (n && s.includes(r) || lB.includes(r)) || i && Mw.includes(r);
}, Ie = function(t, r, i) {
  if (!t || typeof t == "function" || typeof t == "boolean")
    return null;
  var n = t;
  if (/* @__PURE__ */ cn(t) && (n = t.props), !xu(n))
    return null;
  var o = {};
  return Object.keys(n).forEach(function(s) {
    var a;
    mB((a = n) === null || a === void 0 ? void 0 : a[s], s, r, i) && (o[s] = n[s]);
  }), o;
}, QC = function e(t, r) {
  if (t === r)
    return !0;
  var i = Ws.count(t);
  if (i !== Ws.count(r))
    return !1;
  if (i === 0)
    return !0;
  if (i === 1)
    return kx(Array.isArray(t) ? t[0] : t, Array.isArray(r) ? r[0] : r);
  for (var n = 0; n < i; n++) {
    var o = t[n], s = r[n];
    if (Array.isArray(o) || Array.isArray(s)) {
      if (!e(o, s))
        return !1;
    } else if (!kx(o, s))
      return !1;
  }
  return !0;
}, kx = function(t, r) {
  if (ke(t) && ke(r))
    return !0;
  if (!ke(t) && !ke(r)) {
    var i = t.props || {}, n = i.children, o = _x(i, cB), s = r.props || {}, a = s.children, l = _x(s, dB);
    return n && a ? pl(o, l) && QC(n, a) : !n && !a ? pl(o, l) : !1;
  }
  return !1;
}, Vx = function(t, r) {
  var i = [], n = {};
  return Fw(t).forEach(function(o, s) {
    if (fB(o))
      i.push(o);
    else if (o) {
      var a = lo(o.type), l = r[a] || {}, u = l.handler, c = l.once;
      if (u && (!c || !n[a])) {
        var d = u(o, a, s);
        i.push(d), n[a] = !0;
      }
    }
  }), i;
}, vB = function(t) {
  var r = t && t.type;
  return r && Nx[r] ? Nx[r] : null;
}, CB = function(t, r) {
  return Fw(r).indexOf(t);
}, yB = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function ey() {
  return ey = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ey.apply(this, arguments);
}
function bB(e, t) {
  if (e == null) return {};
  var r = wB(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function wB(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function ty(e) {
  var t = e.children, r = e.width, i = e.height, n = e.viewBox, o = e.className, s = e.style, a = e.title, l = e.desc, u = bB(e, yB), c = n || {
    width: r,
    height: i,
    x: 0,
    y: 0
  }, d = xe("recharts-surface", o);
  return /* @__PURE__ */ D.createElement("svg", ey({}, Ie(u, !0, "svg"), {
    className: d,
    width: r,
    height: i,
    style: s,
    viewBox: "".concat(c.x, " ").concat(c.y, " ").concat(c.width, " ").concat(c.height)
  }), /* @__PURE__ */ D.createElement("title", null, a), /* @__PURE__ */ D.createElement("desc", null, l), t);
}
var SB = ["children", "className"];
function ry() {
  return ry = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ry.apply(this, arguments);
}
function EB(e, t) {
  if (e == null) return {};
  var r = xB(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function xB(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
var Ze = /* @__PURE__ */ D.forwardRef(function(e, t) {
  var r = e.children, i = e.className, n = EB(e, SB), o = xe("recharts-layer", i);
  return /* @__PURE__ */ D.createElement("g", ry({
    className: o
  }, Ie(n, !0), {
    ref: t
  }), r);
}), AB = process.env.NODE_ENV !== "production", dn = function(t, r) {
  for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)
    n[o - 2] = arguments[o];
  if (AB && typeof console < "u" && console.warn && (r === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (r === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var s = 0;
      console.warn(r.replace(/%s/g, function() {
        return n[s++];
      }));
    }
};
function DB(e, t, r) {
  var i = -1, n = e.length;
  t < 0 && (t = -t > n ? 0 : n + t), r = r > n ? n : r, r < 0 && (r += n), n = t > r ? 0 : r - t >>> 0, t >>>= 0;
  for (var o = Array(n); ++i < n; )
    o[i] = e[i + t];
  return o;
}
var TB = DB, RB = TB;
function PB(e, t, r) {
  var i = e.length;
  return r = r === void 0 ? i : r, !t && r >= i ? e : RB(e, t, r);
}
var IB = PB, OB = "\\ud800-\\udfff", MB = "\\u0300-\\u036f", FB = "\\ufe20-\\ufe2f", _B = "\\u20d0-\\u20ff", NB = MB + FB + _B, LB = "\\ufe0e\\ufe0f", GB = "\\u200d", kB = RegExp("[" + GB + OB + NB + LB + "]");
function VB(e) {
  return kB.test(e);
}
var qP = VB;
function HB(e) {
  return e.split("");
}
var BB = HB, ZP = "\\ud800-\\udfff", WB = "\\u0300-\\u036f", $B = "\\ufe20-\\ufe2f", jB = "\\u20d0-\\u20ff", zB = WB + $B + jB, UB = "\\ufe0e\\ufe0f", YB = "[" + ZP + "]", iy = "[" + zB + "]", ny = "\\ud83c[\\udffb-\\udfff]", XB = "(?:" + iy + "|" + ny + ")", JP = "[^" + ZP + "]", QP = "(?:\\ud83c[\\udde6-\\uddff]){2}", eI = "[\\ud800-\\udbff][\\udc00-\\udfff]", KB = "\\u200d", tI = XB + "?", rI = "[" + UB + "]?", qB = "(?:" + KB + "(?:" + [JP, QP, eI].join("|") + ")" + rI + tI + ")*", ZB = rI + tI + qB, JB = "(?:" + [JP + iy + "?", iy, QP, eI, YB].join("|") + ")", QB = RegExp(ny + "(?=" + ny + ")|" + JB + ZB, "g");
function eW(e) {
  return e.match(QB) || [];
}
var tW = eW, rW = BB, iW = qP, nW = tW;
function oW(e) {
  return iW(e) ? nW(e) : rW(e);
}
var sW = oW, aW = IB, lW = qP, uW = sW, cW = UP;
function dW(e) {
  return function(t) {
    t = cW(t);
    var r = lW(t) ? uW(t) : void 0, i = r ? r[0] : t.charAt(0), n = r ? aW(r, 1).join("") : t.slice(1);
    return i[e]() + n;
  };
}
var hW = dW, pW = hW, fW = pW("toUpperCase"), gW = fW;
const qg = /* @__PURE__ */ Ct(gW);
function xt(e) {
  return function() {
    return e;
  };
}
const iI = Math.cos, Qp = Math.sin, yn = Math.sqrt, ef = Math.PI, Zg = 2 * ef, oy = Math.PI, sy = 2 * oy, xs = 1e-6, mW = sy - xs;
function nI(e) {
  this._ += e[0];
  for (let t = 1, r = e.length; t < r; ++t)
    this._ += arguments[t] + e[t];
}
function vW(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return nI;
  const r = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let n = 1, o = i.length; n < o; ++n)
      this._ += Math.round(arguments[n] * r) / r + i[n];
  };
}
class CW {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? nI : vW(t);
  }
  moveTo(t, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, r) {
    this._append`L${this._x1 = +t},${this._y1 = +r}`;
  }
  quadraticCurveTo(t, r, i, n) {
    this._append`Q${+t},${+r},${this._x1 = +i},${this._y1 = +n}`;
  }
  bezierCurveTo(t, r, i, n, o, s) {
    this._append`C${+t},${+r},${+i},${+n},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, r, i, n, o) {
    if (t = +t, r = +r, i = +i, n = +n, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, a = this._y1, l = i - t, u = n - r, c = s - t, d = a - r, h = c * c + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = r}`;
    else if (h > xs) if (!(Math.abs(d * l - u * c) > xs) || !o)
      this._append`L${this._x1 = t},${this._y1 = r}`;
    else {
      let p = i - s, g = n - a, m = l * l + u * u, f = p * p + g * g, C = Math.sqrt(m), w = Math.sqrt(h), E = o * Math.tan((oy - Math.acos((m + h - f) / (2 * C * w))) / 2), b = E / w, y = E / C;
      Math.abs(b - 1) > xs && this._append`L${t + b * c},${r + b * d}`, this._append`A${o},${o},0,0,${+(d * p > c * g)},${this._x1 = t + y * l},${this._y1 = r + y * u}`;
    }
  }
  arc(t, r, i, n, o, s) {
    if (t = +t, r = +r, i = +i, s = !!s, i < 0) throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(n), l = i * Math.sin(n), u = t + a, c = r + l, d = 1 ^ s, h = s ? n - o : o - n;
    this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > xs || Math.abs(this._y1 - c) > xs) && this._append`L${u},${c}`, i && (h < 0 && (h = h % sy + sy), h > mW ? this._append`A${i},${i},0,1,${d},${t - a},${r - l}A${i},${i},0,1,${d},${this._x1 = u},${this._y1 = c}` : h > xs && this._append`A${i},${i},0,${+(h >= oy)},${d},${this._x1 = t + i * Math.cos(o)},${this._y1 = r + i * Math.sin(o)}`);
  }
  rect(t, r, i, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${i = +i}v${+n}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function _w(e) {
  let t = 3;
  return e.digits = function(r) {
    if (!arguments.length) return t;
    if (r == null)
      t = null;
    else {
      const i = Math.floor(r);
      if (!(i >= 0)) throw new RangeError(`invalid digits: ${r}`);
      t = i;
    }
    return e;
  }, () => new CW(t);
}
function Nw(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function oI(e) {
  this._context = e;
}
oI.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Jg(e) {
  return new oI(e);
}
function sI(e) {
  return e[0];
}
function aI(e) {
  return e[1];
}
function lI(e, t) {
  var r = xt(!0), i = null, n = Jg, o = null, s = _w(a);
  e = typeof e == "function" ? e : e === void 0 ? sI : xt(e), t = typeof t == "function" ? t : t === void 0 ? aI : xt(t);
  function a(l) {
    var u, c = (l = Nw(l)).length, d, h = !1, p;
    for (i == null && (o = n(p = s())), u = 0; u <= c; ++u)
      !(u < c && r(d = l[u], u, l)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()), h && o.point(+e(d, u, l), +t(d, u, l));
    if (p) return o = null, p + "" || null;
  }
  return a.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : xt(+l), a) : e;
  }, a.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : xt(+l), a) : t;
  }, a.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : xt(!!l), a) : r;
  }, a.curve = function(l) {
    return arguments.length ? (n = l, i != null && (o = n(i)), a) : n;
  }, a.context = function(l) {
    return arguments.length ? (l == null ? i = o = null : o = n(i = l), a) : i;
  }, a;
}
function Zh(e, t, r) {
  var i = null, n = xt(!0), o = null, s = Jg, a = null, l = _w(u);
  e = typeof e == "function" ? e : e === void 0 ? sI : xt(+e), t = typeof t == "function" ? t : xt(t === void 0 ? 0 : +t), r = typeof r == "function" ? r : r === void 0 ? aI : xt(+r);
  function u(d) {
    var h, p, g, m = (d = Nw(d)).length, f, C = !1, w, E = new Array(m), b = new Array(m);
    for (o == null && (a = s(w = l())), h = 0; h <= m; ++h) {
      if (!(h < m && n(f = d[h], h, d)) === C)
        if (C = !C)
          p = h, a.areaStart(), a.lineStart();
        else {
          for (a.lineEnd(), a.lineStart(), g = h - 1; g >= p; --g)
            a.point(E[g], b[g]);
          a.lineEnd(), a.areaEnd();
        }
      C && (E[h] = +e(f, h, d), b[h] = +t(f, h, d), a.point(i ? +i(f, h, d) : E[h], r ? +r(f, h, d) : b[h]));
    }
    if (w) return a = null, w + "" || null;
  }
  function c() {
    return lI().defined(n).curve(s).context(o);
  }
  return u.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : xt(+d), i = null, u) : e;
  }, u.x0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : xt(+d), u) : e;
  }, u.x1 = function(d) {
    return arguments.length ? (i = d == null ? null : typeof d == "function" ? d : xt(+d), u) : i;
  }, u.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : xt(+d), r = null, u) : t;
  }, u.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : xt(+d), u) : t;
  }, u.y1 = function(d) {
    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : xt(+d), u) : r;
  }, u.lineX0 = u.lineY0 = function() {
    return c().x(e).y(t);
  }, u.lineY1 = function() {
    return c().x(e).y(r);
  }, u.lineX1 = function() {
    return c().x(i).y(t);
  }, u.defined = function(d) {
    return arguments.length ? (n = typeof d == "function" ? d : xt(!!d), u) : n;
  }, u.curve = function(d) {
    return arguments.length ? (s = d, o != null && (a = s(o)), u) : s;
  }, u.context = function(d) {
    return arguments.length ? (d == null ? o = a = null : a = s(o = d), u) : o;
  }, u;
}
class uI {
  constructor(t, r) {
    this._context = t, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, r) {
    switch (t = +t, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, r, t, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, t, this._y0, t, r);
        break;
      }
    }
    this._x0 = t, this._y0 = r;
  }
}
function yW(e) {
  return new uI(e, !0);
}
function bW(e) {
  return new uI(e, !1);
}
const Lw = {
  draw(e, t) {
    const r = yn(t / ef);
    e.moveTo(r, 0), e.arc(0, 0, r, 0, Zg);
  }
}, wW = {
  draw(e, t) {
    const r = yn(t / 5) / 2;
    e.moveTo(-3 * r, -r), e.lineTo(-r, -r), e.lineTo(-r, -3 * r), e.lineTo(r, -3 * r), e.lineTo(r, -r), e.lineTo(3 * r, -r), e.lineTo(3 * r, r), e.lineTo(r, r), e.lineTo(r, 3 * r), e.lineTo(-r, 3 * r), e.lineTo(-r, r), e.lineTo(-3 * r, r), e.closePath();
  }
}, cI = yn(1 / 3), SW = cI * 2, EW = {
  draw(e, t) {
    const r = yn(t / SW), i = r * cI;
    e.moveTo(0, -r), e.lineTo(i, 0), e.lineTo(0, r), e.lineTo(-i, 0), e.closePath();
  }
}, xW = {
  draw(e, t) {
    const r = yn(t), i = -r / 2;
    e.rect(i, i, r, r);
  }
}, AW = 0.8908130915292852, dI = Qp(ef / 10) / Qp(7 * ef / 10), DW = Qp(Zg / 10) * dI, TW = -iI(Zg / 10) * dI, RW = {
  draw(e, t) {
    const r = yn(t * AW), i = DW * r, n = TW * r;
    e.moveTo(0, -r), e.lineTo(i, n);
    for (let o = 1; o < 5; ++o) {
      const s = Zg * o / 5, a = iI(s), l = Qp(s);
      e.lineTo(l * r, -a * r), e.lineTo(a * i - l * n, l * i + a * n);
    }
    e.closePath();
  }
}, Pv = yn(3), PW = {
  draw(e, t) {
    const r = -yn(t / (Pv * 3));
    e.moveTo(0, r * 2), e.lineTo(-Pv * r, -r), e.lineTo(Pv * r, -r), e.closePath();
  }
}, Ti = -0.5, Ri = yn(3) / 2, ay = 1 / yn(12), IW = (ay / 2 + 1) * 3, OW = {
  draw(e, t) {
    const r = yn(t / IW), i = r / 2, n = r * ay, o = i, s = r * ay + r, a = -o, l = s;
    e.moveTo(i, n), e.lineTo(o, s), e.lineTo(a, l), e.lineTo(Ti * i - Ri * n, Ri * i + Ti * n), e.lineTo(Ti * o - Ri * s, Ri * o + Ti * s), e.lineTo(Ti * a - Ri * l, Ri * a + Ti * l), e.lineTo(Ti * i + Ri * n, Ti * n - Ri * i), e.lineTo(Ti * o + Ri * s, Ti * s - Ri * o), e.lineTo(Ti * a + Ri * l, Ti * l - Ri * a), e.closePath();
  }
};
function MW(e, t) {
  let r = null, i = _w(n);
  e = typeof e == "function" ? e : xt(e || Lw), t = typeof t == "function" ? t : xt(t === void 0 ? 64 : +t);
  function n() {
    let o;
    if (r || (r = o = i()), e.apply(this, arguments).draw(r, +t.apply(this, arguments)), o) return r = null, o + "" || null;
  }
  return n.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : xt(o), n) : e;
  }, n.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : xt(+o), n) : t;
  }, n.context = function(o) {
    return arguments.length ? (r = o ?? null, n) : r;
  }, n;
}
function tf() {
}
function rf(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function hI(e) {
  this._context = e;
}
hI.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        rf(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        rf(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function FW(e) {
  return new hI(e);
}
function pI(e) {
  this._context = e;
}
pI.prototype = {
  areaStart: tf,
  areaEnd: tf,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        rf(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function _W(e) {
  return new pI(e);
}
function fI(e) {
  this._context = e;
}
fI.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, i) : this._context.moveTo(r, i);
        break;
      case 3:
        this._point = 4;
      default:
        rf(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function NW(e) {
  return new fI(e);
}
function gI(e) {
  this._context = e;
}
gI.prototype = {
  areaStart: tf,
  areaEnd: tf,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function LW(e) {
  return new gI(e);
}
function Hx(e) {
  return e < 0 ? -1 : 1;
}
function Bx(e, t, r) {
  var i = e._x1 - e._x0, n = t - e._x1, o = (e._y1 - e._y0) / (i || n < 0 && -0), s = (r - e._y1) / (n || i < 0 && -0), a = (o * n + s * i) / (i + n);
  return (Hx(o) + Hx(s)) * Math.min(Math.abs(o), Math.abs(s), 0.5 * Math.abs(a)) || 0;
}
function Wx(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function Iv(e, t, r) {
  var i = e._x0, n = e._y0, o = e._x1, s = e._y1, a = (o - i) / 3;
  e._context.bezierCurveTo(i + a, n + a * t, o - a, s - a * r, o, s);
}
function nf(e) {
  this._context = e;
}
nf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Iv(this, this._t0, Wx(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Iv(this, Wx(this, r = Bx(this, e, t)), r);
          break;
        default:
          Iv(this, this._t0, r = Bx(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function mI(e) {
  this._context = new vI(e);
}
(mI.prototype = Object.create(nf.prototype)).point = function(e, t) {
  nf.prototype.point.call(this, t, e);
};
function vI(e) {
  this._context = e;
}
vI.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, i, n, o) {
    this._context.bezierCurveTo(t, e, i, r, o, n);
  }
};
function GW(e) {
  return new nf(e);
}
function kW(e) {
  return new mI(e);
}
function CI(e) {
  this._context = e;
}
CI.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var i = $x(e), n = $x(t), o = 0, s = 1; s < r; ++o, ++s)
          this._context.bezierCurveTo(i[0][o], n[0][o], i[1][o], n[1][o], e[s], t[s]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function $x(e) {
  var t, r = e.length - 1, i, n = new Array(r), o = new Array(r), s = new Array(r);
  for (n[0] = 0, o[0] = 2, s[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t) n[t] = 1, o[t] = 4, s[t] = 4 * e[t] + 2 * e[t + 1];
  for (n[r - 1] = 2, o[r - 1] = 7, s[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t) i = n[t] / o[t - 1], o[t] -= i, s[t] -= i * s[t - 1];
  for (n[r - 1] = s[r - 1] / o[r - 1], t = r - 2; t >= 0; --t) n[t] = (s[t] - n[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + n[r - 1]) / 2, t = 0; t < r - 1; ++t) o[t] = 2 * e[t + 1] - n[t + 1];
  return [n, o];
}
function VW(e) {
  return new CI(e);
}
function Qg(e, t) {
  this._context = e, this._t = t;
}
Qg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function HW(e) {
  return new Qg(e, 0.5);
}
function BW(e) {
  return new Qg(e, 0);
}
function WW(e) {
  return new Qg(e, 1);
}
function Sl(e, t) {
  if ((s = e.length) > 1)
    for (var r = 1, i, n, o = e[t[0]], s, a = o.length; r < s; ++r)
      for (n = o, o = e[t[r]], i = 0; i < a; ++i)
        o[i][1] += o[i][0] = isNaN(n[i][1]) ? n[i][0] : n[i][1];
}
function ly(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; ) r[t] = t;
  return r;
}
function $W(e, t) {
  return e[t];
}
function jW(e) {
  const t = [];
  return t.key = e, t;
}
function zW() {
  var e = xt([]), t = ly, r = Sl, i = $W;
  function n(o) {
    var s = Array.from(e.apply(this, arguments), jW), a, l = s.length, u = -1, c;
    for (const d of o)
      for (a = 0, ++u; a < l; ++a)
        (s[a][u] = [0, +i(d, s[a].key, u, o)]).data = d;
    for (a = 0, c = Nw(t(s)); a < l; ++a)
      s[c[a]].index = a;
    return r(s, c), s;
  }
  return n.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : xt(Array.from(o)), n) : e;
  }, n.value = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : xt(+o), n) : i;
  }, n.order = function(o) {
    return arguments.length ? (t = o == null ? ly : typeof o == "function" ? o : xt(Array.from(o)), n) : t;
  }, n.offset = function(o) {
    return arguments.length ? (r = o ?? Sl, n) : r;
  }, n;
}
function UW(e, t) {
  if ((i = e.length) > 0) {
    for (var r, i, n = 0, o = e[0].length, s; n < o; ++n) {
      for (s = r = 0; r < i; ++r) s += e[r][n][1] || 0;
      if (s) for (r = 0; r < i; ++r) e[r][n][1] /= s;
    }
    Sl(e, t);
  }
}
function YW(e, t) {
  if ((n = e.length) > 0) {
    for (var r = 0, i = e[t[0]], n, o = i.length; r < o; ++r) {
      for (var s = 0, a = 0; s < n; ++s) a += e[s][r][1] || 0;
      i[r][1] += i[r][0] = -a / 2;
    }
    Sl(e, t);
  }
}
function XW(e, t) {
  if (!(!((s = e.length) > 0) || !((o = (n = e[t[0]]).length) > 0))) {
    for (var r = 0, i = 1, n, o, s; i < o; ++i) {
      for (var a = 0, l = 0, u = 0; a < s; ++a) {
        for (var c = e[t[a]], d = c[i][1] || 0, h = c[i - 1][1] || 0, p = (d - h) / 2, g = 0; g < a; ++g) {
          var m = e[t[g]], f = m[i][1] || 0, C = m[i - 1][1] || 0;
          p += f - C;
        }
        l += d, u += p * d;
      }
      n[i - 1][1] += n[i - 1][0] = r, l && (r -= u / l);
    }
    n[i - 1][1] += n[i - 1][0] = r, Sl(e, t);
  }
}
function Uc(e) {
  "@babel/helpers - typeof";
  return Uc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Uc(e);
}
var KW = ["type", "size", "sizeType"];
function uy() {
  return uy = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, uy.apply(this, arguments);
}
function jx(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function zx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jx(Object(r), !0).forEach(function(i) {
      qW(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : jx(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function qW(e, t, r) {
  return t = ZW(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function ZW(e) {
  var t = JW(e, "string");
  return Uc(t) == "symbol" ? t : t + "";
}
function JW(e, t) {
  if (Uc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Uc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function QW(e, t) {
  if (e == null) return {};
  var r = e2(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function e2(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
var yI = {
  symbolCircle: Lw,
  symbolCross: wW,
  symbolDiamond: EW,
  symbolSquare: xW,
  symbolStar: RW,
  symbolTriangle: PW,
  symbolWye: OW
}, t2 = Math.PI / 180, r2 = function(t) {
  var r = "symbol".concat(qg(t));
  return yI[r] || Lw;
}, i2 = function(t, r, i) {
  if (r === "area")
    return t;
  switch (i) {
    case "cross":
      return 5 * t * t / 9;
    case "diamond":
      return 0.5 * t * t / Math.sqrt(3);
    case "square":
      return t * t;
    case "star": {
      var n = 18 * t2;
      return 1.25 * t * t * (Math.tan(n) - Math.tan(n * 2) * Math.pow(Math.tan(n), 2));
    }
    case "triangle":
      return Math.sqrt(3) * t * t / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * t * t / 8;
    default:
      return Math.PI * t * t / 4;
  }
}, n2 = function(t, r) {
  yI["symbol".concat(qg(t))] = r;
}, Gw = function(t) {
  var r = t.type, i = r === void 0 ? "circle" : r, n = t.size, o = n === void 0 ? 64 : n, s = t.sizeType, a = s === void 0 ? "area" : s, l = QW(t, KW), u = zx(zx({}, l), {}, {
    type: i,
    size: o,
    sizeType: a
  }), c = function() {
    var f = r2(i), C = MW().type(f).size(i2(o, a, i));
    return C();
  }, d = u.className, h = u.cx, p = u.cy, g = Ie(u, !0);
  return h === +h && p === +p && o === +o ? /* @__PURE__ */ D.createElement("path", uy({}, g, {
    className: xe("recharts-symbols", d),
    transform: "translate(".concat(h, ", ").concat(p, ")"),
    d: c()
  })) : null;
};
Gw.registerSymbol = n2;
function El(e) {
  "@babel/helpers - typeof";
  return El = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, El(e);
}
function cy() {
  return cy = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, cy.apply(this, arguments);
}
function Ux(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function o2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ux(Object(r), !0).forEach(function(i) {
      Yc(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ux(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function s2(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function a2(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, wI(i.key), i);
  }
}
function l2(e, t, r) {
  return t && a2(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function u2(e, t, r) {
  return t = of(t), c2(e, bI() ? Reflect.construct(t, r || [], of(e).constructor) : t.apply(e, r));
}
function c2(e, t) {
  if (t && (El(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return d2(e);
}
function d2(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function bI() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (bI = function() {
    return !!e;
  })();
}
function of(e) {
  return of = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, of(e);
}
function h2(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && dy(e, t);
}
function dy(e, t) {
  return dy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, dy(e, t);
}
function Yc(e, t, r) {
  return t = wI(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function wI(e) {
  var t = p2(e, "string");
  return El(t) == "symbol" ? t : t + "";
}
function p2(e, t) {
  if (El(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (El(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Pi = 32, kw = /* @__PURE__ */ function(e) {
  function t() {
    return s2(this, t), u2(this, t, arguments);
  }
  return h2(t, e), l2(t, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function(i) {
        var n = this.props.inactiveColor, o = Pi / 2, s = Pi / 6, a = Pi / 3, l = i.inactive ? n : i.color;
        if (i.type === "plainline")
          return /* @__PURE__ */ D.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            strokeDasharray: i.payload.strokeDasharray,
            x1: 0,
            y1: o,
            x2: Pi,
            y2: o,
            className: "recharts-legend-icon"
          });
        if (i.type === "line")
          return /* @__PURE__ */ D.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            d: "M0,".concat(o, "h").concat(a, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(2 * a, ",").concat(o, `
            H`).concat(Pi, "M").concat(2 * a, ",").concat(o, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(a, ",").concat(o),
            className: "recharts-legend-icon"
          });
        if (i.type === "rect")
          return /* @__PURE__ */ D.createElement("path", {
            stroke: "none",
            fill: l,
            d: "M0,".concat(Pi / 8, "h").concat(Pi, "v").concat(Pi * 3 / 4, "h").concat(-Pi, "z"),
            className: "recharts-legend-icon"
          });
        if (/* @__PURE__ */ D.isValidElement(i.legendIcon)) {
          var u = o2({}, i);
          return delete u.legendIcon, /* @__PURE__ */ D.cloneElement(i.legendIcon, u);
        }
        return /* @__PURE__ */ D.createElement(Gw, {
          fill: l,
          cx: o,
          cy: o,
          size: Pi,
          sizeType: "diameter",
          type: i.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function() {
      var i = this, n = this.props, o = n.payload, s = n.iconSize, a = n.layout, l = n.formatter, u = n.inactiveColor, c = {
        x: 0,
        y: 0,
        width: Pi,
        height: Pi
      }, d = {
        display: a === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      }, h = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return o.map(function(p, g) {
        var m = p.formatter || l, f = xe(Yc(Yc({
          "recharts-legend-item": !0
        }, "legend-item-".concat(g), !0), "inactive", p.inactive));
        if (p.type === "none")
          return null;
        var C = Le(p.value) ? null : p.value;
        dn(
          !Le(p.value),
          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
          // eslint-disable-line max-len
        );
        var w = p.inactive ? u : p.color;
        return /* @__PURE__ */ D.createElement("li", cy({
          className: f,
          style: d,
          key: "legend-item-".concat(g)
        }, na(i.props, p, g)), /* @__PURE__ */ D.createElement(ty, {
          width: s,
          height: s,
          viewBox: c,
          style: h
        }, i.renderIcon(p)), /* @__PURE__ */ D.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: w
          }
        }, m ? m(C, p, g) : C));
      });
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, n = i.payload, o = i.layout, s = i.align;
      if (!n || !n.length)
        return null;
      var a = {
        padding: 0,
        margin: 0,
        textAlign: o === "horizontal" ? s : "left"
      };
      return /* @__PURE__ */ D.createElement("ul", {
        className: "recharts-default-legend",
        style: a
      }, this.renderItems());
    }
  }]);
}(vn);
Yc(kw, "displayName", "Legend");
Yc(kw, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
var f2 = Yg;
function g2() {
  this.__data__ = new f2(), this.size = 0;
}
var m2 = g2;
function v2(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
var C2 = v2;
function y2(e) {
  return this.__data__.get(e);
}
var b2 = y2;
function w2(e) {
  return this.__data__.has(e);
}
var S2 = w2, E2 = Yg, x2 = Tw, A2 = Rw, D2 = 200;
function T2(e, t) {
  var r = this.__data__;
  if (r instanceof E2) {
    var i = r.__data__;
    if (!x2 || i.length < D2 - 1)
      return i.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new A2(i);
  }
  return r.set(e, t), this.size = r.size, this;
}
var R2 = T2, P2 = Yg, I2 = m2, O2 = C2, M2 = b2, F2 = S2, _2 = R2;
function Pu(e) {
  var t = this.__data__ = new P2(e);
  this.size = t.size;
}
Pu.prototype.clear = I2;
Pu.prototype.delete = O2;
Pu.prototype.get = M2;
Pu.prototype.has = F2;
Pu.prototype.set = _2;
var SI = Pu, N2 = "__lodash_hash_undefined__";
function L2(e) {
  return this.__data__.set(e, N2), this;
}
var G2 = L2;
function k2(e) {
  return this.__data__.has(e);
}
var V2 = k2, H2 = Rw, B2 = G2, W2 = V2;
function sf(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.__data__ = new H2(); ++t < r; )
    this.add(e[t]);
}
sf.prototype.add = sf.prototype.push = B2;
sf.prototype.has = W2;
var EI = sf;
function $2(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (t(e[r], r, e))
      return !0;
  return !1;
}
var xI = $2;
function j2(e, t) {
  return e.has(t);
}
var AI = j2, z2 = EI, U2 = xI, Y2 = AI, X2 = 1, K2 = 2;
function q2(e, t, r, i, n, o) {
  var s = r & X2, a = e.length, l = t.length;
  if (a != l && !(s && l > a))
    return !1;
  var u = o.get(e), c = o.get(t);
  if (u && c)
    return u == t && c == e;
  var d = -1, h = !0, p = r & K2 ? new z2() : void 0;
  for (o.set(e, t), o.set(t, e); ++d < a; ) {
    var g = e[d], m = t[d];
    if (i)
      var f = s ? i(m, g, d, t, e, o) : i(g, m, d, e, t, o);
    if (f !== void 0) {
      if (f)
        continue;
      h = !1;
      break;
    }
    if (p) {
      if (!U2(t, function(C, w) {
        if (!Y2(p, w) && (g === C || n(g, C, r, i, o)))
          return p.push(w);
      })) {
        h = !1;
        break;
      }
    } else if (!(g === m || n(g, m, r, i, o))) {
      h = !1;
      break;
    }
  }
  return o.delete(e), o.delete(t), h;
}
var DI = q2, Z2 = Zn, J2 = Z2.Uint8Array, Q2 = J2;
function e$(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(i, n) {
    r[++t] = [n, i];
  }), r;
}
var t$ = e$;
function r$(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(i) {
    r[++t] = i;
  }), r;
}
var Vw = r$, Yx = lh, Xx = Q2, i$ = Dw, n$ = DI, o$ = t$, s$ = Vw, a$ = 1, l$ = 2, u$ = "[object Boolean]", c$ = "[object Date]", d$ = "[object Error]", h$ = "[object Map]", p$ = "[object Number]", f$ = "[object RegExp]", g$ = "[object Set]", m$ = "[object String]", v$ = "[object Symbol]", C$ = "[object ArrayBuffer]", y$ = "[object DataView]", Kx = Yx ? Yx.prototype : void 0, Ov = Kx ? Kx.valueOf : void 0;
function b$(e, t, r, i, n, o, s) {
  switch (r) {
    case y$:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case C$:
      return !(e.byteLength != t.byteLength || !o(new Xx(e), new Xx(t)));
    case u$:
    case c$:
    case p$:
      return i$(+e, +t);
    case d$:
      return e.name == t.name && e.message == t.message;
    case f$:
    case m$:
      return e == t + "";
    case h$:
      var a = o$;
    case g$:
      var l = i & a$;
      if (a || (a = s$), e.size != t.size && !l)
        return !1;
      var u = s.get(e);
      if (u)
        return u == t;
      i |= l$, s.set(e, t);
      var c = n$(a(e), a(t), i, n, o, s);
      return s.delete(e), c;
    case v$:
      if (Ov)
        return Ov.call(e) == Ov.call(t);
  }
  return !1;
}
var w$ = b$;
function S$(e, t) {
  for (var r = -1, i = t.length, n = e.length; ++r < i; )
    e[n + r] = t[r];
  return e;
}
var TI = S$, E$ = TI, x$ = oi;
function A$(e, t, r) {
  var i = t(e);
  return x$(e) ? i : E$(i, r(e));
}
var D$ = A$;
function T$(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length, n = 0, o = []; ++r < i; ) {
    var s = e[r];
    t(s, r, e) && (o[n++] = s);
  }
  return o;
}
var R$ = T$;
function P$() {
  return [];
}
var I$ = P$, O$ = R$, M$ = I$, F$ = Object.prototype, _$ = F$.propertyIsEnumerable, qx = Object.getOwnPropertySymbols, N$ = qx ? function(e) {
  return e == null ? [] : (e = Object(e), O$(qx(e), function(t) {
    return _$.call(e, t);
  }));
} : M$, L$ = N$;
function G$(e, t) {
  for (var r = -1, i = Array(e); ++r < e; )
    i[r] = t(r);
  return i;
}
var k$ = G$, V$ = Do, H$ = To, B$ = "[object Arguments]";
function W$(e) {
  return H$(e) && V$(e) == B$;
}
var $$ = W$, Zx = $$, j$ = To, RI = Object.prototype, z$ = RI.hasOwnProperty, U$ = RI.propertyIsEnumerable, Y$ = Zx(/* @__PURE__ */ function() {
  return arguments;
}()) ? Zx : function(e) {
  return j$(e) && z$.call(e, "callee") && !U$.call(e, "callee");
}, Hw = Y$, af = { exports: {} };
function X$() {
  return !1;
}
var K$ = X$;
af.exports;
(function(e, t) {
  var r = Zn, i = K$, n = t && !t.nodeType && t, o = n && !0 && e && !e.nodeType && e, s = o && o.exports === n, a = s ? r.Buffer : void 0, l = a ? a.isBuffer : void 0, u = l || i;
  e.exports = u;
})(af, af.exports);
var PI = af.exports, q$ = 9007199254740991, Z$ = /^(?:0|[1-9]\d*)$/;
function J$(e, t) {
  var r = typeof e;
  return t = t ?? q$, !!t && (r == "number" || r != "symbol" && Z$.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var Bw = J$, Q$ = 9007199254740991;
function ej(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Q$;
}
var Ww = ej, tj = Do, rj = Ww, ij = To, nj = "[object Arguments]", oj = "[object Array]", sj = "[object Boolean]", aj = "[object Date]", lj = "[object Error]", uj = "[object Function]", cj = "[object Map]", dj = "[object Number]", hj = "[object Object]", pj = "[object RegExp]", fj = "[object Set]", gj = "[object String]", mj = "[object WeakMap]", vj = "[object ArrayBuffer]", Cj = "[object DataView]", yj = "[object Float32Array]", bj = "[object Float64Array]", wj = "[object Int8Array]", Sj = "[object Int16Array]", Ej = "[object Int32Array]", xj = "[object Uint8Array]", Aj = "[object Uint8ClampedArray]", Dj = "[object Uint16Array]", Tj = "[object Uint32Array]", Rt = {};
Rt[yj] = Rt[bj] = Rt[wj] = Rt[Sj] = Rt[Ej] = Rt[xj] = Rt[Aj] = Rt[Dj] = Rt[Tj] = !0;
Rt[nj] = Rt[oj] = Rt[vj] = Rt[sj] = Rt[Cj] = Rt[aj] = Rt[lj] = Rt[uj] = Rt[cj] = Rt[dj] = Rt[hj] = Rt[pj] = Rt[fj] = Rt[gj] = Rt[mj] = !1;
function Rj(e) {
  return ij(e) && rj(e.length) && !!Rt[tj(e)];
}
var Pj = Rj;
function Ij(e) {
  return function(t) {
    return e(t);
  };
}
var II = Ij, lf = { exports: {} };
lf.exports;
(function(e, t) {
  var r = HP, i = t && !t.nodeType && t, n = i && !0 && e && !e.nodeType && e, o = n && n.exports === i, s = o && r.process, a = function() {
    try {
      var l = n && n.require && n.require("util").types;
      return l || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  e.exports = a;
})(lf, lf.exports);
var Oj = lf.exports, Mj = Pj, Fj = II, Jx = Oj, Qx = Jx && Jx.isTypedArray, _j = Qx ? Fj(Qx) : Mj, OI = _j, Nj = k$, Lj = Hw, Gj = oi, kj = PI, Vj = Bw, Hj = OI, Bj = Object.prototype, Wj = Bj.hasOwnProperty;
function $j(e, t) {
  var r = Gj(e), i = !r && Lj(e), n = !r && !i && kj(e), o = !r && !i && !n && Hj(e), s = r || i || n || o, a = s ? Nj(e.length, String) : [], l = a.length;
  for (var u in e)
    (t || Wj.call(e, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    n && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Vj(u, l))) && a.push(u);
  return a;
}
var jj = $j, zj = Object.prototype;
function Uj(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || zj;
  return e === r;
}
var Yj = Uj;
function Xj(e, t) {
  return function(r) {
    return e(t(r));
  };
}
var MI = Xj, Kj = MI, qj = Kj(Object.keys, Object), Zj = qj, Jj = Yj, Qj = Zj, ez = Object.prototype, tz = ez.hasOwnProperty;
function rz(e) {
  if (!Jj(e))
    return Qj(e);
  var t = [];
  for (var r in Object(e))
    tz.call(e, r) && r != "constructor" && t.push(r);
  return t;
}
var iz = rz, nz = Aw, oz = Ww;
function sz(e) {
  return e != null && oz(e.length) && !nz(e);
}
var ch = sz, az = jj, lz = iz, uz = ch;
function cz(e) {
  return uz(e) ? az(e) : lz(e);
}
var em = cz, dz = D$, hz = L$, pz = em;
function fz(e) {
  return dz(e, pz, hz);
}
var gz = fz, e0 = gz, mz = 1, vz = Object.prototype, Cz = vz.hasOwnProperty;
function yz(e, t, r, i, n, o) {
  var s = r & mz, a = e0(e), l = a.length, u = e0(t), c = u.length;
  if (l != c && !s)
    return !1;
  for (var d = l; d--; ) {
    var h = a[d];
    if (!(s ? h in t : Cz.call(t, h)))
      return !1;
  }
  var p = o.get(e), g = o.get(t);
  if (p && g)
    return p == t && g == e;
  var m = !0;
  o.set(e, t), o.set(t, e);
  for (var f = s; ++d < l; ) {
    h = a[d];
    var C = e[h], w = t[h];
    if (i)
      var E = s ? i(w, C, h, t, e, o) : i(C, w, h, e, t, o);
    if (!(E === void 0 ? C === w || n(C, w, r, i, o) : E)) {
      m = !1;
      break;
    }
    f || (f = h == "constructor");
  }
  if (m && !f) {
    var b = e.constructor, y = t.constructor;
    b != y && "constructor" in e && "constructor" in t && !(typeof b == "function" && b instanceof b && typeof y == "function" && y instanceof y) && (m = !1);
  }
  return o.delete(e), o.delete(t), m;
}
var bz = yz, wz = Aa, Sz = Zn, Ez = wz(Sz, "DataView"), xz = Ez, Az = Aa, Dz = Zn, Tz = Az(Dz, "Promise"), Rz = Tz, Pz = Aa, Iz = Zn, Oz = Pz(Iz, "Set"), FI = Oz, Mz = Aa, Fz = Zn, _z = Mz(Fz, "WeakMap"), Nz = _z, hy = xz, py = Tw, fy = Rz, gy = FI, my = Nz, _I = Do, Iu = WP, t0 = "[object Map]", Lz = "[object Object]", r0 = "[object Promise]", i0 = "[object Set]", n0 = "[object WeakMap]", o0 = "[object DataView]", Gz = Iu(hy), kz = Iu(py), Vz = Iu(fy), Hz = Iu(gy), Bz = Iu(my), As = _I;
(hy && As(new hy(new ArrayBuffer(1))) != o0 || py && As(new py()) != t0 || fy && As(fy.resolve()) != r0 || gy && As(new gy()) != i0 || my && As(new my()) != n0) && (As = function(e) {
  var t = _I(e), r = t == Lz ? e.constructor : void 0, i = r ? Iu(r) : "";
  if (i)
    switch (i) {
      case Gz:
        return o0;
      case kz:
        return t0;
      case Vz:
        return r0;
      case Hz:
        return i0;
      case Bz:
        return n0;
    }
  return t;
});
var Wz = As, Mv = SI, $z = DI, jz = w$, zz = bz, s0 = Wz, a0 = oi, l0 = PI, Uz = OI, Yz = 1, u0 = "[object Arguments]", c0 = "[object Array]", Jh = "[object Object]", Xz = Object.prototype, d0 = Xz.hasOwnProperty;
function Kz(e, t, r, i, n, o) {
  var s = a0(e), a = a0(t), l = s ? c0 : s0(e), u = a ? c0 : s0(t);
  l = l == u0 ? Jh : l, u = u == u0 ? Jh : u;
  var c = l == Jh, d = u == Jh, h = l == u;
  if (h && l0(e)) {
    if (!l0(t))
      return !1;
    s = !0, c = !1;
  }
  if (h && !c)
    return o || (o = new Mv()), s || Uz(e) ? $z(e, t, r, i, n, o) : jz(e, t, l, r, i, n, o);
  if (!(r & Yz)) {
    var p = c && d0.call(e, "__wrapped__"), g = d && d0.call(t, "__wrapped__");
    if (p || g) {
      var m = p ? e.value() : e, f = g ? t.value() : t;
      return o || (o = new Mv()), n(m, f, r, i, o);
    }
  }
  return h ? (o || (o = new Mv()), zz(e, t, r, i, n, o)) : !1;
}
var qz = Kz, Zz = qz, h0 = To;
function NI(e, t, r, i, n) {
  return e === t ? !0 : e == null || t == null || !h0(e) && !h0(t) ? e !== e && t !== t : Zz(e, t, r, i, NI, n);
}
var $w = NI, Jz = SI, Qz = $w, eU = 1, tU = 2;
function rU(e, t, r, i) {
  var n = r.length, o = n, s = !i;
  if (e == null)
    return !o;
  for (e = Object(e); n--; ) {
    var a = r[n];
    if (s && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++n < o; ) {
    a = r[n];
    var l = a[0], u = e[l], c = a[1];
    if (s && a[2]) {
      if (u === void 0 && !(l in e))
        return !1;
    } else {
      var d = new Jz();
      if (i)
        var h = i(u, c, l, e, t, d);
      if (!(h === void 0 ? Qz(c, u, eU | tU, i, d) : h))
        return !1;
    }
  }
  return !0;
}
var iU = rU, nU = os;
function oU(e) {
  return e === e && !nU(e);
}
var LI = oU, sU = LI, aU = em;
function lU(e) {
  for (var t = aU(e), r = t.length; r--; ) {
    var i = t[r], n = e[i];
    t[r] = [i, n, sU(n)];
  }
  return t;
}
var uU = lU;
function cU(e, t) {
  return function(r) {
    return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
var GI = cU, dU = iU, hU = uU, pU = GI;
function fU(e) {
  var t = hU(e);
  return t.length == 1 && t[0][2] ? pU(t[0][0], t[0][1]) : function(r) {
    return r === e || dU(r, e, t);
  };
}
var gU = fU;
function mU(e, t) {
  return e != null && t in Object(e);
}
var vU = mU, CU = YP, yU = Hw, bU = oi, wU = Bw, SU = Ww, EU = Kg;
function xU(e, t, r) {
  t = CU(t, e);
  for (var i = -1, n = t.length, o = !1; ++i < n; ) {
    var s = EU(t[i]);
    if (!(o = e != null && r(e, s)))
      break;
    e = e[s];
  }
  return o || ++i != n ? o : (n = e == null ? 0 : e.length, !!n && SU(n) && wU(s, n) && (bU(e) || yU(e)));
}
var AU = xU, DU = vU, TU = AU;
function RU(e, t) {
  return e != null && TU(e, t, DU);
}
var PU = RU, IU = $w, OU = XP, MU = PU, FU = xw, _U = LI, NU = GI, LU = Kg, GU = 1, kU = 2;
function VU(e, t) {
  return FU(e) && _U(t) ? NU(LU(e), t) : function(r) {
    var i = OU(r, e);
    return i === void 0 && i === t ? MU(r, e) : IU(t, i, GU | kU);
  };
}
var HU = VU;
function BU(e) {
  return e;
}
var Ou = BU;
function WU(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var $U = WU, jU = Ow;
function zU(e) {
  return function(t) {
    return jU(t, e);
  };
}
var UU = zU, YU = $U, XU = UU, KU = xw, qU = Kg;
function ZU(e) {
  return KU(e) ? YU(qU(e)) : XU(e);
}
var JU = ZU, QU = gU, eY = HU, tY = Ou, rY = oi, iY = JU;
function nY(e) {
  return typeof e == "function" ? e : e == null ? tY : typeof e == "object" ? rY(e) ? eY(e[0], e[1]) : QU(e) : iY(e);
}
var Jn = nY;
function oY(e, t, r, i) {
  for (var n = e.length, o = r + (i ? 1 : -1); i ? o-- : ++o < n; )
    if (t(e[o], o, e))
      return o;
  return -1;
}
var kI = oY;
function sY(e) {
  return e !== e;
}
var aY = sY;
function lY(e, t, r) {
  for (var i = r - 1, n = e.length; ++i < n; )
    if (e[i] === t)
      return i;
  return -1;
}
var uY = lY, cY = kI, dY = aY, hY = uY;
function pY(e, t, r) {
  return t === t ? hY(e, t, r) : cY(e, dY, r);
}
var fY = pY, gY = fY;
function mY(e, t) {
  var r = e == null ? 0 : e.length;
  return !!r && gY(e, t, 0) > -1;
}
var vY = mY;
function CY(e, t, r) {
  for (var i = -1, n = e == null ? 0 : e.length; ++i < n; )
    if (r(t, e[i]))
      return !0;
  return !1;
}
var yY = CY;
function bY() {
}
var wY = bY, Fv = FI, SY = wY, EY = Vw, xY = 1 / 0, AY = Fv && 1 / EY(new Fv([, -0]))[1] == xY ? function(e) {
  return new Fv(e);
} : SY, DY = AY, TY = EI, RY = vY, PY = yY, IY = AI, OY = DY, MY = Vw, FY = 200;
function _Y(e, t, r) {
  var i = -1, n = RY, o = e.length, s = !0, a = [], l = a;
  if (r)
    s = !1, n = PY;
  else if (o >= FY) {
    var u = t ? null : OY(e);
    if (u)
      return MY(u);
    s = !1, n = IY, l = new TY();
  } else
    l = t ? [] : a;
  e:
    for (; ++i < o; ) {
      var c = e[i], d = t ? t(c) : c;
      if (c = r || c !== 0 ? c : 0, s && d === d) {
        for (var h = l.length; h--; )
          if (l[h] === d)
            continue e;
        t && l.push(d), a.push(c);
      } else n(l, d, r) || (l !== a && l.push(d), a.push(c));
    }
  return a;
}
var NY = _Y, LY = Jn, GY = NY;
function kY(e, t) {
  return e && e.length ? GY(e, LY(t)) : [];
}
var VY = kY;
const p0 = /* @__PURE__ */ Ct(VY);
function VI(e, t, r) {
  return t === !0 ? p0(e, r) : Le(t) ? p0(e, t) : e;
}
function xl(e) {
  "@babel/helpers - typeof";
  return xl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xl(e);
}
var HY = ["ref"];
function f0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function eo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f0(Object(r), !0).forEach(function(i) {
      tm(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : f0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function BY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function g0(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, BI(i.key), i);
  }
}
function WY(e, t, r) {
  return t && g0(e.prototype, t), r && g0(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function $Y(e, t, r) {
  return t = uf(t), jY(e, HI() ? Reflect.construct(t, r || [], uf(e).constructor) : t.apply(e, r));
}
function jY(e, t) {
  if (t && (xl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return zY(e);
}
function zY(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function HI() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (HI = function() {
    return !!e;
  })();
}
function uf(e) {
  return uf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, uf(e);
}
function UY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && vy(e, t);
}
function vy(e, t) {
  return vy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, vy(e, t);
}
function tm(e, t, r) {
  return t = BI(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function BI(e) {
  var t = YY(e, "string");
  return xl(t) == "symbol" ? t : t + "";
}
function YY(e, t) {
  if (xl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (xl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function XY(e, t) {
  if (e == null) return {};
  var r = KY(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function KY(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function qY(e) {
  return e.value;
}
function ZY(e, t) {
  if (/* @__PURE__ */ D.isValidElement(e))
    return /* @__PURE__ */ D.cloneElement(e, t);
  if (typeof e == "function")
    return /* @__PURE__ */ D.createElement(e, t);
  t.ref;
  var r = XY(t, HY);
  return /* @__PURE__ */ D.createElement(kw, r);
}
var m0 = 1, uo = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    BY(this, t);
    for (var i = arguments.length, n = new Array(i), o = 0; o < i; o++)
      n[o] = arguments[o];
    return r = $Y(this, t, [].concat(n)), tm(r, "lastBoundingBox", {
      width: -1,
      height: -1
    }), r;
  }
  return UY(t, e), WY(t, [{
    key: "componentDidMount",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var i = this.wrapperNode.getBoundingClientRect();
        return i.height = this.wrapperNode.offsetHeight, i.width = this.wrapperNode.offsetWidth, i;
      }
      return null;
    }
  }, {
    key: "updateBBox",
    value: function() {
      var i = this.props.onBBoxUpdate, n = this.getBBox();
      n ? (Math.abs(n.width - this.lastBoundingBox.width) > m0 || Math.abs(n.height - this.lastBoundingBox.height) > m0) && (this.lastBoundingBox.width = n.width, this.lastBoundingBox.height = n.height, i && i(n)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, i && i(null));
    }
  }, {
    key: "getBBoxSnapshot",
    value: function() {
      return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? eo({}, this.lastBoundingBox) : {
        width: 0,
        height: 0
      };
    }
  }, {
    key: "getDefaultPosition",
    value: function(i) {
      var n = this.props, o = n.layout, s = n.align, a = n.verticalAlign, l = n.margin, u = n.chartWidth, c = n.chartHeight, d, h;
      if (!i || (i.left === void 0 || i.left === null) && (i.right === void 0 || i.right === null))
        if (s === "center" && o === "vertical") {
          var p = this.getBBoxSnapshot();
          d = {
            left: ((u || 0) - p.width) / 2
          };
        } else
          d = s === "right" ? {
            right: l && l.right || 0
          } : {
            left: l && l.left || 0
          };
      if (!i || (i.top === void 0 || i.top === null) && (i.bottom === void 0 || i.bottom === null))
        if (a === "middle") {
          var g = this.getBBoxSnapshot();
          h = {
            top: ((c || 0) - g.height) / 2
          };
        } else
          h = a === "bottom" ? {
            bottom: l && l.bottom || 0
          } : {
            top: l && l.top || 0
          };
      return eo(eo({}, d), h);
    }
  }, {
    key: "render",
    value: function() {
      var i = this, n = this.props, o = n.content, s = n.width, a = n.height, l = n.wrapperStyle, u = n.payloadUniqBy, c = n.payload, d = eo(eo({
        position: "absolute",
        width: s || "auto",
        height: a || "auto"
      }, this.getDefaultPosition(l)), l);
      return /* @__PURE__ */ D.createElement("div", {
        className: "recharts-legend-wrapper",
        style: d,
        ref: function(p) {
          i.wrapperNode = p;
        }
      }, ZY(o, eo(eo({}, this.props), {}, {
        payload: VI(c, u, qY)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function(i, n) {
      var o = eo(eo({}, this.defaultProps), i.props), s = o.layout;
      return s === "vertical" && ue(i.props.height) ? {
        height: i.props.height
      } : s === "horizontal" ? {
        width: i.props.width || n
      } : null;
    }
  }]);
}(vn);
tm(uo, "displayName", "Legend");
tm(uo, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var v0 = lh, JY = Hw, QY = oi, C0 = v0 ? v0.isConcatSpreadable : void 0;
function e3(e) {
  return QY(e) || JY(e) || !!(C0 && e && e[C0]);
}
var t3 = e3, r3 = TI, i3 = t3;
function WI(e, t, r, i, n) {
  var o = -1, s = e.length;
  for (r || (r = i3), n || (n = []); ++o < s; ) {
    var a = e[o];
    t > 0 && r(a) ? t > 1 ? WI(a, t - 1, r, i, n) : r3(n, a) : i || (n[n.length] = a);
  }
  return n;
}
var $I = WI;
function n3(e) {
  return function(t, r, i) {
    for (var n = -1, o = Object(t), s = i(t), a = s.length; a--; ) {
      var l = s[e ? a : ++n];
      if (r(o[l], l, o) === !1)
        break;
    }
    return t;
  };
}
var o3 = n3, s3 = o3, a3 = s3(), l3 = a3, u3 = l3, c3 = em;
function d3(e, t) {
  return e && u3(e, t, c3);
}
var jI = d3, h3 = ch;
function p3(e, t) {
  return function(r, i) {
    if (r == null)
      return r;
    if (!h3(r))
      return e(r, i);
    for (var n = r.length, o = t ? n : -1, s = Object(r); (t ? o-- : ++o < n) && i(s[o], o, s) !== !1; )
      ;
    return r;
  };
}
var f3 = p3, g3 = jI, m3 = f3, v3 = m3(g3), jw = v3, C3 = jw, y3 = ch;
function b3(e, t) {
  var r = -1, i = y3(e) ? Array(e.length) : [];
  return C3(e, function(n, o, s) {
    i[++r] = t(n, o, s);
  }), i;
}
var zI = b3;
function w3(e, t) {
  var r = e.length;
  for (e.sort(t); r--; )
    e[r] = e[r].value;
  return e;
}
var S3 = w3, y0 = Eu;
function E3(e, t) {
  if (e !== t) {
    var r = e !== void 0, i = e === null, n = e === e, o = y0(e), s = t !== void 0, a = t === null, l = t === t, u = y0(t);
    if (!a && !u && !o && e > t || o && s && l && !a && !u || i && s && l || !r && l || !n)
      return 1;
    if (!i && !o && !u && e < t || u && r && n && !i && !o || a && r && n || !s && n || !l)
      return -1;
  }
  return 0;
}
var x3 = E3, A3 = x3;
function D3(e, t, r) {
  for (var i = -1, n = e.criteria, o = t.criteria, s = n.length, a = r.length; ++i < s; ) {
    var l = A3(n[i], o[i]);
    if (l) {
      if (i >= a)
        return l;
      var u = r[i];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
var T3 = D3, _v = Iw, R3 = Ow, P3 = Jn, I3 = zI, O3 = S3, M3 = II, F3 = T3, _3 = Ou, N3 = oi;
function L3(e, t, r) {
  t.length ? t = _v(t, function(o) {
    return N3(o) ? function(s) {
      return R3(s, o.length === 1 ? o[0] : o);
    } : o;
  }) : t = [_3];
  var i = -1;
  t = _v(t, M3(P3));
  var n = I3(e, function(o, s, a) {
    var l = _v(t, function(u) {
      return u(o);
    });
    return { criteria: l, index: ++i, value: o };
  });
  return O3(n, function(o, s) {
    return F3(o, s, r);
  });
}
var G3 = L3;
function k3(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
var V3 = k3, H3 = V3, b0 = Math.max;
function B3(e, t, r) {
  return t = b0(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var i = arguments, n = -1, o = b0(i.length - t, 0), s = Array(o); ++n < o; )
      s[n] = i[t + n];
    n = -1;
    for (var a = Array(t + 1); ++n < t; )
      a[n] = i[n];
    return a[t] = r(s), H3(e, this, a);
  };
}
var W3 = B3;
function $3(e) {
  return function() {
    return e;
  };
}
var j3 = $3, z3 = Aa, U3 = function() {
  try {
    var e = z3(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), UI = U3, Y3 = j3, w0 = UI, X3 = Ou, K3 = w0 ? function(e, t) {
  return w0(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Y3(t),
    writable: !0
  });
} : X3, q3 = K3, Z3 = 800, J3 = 16, Q3 = Date.now;
function e4(e) {
  var t = 0, r = 0;
  return function() {
    var i = Q3(), n = J3 - (i - r);
    if (r = i, n > 0) {
      if (++t >= Z3)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var t4 = e4, r4 = q3, i4 = t4, n4 = i4(r4), o4 = n4, s4 = Ou, a4 = W3, l4 = o4;
function u4(e, t) {
  return l4(a4(e, t, s4), e + "");
}
var c4 = u4, d4 = Dw, h4 = ch, p4 = Bw, f4 = os;
function g4(e, t, r) {
  if (!f4(r))
    return !1;
  var i = typeof t;
  return (i == "number" ? h4(r) && p4(t, r.length) : i == "string" && t in r) ? d4(r[t], e) : !1;
}
var rm = g4, m4 = $I, v4 = G3, C4 = c4, S0 = rm, y4 = C4(function(e, t) {
  if (e == null)
    return [];
  var r = t.length;
  return r > 1 && S0(e, t[0], t[1]) ? t = [] : r > 2 && S0(t[0], t[1], t[2]) && (t = [t[0]]), v4(e, m4(t, 1), []);
}), b4 = y4;
const zw = /* @__PURE__ */ Ct(b4);
function Xc(e) {
  "@babel/helpers - typeof";
  return Xc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xc(e);
}
function Cy() {
  return Cy = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Cy.apply(this, arguments);
}
function w4(e, t) {
  return A4(e) || x4(e, t) || E4(e, t) || S4();
}
function S4() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function E4(e, t) {
  if (e) {
    if (typeof e == "string") return E0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return E0(e, t);
  }
}
function E0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function x4(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function A4(e) {
  if (Array.isArray(e)) return e;
}
function x0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Nv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x0(Object(r), !0).forEach(function(i) {
      D4(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : x0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function D4(e, t, r) {
  return t = T4(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function T4(e) {
  var t = R4(e, "string");
  return Xc(t) == "symbol" ? t : t + "";
}
function R4(e, t) {
  if (Xc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Xc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function P4(e) {
  return Array.isArray(e) && dr(e[0]) && dr(e[1]) ? e.join(" ~ ") : e;
}
var I4 = function(t) {
  var r = t.separator, i = r === void 0 ? " : " : r, n = t.contentStyle, o = n === void 0 ? {} : n, s = t.itemStyle, a = s === void 0 ? {} : s, l = t.labelStyle, u = l === void 0 ? {} : l, c = t.payload, d = t.formatter, h = t.itemSorter, p = t.wrapperClassName, g = t.labelClassName, m = t.label, f = t.labelFormatter, C = t.accessibilityLayer, w = C === void 0 ? !1 : C, E = function() {
    if (c && c.length) {
      var M = {
        padding: 0,
        margin: 0
      }, _ = (h ? zw(c, h) : c).map(function(G, F) {
        if (G.type === "none")
          return null;
        var N = Nv({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: G.color || "#000"
        }, a), V = G.formatter || d || P4, B = G.value, $ = G.name, L = B, z = $;
        if (V && L != null && z != null) {
          var j = V(B, $, G, F, c);
          if (Array.isArray(j)) {
            var U = w4(j, 2);
            L = U[0], z = U[1];
          } else
            L = j;
        }
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ D.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(F),
            style: N
          }, dr(z) ? /* @__PURE__ */ D.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, z) : null, dr(z) ? /* @__PURE__ */ D.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, i) : null, /* @__PURE__ */ D.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, L), /* @__PURE__ */ D.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, G.unit || ""))
        );
      });
      return /* @__PURE__ */ D.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: M
      }, _);
    }
    return null;
  }, b = Nv({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, o), y = Nv({
    margin: 0
  }, u), S = !ke(m), x = S ? m : "", R = xe("recharts-default-tooltip", p), P = xe("recharts-tooltip-label", g);
  S && f && c !== void 0 && c !== null && (x = f(m, c));
  var O = w ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ D.createElement("div", Cy({
    className: R,
    style: b
  }, O), /* @__PURE__ */ D.createElement("p", {
    className: P,
    style: y
  }, /* @__PURE__ */ D.isValidElement(x) ? x : "".concat(x)), E());
};
function Kc(e) {
  "@babel/helpers - typeof";
  return Kc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kc(e);
}
function Qh(e, t, r) {
  return t = O4(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function O4(e) {
  var t = M4(e, "string");
  return Kc(t) == "symbol" ? t : t + "";
}
function M4(e, t) {
  if (Kc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Kc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var oc = "recharts-tooltip-wrapper", F4 = {
  visibility: "hidden"
};
function _4(e) {
  var t = e.coordinate, r = e.translateX, i = e.translateY;
  return xe(oc, Qh(Qh(Qh(Qh({}, "".concat(oc, "-right"), ue(r) && t && ue(t.x) && r >= t.x), "".concat(oc, "-left"), ue(r) && t && ue(t.x) && r < t.x), "".concat(oc, "-bottom"), ue(i) && t && ue(t.y) && i >= t.y), "".concat(oc, "-top"), ue(i) && t && ue(t.y) && i < t.y));
}
function A0(e) {
  var t = e.allowEscapeViewBox, r = e.coordinate, i = e.key, n = e.offsetTopLeft, o = e.position, s = e.reverseDirection, a = e.tooltipDimension, l = e.viewBox, u = e.viewBoxDimension;
  if (o && ue(o[i]))
    return o[i];
  var c = r[i] - a - n, d = r[i] + n;
  if (t[i])
    return s[i] ? c : d;
  if (s[i]) {
    var h = c, p = l[i];
    return h < p ? Math.max(d, l[i]) : Math.max(c, l[i]);
  }
  var g = d + a, m = l[i] + u;
  return g > m ? Math.max(c, l[i]) : Math.max(d, l[i]);
}
function N4(e) {
  var t = e.translateX, r = e.translateY, i = e.useTranslate3d;
  return {
    transform: i ? "translate3d(".concat(t, "px, ").concat(r, "px, 0)") : "translate(".concat(t, "px, ").concat(r, "px)")
  };
}
function L4(e) {
  var t = e.allowEscapeViewBox, r = e.coordinate, i = e.offsetTopLeft, n = e.position, o = e.reverseDirection, s = e.tooltipBox, a = e.useTranslate3d, l = e.viewBox, u, c, d;
  return s.height > 0 && s.width > 0 && r ? (c = A0({
    allowEscapeViewBox: t,
    coordinate: r,
    key: "x",
    offsetTopLeft: i,
    position: n,
    reverseDirection: o,
    tooltipDimension: s.width,
    viewBox: l,
    viewBoxDimension: l.width
  }), d = A0({
    allowEscapeViewBox: t,
    coordinate: r,
    key: "y",
    offsetTopLeft: i,
    position: n,
    reverseDirection: o,
    tooltipDimension: s.height,
    viewBox: l,
    viewBoxDimension: l.height
  }), u = N4({
    translateX: c,
    translateY: d,
    useTranslate3d: a
  })) : u = F4, {
    cssProperties: u,
    cssClasses: _4({
      translateX: c,
      translateY: d,
      coordinate: r
    })
  };
}
function Al(e) {
  "@babel/helpers - typeof";
  return Al = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Al(e);
}
function D0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function T0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D0(Object(r), !0).forEach(function(i) {
      by(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : D0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function G4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function k4(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, XI(i.key), i);
  }
}
function V4(e, t, r) {
  return t && k4(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function H4(e, t, r) {
  return t = cf(t), B4(e, YI() ? Reflect.construct(t, r || [], cf(e).constructor) : t.apply(e, r));
}
function B4(e, t) {
  if (t && (Al(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return W4(e);
}
function W4(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function YI() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (YI = function() {
    return !!e;
  })();
}
function cf(e) {
  return cf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, cf(e);
}
function $4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && yy(e, t);
}
function yy(e, t) {
  return yy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, yy(e, t);
}
function by(e, t, r) {
  return t = XI(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function XI(e) {
  var t = j4(e, "string");
  return Al(t) == "symbol" ? t : t + "";
}
function j4(e, t) {
  if (Al(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Al(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var R0 = 1, z4 = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    G4(this, t);
    for (var i = arguments.length, n = new Array(i), o = 0; o < i; o++)
      n[o] = arguments[o];
    return r = H4(this, t, [].concat(n)), by(r, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      },
      lastBoundingBox: {
        width: -1,
        height: -1
      }
    }), by(r, "handleKeyDown", function(s) {
      if (s.key === "Escape") {
        var a, l, u, c;
        r.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (a = (l = r.props.coordinate) === null || l === void 0 ? void 0 : l.x) !== null && a !== void 0 ? a : 0,
            y: (u = (c = r.props.coordinate) === null || c === void 0 ? void 0 : c.y) !== null && u !== void 0 ? u : 0
          }
        });
      }
    }), r;
  }
  return $4(t, e), V4(t, [{
    key: "updateBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var i = this.wrapperNode.getBoundingClientRect();
        (Math.abs(i.width - this.state.lastBoundingBox.width) > R0 || Math.abs(i.height - this.state.lastBoundingBox.height) > R0) && this.setState({
          lastBoundingBox: {
            width: i.width,
            height: i.height
          }
        });
      } else (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({
        lastBoundingBox: {
          width: -1,
          height: -1
        }
      });
    }
  }, {
    key: "componentDidMount",
    value: function() {
      document.addEventListener("keydown", this.handleKeyDown), this.updateBBox();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      var i, n;
      this.props.active && this.updateBBox(), this.state.dismissed && (((i = this.props.coordinate) === null || i === void 0 ? void 0 : i.x) !== this.state.dismissedAtCoordinate.x || ((n = this.props.coordinate) === null || n === void 0 ? void 0 : n.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
    }
  }, {
    key: "render",
    value: function() {
      var i = this, n = this.props, o = n.active, s = n.allowEscapeViewBox, a = n.animationDuration, l = n.animationEasing, u = n.children, c = n.coordinate, d = n.hasPayload, h = n.isAnimationActive, p = n.offset, g = n.position, m = n.reverseDirection, f = n.useTranslate3d, C = n.viewBox, w = n.wrapperStyle, E = L4({
        allowEscapeViewBox: s,
        coordinate: c,
        offsetTopLeft: p,
        position: g,
        reverseDirection: m,
        tooltipBox: this.state.lastBoundingBox,
        useTranslate3d: f,
        viewBox: C
      }), b = E.cssClasses, y = E.cssProperties, S = T0(T0({
        transition: h && o ? "transform ".concat(a, "ms ").concat(l) : void 0
      }, y), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && o && d ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, w);
      return (
        // This element allow listening to the `Escape` key.
        // See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ D.createElement("div", {
          tabIndex: -1,
          className: b,
          style: S,
          ref: function(R) {
            i.wrapperNode = R;
          }
        }, u)
      );
    }
  }]);
}(vn), U4 = function() {
  return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout);
}, Da = {
  isSsr: U4()
};
function Dl(e) {
  "@babel/helpers - typeof";
  return Dl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dl(e);
}
function P0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function I0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P0(Object(r), !0).forEach(function(i) {
      Uw(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : P0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Y4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function X4(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, qI(i.key), i);
  }
}
function K4(e, t, r) {
  return t && X4(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function q4(e, t, r) {
  return t = df(t), Z4(e, KI() ? Reflect.construct(t, r || [], df(e).constructor) : t.apply(e, r));
}
function Z4(e, t) {
  if (t && (Dl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return J4(e);
}
function J4(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function KI() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (KI = function() {
    return !!e;
  })();
}
function df(e) {
  return df = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, df(e);
}
function Q4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && wy(e, t);
}
function wy(e, t) {
  return wy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, wy(e, t);
}
function Uw(e, t, r) {
  return t = qI(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function qI(e) {
  var t = e5(e, "string");
  return Dl(t) == "symbol" ? t : t + "";
}
function e5(e, t) {
  if (Dl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Dl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function t5(e) {
  return e.dataKey;
}
function r5(e, t) {
  return /* @__PURE__ */ D.isValidElement(e) ? /* @__PURE__ */ D.cloneElement(e, t) : typeof e == "function" ? /* @__PURE__ */ D.createElement(e, t) : /* @__PURE__ */ D.createElement(I4, t);
}
var Mi = /* @__PURE__ */ function(e) {
  function t() {
    return Y4(this, t), q4(this, t, arguments);
  }
  return Q4(t, e), K4(t, [{
    key: "render",
    value: function() {
      var i = this, n = this.props, o = n.active, s = n.allowEscapeViewBox, a = n.animationDuration, l = n.animationEasing, u = n.content, c = n.coordinate, d = n.filterNull, h = n.isAnimationActive, p = n.offset, g = n.payload, m = n.payloadUniqBy, f = n.position, C = n.reverseDirection, w = n.useTranslate3d, E = n.viewBox, b = n.wrapperStyle, y = g ?? [];
      d && y.length && (y = VI(g.filter(function(x) {
        return x.value != null && (x.hide !== !0 || i.props.includeHidden);
      }), m, t5));
      var S = y.length > 0;
      return /* @__PURE__ */ D.createElement(z4, {
        allowEscapeViewBox: s,
        animationDuration: a,
        animationEasing: l,
        isAnimationActive: h,
        active: o,
        coordinate: c,
        hasPayload: S,
        offset: p,
        position: f,
        reverseDirection: C,
        useTranslate3d: w,
        viewBox: E,
        wrapperStyle: b
      }, r5(u, I0(I0({}, this.props), {}, {
        payload: y
      })));
    }
  }]);
}(vn);
Uw(Mi, "displayName", "Tooltip");
Uw(Mi, "defaultProps", {
  accessibilityLayer: !1,
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: {
    x: 0,
    y: 0
  },
  cursor: !0,
  cursorStyle: {},
  filterNull: !0,
  isAnimationActive: !Da.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  wrapperStyle: {}
});
var i5 = Zn, n5 = function() {
  return i5.Date.now();
}, o5 = n5, s5 = /\s/;
function a5(e) {
  for (var t = e.length; t-- && s5.test(e.charAt(t)); )
    ;
  return t;
}
var l5 = a5, u5 = l5, c5 = /^\s+/;
function d5(e) {
  return e && e.slice(0, u5(e) + 1).replace(c5, "");
}
var h5 = d5, p5 = h5, O0 = os, f5 = Eu, M0 = NaN, g5 = /^[-+]0x[0-9a-f]+$/i, m5 = /^0b[01]+$/i, v5 = /^0o[0-7]+$/i, C5 = parseInt;
function y5(e) {
  if (typeof e == "number")
    return e;
  if (f5(e))
    return M0;
  if (O0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = O0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = p5(e);
  var r = m5.test(e);
  return r || v5.test(e) ? C5(e.slice(2), r ? 2 : 8) : g5.test(e) ? M0 : +e;
}
var ZI = y5, b5 = os, Lv = o5, F0 = ZI, w5 = "Expected a function", S5 = Math.max, E5 = Math.min;
function x5(e, t, r) {
  var i, n, o, s, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(w5);
  t = F0(t) || 0, b5(r) && (c = !!r.leading, d = "maxWait" in r, o = d ? S5(F0(r.maxWait) || 0, t) : o, h = "trailing" in r ? !!r.trailing : h);
  function p(S) {
    var x = i, R = n;
    return i = n = void 0, u = S, s = e.apply(R, x), s;
  }
  function g(S) {
    return u = S, a = setTimeout(C, t), c ? p(S) : s;
  }
  function m(S) {
    var x = S - l, R = S - u, P = t - x;
    return d ? E5(P, o - R) : P;
  }
  function f(S) {
    var x = S - l, R = S - u;
    return l === void 0 || x >= t || x < 0 || d && R >= o;
  }
  function C() {
    var S = Lv();
    if (f(S))
      return w(S);
    a = setTimeout(C, m(S));
  }
  function w(S) {
    return a = void 0, h && i ? p(S) : (i = n = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, i = l = n = a = void 0;
  }
  function b() {
    return a === void 0 ? s : w(Lv());
  }
  function y() {
    var S = Lv(), x = f(S);
    if (i = arguments, n = this, l = S, x) {
      if (a === void 0)
        return g(l);
      if (d)
        return clearTimeout(a), a = setTimeout(C, t), p(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return y.cancel = E, y.flush = b, y;
}
var A5 = x5, D5 = A5, T5 = os, R5 = "Expected a function";
function P5(e, t, r) {
  var i = !0, n = !0;
  if (typeof e != "function")
    throw new TypeError(R5);
  return T5(r) && (i = "leading" in r ? !!r.leading : i, n = "trailing" in r ? !!r.trailing : n), D5(e, t, {
    leading: i,
    maxWait: t,
    trailing: n
  });
}
var I5 = P5;
const JI = /* @__PURE__ */ Ct(I5);
function qc(e) {
  "@babel/helpers - typeof";
  return qc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qc(e);
}
function _0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function ep(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _0(Object(r), !0).forEach(function(i) {
      O5(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : _0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function O5(e, t, r) {
  return t = M5(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function M5(e) {
  var t = F5(e, "string");
  return qc(t) == "symbol" ? t : t + "";
}
function F5(e, t) {
  if (qc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (qc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _5(e, t) {
  return k5(e) || G5(e, t) || L5(e, t) || N5();
}
function N5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function L5(e, t) {
  if (e) {
    if (typeof e == "string") return N0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return N0(e, t);
  }
}
function N0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function G5(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function k5(e) {
  if (Array.isArray(e)) return e;
}
var Yw = /* @__PURE__ */ ns(function(e, t) {
  var r = e.aspect, i = e.initialDimension, n = i === void 0 ? {
    width: -1,
    height: -1
  } : i, o = e.width, s = o === void 0 ? "100%" : o, a = e.height, l = a === void 0 ? "100%" : a, u = e.minWidth, c = u === void 0 ? 0 : u, d = e.minHeight, h = e.maxHeight, p = e.children, g = e.debounce, m = g === void 0 ? 0 : g, f = e.id, C = e.className, w = e.onResize, E = e.style, b = E === void 0 ? {} : E, y = re(null), S = re();
  S.current = w, jg(t, function() {
    return Object.defineProperty(y.current, "current", {
      get: function() {
        return console.warn("The usage of ref.current.current is deprecated and will no longer be supported."), y.current;
      },
      configurable: !0
    });
  });
  var x = ee({
    containerWidth: n.width,
    containerHeight: n.height
  }), R = _5(x, 2), P = R[0], O = R[1], I = fe(function(_, G) {
    O(function(F) {
      var N = Math.round(_), V = Math.round(G);
      return F.containerWidth === N && F.containerHeight === V ? F : {
        containerWidth: N,
        containerHeight: V
      };
    });
  }, []);
  gt(function() {
    var _ = function($) {
      var L, z = $[0].contentRect, j = z.width, U = z.height;
      I(j, U), (L = S.current) === null || L === void 0 || L.call(S, j, U);
    };
    m > 0 && (_ = JI(_, m, {
      trailing: !0,
      leading: !1
    }));
    var G = new ResizeObserver(_), F = y.current.getBoundingClientRect(), N = F.width, V = F.height;
    return I(N, V), G.observe(y.current), function() {
      G.disconnect();
    };
  }, [I, m]);
  var M = Ee(function() {
    var _ = P.containerWidth, G = P.containerHeight;
    if (_ < 0 || G < 0)
      return null;
    dn(_s(s) || _s(l), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, s, l), dn(!r || r > 0, "The aspect(%s) must be greater than zero.", r);
    var F = _s(s) ? _ : s, N = _s(l) ? G : l;
    r && r > 0 && (F ? N = F / r : N && (F = N * r), h && N > h && (N = h)), dn(F > 0 || N > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, F, N, s, l, c, d, r);
    var V = !Array.isArray(p) && lo(p.type).endsWith("Chart");
    return D.Children.map(p, function(B) {
      return /* @__PURE__ */ D.isValidElement(B) ? /* @__PURE__ */ Gt(B, ep({
        width: F,
        height: N
      }, V ? {
        style: ep({
          height: "100%",
          width: "100%",
          maxHeight: N,
          maxWidth: F
        }, B.props.style)
      } : {})) : B;
    });
  }, [r, p, l, h, d, c, P, s]);
  return /* @__PURE__ */ D.createElement("div", {
    id: f ? "".concat(f) : void 0,
    className: xe("recharts-responsive-container", C),
    style: ep(ep({}, b), {}, {
      width: s,
      height: l,
      minWidth: c,
      minHeight: d,
      maxHeight: h
    }),
    ref: y
  }, M);
}), im = function(t) {
  return null;
};
im.displayName = "Cell";
function Zc(e) {
  "@babel/helpers - typeof";
  return Zc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Zc(e);
}
function L0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Sy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L0(Object(r), !0).forEach(function(i) {
      V5(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : L0(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function V5(e, t, r) {
  return t = H5(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function H5(e) {
  var t = B5(e, "string");
  return Zc(t) == "symbol" ? t : t + "";
}
function B5(e, t) {
  if (Zc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Zc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Ya = {
  widthCache: {},
  cacheCount: 0
}, W5 = 2e3, $5 = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, G0 = "recharts_measurement_span";
function j5(e) {
  var t = Sy({}, e);
  return Object.keys(t).forEach(function(r) {
    t[r] || delete t[r];
  }), t;
}
var Fc = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (t == null || Da.isSsr)
    return {
      width: 0,
      height: 0
    };
  var i = j5(r), n = JSON.stringify({
    text: t,
    copyStyle: i
  });
  if (Ya.widthCache[n])
    return Ya.widthCache[n];
  try {
    var o = document.getElementById(G0);
    o || (o = document.createElement("span"), o.setAttribute("id", G0), o.setAttribute("aria-hidden", "true"), document.body.appendChild(o));
    var s = Sy(Sy({}, $5), i);
    Object.assign(o.style, s), o.textContent = "".concat(t);
    var a = o.getBoundingClientRect(), l = {
      width: a.width,
      height: a.height
    };
    return Ya.widthCache[n] = l, ++Ya.cacheCount > W5 && (Ya.cacheCount = 0, Ya.widthCache = {}), l;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, z5 = function(t) {
  return {
    top: t.top + window.scrollY - document.documentElement.clientTop,
    left: t.left + window.scrollX - document.documentElement.clientLeft
  };
};
function Jc(e) {
  "@babel/helpers - typeof";
  return Jc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jc(e);
}
function hf(e, t) {
  return K5(e) || X5(e, t) || Y5(e, t) || U5();
}
function U5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Y5(e, t) {
  if (e) {
    if (typeof e == "string") return k0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return k0(e, t);
  }
}
function k0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function X5(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function K5(e) {
  if (Array.isArray(e)) return e;
}
function q5(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function V0(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, J5(i.key), i);
  }
}
function Z5(e, t, r) {
  return t && V0(e.prototype, t), r && V0(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function J5(e) {
  var t = Q5(e, "string");
  return Jc(t) == "symbol" ? t : t + "";
}
function Q5(e, t) {
  if (Jc(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Jc(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var H0 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, B0 = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, eX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, tX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, QI = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, rX = Object.keys(QI), sl = "NaN";
function iX(e, t) {
  return e * QI[t];
}
var tp = /* @__PURE__ */ function() {
  function e(t, r) {
    q5(this, e), this.num = t, this.unit = r, this.num = t, this.unit = r, Number.isNaN(t) && (this.unit = ""), r !== "" && !eX.test(r) && (this.num = NaN, this.unit = ""), rX.includes(r) && (this.num = iX(t, r), this.unit = "px");
  }
  return Z5(e, [{
    key: "add",
    value: function(r) {
      return this.unit !== r.unit ? new e(NaN, "") : new e(this.num + r.num, this.unit);
    }
  }, {
    key: "subtract",
    value: function(r) {
      return this.unit !== r.unit ? new e(NaN, "") : new e(this.num - r.num, this.unit);
    }
  }, {
    key: "multiply",
    value: function(r) {
      return this.unit !== "" && r.unit !== "" && this.unit !== r.unit ? new e(NaN, "") : new e(this.num * r.num, this.unit || r.unit);
    }
  }, {
    key: "divide",
    value: function(r) {
      return this.unit !== "" && r.unit !== "" && this.unit !== r.unit ? new e(NaN, "") : new e(this.num / r.num, this.unit || r.unit);
    }
  }, {
    key: "toString",
    value: function() {
      return "".concat(this.num).concat(this.unit);
    }
  }, {
    key: "isNaN",
    value: function() {
      return Number.isNaN(this.num);
    }
  }], [{
    key: "parse",
    value: function(r) {
      var i, n = (i = tX.exec(r)) !== null && i !== void 0 ? i : [], o = hf(n, 3), s = o[1], a = o[2];
      return new e(parseFloat(s), a ?? "");
    }
  }]);
}();
function eO(e) {
  if (e.includes(sl))
    return sl;
  for (var t = e; t.includes("*") || t.includes("/"); ) {
    var r, i = (r = H0.exec(t)) !== null && r !== void 0 ? r : [], n = hf(i, 4), o = n[1], s = n[2], a = n[3], l = tp.parse(o ?? ""), u = tp.parse(a ?? ""), c = s === "*" ? l.multiply(u) : l.divide(u);
    if (c.isNaN())
      return sl;
    t = t.replace(H0, c.toString());
  }
  for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t); ) {
    var d, h = (d = B0.exec(t)) !== null && d !== void 0 ? d : [], p = hf(h, 4), g = p[1], m = p[2], f = p[3], C = tp.parse(g ?? ""), w = tp.parse(f ?? ""), E = m === "+" ? C.add(w) : C.subtract(w);
    if (E.isNaN())
      return sl;
    t = t.replace(B0, E.toString());
  }
  return t;
}
var W0 = /\(([^()]*)\)/;
function nX(e) {
  for (var t = e; t.includes("("); ) {
    var r = W0.exec(t), i = hf(r, 2), n = i[1];
    t = t.replace(W0, eO(n));
  }
  return t;
}
function oX(e) {
  var t = e.replace(/\s+/g, "");
  return t = nX(t), t = eO(t), t;
}
function sX(e) {
  try {
    return oX(e);
  } catch {
    return sl;
  }
}
function Gv(e) {
  var t = sX(e.slice(5, -1));
  return t === sl ? "" : t;
}
var aX = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], lX = ["dx", "dy", "angle", "className", "breakAll"];
function Ey() {
  return Ey = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Ey.apply(this, arguments);
}
function $0(e, t) {
  if (e == null) return {};
  var r = uX(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function uX(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function j0(e, t) {
  return pX(e) || hX(e, t) || dX(e, t) || cX();
}
function cX() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dX(e, t) {
  if (e) {
    if (typeof e == "string") return z0(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return z0(e, t);
  }
}
function z0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function hX(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function pX(e) {
  if (Array.isArray(e)) return e;
}
var tO = /[ \f\n\r\t\v\u2028\u2029]+/, rO = function(t) {
  var r = t.children, i = t.breakAll, n = t.style;
  try {
    var o = [];
    ke(r) || (i ? o = r.toString().split("") : o = r.toString().split(tO));
    var s = o.map(function(l) {
      return {
        word: l,
        width: Fc(l, n).width
      };
    }), a = i ? 0 : Fc("", n).width;
    return {
      wordsWithComputedWidth: s,
      spaceWidth: a
    };
  } catch {
    return null;
  }
}, fX = function(t, r, i, n, o) {
  var s = t.maxLines, a = t.children, l = t.style, u = t.breakAll, c = ue(s), d = a, h = function() {
    var F = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return F.reduce(function(N, V) {
      var B = V.word, $ = V.width, L = N[N.length - 1];
      if (L && (n == null || o || L.width + $ + i < Number(n)))
        L.words.push(B), L.width += $ + i;
      else {
        var z = {
          words: [B],
          width: $
        };
        N.push(z);
      }
      return N;
    }, []);
  }, p = h(r), g = function(F) {
    return F.reduce(function(N, V) {
      return N.width > V.width ? N : V;
    });
  };
  if (!c)
    return p;
  for (var m = "", f = function(F) {
    var N = d.slice(0, F), V = rO({
      breakAll: u,
      style: l,
      children: N + m
    }).wordsWithComputedWidth, B = h(V), $ = B.length > s || g(B).width > Number(n);
    return [$, B];
  }, C = 0, w = d.length - 1, E = 0, b; C <= w && E <= d.length - 1; ) {
    var y = Math.floor((C + w) / 2), S = y - 1, x = f(S), R = j0(x, 2), P = R[0], O = R[1], I = f(y), M = j0(I, 1), _ = M[0];
    if (!P && !_ && (C = y + 1), P && _ && (w = y - 1), !P && _) {
      b = O;
      break;
    }
    E++;
  }
  return b || p;
}, U0 = function(t) {
  var r = ke(t) ? [] : t.toString().split(tO);
  return [{
    words: r
  }];
}, gX = function(t) {
  var r = t.width, i = t.scaleToFit, n = t.children, o = t.style, s = t.breakAll, a = t.maxLines;
  if ((r || i) && !Da.isSsr) {
    var l, u, c = rO({
      breakAll: s,
      children: n,
      style: o
    });
    if (c) {
      var d = c.wordsWithComputedWidth, h = c.spaceWidth;
      l = d, u = h;
    } else
      return U0(n);
    return fX({
      breakAll: s,
      children: n,
      maxLines: a,
      style: o
    }, l, u, r, i);
  }
  return U0(n);
}, Y0 = "#808080", oa = function(t) {
  var r = t.x, i = r === void 0 ? 0 : r, n = t.y, o = n === void 0 ? 0 : n, s = t.lineHeight, a = s === void 0 ? "1em" : s, l = t.capHeight, u = l === void 0 ? "0.71em" : l, c = t.scaleToFit, d = c === void 0 ? !1 : c, h = t.textAnchor, p = h === void 0 ? "start" : h, g = t.verticalAnchor, m = g === void 0 ? "end" : g, f = t.fill, C = f === void 0 ? Y0 : f, w = $0(t, aX), E = Ee(function() {
    return gX({
      breakAll: w.breakAll,
      children: w.children,
      maxLines: w.maxLines,
      scaleToFit: d,
      style: w.style,
      width: w.width
    });
  }, [w.breakAll, w.children, w.maxLines, d, w.style, w.width]), b = w.dx, y = w.dy, S = w.angle, x = w.className, R = w.breakAll, P = $0(w, lX);
  if (!dr(i) || !dr(o))
    return null;
  var O = i + (ue(b) ? b : 0), I = o + (ue(y) ? y : 0), M;
  switch (m) {
    case "start":
      M = Gv("calc(".concat(u, ")"));
      break;
    case "middle":
      M = Gv("calc(".concat((E.length - 1) / 2, " * -").concat(a, " + (").concat(u, " / 2))"));
      break;
    default:
      M = Gv("calc(".concat(E.length - 1, " * -").concat(a, ")"));
      break;
  }
  var _ = [];
  if (d) {
    var G = E[0].width, F = w.width;
    _.push("scale(".concat((ue(F) ? F / G : 1) / G, ")"));
  }
  return S && _.push("rotate(".concat(S, ", ").concat(O, ", ").concat(I, ")")), _.length && (P.transform = _.join(" ")), /* @__PURE__ */ D.createElement("text", Ey({}, Ie(P, !0), {
    x: O,
    y: I,
    className: xe("recharts-text", x),
    textAnchor: p,
    fill: C.includes("url") ? Y0 : C
  }), E.map(function(N, V) {
    var B = N.words.join(R ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ D.createElement("tspan", {
        x: O,
        dy: V === 0 ? M : a,
        key: "".concat(B, "-").concat(V)
      }, B)
    );
  }));
};
function zo(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function mX(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Xw(e) {
  let t, r, i;
  e.length !== 2 ? (t = zo, r = (a, l) => zo(e(a), l), i = (a, l) => e(a) - l) : (t = e === zo || e === mX ? e : vX, r = e, i = e);
  function n(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (t(l, l) !== 0) return c;
      do {
        const d = u + c >>> 1;
        r(a[d], l) < 0 ? u = d + 1 : c = d;
      } while (u < c);
    }
    return u;
  }
  function o(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (t(l, l) !== 0) return c;
      do {
        const d = u + c >>> 1;
        r(a[d], l) <= 0 ? u = d + 1 : c = d;
      } while (u < c);
    }
    return u;
  }
  function s(a, l, u = 0, c = a.length) {
    const d = n(a, l, u, c - 1);
    return d > u && i(a[d - 1], l) > -i(a[d], l) ? d - 1 : d;
  }
  return { left: n, center: s, right: o };
}
function vX() {
  return 0;
}
function iO(e) {
  return e === null ? NaN : +e;
}
function* CX(e, t) {
  for (let r of e)
    r != null && (r = +r) >= r && (yield r);
}
const yX = Xw(zo), dh = yX.right;
Xw(iO).center;
class X0 extends Map {
  constructor(t, r = SX) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null) for (const [i, n] of t) this.set(i, n);
  }
  get(t) {
    return super.get(K0(this, t));
  }
  has(t) {
    return super.has(K0(this, t));
  }
  set(t, r) {
    return super.set(bX(this, t), r);
  }
  delete(t) {
    return super.delete(wX(this, t));
  }
}
function K0({ _intern: e, _key: t }, r) {
  const i = t(r);
  return e.has(i) ? e.get(i) : r;
}
function bX({ _intern: e, _key: t }, r) {
  const i = t(r);
  return e.has(i) ? e.get(i) : (e.set(i, r), r);
}
function wX({ _intern: e, _key: t }, r) {
  const i = t(r);
  return e.has(i) && (r = e.get(i), e.delete(i)), r;
}
function SX(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function EX(e = zo) {
  if (e === zo) return nO;
  if (typeof e != "function") throw new TypeError("compare is not a function");
  return (t, r) => {
    const i = e(t, r);
    return i || i === 0 ? i : (e(r, r) === 0) - (e(t, t) === 0);
  };
}
function nO(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const xX = Math.sqrt(50), AX = Math.sqrt(10), DX = Math.sqrt(2);
function pf(e, t, r) {
  const i = (t - e) / Math.max(0, r), n = Math.floor(Math.log10(i)), o = i / Math.pow(10, n), s = o >= xX ? 10 : o >= AX ? 5 : o >= DX ? 2 : 1;
  let a, l, u;
  return n < 0 ? (u = Math.pow(10, -n) / s, a = Math.round(e * u), l = Math.round(t * u), a / u < e && ++a, l / u > t && --l, u = -u) : (u = Math.pow(10, n) * s, a = Math.round(e / u), l = Math.round(t / u), a * u < e && ++a, l * u > t && --l), l < a && 0.5 <= r && r < 2 ? pf(e, t, r * 2) : [a, l, u];
}
function xy(e, t, r) {
  if (t = +t, e = +e, r = +r, !(r > 0)) return [];
  if (e === t) return [e];
  const i = t < e, [n, o, s] = i ? pf(t, e, r) : pf(e, t, r);
  if (!(o >= n)) return [];
  const a = o - n + 1, l = new Array(a);
  if (i)
    if (s < 0) for (let u = 0; u < a; ++u) l[u] = (o - u) / -s;
    else for (let u = 0; u < a; ++u) l[u] = (o - u) * s;
  else if (s < 0) for (let u = 0; u < a; ++u) l[u] = (n + u) / -s;
  else for (let u = 0; u < a; ++u) l[u] = (n + u) * s;
  return l;
}
function Ay(e, t, r) {
  return t = +t, e = +e, r = +r, pf(e, t, r)[2];
}
function Dy(e, t, r) {
  t = +t, e = +e, r = +r;
  const i = t < e, n = i ? Ay(t, e, r) : Ay(e, t, r);
  return (i ? -1 : 1) * (n < 0 ? 1 / -n : n);
}
function q0(e, t) {
  let r;
  for (const i of e)
    i != null && (r < i || r === void 0 && i >= i) && (r = i);
  return r;
}
function Z0(e, t) {
  let r;
  for (const i of e)
    i != null && (r > i || r === void 0 && i >= i) && (r = i);
  return r;
}
function oO(e, t, r = 0, i = 1 / 0, n) {
  if (t = Math.floor(t), r = Math.floor(Math.max(0, r)), i = Math.floor(Math.min(e.length - 1, i)), !(r <= t && t <= i)) return e;
  for (n = n === void 0 ? nO : EX(n); i > r; ) {
    if (i - r > 600) {
      const l = i - r + 1, u = t - r + 1, c = Math.log(l), d = 0.5 * Math.exp(2 * c / 3), h = 0.5 * Math.sqrt(c * d * (l - d) / l) * (u - l / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(t - u * d / l + h)), g = Math.min(i, Math.floor(t + (l - u) * d / l + h));
      oO(e, t, p, g, n);
    }
    const o = e[t];
    let s = r, a = i;
    for (sc(e, r, t), n(e[i], o) > 0 && sc(e, r, i); s < a; ) {
      for (sc(e, s, a), ++s, --a; n(e[s], o) < 0; ) ++s;
      for (; n(e[a], o) > 0; ) --a;
    }
    n(e[r], o) === 0 ? sc(e, r, a) : (++a, sc(e, a, i)), a <= t && (r = a + 1), t <= a && (i = a - 1);
  }
  return e;
}
function sc(e, t, r) {
  const i = e[t];
  e[t] = e[r], e[r] = i;
}
function TX(e, t, r) {
  if (e = Float64Array.from(CX(e)), !(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2) return Z0(e);
    if (t >= 1) return q0(e);
    var i, n = (i - 1) * t, o = Math.floor(n), s = q0(oO(e, o).subarray(0, o + 1)), a = Z0(e.subarray(o + 1));
    return s + (a - s) * (n - o);
  }
}
function RX(e, t, r = iO) {
  if (!(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2) return +r(e[0], 0, e);
    if (t >= 1) return +r(e[i - 1], i - 1, e);
    var i, n = (i - 1) * t, o = Math.floor(n), s = +r(e[o], o, e), a = +r(e[o + 1], o + 1, e);
    return s + (a - s) * (n - o);
  }
}
function PX(e, t, r) {
  e = +e, t = +t, r = (n = arguments.length) < 2 ? (t = e, e = 0, 1) : n < 3 ? 1 : +r;
  for (var i = -1, n = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(n); ++i < n; )
    o[i] = e + i * r;
  return o;
}
function qi(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Ro(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const Ty = Symbol("implicit");
function Kw() {
  var e = new X0(), t = [], r = [], i = Ty;
  function n(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (i !== Ty) return i;
      e.set(o, s = t.push(o) - 1);
    }
    return r[s % r.length];
  }
  return n.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new X0();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return n;
  }, n.range = function(o) {
    return arguments.length ? (r = Array.from(o), n) : r.slice();
  }, n.unknown = function(o) {
    return arguments.length ? (i = o, n) : i;
  }, n.copy = function() {
    return Kw(t, r).unknown(i);
  }, qi.apply(n, arguments), n;
}
function Qc() {
  var e = Kw().unknown(void 0), t = e.domain, r = e.range, i = 0, n = 1, o, s, a = !1, l = 0, u = 0, c = 0.5;
  delete e.unknown;
  function d() {
    var h = t().length, p = n < i, g = p ? n : i, m = p ? i : n;
    o = (m - g) / Math.max(1, h - l + u * 2), a && (o = Math.floor(o)), g += (m - g - o * (h - l)) * c, s = o * (1 - l), a && (g = Math.round(g), s = Math.round(s));
    var f = PX(h).map(function(C) {
      return g + o * C;
    });
    return r(p ? f.reverse() : f);
  }
  return e.domain = function(h) {
    return arguments.length ? (t(h), d()) : t();
  }, e.range = function(h) {
    return arguments.length ? ([i, n] = h, i = +i, n = +n, d()) : [i, n];
  }, e.rangeRound = function(h) {
    return [i, n] = h, i = +i, n = +n, a = !0, d();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(h) {
    return arguments.length ? (a = !!h, d()) : a;
  }, e.padding = function(h) {
    return arguments.length ? (l = Math.min(1, u = +h), d()) : l;
  }, e.paddingInner = function(h) {
    return arguments.length ? (l = Math.min(1, h), d()) : l;
  }, e.paddingOuter = function(h) {
    return arguments.length ? (u = +h, d()) : u;
  }, e.align = function(h) {
    return arguments.length ? (c = Math.max(0, Math.min(1, h)), d()) : c;
  }, e.copy = function() {
    return Qc(t(), [i, n]).round(a).paddingInner(l).paddingOuter(u).align(c);
  }, qi.apply(d(), arguments);
}
function sO(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return sO(t());
  }, e;
}
function _c() {
  return sO(Qc.apply(null, arguments).paddingInner(1));
}
function qw(e, t, r) {
  e.prototype = t.prototype = r, r.constructor = e;
}
function aO(e, t) {
  var r = Object.create(e.prototype);
  for (var i in t) r[i] = t[i];
  return r;
}
function hh() {
}
var ed = 0.7, ff = 1 / ed, fl = "\\s*([+-]?\\d+)\\s*", td = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Fn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", IX = /^#([0-9a-f]{3,8})$/, OX = new RegExp(`^rgb\\(${fl},${fl},${fl}\\)$`), MX = new RegExp(`^rgb\\(${Fn},${Fn},${Fn}\\)$`), FX = new RegExp(`^rgba\\(${fl},${fl},${fl},${td}\\)$`), _X = new RegExp(`^rgba\\(${Fn},${Fn},${Fn},${td}\\)$`), NX = new RegExp(`^hsl\\(${td},${Fn},${Fn}\\)$`), LX = new RegExp(`^hsla\\(${td},${Fn},${Fn},${td}\\)$`), J0 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
qw(hh, rd, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Q0,
  // Deprecated! Use color.formatHex.
  formatHex: Q0,
  formatHex8: GX,
  formatHsl: kX,
  formatRgb: eA,
  toString: eA
});
function Q0() {
  return this.rgb().formatHex();
}
function GX() {
  return this.rgb().formatHex8();
}
function kX() {
  return lO(this).formatHsl();
}
function eA() {
  return this.rgb().formatRgb();
}
function rd(e) {
  var t, r;
  return e = (e + "").trim().toLowerCase(), (t = IX.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), r === 6 ? tA(t) : r === 3 ? new Kr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? rp(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? rp(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = OX.exec(e)) ? new Kr(t[1], t[2], t[3], 1) : (t = MX.exec(e)) ? new Kr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = FX.exec(e)) ? rp(t[1], t[2], t[3], t[4]) : (t = _X.exec(e)) ? rp(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = NX.exec(e)) ? nA(t[1], t[2] / 100, t[3] / 100, 1) : (t = LX.exec(e)) ? nA(t[1], t[2] / 100, t[3] / 100, t[4]) : J0.hasOwnProperty(e) ? tA(J0[e]) : e === "transparent" ? new Kr(NaN, NaN, NaN, 0) : null;
}
function tA(e) {
  return new Kr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function rp(e, t, r, i) {
  return i <= 0 && (e = t = r = NaN), new Kr(e, t, r, i);
}
function VX(e) {
  return e instanceof hh || (e = rd(e)), e ? (e = e.rgb(), new Kr(e.r, e.g, e.b, e.opacity)) : new Kr();
}
function Ry(e, t, r, i) {
  return arguments.length === 1 ? VX(e) : new Kr(e, t, r, i ?? 1);
}
function Kr(e, t, r, i) {
  this.r = +e, this.g = +t, this.b = +r, this.opacity = +i;
}
qw(Kr, Ry, aO(hh, {
  brighter(e) {
    return e = e == null ? ff : Math.pow(ff, e), new Kr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ed : Math.pow(ed, e), new Kr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Kr($s(this.r), $s(this.g), $s(this.b), gf(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rA,
  // Deprecated! Use color.formatHex.
  formatHex: rA,
  formatHex8: HX,
  formatRgb: iA,
  toString: iA
}));
function rA() {
  return `#${Ns(this.r)}${Ns(this.g)}${Ns(this.b)}`;
}
function HX() {
  return `#${Ns(this.r)}${Ns(this.g)}${Ns(this.b)}${Ns((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function iA() {
  const e = gf(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${$s(this.r)}, ${$s(this.g)}, ${$s(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function gf(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function $s(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ns(e) {
  return e = $s(e), (e < 16 ? "0" : "") + e.toString(16);
}
function nA(e, t, r, i) {
  return i <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new sn(e, t, r, i);
}
function lO(e) {
  if (e instanceof sn) return new sn(e.h, e.s, e.l, e.opacity);
  if (e instanceof hh || (e = rd(e)), !e) return new sn();
  if (e instanceof sn) return e;
  e = e.rgb();
  var t = e.r / 255, r = e.g / 255, i = e.b / 255, n = Math.min(t, r, i), o = Math.max(t, r, i), s = NaN, a = o - n, l = (o + n) / 2;
  return a ? (t === o ? s = (r - i) / a + (r < i) * 6 : r === o ? s = (i - t) / a + 2 : s = (t - r) / a + 4, a /= l < 0.5 ? o + n : 2 - o - n, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new sn(s, a, l, e.opacity);
}
function BX(e, t, r, i) {
  return arguments.length === 1 ? lO(e) : new sn(e, t, r, i ?? 1);
}
function sn(e, t, r, i) {
  this.h = +e, this.s = +t, this.l = +r, this.opacity = +i;
}
qw(sn, BX, aO(hh, {
  brighter(e) {
    return e = e == null ? ff : Math.pow(ff, e), new sn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ed : Math.pow(ed, e), new sn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, i = r + (r < 0.5 ? r : 1 - r) * t, n = 2 * r - i;
    return new Kr(
      kv(e >= 240 ? e - 240 : e + 120, n, i),
      kv(e, n, i),
      kv(e < 120 ? e + 240 : e - 120, n, i),
      this.opacity
    );
  },
  clamp() {
    return new sn(oA(this.h), ip(this.s), ip(this.l), gf(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = gf(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${oA(this.h)}, ${ip(this.s) * 100}%, ${ip(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function oA(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function ip(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function kv(e, t, r) {
  return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
const Zw = (e) => () => e;
function WX(e, t) {
  return function(r) {
    return e + r * t;
  };
}
function $X(e, t, r) {
  return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(i) {
    return Math.pow(e + i * t, r);
  };
}
function jX(e) {
  return (e = +e) == 1 ? uO : function(t, r) {
    return r - t ? $X(t, r, e) : Zw(isNaN(t) ? r : t);
  };
}
function uO(e, t) {
  var r = t - e;
  return r ? WX(e, r) : Zw(isNaN(e) ? t : e);
}
const sA = function e(t) {
  var r = jX(t);
  function i(n, o) {
    var s = r((n = Ry(n)).r, (o = Ry(o)).r), a = r(n.g, o.g), l = r(n.b, o.b), u = uO(n.opacity, o.opacity);
    return function(c) {
      return n.r = s(c), n.g = a(c), n.b = l(c), n.opacity = u(c), n + "";
    };
  }
  return i.gamma = e, i;
}(1);
function zX(e, t) {
  t || (t = []);
  var r = e ? Math.min(t.length, e.length) : 0, i = t.slice(), n;
  return function(o) {
    for (n = 0; n < r; ++n) i[n] = e[n] * (1 - o) + t[n] * o;
    return i;
  };
}
function UX(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function YX(e, t) {
  var r = t ? t.length : 0, i = e ? Math.min(r, e.length) : 0, n = new Array(i), o = new Array(r), s;
  for (s = 0; s < i; ++s) n[s] = Mu(e[s], t[s]);
  for (; s < r; ++s) o[s] = t[s];
  return function(a) {
    for (s = 0; s < i; ++s) o[s] = n[s](a);
    return o;
  };
}
function XX(e, t) {
  var r = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(i) {
    return r.setTime(e * (1 - i) + t * i), r;
  };
}
function mf(e, t) {
  return e = +e, t = +t, function(r) {
    return e * (1 - r) + t * r;
  };
}
function KX(e, t) {
  var r = {}, i = {}, n;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (n in t)
    n in e ? r[n] = Mu(e[n], t[n]) : i[n] = t[n];
  return function(o) {
    for (n in r) i[n] = r[n](o);
    return i;
  };
}
var Py = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Vv = new RegExp(Py.source, "g");
function qX(e) {
  return function() {
    return e;
  };
}
function ZX(e) {
  return function(t) {
    return e(t) + "";
  };
}
function JX(e, t) {
  var r = Py.lastIndex = Vv.lastIndex = 0, i, n, o, s = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (i = Py.exec(e)) && (n = Vv.exec(t)); )
    (o = n.index) > r && (o = t.slice(r, o), a[s] ? a[s] += o : a[++s] = o), (i = i[0]) === (n = n[0]) ? a[s] ? a[s] += n : a[++s] = n : (a[++s] = null, l.push({ i: s, x: mf(i, n) })), r = Vv.lastIndex;
  return r < t.length && (o = t.slice(r), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? ZX(l[0].x) : qX(t) : (t = l.length, function(u) {
    for (var c = 0, d; c < t; ++c) a[(d = l[c]).i] = d.x(u);
    return a.join("");
  });
}
function Mu(e, t) {
  var r = typeof t, i;
  return t == null || r === "boolean" ? Zw(t) : (r === "number" ? mf : r === "string" ? (i = rd(t)) ? (t = i, sA) : JX : t instanceof rd ? sA : t instanceof Date ? XX : UX(t) ? zX : Array.isArray(t) ? YX : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? KX : mf)(e, t);
}
function Jw(e, t) {
  return e = +e, t = +t, function(r) {
    return Math.round(e * (1 - r) + t * r);
  };
}
function QX(e, t) {
  t === void 0 && (t = e, e = Mu);
  for (var r = 0, i = t.length - 1, n = t[0], o = new Array(i < 0 ? 0 : i); r < i; ) o[r] = e(n, n = t[++r]);
  return function(s) {
    var a = Math.max(0, Math.min(i - 1, Math.floor(s *= i)));
    return o[a](s - a);
  };
}
function e9(e) {
  return function() {
    return e;
  };
}
function vf(e) {
  return +e;
}
var aA = [0, 1];
function Gr(e) {
  return e;
}
function Iy(e, t) {
  return (t -= e = +e) ? function(r) {
    return (r - e) / t;
  } : e9(isNaN(t) ? NaN : 0.5);
}
function t9(e, t) {
  var r;
  return e > t && (r = e, e = t, t = r), function(i) {
    return Math.max(e, Math.min(t, i));
  };
}
function r9(e, t, r) {
  var i = e[0], n = e[1], o = t[0], s = t[1];
  return n < i ? (i = Iy(n, i), o = r(s, o)) : (i = Iy(i, n), o = r(o, s)), function(a) {
    return o(i(a));
  };
}
function i9(e, t, r) {
  var i = Math.min(e.length, t.length) - 1, n = new Array(i), o = new Array(i), s = -1;
  for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < i; )
    n[s] = Iy(e[s], e[s + 1]), o[s] = r(t[s], t[s + 1]);
  return function(a) {
    var l = dh(e, a, 1, i) - 1;
    return o[l](n[l](a));
  };
}
function ph(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function nm() {
  var e = aA, t = aA, r = Mu, i, n, o, s = Gr, a, l, u;
  function c() {
    var h = Math.min(e.length, t.length);
    return s !== Gr && (s = t9(e[0], e[h - 1])), a = h > 2 ? i9 : r9, l = u = null, d;
  }
  function d(h) {
    return h == null || isNaN(h = +h) ? o : (l || (l = a(e.map(i), t, r)))(i(s(h)));
  }
  return d.invert = function(h) {
    return s(n((u || (u = a(t, e.map(i), mf)))(h)));
  }, d.domain = function(h) {
    return arguments.length ? (e = Array.from(h, vf), c()) : e.slice();
  }, d.range = function(h) {
    return arguments.length ? (t = Array.from(h), c()) : t.slice();
  }, d.rangeRound = function(h) {
    return t = Array.from(h), r = Jw, c();
  }, d.clamp = function(h) {
    return arguments.length ? (s = h ? !0 : Gr, c()) : s !== Gr;
  }, d.interpolate = function(h) {
    return arguments.length ? (r = h, c()) : r;
  }, d.unknown = function(h) {
    return arguments.length ? (o = h, d) : o;
  }, function(h, p) {
    return i = h, n = p, c();
  };
}
function Qw() {
  return nm()(Gr, Gr);
}
function n9(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Cf(e, t) {
  if ((r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var r, i = e.slice(0, r);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +e.slice(r + 1)
  ];
}
function Tl(e) {
  return e = Cf(Math.abs(e)), e ? e[1] : NaN;
}
function o9(e, t) {
  return function(r, i) {
    for (var n = r.length, o = [], s = 0, a = e[0], l = 0; n > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), o.push(r.substring(n -= a, n + a)), !((l += a + 1) > i)); )
      a = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function s9(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(r) {
      return e[+r];
    });
  };
}
var a9 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function id(e) {
  if (!(t = a9.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new eS({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
id.prototype = eS.prototype;
function eS(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
eS.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function l9(e) {
  e: for (var t = e.length, r = 1, i = -1, n; r < t; ++r)
    switch (e[r]) {
      case ".":
        i = n = r;
        break;
      case "0":
        i === 0 && (i = r), n = r;
        break;
      default:
        if (!+e[r]) break e;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? e.slice(0, i) + e.slice(n + 1) : e;
}
var cO;
function u9(e, t) {
  var r = Cf(e, t);
  if (!r) return e + "";
  var i = r[0], n = r[1], o = n - (cO = Math.max(-8, Math.min(8, Math.floor(n / 3))) * 3) + 1, s = i.length;
  return o === s ? i : o > s ? i + new Array(o - s + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + Cf(e, Math.max(0, t + o - 1))[0];
}
function lA(e, t) {
  var r = Cf(e, t);
  if (!r) return e + "";
  var i = r[0], n = r[1];
  return n < 0 ? "0." + new Array(-n).join("0") + i : i.length > n + 1 ? i.slice(0, n + 1) + "." + i.slice(n + 1) : i + new Array(n - i.length + 2).join("0");
}
const uA = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: n9,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => lA(e * 100, t),
  r: lA,
  s: u9,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function cA(e) {
  return e;
}
var dA = Array.prototype.map, hA = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function c9(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? cA : o9(dA.call(e.grouping, Number), e.thousands + ""), r = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", n = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? cA : s9(dA.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function u(d) {
    d = id(d);
    var h = d.fill, p = d.align, g = d.sign, m = d.symbol, f = d.zero, C = d.width, w = d.comma, E = d.precision, b = d.trim, y = d.type;
    y === "n" ? (w = !0, y = "g") : uA[y] || (E === void 0 && (E = 12), b = !0, y = "g"), (f || h === "0" && p === "=") && (f = !0, h = "0", p = "=");
    var S = m === "$" ? r : m === "#" && /[boxX]/.test(y) ? "0" + y.toLowerCase() : "", x = m === "$" ? i : /[%p]/.test(y) ? s : "", R = uA[y], P = /[defgprs%]/.test(y);
    E = E === void 0 ? 6 : /[gprs]/.test(y) ? Math.max(1, Math.min(21, E)) : Math.max(0, Math.min(20, E));
    function O(I) {
      var M = S, _ = x, G, F, N;
      if (y === "c")
        _ = R(I) + _, I = "";
      else {
        I = +I;
        var V = I < 0 || 1 / I < 0;
        if (I = isNaN(I) ? l : R(Math.abs(I), E), b && (I = l9(I)), V && +I == 0 && g !== "+" && (V = !1), M = (V ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + M, _ = (y === "s" ? hA[8 + cO / 3] : "") + _ + (V && g === "(" ? ")" : ""), P) {
          for (G = -1, F = I.length; ++G < F; )
            if (N = I.charCodeAt(G), 48 > N || N > 57) {
              _ = (N === 46 ? n + I.slice(G + 1) : I.slice(G)) + _, I = I.slice(0, G);
              break;
            }
        }
      }
      w && !f && (I = t(I, 1 / 0));
      var B = M.length + I.length + _.length, $ = B < C ? new Array(C - B + 1).join(h) : "";
      switch (w && f && (I = t($ + I, $.length ? C - _.length : 1 / 0), $ = ""), p) {
        case "<":
          I = M + I + _ + $;
          break;
        case "=":
          I = M + $ + I + _;
          break;
        case "^":
          I = $.slice(0, B = $.length >> 1) + M + I + _ + $.slice(B);
          break;
        default:
          I = $ + M + I + _;
          break;
      }
      return o(I);
    }
    return O.toString = function() {
      return d + "";
    }, O;
  }
  function c(d, h) {
    var p = u((d = id(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(Tl(h) / 3))) * 3, m = Math.pow(10, -g), f = hA[8 + g / 3];
    return function(C) {
      return p(m * C) + f;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var np, tS, dO;
d9({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function d9(e) {
  return np = c9(e), tS = np.format, dO = np.formatPrefix, np;
}
function h9(e) {
  return Math.max(0, -Tl(Math.abs(e)));
}
function p9(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Tl(t) / 3))) * 3 - Tl(Math.abs(e)));
}
function f9(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Tl(t) - Tl(e)) + 1;
}
function hO(e, t, r, i) {
  var n = Dy(e, t, r), o;
  switch (i = id(i ?? ",f"), i.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return i.precision == null && !isNaN(o = p9(n, s)) && (i.precision = o), dO(i, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(o = f9(n, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = o - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(o = h9(n)) && (i.precision = o - (i.type === "%") * 2);
      break;
    }
  }
  return tS(i);
}
function ss(e) {
  var t = e.domain;
  return e.ticks = function(r) {
    var i = t();
    return xy(i[0], i[i.length - 1], r ?? 10);
  }, e.tickFormat = function(r, i) {
    var n = t();
    return hO(n[0], n[n.length - 1], r ?? 10, i);
  }, e.nice = function(r) {
    r == null && (r = 10);
    var i = t(), n = 0, o = i.length - 1, s = i[n], a = i[o], l, u, c = 10;
    for (a < s && (u = s, s = a, a = u, u = n, n = o, o = u); c-- > 0; ) {
      if (u = Ay(s, a, r), u === l)
        return i[n] = s, i[o] = a, t(i);
      if (u > 0)
        s = Math.floor(s / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return e;
  }, e;
}
function yf() {
  var e = Qw();
  return e.copy = function() {
    return ph(e, yf());
  }, qi.apply(e, arguments), ss(e);
}
function pO(e) {
  var t;
  function r(i) {
    return i == null || isNaN(i = +i) ? t : i;
  }
  return r.invert = r, r.domain = r.range = function(i) {
    return arguments.length ? (e = Array.from(i, vf), r) : e.slice();
  }, r.unknown = function(i) {
    return arguments.length ? (t = i, r) : t;
  }, r.copy = function() {
    return pO(e).unknown(t);
  }, e = arguments.length ? Array.from(e, vf) : [0, 1], ss(r);
}
function fO(e, t) {
  e = e.slice();
  var r = 0, i = e.length - 1, n = e[r], o = e[i], s;
  return o < n && (s = r, r = i, i = s, s = n, n = o, o = s), e[r] = t.floor(n), e[i] = t.ceil(o), e;
}
function pA(e) {
  return Math.log(e);
}
function fA(e) {
  return Math.exp(e);
}
function g9(e) {
  return -Math.log(-e);
}
function m9(e) {
  return -Math.exp(-e);
}
function v9(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function C9(e) {
  return e === 10 ? v9 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function y9(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function gA(e) {
  return (t, r) => -e(-t, r);
}
function rS(e) {
  const t = e(pA, fA), r = t.domain;
  let i = 10, n, o;
  function s() {
    return n = y9(i), o = C9(i), r()[0] < 0 ? (n = gA(n), o = gA(o), e(g9, m9)) : e(pA, fA), t;
  }
  return t.base = function(a) {
    return arguments.length ? (i = +a, s()) : i;
  }, t.domain = function(a) {
    return arguments.length ? (r(a), s()) : r();
  }, t.ticks = (a) => {
    const l = r();
    let u = l[0], c = l[l.length - 1];
    const d = c < u;
    d && ([u, c] = [c, u]);
    let h = n(u), p = n(c), g, m;
    const f = a == null ? 10 : +a;
    let C = [];
    if (!(i % 1) && p - h < f) {
      if (h = Math.floor(h), p = Math.ceil(p), u > 0) {
        for (; h <= p; ++h)
          for (g = 1; g < i; ++g)
            if (m = h < 0 ? g / o(-h) : g * o(h), !(m < u)) {
              if (m > c) break;
              C.push(m);
            }
      } else for (; h <= p; ++h)
        for (g = i - 1; g >= 1; --g)
          if (m = h > 0 ? g / o(-h) : g * o(h), !(m < u)) {
            if (m > c) break;
            C.push(m);
          }
      C.length * 2 < f && (C = xy(u, c, f));
    } else
      C = xy(h, p, Math.min(p - h, f)).map(o);
    return d ? C.reverse() : C;
  }, t.tickFormat = (a, l) => {
    if (a == null && (a = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = id(l)).precision == null && (l.trim = !0), l = tS(l)), a === 1 / 0) return l;
    const u = Math.max(1, i * a / t.ticks().length);
    return (c) => {
      let d = c / o(Math.round(n(c)));
      return d * i < i - 0.5 && (d *= i), d <= u ? l(c) : "";
    };
  }, t.nice = () => r(fO(r(), {
    floor: (a) => o(Math.floor(n(a))),
    ceil: (a) => o(Math.ceil(n(a)))
  })), t;
}
function gO() {
  const e = rS(nm()).domain([1, 10]);
  return e.copy = () => ph(e, gO()).base(e.base()), qi.apply(e, arguments), e;
}
function mA(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function vA(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function iS(e) {
  var t = 1, r = e(mA(t), vA(t));
  return r.constant = function(i) {
    return arguments.length ? e(mA(t = +i), vA(t)) : t;
  }, ss(r);
}
function mO() {
  var e = iS(nm());
  return e.copy = function() {
    return ph(e, mO()).constant(e.constant());
  }, qi.apply(e, arguments);
}
function CA(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function b9(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function w9(e) {
  return e < 0 ? -e * e : e * e;
}
function nS(e) {
  var t = e(Gr, Gr), r = 1;
  function i() {
    return r === 1 ? e(Gr, Gr) : r === 0.5 ? e(b9, w9) : e(CA(r), CA(1 / r));
  }
  return t.exponent = function(n) {
    return arguments.length ? (r = +n, i()) : r;
  }, ss(t);
}
function oS() {
  var e = nS(nm());
  return e.copy = function() {
    return ph(e, oS()).exponent(e.exponent());
  }, qi.apply(e, arguments), e;
}
function S9() {
  return oS.apply(null, arguments).exponent(0.5);
}
function yA(e) {
  return Math.sign(e) * e * e;
}
function E9(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e));
}
function vO() {
  var e = Qw(), t = [0, 1], r = !1, i;
  function n(o) {
    var s = E9(e(o));
    return isNaN(s) ? i : r ? Math.round(s) : s;
  }
  return n.invert = function(o) {
    return e.invert(yA(o));
  }, n.domain = function(o) {
    return arguments.length ? (e.domain(o), n) : e.domain();
  }, n.range = function(o) {
    return arguments.length ? (e.range((t = Array.from(o, vf)).map(yA)), n) : t.slice();
  }, n.rangeRound = function(o) {
    return n.range(o).round(!0);
  }, n.round = function(o) {
    return arguments.length ? (r = !!o, n) : r;
  }, n.clamp = function(o) {
    return arguments.length ? (e.clamp(o), n) : e.clamp();
  }, n.unknown = function(o) {
    return arguments.length ? (i = o, n) : i;
  }, n.copy = function() {
    return vO(e.domain(), t).round(r).clamp(e.clamp()).unknown(i);
  }, qi.apply(n, arguments), ss(n);
}
function CO() {
  var e = [], t = [], r = [], i;
  function n() {
    var s = 0, a = Math.max(1, t.length);
    for (r = new Array(a - 1); ++s < a; ) r[s - 1] = RX(e, s / a);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? i : t[dh(r, s)];
  }
  return o.invertExtent = function(s) {
    var a = t.indexOf(s);
    return a < 0 ? [NaN, NaN] : [
      a > 0 ? r[a - 1] : e[0],
      a < r.length ? r[a] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let a of s) a != null && !isNaN(a = +a) && e.push(a);
    return e.sort(zo), n();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), n()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (i = s, o) : i;
  }, o.quantiles = function() {
    return r.slice();
  }, o.copy = function() {
    return CO().domain(e).range(t).unknown(i);
  }, qi.apply(o, arguments);
}
function yO() {
  var e = 0, t = 1, r = 1, i = [0.5], n = [0, 1], o;
  function s(l) {
    return l != null && l <= l ? n[dh(i, l, 0, r)] : o;
  }
  function a() {
    var l = -1;
    for (i = new Array(r); ++l < r; ) i[l] = ((l + 1) * t - (l - r) * e) / (r + 1);
    return s;
  }
  return s.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, a()) : [e, t];
  }, s.range = function(l) {
    return arguments.length ? (r = (n = Array.from(l)).length - 1, a()) : n.slice();
  }, s.invertExtent = function(l) {
    var u = n.indexOf(l);
    return u < 0 ? [NaN, NaN] : u < 1 ? [e, i[0]] : u >= r ? [i[r - 1], t] : [i[u - 1], i[u]];
  }, s.unknown = function(l) {
    return arguments.length && (o = l), s;
  }, s.thresholds = function() {
    return i.slice();
  }, s.copy = function() {
    return yO().domain([e, t]).range(n).unknown(o);
  }, qi.apply(ss(s), arguments);
}
function bO() {
  var e = [0.5], t = [0, 1], r, i = 1;
  function n(o) {
    return o != null && o <= o ? t[dh(e, o, 0, i)] : r;
  }
  return n.domain = function(o) {
    return arguments.length ? (e = Array.from(o), i = Math.min(e.length, t.length - 1), n) : e.slice();
  }, n.range = function(o) {
    return arguments.length ? (t = Array.from(o), i = Math.min(e.length, t.length - 1), n) : t.slice();
  }, n.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, n.unknown = function(o) {
    return arguments.length ? (r = o, n) : r;
  }, n.copy = function() {
    return bO().domain(e).range(t).unknown(r);
  }, qi.apply(n, arguments);
}
const Hv = /* @__PURE__ */ new Date(), Bv = /* @__PURE__ */ new Date();
function hr(e, t, r, i) {
  function n(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return n.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), n.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), n.round = (o) => {
    const s = n(o), a = n.ceil(o);
    return o - s < a - o ? s : a;
  }, n.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), n.range = (o, s, a) => {
    const l = [];
    if (o = n.ceil(o), a = a == null ? 1 : Math.floor(a), !(o < s) || !(a > 0)) return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+o)), t(o, a), e(o);
    while (u < o && o < s);
    return l;
  }, n.filter = (o) => hr((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, a) => {
    if (s >= s)
      if (a < 0) for (; ++a <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --a >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), r && (n.count = (o, s) => (Hv.setTime(+o), Bv.setTime(+s), e(Hv), e(Bv), Math.floor(r(Hv, Bv))), n.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? n.filter(i ? (s) => i(s) % o === 0 : (s) => n.count(0, s) % o === 0) : n)), n;
}
const bf = hr(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
bf.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? hr((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : bf);
bf.range;
const oo = 1e3, Li = oo * 60, so = Li * 60, yo = so * 24, sS = yo * 7, bA = yo * 30, Wv = yo * 365, Ls = hr((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * oo);
}, (e, t) => (t - e) / oo, (e) => e.getUTCSeconds());
Ls.range;
const aS = hr((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * oo);
}, (e, t) => {
  e.setTime(+e + t * Li);
}, (e, t) => (t - e) / Li, (e) => e.getMinutes());
aS.range;
const lS = hr((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Li);
}, (e, t) => (t - e) / Li, (e) => e.getUTCMinutes());
lS.range;
const uS = hr((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * oo - e.getMinutes() * Li);
}, (e, t) => {
  e.setTime(+e + t * so);
}, (e, t) => (t - e) / so, (e) => e.getHours());
uS.range;
const cS = hr((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * so);
}, (e, t) => (t - e) / so, (e) => e.getUTCHours());
cS.range;
const fh = hr(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Li) / yo,
  (e) => e.getDate() - 1
);
fh.range;
const om = hr((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / yo, (e) => e.getUTCDate() - 1);
om.range;
const wO = hr((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / yo, (e) => Math.floor(e / yo));
wO.range;
function Ta(e) {
  return hr((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setDate(t.getDate() + r * 7);
  }, (t, r) => (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * Li) / sS);
}
const sm = Ta(0), wf = Ta(1), x9 = Ta(2), A9 = Ta(3), Rl = Ta(4), D9 = Ta(5), T9 = Ta(6);
sm.range;
wf.range;
x9.range;
A9.range;
Rl.range;
D9.range;
T9.range;
function Ra(e) {
  return hr((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, (t, r) => (r - t) / sS);
}
const am = Ra(0), Sf = Ra(1), R9 = Ra(2), P9 = Ra(3), Pl = Ra(4), I9 = Ra(5), O9 = Ra(6);
am.range;
Sf.range;
R9.range;
P9.range;
Pl.range;
I9.range;
O9.range;
const dS = hr((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
dS.range;
const hS = hr((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
hS.range;
const bo = hr((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
bo.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : hr((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, r) => {
  t.setFullYear(t.getFullYear() + r * e);
});
bo.range;
const wo = hr((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
wo.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : hr((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, r) => {
  t.setUTCFullYear(t.getUTCFullYear() + r * e);
});
wo.range;
function SO(e, t, r, i, n, o) {
  const s = [
    [Ls, 1, oo],
    [Ls, 5, 5 * oo],
    [Ls, 15, 15 * oo],
    [Ls, 30, 30 * oo],
    [o, 1, Li],
    [o, 5, 5 * Li],
    [o, 15, 15 * Li],
    [o, 30, 30 * Li],
    [n, 1, so],
    [n, 3, 3 * so],
    [n, 6, 6 * so],
    [n, 12, 12 * so],
    [i, 1, yo],
    [i, 2, 2 * yo],
    [r, 1, sS],
    [t, 1, bA],
    [t, 3, 3 * bA],
    [e, 1, Wv]
  ];
  function a(u, c, d) {
    const h = c < u;
    h && ([u, c] = [c, u]);
    const p = d && typeof d.range == "function" ? d : l(u, c, d), g = p ? p.range(u, +c + 1) : [];
    return h ? g.reverse() : g;
  }
  function l(u, c, d) {
    const h = Math.abs(c - u) / d, p = Xw(([, , f]) => f).right(s, h);
    if (p === s.length) return e.every(Dy(u / Wv, c / Wv, d));
    if (p === 0) return bf.every(Math.max(Dy(u, c, d), 1));
    const [g, m] = s[h / s[p - 1][2] < s[p][2] / h ? p - 1 : p];
    return g.every(m);
  }
  return [a, l];
}
const [M9, F9] = SO(wo, hS, am, wO, cS, lS), [_9, N9] = SO(bo, dS, sm, fh, uS, aS);
function $v(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function jv(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ac(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function L9(e) {
  var t = e.dateTime, r = e.date, i = e.time, n = e.periods, o = e.days, s = e.shortDays, a = e.months, l = e.shortMonths, u = lc(n), c = uc(n), d = lc(o), h = uc(o), p = lc(s), g = uc(s), m = lc(a), f = uc(a), C = lc(l), w = uc(l), E = {
    a: V,
    A: B,
    b: $,
    B: L,
    c: null,
    d: DA,
    e: DA,
    f: oK,
    g: gK,
    G: vK,
    H: rK,
    I: iK,
    j: nK,
    L: EO,
    m: sK,
    M: aK,
    p: z,
    q: j,
    Q: PA,
    s: IA,
    S: lK,
    u: uK,
    U: cK,
    V: dK,
    w: hK,
    W: pK,
    x: null,
    X: null,
    y: fK,
    Y: mK,
    Z: CK,
    "%": RA
  }, b = {
    a: U,
    A: oe,
    b: ie,
    B: le,
    c: null,
    d: TA,
    e: TA,
    f: SK,
    g: MK,
    G: _K,
    H: yK,
    I: bK,
    j: wK,
    L: AO,
    m: EK,
    M: xK,
    p: ce,
    q: he,
    Q: PA,
    s: IA,
    S: AK,
    u: DK,
    U: TK,
    V: RK,
    w: PK,
    W: IK,
    x: null,
    X: null,
    y: OK,
    Y: FK,
    Z: NK,
    "%": RA
  }, y = {
    a: O,
    A: I,
    b: M,
    B: _,
    c: G,
    d: xA,
    e: xA,
    f: J9,
    g: EA,
    G: SA,
    H: AA,
    I: AA,
    j: X9,
    L: Z9,
    m: Y9,
    M: K9,
    p: P,
    q: U9,
    Q: eK,
    s: tK,
    S: q9,
    u: B9,
    U: W9,
    V: $9,
    w: H9,
    W: j9,
    x: F,
    X: N,
    y: EA,
    Y: SA,
    Z: z9,
    "%": Q9
  };
  E.x = S(r, E), E.X = S(i, E), E.c = S(t, E), b.x = S(r, b), b.X = S(i, b), b.c = S(t, b);
  function S(Z, se) {
    return function(ae) {
      var W = [], be = -1, X = 0, Te = Z.length, He, je, jt;
      for (ae instanceof Date || (ae = /* @__PURE__ */ new Date(+ae)); ++be < Te; )
        Z.charCodeAt(be) === 37 && (W.push(Z.slice(X, be)), (je = wA[He = Z.charAt(++be)]) != null ? He = Z.charAt(++be) : je = He === "e" ? " " : "0", (jt = se[He]) && (He = jt(ae, je)), W.push(He), X = be + 1);
      return W.push(Z.slice(X, be)), W.join("");
    };
  }
  function x(Z, se) {
    return function(ae) {
      var W = ac(1900, void 0, 1), be = R(W, Z, ae += "", 0), X, Te;
      if (be != ae.length) return null;
      if ("Q" in W) return new Date(W.Q);
      if ("s" in W) return new Date(W.s * 1e3 + ("L" in W ? W.L : 0));
      if (se && !("Z" in W) && (W.Z = 0), "p" in W && (W.H = W.H % 12 + W.p * 12), W.m === void 0 && (W.m = "q" in W ? W.q : 0), "V" in W) {
        if (W.V < 1 || W.V > 53) return null;
        "w" in W || (W.w = 1), "Z" in W ? (X = jv(ac(W.y, 0, 1)), Te = X.getUTCDay(), X = Te > 4 || Te === 0 ? Sf.ceil(X) : Sf(X), X = om.offset(X, (W.V - 1) * 7), W.y = X.getUTCFullYear(), W.m = X.getUTCMonth(), W.d = X.getUTCDate() + (W.w + 6) % 7) : (X = $v(ac(W.y, 0, 1)), Te = X.getDay(), X = Te > 4 || Te === 0 ? wf.ceil(X) : wf(X), X = fh.offset(X, (W.V - 1) * 7), W.y = X.getFullYear(), W.m = X.getMonth(), W.d = X.getDate() + (W.w + 6) % 7);
      } else ("W" in W || "U" in W) && ("w" in W || (W.w = "u" in W ? W.u % 7 : "W" in W ? 1 : 0), Te = "Z" in W ? jv(ac(W.y, 0, 1)).getUTCDay() : $v(ac(W.y, 0, 1)).getDay(), W.m = 0, W.d = "W" in W ? (W.w + 6) % 7 + W.W * 7 - (Te + 5) % 7 : W.w + W.U * 7 - (Te + 6) % 7);
      return "Z" in W ? (W.H += W.Z / 100 | 0, W.M += W.Z % 100, jv(W)) : $v(W);
    };
  }
  function R(Z, se, ae, W) {
    for (var be = 0, X = se.length, Te = ae.length, He, je; be < X; ) {
      if (W >= Te) return -1;
      if (He = se.charCodeAt(be++), He === 37) {
        if (He = se.charAt(be++), je = y[He in wA ? se.charAt(be++) : He], !je || (W = je(Z, ae, W)) < 0) return -1;
      } else if (He != ae.charCodeAt(W++))
        return -1;
    }
    return W;
  }
  function P(Z, se, ae) {
    var W = u.exec(se.slice(ae));
    return W ? (Z.p = c.get(W[0].toLowerCase()), ae + W[0].length) : -1;
  }
  function O(Z, se, ae) {
    var W = p.exec(se.slice(ae));
    return W ? (Z.w = g.get(W[0].toLowerCase()), ae + W[0].length) : -1;
  }
  function I(Z, se, ae) {
    var W = d.exec(se.slice(ae));
    return W ? (Z.w = h.get(W[0].toLowerCase()), ae + W[0].length) : -1;
  }
  function M(Z, se, ae) {
    var W = C.exec(se.slice(ae));
    return W ? (Z.m = w.get(W[0].toLowerCase()), ae + W[0].length) : -1;
  }
  function _(Z, se, ae) {
    var W = m.exec(se.slice(ae));
    return W ? (Z.m = f.get(W[0].toLowerCase()), ae + W[0].length) : -1;
  }
  function G(Z, se, ae) {
    return R(Z, t, se, ae);
  }
  function F(Z, se, ae) {
    return R(Z, r, se, ae);
  }
  function N(Z, se, ae) {
    return R(Z, i, se, ae);
  }
  function V(Z) {
    return s[Z.getDay()];
  }
  function B(Z) {
    return o[Z.getDay()];
  }
  function $(Z) {
    return l[Z.getMonth()];
  }
  function L(Z) {
    return a[Z.getMonth()];
  }
  function z(Z) {
    return n[+(Z.getHours() >= 12)];
  }
  function j(Z) {
    return 1 + ~~(Z.getMonth() / 3);
  }
  function U(Z) {
    return s[Z.getUTCDay()];
  }
  function oe(Z) {
    return o[Z.getUTCDay()];
  }
  function ie(Z) {
    return l[Z.getUTCMonth()];
  }
  function le(Z) {
    return a[Z.getUTCMonth()];
  }
  function ce(Z) {
    return n[+(Z.getUTCHours() >= 12)];
  }
  function he(Z) {
    return 1 + ~~(Z.getUTCMonth() / 3);
  }
  return {
    format: function(Z) {
      var se = S(Z += "", E);
      return se.toString = function() {
        return Z;
      }, se;
    },
    parse: function(Z) {
      var se = x(Z += "", !1);
      return se.toString = function() {
        return Z;
      }, se;
    },
    utcFormat: function(Z) {
      var se = S(Z += "", b);
      return se.toString = function() {
        return Z;
      }, se;
    },
    utcParse: function(Z) {
      var se = x(Z += "", !0);
      return se.toString = function() {
        return Z;
      }, se;
    }
  };
}
var wA = { "-": "", _: " ", 0: "0" }, Cr = /^\s*\d+/, G9 = /^%/, k9 = /[\\^$*+?|[\]().{}]/g;
function Je(e, t, r) {
  var i = e < 0 ? "-" : "", n = (i ? -e : e) + "", o = n.length;
  return i + (o < r ? new Array(r - o + 1).join(t) + n : n);
}
function V9(e) {
  return e.replace(k9, "\\$&");
}
function lc(e) {
  return new RegExp("^(?:" + e.map(V9).join("|") + ")", "i");
}
function uc(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function H9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 1));
  return i ? (e.w = +i[0], r + i[0].length) : -1;
}
function B9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 1));
  return i ? (e.u = +i[0], r + i[0].length) : -1;
}
function W9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.U = +i[0], r + i[0].length) : -1;
}
function $9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.V = +i[0], r + i[0].length) : -1;
}
function j9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.W = +i[0], r + i[0].length) : -1;
}
function SA(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 4));
  return i ? (e.y = +i[0], r + i[0].length) : -1;
}
function EA(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), r + i[0].length) : -1;
}
function z9(e, t, r) {
  var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), r + i[0].length) : -1;
}
function U9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 1));
  return i ? (e.q = i[0] * 3 - 3, r + i[0].length) : -1;
}
function Y9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.m = i[0] - 1, r + i[0].length) : -1;
}
function xA(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.d = +i[0], r + i[0].length) : -1;
}
function X9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 3));
  return i ? (e.m = 0, e.d = +i[0], r + i[0].length) : -1;
}
function AA(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.H = +i[0], r + i[0].length) : -1;
}
function K9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.M = +i[0], r + i[0].length) : -1;
}
function q9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 2));
  return i ? (e.S = +i[0], r + i[0].length) : -1;
}
function Z9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 3));
  return i ? (e.L = +i[0], r + i[0].length) : -1;
}
function J9(e, t, r) {
  var i = Cr.exec(t.slice(r, r + 6));
  return i ? (e.L = Math.floor(i[0] / 1e3), r + i[0].length) : -1;
}
function Q9(e, t, r) {
  var i = G9.exec(t.slice(r, r + 1));
  return i ? r + i[0].length : -1;
}
function eK(e, t, r) {
  var i = Cr.exec(t.slice(r));
  return i ? (e.Q = +i[0], r + i[0].length) : -1;
}
function tK(e, t, r) {
  var i = Cr.exec(t.slice(r));
  return i ? (e.s = +i[0], r + i[0].length) : -1;
}
function DA(e, t) {
  return Je(e.getDate(), t, 2);
}
function rK(e, t) {
  return Je(e.getHours(), t, 2);
}
function iK(e, t) {
  return Je(e.getHours() % 12 || 12, t, 2);
}
function nK(e, t) {
  return Je(1 + fh.count(bo(e), e), t, 3);
}
function EO(e, t) {
  return Je(e.getMilliseconds(), t, 3);
}
function oK(e, t) {
  return EO(e, t) + "000";
}
function sK(e, t) {
  return Je(e.getMonth() + 1, t, 2);
}
function aK(e, t) {
  return Je(e.getMinutes(), t, 2);
}
function lK(e, t) {
  return Je(e.getSeconds(), t, 2);
}
function uK(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function cK(e, t) {
  return Je(sm.count(bo(e) - 1, e), t, 2);
}
function xO(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Rl(e) : Rl.ceil(e);
}
function dK(e, t) {
  return e = xO(e), Je(Rl.count(bo(e), e) + (bo(e).getDay() === 4), t, 2);
}
function hK(e) {
  return e.getDay();
}
function pK(e, t) {
  return Je(wf.count(bo(e) - 1, e), t, 2);
}
function fK(e, t) {
  return Je(e.getFullYear() % 100, t, 2);
}
function gK(e, t) {
  return e = xO(e), Je(e.getFullYear() % 100, t, 2);
}
function mK(e, t) {
  return Je(e.getFullYear() % 1e4, t, 4);
}
function vK(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? Rl(e) : Rl.ceil(e), Je(e.getFullYear() % 1e4, t, 4);
}
function CK(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Je(t / 60 | 0, "0", 2) + Je(t % 60, "0", 2);
}
function TA(e, t) {
  return Je(e.getUTCDate(), t, 2);
}
function yK(e, t) {
  return Je(e.getUTCHours(), t, 2);
}
function bK(e, t) {
  return Je(e.getUTCHours() % 12 || 12, t, 2);
}
function wK(e, t) {
  return Je(1 + om.count(wo(e), e), t, 3);
}
function AO(e, t) {
  return Je(e.getUTCMilliseconds(), t, 3);
}
function SK(e, t) {
  return AO(e, t) + "000";
}
function EK(e, t) {
  return Je(e.getUTCMonth() + 1, t, 2);
}
function xK(e, t) {
  return Je(e.getUTCMinutes(), t, 2);
}
function AK(e, t) {
  return Je(e.getUTCSeconds(), t, 2);
}
function DK(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function TK(e, t) {
  return Je(am.count(wo(e) - 1, e), t, 2);
}
function DO(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Pl(e) : Pl.ceil(e);
}
function RK(e, t) {
  return e = DO(e), Je(Pl.count(wo(e), e) + (wo(e).getUTCDay() === 4), t, 2);
}
function PK(e) {
  return e.getUTCDay();
}
function IK(e, t) {
  return Je(Sf.count(wo(e) - 1, e), t, 2);
}
function OK(e, t) {
  return Je(e.getUTCFullYear() % 100, t, 2);
}
function MK(e, t) {
  return e = DO(e), Je(e.getUTCFullYear() % 100, t, 2);
}
function FK(e, t) {
  return Je(e.getUTCFullYear() % 1e4, t, 4);
}
function _K(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? Pl(e) : Pl.ceil(e), Je(e.getUTCFullYear() % 1e4, t, 4);
}
function NK() {
  return "+0000";
}
function RA() {
  return "%";
}
function PA(e) {
  return +e;
}
function IA(e) {
  return Math.floor(+e / 1e3);
}
var Xa, TO, RO;
LK({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function LK(e) {
  return Xa = L9(e), TO = Xa.format, Xa.parse, RO = Xa.utcFormat, Xa.utcParse, Xa;
}
function GK(e) {
  return new Date(e);
}
function kK(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function pS(e, t, r, i, n, o, s, a, l, u) {
  var c = Qw(), d = c.invert, h = c.domain, p = u(".%L"), g = u(":%S"), m = u("%I:%M"), f = u("%I %p"), C = u("%a %d"), w = u("%b %d"), E = u("%B"), b = u("%Y");
  function y(S) {
    return (l(S) < S ? p : a(S) < S ? g : s(S) < S ? m : o(S) < S ? f : i(S) < S ? n(S) < S ? C : w : r(S) < S ? E : b)(S);
  }
  return c.invert = function(S) {
    return new Date(d(S));
  }, c.domain = function(S) {
    return arguments.length ? h(Array.from(S, kK)) : h().map(GK);
  }, c.ticks = function(S) {
    var x = h();
    return e(x[0], x[x.length - 1], S ?? 10);
  }, c.tickFormat = function(S, x) {
    return x == null ? y : u(x);
  }, c.nice = function(S) {
    var x = h();
    return (!S || typeof S.range != "function") && (S = t(x[0], x[x.length - 1], S ?? 10)), S ? h(fO(x, S)) : c;
  }, c.copy = function() {
    return ph(c, pS(e, t, r, i, n, o, s, a, l, u));
  }, c;
}
function VK() {
  return qi.apply(pS(_9, N9, bo, dS, sm, fh, uS, aS, Ls, TO).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function HK() {
  return qi.apply(pS(M9, F9, wo, hS, am, om, cS, lS, Ls, RO).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function lm() {
  var e = 0, t = 1, r, i, n, o, s = Gr, a = !1, l;
  function u(d) {
    return d == null || isNaN(d = +d) ? l : s(n === 0 ? 0.5 : (d = (o(d) - r) * n, a ? Math.max(0, Math.min(1, d)) : d));
  }
  u.domain = function(d) {
    return arguments.length ? ([e, t] = d, r = o(e = +e), i = o(t = +t), n = r === i ? 0 : 1 / (i - r), u) : [e, t];
  }, u.clamp = function(d) {
    return arguments.length ? (a = !!d, u) : a;
  }, u.interpolator = function(d) {
    return arguments.length ? (s = d, u) : s;
  };
  function c(d) {
    return function(h) {
      var p, g;
      return arguments.length ? ([p, g] = h, s = d(p, g), u) : [s(0), s(1)];
    };
  }
  return u.range = c(Mu), u.rangeRound = c(Jw), u.unknown = function(d) {
    return arguments.length ? (l = d, u) : l;
  }, function(d) {
    return o = d, r = d(e), i = d(t), n = r === i ? 0 : 1 / (i - r), u;
  };
}
function as(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function PO() {
  var e = ss(lm()(Gr));
  return e.copy = function() {
    return as(e, PO());
  }, Ro.apply(e, arguments);
}
function IO() {
  var e = rS(lm()).domain([1, 10]);
  return e.copy = function() {
    return as(e, IO()).base(e.base());
  }, Ro.apply(e, arguments);
}
function OO() {
  var e = iS(lm());
  return e.copy = function() {
    return as(e, OO()).constant(e.constant());
  }, Ro.apply(e, arguments);
}
function fS() {
  var e = nS(lm());
  return e.copy = function() {
    return as(e, fS()).exponent(e.exponent());
  }, Ro.apply(e, arguments);
}
function BK() {
  return fS.apply(null, arguments).exponent(0.5);
}
function MO() {
  var e = [], t = Gr;
  function r(i) {
    if (i != null && !isNaN(i = +i)) return t((dh(e, i, 1) - 1) / (e.length - 1));
  }
  return r.domain = function(i) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let n of i) n != null && !isNaN(n = +n) && e.push(n);
    return e.sort(zo), r;
  }, r.interpolator = function(i) {
    return arguments.length ? (t = i, r) : t;
  }, r.range = function() {
    return e.map((i, n) => t(n / (e.length - 1)));
  }, r.quantiles = function(i) {
    return Array.from({ length: i + 1 }, (n, o) => TX(e, o / i));
  }, r.copy = function() {
    return MO(t).domain(e);
  }, Ro.apply(r, arguments);
}
function um() {
  var e = 0, t = 0.5, r = 1, i = 1, n, o, s, a, l, u = Gr, c, d = !1, h;
  function p(m) {
    return isNaN(m = +m) ? h : (m = 0.5 + ((m = +c(m)) - o) * (i * m < i * o ? a : l), u(d ? Math.max(0, Math.min(1, m)) : m));
  }
  p.domain = function(m) {
    return arguments.length ? ([e, t, r] = m, n = c(e = +e), o = c(t = +t), s = c(r = +r), a = n === o ? 0 : 0.5 / (o - n), l = o === s ? 0 : 0.5 / (s - o), i = o < n ? -1 : 1, p) : [e, t, r];
  }, p.clamp = function(m) {
    return arguments.length ? (d = !!m, p) : d;
  }, p.interpolator = function(m) {
    return arguments.length ? (u = m, p) : u;
  };
  function g(m) {
    return function(f) {
      var C, w, E;
      return arguments.length ? ([C, w, E] = f, u = QX(m, [C, w, E]), p) : [u(0), u(0.5), u(1)];
    };
  }
  return p.range = g(Mu), p.rangeRound = g(Jw), p.unknown = function(m) {
    return arguments.length ? (h = m, p) : h;
  }, function(m) {
    return c = m, n = m(e), o = m(t), s = m(r), a = n === o ? 0 : 0.5 / (o - n), l = o === s ? 0 : 0.5 / (s - o), i = o < n ? -1 : 1, p;
  };
}
function FO() {
  var e = ss(um()(Gr));
  return e.copy = function() {
    return as(e, FO());
  }, Ro.apply(e, arguments);
}
function _O() {
  var e = rS(um()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return as(e, _O()).base(e.base());
  }, Ro.apply(e, arguments);
}
function NO() {
  var e = iS(um());
  return e.copy = function() {
    return as(e, NO()).constant(e.constant());
  }, Ro.apply(e, arguments);
}
function gS() {
  var e = nS(um());
  return e.copy = function() {
    return as(e, gS()).exponent(e.exponent());
  }, Ro.apply(e, arguments);
}
function WK() {
  return gS.apply(null, arguments).exponent(0.5);
}
const OA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: Qc,
  scaleDiverging: FO,
  scaleDivergingLog: _O,
  scaleDivergingPow: gS,
  scaleDivergingSqrt: WK,
  scaleDivergingSymlog: NO,
  scaleIdentity: pO,
  scaleImplicit: Ty,
  scaleLinear: yf,
  scaleLog: gO,
  scaleOrdinal: Kw,
  scalePoint: _c,
  scalePow: oS,
  scaleQuantile: CO,
  scaleQuantize: yO,
  scaleRadial: vO,
  scaleSequential: PO,
  scaleSequentialLog: IO,
  scaleSequentialPow: fS,
  scaleSequentialQuantile: MO,
  scaleSequentialSqrt: BK,
  scaleSequentialSymlog: OO,
  scaleSqrt: S9,
  scaleSymlog: mO,
  scaleThreshold: bO,
  scaleTime: VK,
  scaleUtc: HK,
  tickFormat: hO
}, Symbol.toStringTag, { value: "Module" }));
var $K = Eu;
function jK(e, t, r) {
  for (var i = -1, n = e.length; ++i < n; ) {
    var o = e[i], s = t(o);
    if (s != null && (a === void 0 ? s === s && !$K(s) : r(s, a)))
      var a = s, l = o;
  }
  return l;
}
var cm = jK;
function zK(e, t) {
  return e > t;
}
var LO = zK, UK = cm, YK = LO, XK = Ou;
function KK(e) {
  return e && e.length ? UK(e, XK, YK) : void 0;
}
var qK = KK;
const dm = /* @__PURE__ */ Ct(qK);
function ZK(e, t) {
  return e < t;
}
var GO = ZK, JK = cm, QK = GO, eq = Ou;
function tq(e) {
  return e && e.length ? JK(e, eq, QK) : void 0;
}
var rq = tq;
const hm = /* @__PURE__ */ Ct(rq);
var iq = Iw, nq = Jn, oq = zI, sq = oi;
function aq(e, t) {
  var r = sq(e) ? iq : oq;
  return r(e, nq(t));
}
var lq = aq, uq = $I, cq = lq;
function dq(e, t) {
  return uq(cq(e, t), 1);
}
var hq = dq;
const pq = /* @__PURE__ */ Ct(hq);
var fq = $w;
function gq(e, t) {
  return fq(e, t);
}
var mq = gq;
const gh = /* @__PURE__ */ Ct(mq);
var Fu = 1e9, vq = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, vS, _t = !0, ji = "[DecimalError] ", js = ji + "Invalid argument: ", mS = ji + "Exponent out of range: ", _u = Math.floor, Ds = Math.pow, Cq = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, gi, fr = 1e7, Pt = 7, kO = 9007199254740991, Ef = _u(kO / Pt), ye = {};
ye.absoluteValue = ye.abs = function() {
  var e = new this.constructor(this);
  return e.s && (e.s = 1), e;
};
ye.comparedTo = ye.cmp = function(e) {
  var t, r, i, n, o = this;
  if (e = new o.constructor(e), o.s !== e.s) return o.s || -e.s;
  if (o.e !== e.e) return o.e > e.e ^ o.s < 0 ? 1 : -1;
  for (i = o.d.length, n = e.d.length, t = 0, r = i < n ? i : n; t < r; ++t)
    if (o.d[t] !== e.d[t]) return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;
  return i === n ? 0 : i > n ^ o.s < 0 ? 1 : -1;
};
ye.decimalPlaces = ye.dp = function() {
  var e = this, t = e.d.length - 1, r = (t - e.e) * Pt;
  if (t = e.d[t], t) for (; t % 10 == 0; t /= 10) r--;
  return r < 0 ? 0 : r;
};
ye.dividedBy = ye.div = function(e) {
  return co(this, new this.constructor(e));
};
ye.dividedToIntegerBy = ye.idiv = function(e) {
  var t = this, r = t.constructor;
  return yt(co(t, new r(e), 0, 1), r.precision);
};
ye.equals = ye.eq = function(e) {
  return !this.cmp(e);
};
ye.exponent = function() {
  return or(this);
};
ye.greaterThan = ye.gt = function(e) {
  return this.cmp(e) > 0;
};
ye.greaterThanOrEqualTo = ye.gte = function(e) {
  return this.cmp(e) >= 0;
};
ye.isInteger = ye.isint = function() {
  return this.e > this.d.length - 2;
};
ye.isNegative = ye.isneg = function() {
  return this.s < 0;
};
ye.isPositive = ye.ispos = function() {
  return this.s > 0;
};
ye.isZero = function() {
  return this.s === 0;
};
ye.lessThan = ye.lt = function(e) {
  return this.cmp(e) < 0;
};
ye.lessThanOrEqualTo = ye.lte = function(e) {
  return this.cmp(e) < 1;
};
ye.logarithm = ye.log = function(e) {
  var t, r = this, i = r.constructor, n = i.precision, o = n + 5;
  if (e === void 0)
    e = new i(10);
  else if (e = new i(e), e.s < 1 || e.eq(gi)) throw Error(ji + "NaN");
  if (r.s < 1) throw Error(ji + (r.s ? "NaN" : "-Infinity"));
  return r.eq(gi) ? new i(0) : (_t = !1, t = co(nd(r, o), nd(e, o), o), _t = !0, yt(t, n));
};
ye.minus = ye.sub = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? BO(t, e) : VO(t, (e.s = -e.s, e));
};
ye.modulo = ye.mod = function(e) {
  var t, r = this, i = r.constructor, n = i.precision;
  if (e = new i(e), !e.s) throw Error(ji + "NaN");
  return r.s ? (_t = !1, t = co(r, e, 0, 1).times(e), _t = !0, r.minus(t)) : yt(new i(r), n);
};
ye.naturalExponential = ye.exp = function() {
  return HO(this);
};
ye.naturalLogarithm = ye.ln = function() {
  return nd(this);
};
ye.negated = ye.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s || 0, e;
};
ye.plus = ye.add = function(e) {
  var t = this;
  return e = new t.constructor(e), t.s == e.s ? VO(t, e) : BO(t, (e.s = -e.s, e));
};
ye.precision = ye.sd = function(e) {
  var t, r, i, n = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(js + e);
  if (t = or(n) + 1, i = n.d.length - 1, r = i * Pt + 1, i = n.d[i], i) {
    for (; i % 10 == 0; i /= 10) r--;
    for (i = n.d[0]; i >= 10; i /= 10) r++;
  }
  return e && t > r ? t : r;
};
ye.squareRoot = ye.sqrt = function() {
  var e, t, r, i, n, o, s, a = this, l = a.constructor;
  if (a.s < 1) {
    if (!a.s) return new l(0);
    throw Error(ji + "NaN");
  }
  for (e = or(a), _t = !1, n = Math.sqrt(+a), n == 0 || n == 1 / 0 ? (t = In(a.d), (t.length + e) % 2 == 0 && (t += "0"), n = Math.sqrt(t), e = _u((e + 1) / 2) - (e < 0 || e % 2), n == 1 / 0 ? t = "5e" + e : (t = n.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), i = new l(t)) : i = new l(n.toString()), r = l.precision, n = s = r + 3; ; )
    if (o = i, i = o.plus(co(a, o, s + 2)).times(0.5), In(o.d).slice(0, s) === (t = In(i.d)).slice(0, s)) {
      if (t = t.slice(s - 3, s + 1), n == s && t == "4999") {
        if (yt(o, r + 1, 0), o.times(o).eq(a)) {
          i = o;
          break;
        }
      } else if (t != "9999")
        break;
      s += 4;
    }
  return _t = !0, yt(i, r);
};
ye.times = ye.mul = function(e) {
  var t, r, i, n, o, s, a, l, u, c = this, d = c.constructor, h = c.d, p = (e = new d(e)).d;
  if (!c.s || !e.s) return new d(0);
  for (e.s *= c.s, r = c.e + e.e, l = h.length, u = p.length, l < u && (o = h, h = p, p = o, s = l, l = u, u = s), o = [], s = l + u, i = s; i--; ) o.push(0);
  for (i = u; --i >= 0; ) {
    for (t = 0, n = l + i; n > i; )
      a = o[n] + p[i] * h[n - i - 1] + t, o[n--] = a % fr | 0, t = a / fr | 0;
    o[n] = (o[n] + t) % fr | 0;
  }
  for (; !o[--s]; ) o.pop();
  return t ? ++r : o.shift(), e.d = o, e.e = r, _t ? yt(e, d.precision) : e;
};
ye.toDecimalPlaces = ye.todp = function(e, t) {
  var r = this, i = r.constructor;
  return r = new i(r), e === void 0 ? r : (Wn(e, 0, Fu), t === void 0 ? t = i.rounding : Wn(t, 0, 8), yt(r, e + or(r) + 1, t));
};
ye.toExponential = function(e, t) {
  var r, i = this, n = i.constructor;
  return e === void 0 ? r = sa(i, !0) : (Wn(e, 0, Fu), t === void 0 ? t = n.rounding : Wn(t, 0, 8), i = yt(new n(i), e + 1, t), r = sa(i, !0, e + 1)), r;
};
ye.toFixed = function(e, t) {
  var r, i, n = this, o = n.constructor;
  return e === void 0 ? sa(n) : (Wn(e, 0, Fu), t === void 0 ? t = o.rounding : Wn(t, 0, 8), i = yt(new o(n), e + or(n) + 1, t), r = sa(i.abs(), !1, e + or(i) + 1), n.isneg() && !n.isZero() ? "-" + r : r);
};
ye.toInteger = ye.toint = function() {
  var e = this, t = e.constructor;
  return yt(new t(e), or(e) + 1, t.rounding);
};
ye.toNumber = function() {
  return +this;
};
ye.toPower = ye.pow = function(e) {
  var t, r, i, n, o, s, a = this, l = a.constructor, u = 12, c = +(e = new l(e));
  if (!e.s) return new l(gi);
  if (a = new l(a), !a.s) {
    if (e.s < 1) throw Error(ji + "Infinity");
    return a;
  }
  if (a.eq(gi)) return a;
  if (i = l.precision, e.eq(gi)) return yt(a, i);
  if (t = e.e, r = e.d.length - 1, s = t >= r, o = a.s, s) {
    if ((r = c < 0 ? -c : c) <= kO) {
      for (n = new l(gi), t = Math.ceil(i / Pt + 4), _t = !1; r % 2 && (n = n.times(a), FA(n.d, t)), r = _u(r / 2), r !== 0; )
        a = a.times(a), FA(a.d, t);
      return _t = !0, e.s < 0 ? new l(gi).div(n) : yt(n, i);
    }
  } else if (o < 0) throw Error(ji + "NaN");
  return o = o < 0 && e.d[Math.max(t, r)] & 1 ? -1 : 1, a.s = 1, _t = !1, n = e.times(nd(a, i + u)), _t = !0, n = HO(n), n.s = o, n;
};
ye.toPrecision = function(e, t) {
  var r, i, n = this, o = n.constructor;
  return e === void 0 ? (r = or(n), i = sa(n, r <= o.toExpNeg || r >= o.toExpPos)) : (Wn(e, 1, Fu), t === void 0 ? t = o.rounding : Wn(t, 0, 8), n = yt(new o(n), e, t), r = or(n), i = sa(n, e <= r || r <= o.toExpNeg, e)), i;
};
ye.toSignificantDigits = ye.tosd = function(e, t) {
  var r = this, i = r.constructor;
  return e === void 0 ? (e = i.precision, t = i.rounding) : (Wn(e, 1, Fu), t === void 0 ? t = i.rounding : Wn(t, 0, 8)), yt(new i(r), e, t);
};
ye.toString = ye.valueOf = ye.val = ye.toJSON = ye[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var e = this, t = or(e), r = e.constructor;
  return sa(e, t <= r.toExpNeg || t >= r.toExpPos);
};
function VO(e, t) {
  var r, i, n, o, s, a, l, u, c = e.constructor, d = c.precision;
  if (!e.s || !t.s)
    return t.s || (t = new c(e)), _t ? yt(t, d) : t;
  if (l = e.d, u = t.d, s = e.e, n = t.e, l = l.slice(), o = s - n, o) {
    for (o < 0 ? (i = l, o = -o, a = u.length) : (i = u, n = s, a = l.length), s = Math.ceil(d / Pt), a = s > a ? s + 1 : a + 1, o > a && (o = a, i.length = 1), i.reverse(); o--; ) i.push(0);
    i.reverse();
  }
  for (a = l.length, o = u.length, a - o < 0 && (o = a, i = u, u = l, l = i), r = 0; o; )
    r = (l[--o] = l[o] + u[o] + r) / fr | 0, l[o] %= fr;
  for (r && (l.unshift(r), ++n), a = l.length; l[--a] == 0; ) l.pop();
  return t.d = l, t.e = n, _t ? yt(t, d) : t;
}
function Wn(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(js + e);
}
function In(e) {
  var t, r, i, n = e.length - 1, o = "", s = e[0];
  if (n > 0) {
    for (o += s, t = 1; t < n; t++)
      i = e[t] + "", r = Pt - i.length, r && (o += Ho(r)), o += i;
    s = e[t], i = s + "", r = Pt - i.length, r && (o += Ho(r));
  } else if (s === 0)
    return "0";
  for (; s % 10 === 0; ) s /= 10;
  return o + s;
}
var co = /* @__PURE__ */ function() {
  function e(i, n) {
    var o, s = 0, a = i.length;
    for (i = i.slice(); a--; )
      o = i[a] * n + s, i[a] = o % fr | 0, s = o / fr | 0;
    return s && i.unshift(s), i;
  }
  function t(i, n, o, s) {
    var a, l;
    if (o != s)
      l = o > s ? 1 : -1;
    else
      for (a = l = 0; a < o; a++)
        if (i[a] != n[a]) {
          l = i[a] > n[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(i, n, o) {
    for (var s = 0; o--; )
      i[o] -= s, s = i[o] < n[o] ? 1 : 0, i[o] = s * fr + i[o] - n[o];
    for (; !i[0] && i.length > 1; ) i.shift();
  }
  return function(i, n, o, s) {
    var a, l, u, c, d, h, p, g, m, f, C, w, E, b, y, S, x, R, P = i.constructor, O = i.s == n.s ? 1 : -1, I = i.d, M = n.d;
    if (!i.s) return new P(i);
    if (!n.s) throw Error(ji + "Division by zero");
    for (l = i.e - n.e, x = M.length, y = I.length, p = new P(O), g = p.d = [], u = 0; M[u] == (I[u] || 0); ) ++u;
    if (M[u] > (I[u] || 0) && --l, o == null ? w = o = P.precision : s ? w = o + (or(i) - or(n)) + 1 : w = o, w < 0) return new P(0);
    if (w = w / Pt + 2 | 0, u = 0, x == 1)
      for (c = 0, M = M[0], w++; (u < y || c) && w--; u++)
        E = c * fr + (I[u] || 0), g[u] = E / M | 0, c = E % M | 0;
    else {
      for (c = fr / (M[0] + 1) | 0, c > 1 && (M = e(M, c), I = e(I, c), x = M.length, y = I.length), b = x, m = I.slice(0, x), f = m.length; f < x; ) m[f++] = 0;
      R = M.slice(), R.unshift(0), S = M[0], M[1] >= fr / 2 && ++S;
      do
        c = 0, a = t(M, m, x, f), a < 0 ? (C = m[0], x != f && (C = C * fr + (m[1] || 0)), c = C / S | 0, c > 1 ? (c >= fr && (c = fr - 1), d = e(M, c), h = d.length, f = m.length, a = t(d, m, h, f), a == 1 && (c--, r(d, x < h ? R : M, h))) : (c == 0 && (a = c = 1), d = M.slice()), h = d.length, h < f && d.unshift(0), r(m, d, f), a == -1 && (f = m.length, a = t(M, m, x, f), a < 1 && (c++, r(m, x < f ? R : M, f))), f = m.length) : a === 0 && (c++, m = [0]), g[u++] = c, a && m[0] ? m[f++] = I[b] || 0 : (m = [I[b]], f = 1);
      while ((b++ < y || m[0] !== void 0) && w--);
    }
    return g[0] || g.shift(), p.e = l, yt(p, s ? o + or(p) + 1 : o);
  };
}();
function HO(e, t) {
  var r, i, n, o, s, a, l = 0, u = 0, c = e.constructor, d = c.precision;
  if (or(e) > 16) throw Error(mS + or(e));
  if (!e.s) return new c(gi);
  for (_t = !1, a = d, s = new c(0.03125); e.abs().gte(0.1); )
    e = e.times(s), u += 5;
  for (i = Math.log(Ds(2, u)) / Math.LN10 * 2 + 5 | 0, a += i, r = n = o = new c(gi), c.precision = a; ; ) {
    if (n = yt(n.times(e), a), r = r.times(++l), s = o.plus(co(n, r, a)), In(s.d).slice(0, a) === In(o.d).slice(0, a)) {
      for (; u--; ) o = yt(o.times(o), a);
      return c.precision = d, t == null ? (_t = !0, yt(o, d)) : o;
    }
    o = s;
  }
}
function or(e) {
  for (var t = e.e * Pt, r = e.d[0]; r >= 10; r /= 10) t++;
  return t;
}
function zv(e, t, r) {
  if (t > e.LN10.sd())
    throw _t = !0, r && (e.precision = r), Error(ji + "LN10 precision limit exceeded");
  return yt(new e(e.LN10), t);
}
function Ho(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function nd(e, t) {
  var r, i, n, o, s, a, l, u, c, d = 1, h = 10, p = e, g = p.d, m = p.constructor, f = m.precision;
  if (p.s < 1) throw Error(ji + (p.s ? "NaN" : "-Infinity"));
  if (p.eq(gi)) return new m(0);
  if (t == null ? (_t = !1, u = f) : u = t, p.eq(10))
    return t == null && (_t = !0), zv(m, u);
  if (u += h, m.precision = u, r = In(g), i = r.charAt(0), o = or(p), Math.abs(o) < 15e14) {
    for (; i < 7 && i != 1 || i == 1 && r.charAt(1) > 3; )
      p = p.times(e), r = In(p.d), i = r.charAt(0), d++;
    o = or(p), i > 1 ? (p = new m("0." + r), o++) : p = new m(i + "." + r.slice(1));
  } else
    return l = zv(m, u + 2, f).times(o + ""), p = nd(new m(i + "." + r.slice(1)), u - h).plus(l), m.precision = f, t == null ? (_t = !0, yt(p, f)) : p;
  for (a = s = p = co(p.minus(gi), p.plus(gi), u), c = yt(p.times(p), u), n = 3; ; ) {
    if (s = yt(s.times(c), u), l = a.plus(co(s, new m(n), u)), In(l.d).slice(0, u) === In(a.d).slice(0, u))
      return a = a.times(2), o !== 0 && (a = a.plus(zv(m, u + 2, f).times(o + ""))), a = co(a, new m(d), u), m.precision = f, t == null ? (_t = !0, yt(a, f)) : a;
    a = l, n += 2;
  }
}
function MA(e, t) {
  var r, i, n;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (i = t.search(/e/i)) > 0 ? (r < 0 && (r = i), r += +t.slice(i + 1), t = t.substring(0, i)) : r < 0 && (r = t.length), i = 0; t.charCodeAt(i) === 48; ) ++i;
  for (n = t.length; t.charCodeAt(n - 1) === 48; ) --n;
  if (t = t.slice(i, n), t) {
    if (n -= i, r = r - i - 1, e.e = _u(r / Pt), e.d = [], i = (r + 1) % Pt, r < 0 && (i += Pt), i < n) {
      for (i && e.d.push(+t.slice(0, i)), n -= Pt; i < n; ) e.d.push(+t.slice(i, i += Pt));
      t = t.slice(i), i = Pt - t.length;
    } else
      i -= n;
    for (; i--; ) t += "0";
    if (e.d.push(+t), _t && (e.e > Ef || e.e < -Ef)) throw Error(mS + r);
  } else
    e.s = 0, e.e = 0, e.d = [0];
  return e;
}
function yt(e, t, r) {
  var i, n, o, s, a, l, u, c, d = e.d;
  for (s = 1, o = d[0]; o >= 10; o /= 10) s++;
  if (i = t - s, i < 0)
    i += Pt, n = t, u = d[c = 0];
  else {
    if (c = Math.ceil((i + 1) / Pt), o = d.length, c >= o) return e;
    for (u = o = d[c], s = 1; o >= 10; o /= 10) s++;
    i %= Pt, n = i - Pt + s;
  }
  if (r !== void 0 && (o = Ds(10, s - n - 1), a = u / o % 10 | 0, l = t < 0 || d[c + 1] !== void 0 || u % o, l = r < 4 ? (a || l) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : a > 5 || a == 5 && (r == 4 || l || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (i > 0 ? n > 0 ? u / Ds(10, s - n) : 0 : d[c - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7))), t < 1 || !d[0])
    return l ? (o = or(e), d.length = 1, t = t - o - 1, d[0] = Ds(10, (Pt - t % Pt) % Pt), e.e = _u(-t / Pt) || 0) : (d.length = 1, d[0] = e.e = e.s = 0), e;
  if (i == 0 ? (d.length = c, o = 1, c--) : (d.length = c + 1, o = Ds(10, Pt - i), d[c] = n > 0 ? (u / Ds(10, s - n) % Ds(10, n) | 0) * o : 0), l)
    for (; ; )
      if (c == 0) {
        (d[0] += o) == fr && (d[0] = 1, ++e.e);
        break;
      } else {
        if (d[c] += o, d[c] != fr) break;
        d[c--] = 0, o = 1;
      }
  for (i = d.length; d[--i] === 0; ) d.pop();
  if (_t && (e.e > Ef || e.e < -Ef))
    throw Error(mS + or(e));
  return e;
}
function BO(e, t) {
  var r, i, n, o, s, a, l, u, c, d, h = e.constructor, p = h.precision;
  if (!e.s || !t.s)
    return t.s ? t.s = -t.s : t = new h(e), _t ? yt(t, p) : t;
  if (l = e.d, d = t.d, i = t.e, u = e.e, l = l.slice(), s = u - i, s) {
    for (c = s < 0, c ? (r = l, s = -s, a = d.length) : (r = d, i = u, a = l.length), n = Math.max(Math.ceil(p / Pt), a) + 2, s > n && (s = n, r.length = 1), r.reverse(), n = s; n--; ) r.push(0);
    r.reverse();
  } else {
    for (n = l.length, a = d.length, c = n < a, c && (a = n), n = 0; n < a; n++)
      if (l[n] != d[n]) {
        c = l[n] < d[n];
        break;
      }
    s = 0;
  }
  for (c && (r = l, l = d, d = r, t.s = -t.s), a = l.length, n = d.length - a; n > 0; --n) l[a++] = 0;
  for (n = d.length; n > s; ) {
    if (l[--n] < d[n]) {
      for (o = n; o && l[--o] === 0; ) l[o] = fr - 1;
      --l[o], l[n] += fr;
    }
    l[n] -= d[n];
  }
  for (; l[--a] === 0; ) l.pop();
  for (; l[0] === 0; l.shift()) --i;
  return l[0] ? (t.d = l, t.e = i, _t ? yt(t, p) : t) : new h(0);
}
function sa(e, t, r) {
  var i, n = or(e), o = In(e.d), s = o.length;
  return t ? (r && (i = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Ho(i) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (n < 0 ? "e" : "e+") + n) : n < 0 ? (o = "0." + Ho(-n - 1) + o, r && (i = r - s) > 0 && (o += Ho(i))) : n >= s ? (o += Ho(n + 1 - s), r && (i = r - n - 1) > 0 && (o = o + "." + Ho(i))) : ((i = n + 1) < s && (o = o.slice(0, i) + "." + o.slice(i)), r && (i = r - s) > 0 && (n + 1 === s && (o += "."), o += Ho(i))), e.s < 0 ? "-" + o : o;
}
function FA(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function WO(e) {
  var t, r, i;
  function n(o) {
    var s = this;
    if (!(s instanceof n)) return new n(o);
    if (s.constructor = n, o instanceof n) {
      s.s = o.s, s.e = o.e, s.d = (o = o.d) ? o.slice() : o;
      return;
    }
    if (typeof o == "number") {
      if (o * 0 !== 0)
        throw Error(js + o);
      if (o > 0)
        s.s = 1;
      else if (o < 0)
        o = -o, s.s = -1;
      else {
        s.s = 0, s.e = 0, s.d = [0];
        return;
      }
      if (o === ~~o && o < 1e7) {
        s.e = 0, s.d = [o];
        return;
      }
      return MA(s, o.toString());
    } else if (typeof o != "string")
      throw Error(js + o);
    if (o.charCodeAt(0) === 45 ? (o = o.slice(1), s.s = -1) : s.s = 1, Cq.test(o)) MA(s, o);
    else throw Error(js + o);
  }
  if (n.prototype = ye, n.ROUND_UP = 0, n.ROUND_DOWN = 1, n.ROUND_CEIL = 2, n.ROUND_FLOOR = 3, n.ROUND_HALF_UP = 4, n.ROUND_HALF_DOWN = 5, n.ROUND_HALF_EVEN = 6, n.ROUND_HALF_CEIL = 7, n.ROUND_HALF_FLOOR = 8, n.clone = WO, n.config = n.set = yq, e === void 0 && (e = {}), e)
    for (i = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < i.length; ) e.hasOwnProperty(r = i[t++]) || (e[r] = this[r]);
  return n.config(e), n;
}
function yq(e) {
  if (!e || typeof e != "object")
    throw Error(ji + "Object expected");
  var t, r, i, n = [
    "precision",
    1,
    Fu,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (t = 0; t < n.length; t += 3)
    if ((i = e[r = n[t]]) !== void 0)
      if (_u(i) === i && i >= n[t + 1] && i <= n[t + 2]) this[r] = i;
      else throw Error(js + r + ": " + i);
  if ((i = e[r = "LN10"]) !== void 0)
    if (i == Math.LN10) this[r] = new this(i);
    else throw Error(js + r + ": " + i);
  return this;
}
var vS = WO(vq);
gi = new vS(1);
const vt = vS;
function bq(e) {
  return xq(e) || Eq(e) || Sq(e) || wq();
}
function wq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Sq(e, t) {
  if (e) {
    if (typeof e == "string") return Oy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Oy(e, t);
  }
}
function Eq(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function xq(e) {
  if (Array.isArray(e)) return Oy(e);
}
function Oy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++)
    i[r] = e[r];
  return i;
}
var Aq = function(t) {
  return t;
}, $O = {}, jO = function(t) {
  return t === $O;
}, _A = function(t) {
  return function r() {
    return arguments.length === 0 || arguments.length === 1 && jO(arguments.length <= 0 ? void 0 : arguments[0]) ? r : t.apply(void 0, arguments);
  };
}, Dq = function e(t, r) {
  return t === 1 ? r : _A(function() {
    for (var i = arguments.length, n = new Array(i), o = 0; o < i; o++)
      n[o] = arguments[o];
    var s = n.filter(function(a) {
      return a !== $O;
    }).length;
    return s >= t ? r.apply(void 0, n) : e(t - s, _A(function() {
      for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++)
        l[u] = arguments[u];
      var c = n.map(function(d) {
        return jO(d) ? l.shift() : d;
      });
      return r.apply(void 0, bq(c).concat(l));
    }));
  });
}, pm = function(t) {
  return Dq(t.length, t);
}, My = function(t, r) {
  for (var i = [], n = t; n < r; ++n)
    i[n - t] = n;
  return i;
}, Tq = pm(function(e, t) {
  return Array.isArray(t) ? t.map(e) : Object.keys(t).map(function(r) {
    return t[r];
  }).map(e);
}), Rq = function() {
  for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
    r[i] = arguments[i];
  if (!r.length)
    return Aq;
  var n = r.reverse(), o = n[0], s = n.slice(1);
  return function() {
    return s.reduce(function(a, l) {
      return l(a);
    }, o.apply(void 0, arguments));
  };
}, Fy = function(t) {
  return Array.isArray(t) ? t.reverse() : t.split("").reverse.join("");
}, zO = function(t) {
  var r = null, i = null;
  return function() {
    for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++)
      o[s] = arguments[s];
    return r && o.every(function(a, l) {
      return a === r[l];
    }) || (r = o, i = t.apply(void 0, o)), i;
  };
};
function Pq(e) {
  var t;
  return e === 0 ? t = 1 : t = Math.floor(new vt(e).abs().log(10).toNumber()) + 1, t;
}
function Iq(e, t, r) {
  for (var i = new vt(e), n = 0, o = []; i.lt(t) && n < 1e5; )
    o.push(i.toNumber()), i = i.add(r), n++;
  return o;
}
var Oq = pm(function(e, t, r) {
  var i = +e, n = +t;
  return i + r * (n - i);
}), Mq = pm(function(e, t, r) {
  var i = t - +e;
  return i = i || 1 / 0, (r - e) / i;
}), Fq = pm(function(e, t, r) {
  var i = t - +e;
  return i = i || 1 / 0, Math.max(0, Math.min(1, (r - e) / i));
});
const fm = {
  rangeStep: Iq,
  getDigitCount: Pq,
  interpolateNumber: Oq,
  uninterpolateNumber: Mq,
  uninterpolateTruncation: Fq
};
function _y(e) {
  return Lq(e) || Nq(e) || UO(e) || _q();
}
function _q() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Nq(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function Lq(e) {
  if (Array.isArray(e)) return Ny(e);
}
function od(e, t) {
  return Vq(e) || kq(e, t) || UO(e, t) || Gq();
}
function Gq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function UO(e, t) {
  if (e) {
    if (typeof e == "string") return Ny(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Ny(e, t);
  }
}
function Ny(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++)
    i[r] = e[r];
  return i;
}
function kq(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var r = [], i = !0, n = !1, o = void 0;
    try {
      for (var s = e[Symbol.iterator](), a; !(i = (a = s.next()).done) && (r.push(a.value), !(t && r.length === t)); i = !0)
        ;
    } catch (l) {
      n = !0, o = l;
    } finally {
      try {
        !i && s.return != null && s.return();
      } finally {
        if (n) throw o;
      }
    }
    return r;
  }
}
function Vq(e) {
  if (Array.isArray(e)) return e;
}
function YO(e) {
  var t = od(e, 2), r = t[0], i = t[1], n = r, o = i;
  return r > i && (n = i, o = r), [n, o];
}
function XO(e, t, r) {
  if (e.lte(0))
    return new vt(0);
  var i = fm.getDigitCount(e.toNumber()), n = new vt(10).pow(i), o = e.div(n), s = i !== 1 ? 0.05 : 0.1, a = new vt(Math.ceil(o.div(s).toNumber())).add(r).mul(s), l = a.mul(n);
  return t ? l : new vt(Math.ceil(l));
}
function Hq(e, t, r) {
  var i = 1, n = new vt(e);
  if (!n.isint() && r) {
    var o = Math.abs(e);
    o < 1 ? (i = new vt(10).pow(fm.getDigitCount(e) - 1), n = new vt(Math.floor(n.div(i).toNumber())).mul(i)) : o > 1 && (n = new vt(Math.floor(e)));
  } else e === 0 ? n = new vt(Math.floor((t - 1) / 2)) : r || (n = new vt(Math.floor(e)));
  var s = Math.floor((t - 1) / 2), a = Rq(Tq(function(l) {
    return n.add(new vt(l - s).mul(i)).toNumber();
  }), My);
  return a(0, t);
}
function KO(e, t, r, i) {
  var n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((t - e) / (r - 1)))
    return {
      step: new vt(0),
      tickMin: new vt(0),
      tickMax: new vt(0)
    };
  var o = XO(new vt(t).sub(e).div(r - 1), i, n), s;
  e <= 0 && t >= 0 ? s = new vt(0) : (s = new vt(e).add(t).div(2), s = s.sub(new vt(s).mod(o)));
  var a = Math.ceil(s.sub(e).div(o).toNumber()), l = Math.ceil(new vt(t).sub(s).div(o).toNumber()), u = a + l + 1;
  return u > r ? KO(e, t, r, i, n + 1) : (u < r && (l = t > 0 ? l + (r - u) : l, a = t > 0 ? a : a + (r - u)), {
    step: o,
    tickMin: s.sub(new vt(a).mul(o)),
    tickMax: s.add(new vt(l).mul(o))
  });
}
function Bq(e) {
  var t = od(e, 2), r = t[0], i = t[1], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = Math.max(n, 2), a = YO([r, i]), l = od(a, 2), u = l[0], c = l[1];
  if (u === -1 / 0 || c === 1 / 0) {
    var d = c === 1 / 0 ? [u].concat(_y(My(0, n - 1).map(function() {
      return 1 / 0;
    }))) : [].concat(_y(My(0, n - 1).map(function() {
      return -1 / 0;
    })), [c]);
    return r > i ? Fy(d) : d;
  }
  if (u === c)
    return Hq(u, n, o);
  var h = KO(u, c, s, o), p = h.step, g = h.tickMin, m = h.tickMax, f = fm.rangeStep(g, m.add(new vt(0.1).mul(p)), p);
  return r > i ? Fy(f) : f;
}
function Wq(e, t) {
  var r = od(e, 2), i = r[0], n = r[1], o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = YO([i, n]), a = od(s, 2), l = a[0], u = a[1];
  if (l === -1 / 0 || u === 1 / 0)
    return [i, n];
  if (l === u)
    return [l];
  var c = Math.max(t, 2), d = XO(new vt(u).sub(l).div(c - 1), o, 0), h = [].concat(_y(fm.rangeStep(new vt(l), new vt(u).sub(new vt(0.99).mul(d)), d)), [u]);
  return i > n ? Fy(h) : h;
}
var $q = zO(Bq), jq = zO(Wq), zq = process.env.NODE_ENV === "production", Uv = "Invariant failed";
function qr(e, t) {
  if (zq)
    throw new Error(Uv);
  var r = typeof t == "function" ? t() : t, i = r ? "".concat(Uv, ": ").concat(r) : Uv;
  throw new Error(i);
}
var Uq = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function Il(e) {
  "@babel/helpers - typeof";
  return Il = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Il(e);
}
function xf() {
  return xf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, xf.apply(this, arguments);
}
function Yq(e, t) {
  return Zq(e) || qq(e, t) || Kq(e, t) || Xq();
}
function Xq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Kq(e, t) {
  if (e) {
    if (typeof e == "string") return NA(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return NA(e, t);
  }
}
function NA(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function qq(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function Zq(e) {
  if (Array.isArray(e)) return e;
}
function Jq(e, t) {
  if (e == null) return {};
  var r = Qq(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function Qq(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function eZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tZ(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, JO(i.key), i);
  }
}
function rZ(e, t, r) {
  return t && tZ(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function iZ(e, t, r) {
  return t = Af(t), nZ(e, qO() ? Reflect.construct(t, r || [], Af(e).constructor) : t.apply(e, r));
}
function nZ(e, t) {
  if (t && (Il(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return oZ(e);
}
function oZ(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function qO() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (qO = function() {
    return !!e;
  })();
}
function Af(e) {
  return Af = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Af(e);
}
function sZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Ly(e, t);
}
function Ly(e, t) {
  return Ly = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Ly(e, t);
}
function ZO(e, t, r) {
  return t = JO(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function JO(e) {
  var t = aZ(e, "string");
  return Il(t) == "symbol" ? t : t + "";
}
function aZ(e, t) {
  if (Il(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Il(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var mh = /* @__PURE__ */ function(e) {
  function t() {
    return eZ(this, t), iZ(this, t, arguments);
  }
  return sZ(t, e), rZ(t, [{
    key: "render",
    value: function() {
      var i = this.props, n = i.offset, o = i.layout, s = i.width, a = i.dataKey, l = i.data, u = i.dataPointFormatter, c = i.xAxis, d = i.yAxis, h = Jq(i, Uq), p = Ie(h, !1);
      this.props.direction === "x" && c.type !== "number" && (process.env.NODE_ENV !== "production" ? qr(!1, 'ErrorBar requires Axis type property to be "number".') : qr());
      var g = l.map(function(m) {
        var f = u(m, a), C = f.x, w = f.y, E = f.value, b = f.errorVal;
        if (!b)
          return null;
        var y = [], S, x;
        if (Array.isArray(b)) {
          var R = Yq(b, 2);
          S = R[0], x = R[1];
        } else
          S = x = b;
        if (o === "vertical") {
          var P = c.scale, O = w + n, I = O + s, M = O - s, _ = P(E - S), G = P(E + x);
          y.push({
            x1: G,
            y1: I,
            x2: G,
            y2: M
          }), y.push({
            x1: _,
            y1: O,
            x2: G,
            y2: O
          }), y.push({
            x1: _,
            y1: I,
            x2: _,
            y2: M
          });
        } else if (o === "horizontal") {
          var F = d.scale, N = C + n, V = N - s, B = N + s, $ = F(E - S), L = F(E + x);
          y.push({
            x1: V,
            y1: L,
            x2: B,
            y2: L
          }), y.push({
            x1: N,
            y1: $,
            x2: N,
            y2: L
          }), y.push({
            x1: V,
            y1: $,
            x2: B,
            y2: $
          });
        }
        return /* @__PURE__ */ D.createElement(Ze, xf({
          className: "recharts-errorBar",
          key: "bar-".concat(y.map(function(z) {
            return "".concat(z.x1, "-").concat(z.x2, "-").concat(z.y1, "-").concat(z.y2);
          }))
        }, p), y.map(function(z) {
          return /* @__PURE__ */ D.createElement("line", xf({}, z, {
            key: "line-".concat(z.x1, "-").concat(z.x2, "-").concat(z.y1, "-").concat(z.y2)
          }));
        }));
      });
      return /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-errorBars"
      }, g);
    }
  }]);
}(D.Component);
ZO(mh, "defaultProps", {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
});
ZO(mh, "displayName", "ErrorBar");
function sd(e) {
  "@babel/helpers - typeof";
  return sd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sd(e);
}
function LA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function ws(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LA(Object(r), !0).forEach(function(i) {
      lZ(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : LA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function lZ(e, t, r) {
  return t = uZ(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function uZ(e) {
  var t = cZ(e, "string");
  return sd(t) == "symbol" ? t : t + "";
}
function cZ(e, t) {
  if (sd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (sd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var QO = function(t) {
  var r = t.children, i = t.formattedGraphicalItems, n = t.legendWidth, o = t.legendContent, s = hi(r, uo);
  if (!s)
    return null;
  var a = uo.defaultProps, l = a !== void 0 ? ws(ws({}, a), s.props) : {}, u;
  return s.props && s.props.payload ? u = s.props && s.props.payload : o === "children" ? u = (i || []).reduce(function(c, d) {
    var h = d.item, p = d.props, g = p.sectors || p.data || [];
    return c.concat(g.map(function(m) {
      return {
        type: s.props.iconType || h.props.legendType,
        value: m.name,
        color: m.fill,
        payload: m
      };
    }));
  }, []) : u = (i || []).map(function(c) {
    var d = c.item, h = d.type.defaultProps, p = h !== void 0 ? ws(ws({}, h), d.props) : {}, g = p.dataKey, m = p.name, f = p.legendType, C = p.hide;
    return {
      inactive: C,
      dataKey: g,
      type: l.iconType || f || "square",
      color: CS(d),
      value: m || g,
      // @ts-expect-error property strokeDasharray is required in Payload but optional in props
      payload: p
    };
  }), ws(ws(ws({}, l), uo.getWithHeight(s, n)), {}, {
    payload: u,
    item: s
  });
};
function ad(e) {
  "@babel/helpers - typeof";
  return ad = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ad(e);
}
function GA(e) {
  return fZ(e) || pZ(e) || hZ(e) || dZ();
}
function dZ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hZ(e, t) {
  if (e) {
    if (typeof e == "string") return Gy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Gy(e, t);
  }
}
function pZ(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function fZ(e) {
  if (Array.isArray(e)) return Gy(e);
}
function Gy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function kA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Vt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kA(Object(r), !0).forEach(function(i) {
      gl(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : kA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function gl(e, t, r) {
  return t = gZ(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function gZ(e) {
  var t = mZ(e, "string");
  return ad(t) == "symbol" ? t : t + "";
}
function mZ(e, t) {
  if (ad(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (ad(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cr(e, t, r) {
  return ke(e) || ke(t) ? r : dr(t) ? vi(e, t, r) : Le(t) ? t(e) : r;
}
function Nc(e, t, r, i) {
  var n = pq(e, function(a) {
    return cr(a, t);
  });
  if (r === "number") {
    var o = n.filter(function(a) {
      return ue(a) || parseFloat(a);
    });
    return o.length ? [hm(o), dm(o)] : [1 / 0, -1 / 0];
  }
  var s = i ? n.filter(function(a) {
    return !ke(a);
  }) : n;
  return s.map(function(a) {
    return dr(a) || a instanceof Date ? a : "";
  });
}
var vZ = function(t) {
  var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0, s = -1, a = (r = i == null ? void 0 : i.length) !== null && r !== void 0 ? r : 0;
  if (a <= 1)
    return 0;
  if (o && o.axisType === "angleAxis" && Math.abs(Math.abs(o.range[1] - o.range[0]) - 360) <= 1e-6)
    for (var l = o.range, u = 0; u < a; u++) {
      var c = u > 0 ? n[u - 1].coordinate : n[a - 1].coordinate, d = n[u].coordinate, h = u >= a - 1 ? n[0].coordinate : n[u + 1].coordinate, p = void 0;
      if (Nr(d - c) !== Nr(h - d)) {
        var g = [];
        if (Nr(h - d) === Nr(l[1] - l[0])) {
          p = h;
          var m = d + l[1] - l[0];
          g[0] = Math.min(m, (m + c) / 2), g[1] = Math.max(m, (m + c) / 2);
        } else {
          p = c;
          var f = h + l[1] - l[0];
          g[0] = Math.min(d, (f + d) / 2), g[1] = Math.max(d, (f + d) / 2);
        }
        var C = [Math.min(d, (p + d) / 2), Math.max(d, (p + d) / 2)];
        if (t > C[0] && t <= C[1] || t >= g[0] && t <= g[1]) {
          s = n[u].index;
          break;
        }
      } else {
        var w = Math.min(c, h), E = Math.max(c, h);
        if (t > (w + d) / 2 && t <= (E + d) / 2) {
          s = n[u].index;
          break;
        }
      }
    }
  else
    for (var b = 0; b < a; b++)
      if (b === 0 && t <= (i[b].coordinate + i[b + 1].coordinate) / 2 || b > 0 && b < a - 1 && t > (i[b].coordinate + i[b - 1].coordinate) / 2 && t <= (i[b].coordinate + i[b + 1].coordinate) / 2 || b === a - 1 && t > (i[b].coordinate + i[b - 1].coordinate) / 2) {
        s = i[b].index;
        break;
      }
  return s;
}, CS = function(t) {
  var r, i = t, n = i.type.displayName, o = (r = t.type) !== null && r !== void 0 && r.defaultProps ? Vt(Vt({}, t.type.defaultProps), t.props) : t.props, s = o.stroke, a = o.fill, l;
  switch (n) {
    case "Line":
      l = s;
      break;
    case "Area":
    case "Radar":
      l = s && s !== "none" ? s : a;
      break;
    default:
      l = a;
      break;
  }
  return l;
}, CZ = function(t) {
  var r = t.barSize, i = t.totalSize, n = t.stackGroups, o = n === void 0 ? {} : n;
  if (!o)
    return {};
  for (var s = {}, a = Object.keys(o), l = 0, u = a.length; l < u; l++)
    for (var c = o[a[l]].stackGroups, d = Object.keys(c), h = 0, p = d.length; h < p; h++) {
      var g = c[d[h]], m = g.items, f = g.cateAxisId, C = m.filter(function(x) {
        return lo(x.type).indexOf("Bar") >= 0;
      });
      if (C && C.length) {
        var w = C[0].type.defaultProps, E = w !== void 0 ? Vt(Vt({}, w), C[0].props) : C[0].props, b = E.barSize, y = E[f];
        s[y] || (s[y] = []);
        var S = ke(b) ? r : b;
        s[y].push({
          item: C[0],
          stackList: C.slice(1),
          barSize: ke(S) ? void 0 : Lr(S, i, 0)
        });
      }
    }
  return s;
}, yZ = function(t) {
  var r = t.barGap, i = t.barCategoryGap, n = t.bandSize, o = t.sizeList, s = o === void 0 ? [] : o, a = t.maxBarSize, l = s.length;
  if (l < 1) return null;
  var u = Lr(r, n, 0, !0), c, d = [];
  if (s[0].barSize === +s[0].barSize) {
    var h = !1, p = n / l, g = s.reduce(function(b, y) {
      return b + y.barSize || 0;
    }, 0);
    g += (l - 1) * u, g >= n && (g -= (l - 1) * u, u = 0), g >= n && p > 0 && (h = !0, p *= 0.9, g = l * p);
    var m = (n - g) / 2 >> 0, f = {
      offset: m - u,
      size: 0
    };
    c = s.reduce(function(b, y) {
      var S = {
        item: y.item,
        position: {
          offset: f.offset + f.size + u,
          // @ts-expect-error the type check above does not check for type number explicitly
          size: h ? p : y.barSize
        }
      }, x = [].concat(GA(b), [S]);
      return f = x[x.length - 1].position, y.stackList && y.stackList.length && y.stackList.forEach(function(R) {
        x.push({
          item: R,
          position: f
        });
      }), x;
    }, d);
  } else {
    var C = Lr(i, n, 0, !0);
    n - 2 * C - (l - 1) * u <= 0 && (u = 0);
    var w = (n - 2 * C - (l - 1) * u) / l;
    w > 1 && (w >>= 0);
    var E = a === +a ? Math.min(w, a) : w;
    c = s.reduce(function(b, y, S) {
      var x = [].concat(GA(b), [{
        item: y.item,
        position: {
          offset: C + (w + u) * S + (w - E) / 2,
          size: E
        }
      }]);
      return y.stackList && y.stackList.length && y.stackList.forEach(function(R) {
        x.push({
          item: R,
          position: x[x.length - 1].position
        });
      }), x;
    }, d);
  }
  return c;
}, bZ = function(t, r, i, n) {
  var o = i.children, s = i.width, a = i.margin, l = s - (a.left || 0) - (a.right || 0), u = QO({
    children: o,
    legendWidth: l
  });
  if (u) {
    var c = n || {}, d = c.width, h = c.height, p = u.align, g = u.verticalAlign, m = u.layout;
    if ((m === "vertical" || m === "horizontal" && g === "middle") && p !== "center" && ue(t[p]))
      return Vt(Vt({}, t), {}, gl({}, p, t[p] + (d || 0)));
    if ((m === "horizontal" || m === "vertical" && p === "center") && g !== "middle" && ue(t[g]))
      return Vt(Vt({}, t), {}, gl({}, g, t[g] + (h || 0)));
  }
  return t;
}, wZ = function(t, r, i) {
  return ke(r) ? !0 : t === "horizontal" ? r === "yAxis" : t === "vertical" || i === "x" ? r === "xAxis" : i === "y" ? r === "yAxis" : !0;
}, eM = function(t, r, i, n, o) {
  var s = r.props.children, a = Ci(s, mh).filter(function(u) {
    return wZ(n, o, u.props.direction);
  });
  if (a && a.length) {
    var l = a.map(function(u) {
      return u.props.dataKey;
    });
    return t.reduce(function(u, c) {
      var d = cr(c, i);
      if (ke(d)) return u;
      var h = Array.isArray(d) ? [hm(d), dm(d)] : [d, d], p = l.reduce(function(g, m) {
        var f = cr(c, m, 0), C = h[0] - Math.abs(Array.isArray(f) ? f[0] : f), w = h[1] + Math.abs(Array.isArray(f) ? f[1] : f);
        return [Math.min(C, g[0]), Math.max(w, g[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(p[0], u[0]), Math.max(p[1], u[1])];
    }, [1 / 0, -1 / 0]);
  }
  return null;
}, SZ = function(t, r, i, n, o) {
  var s = r.map(function(a) {
    return eM(t, a, i, o, n);
  }).filter(function(a) {
    return !ke(a);
  });
  return s && s.length ? s.reduce(function(a, l) {
    return [Math.min(a[0], l[0]), Math.max(a[1], l[1])];
  }, [1 / 0, -1 / 0]) : null;
}, tM = function(t, r, i, n, o) {
  var s = r.map(function(l) {
    var u = l.props.dataKey;
    return i === "number" && u && eM(t, l, u, n) || Nc(t, u, i, o);
  });
  if (i === "number")
    return s.reduce(
      // @ts-expect-error if (type === number) means that the domain is numerical type
      // - but this link is missing in the type definition
      function(l, u) {
        return [Math.min(l[0], u[0]), Math.max(l[1], u[1])];
      },
      [1 / 0, -1 / 0]
    );
  var a = {};
  return s.reduce(function(l, u) {
    for (var c = 0, d = u.length; c < d; c++)
      a[u[c]] || (a[u[c]] = !0, l.push(u[c]));
    return l;
  }, []);
}, rM = function(t, r) {
  return t === "horizontal" && r === "xAxis" || t === "vertical" && r === "yAxis" || t === "centric" && r === "angleAxis" || t === "radial" && r === "radiusAxis";
}, iM = function(t, r, i, n) {
  if (n)
    return t.map(function(l) {
      return l.coordinate;
    });
  var o, s, a = t.map(function(l) {
    return l.coordinate === r && (o = !0), l.coordinate === i && (s = !0), l.coordinate;
  });
  return o || a.push(r), s || a.push(i), a;
}, ao = function(t, r, i) {
  if (!t) return null;
  var n = t.scale, o = t.duplicateDomain, s = t.type, a = t.range, l = t.realScaleType === "scaleBand" ? n.bandwidth() / 2 : 2, u = (r || i) && s === "category" && n.bandwidth ? n.bandwidth() / l : 0;
  if (u = t.axisType === "angleAxis" && (a == null ? void 0 : a.length) >= 2 ? Nr(a[0] - a[1]) * 2 * u : u, r && (t.ticks || t.niceTicks)) {
    var c = (t.ticks || t.niceTicks).map(function(d) {
      var h = o ? o.indexOf(d) : d;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: n(h) + u,
        value: d,
        offset: u
      };
    });
    return c.filter(function(d) {
      return !uh(d.coordinate);
    });
  }
  return t.isCategorical && t.categoricalDomain ? t.categoricalDomain.map(function(d, h) {
    return {
      coordinate: n(d) + u,
      value: d,
      index: h,
      offset: u
    };
  }) : n.ticks && !i ? n.ticks(t.tickCount).map(function(d) {
    return {
      coordinate: n(d) + u,
      value: d,
      offset: u
    };
  }) : n.domain().map(function(d, h) {
    return {
      coordinate: n(d) + u,
      value: o ? o[d] : d,
      index: h,
      offset: u
    };
  });
}, Yv = /* @__PURE__ */ new WeakMap(), op = function(t, r) {
  if (typeof r != "function")
    return t;
  Yv.has(t) || Yv.set(t, /* @__PURE__ */ new WeakMap());
  var i = Yv.get(t);
  if (i.has(r))
    return i.get(r);
  var n = function() {
    t.apply(void 0, arguments), r.apply(void 0, arguments);
  };
  return i.set(r, n), n;
}, nM = function(t, r, i) {
  var n = t.scale, o = t.type, s = t.layout, a = t.axisType;
  if (n === "auto")
    return s === "radial" && a === "radiusAxis" ? {
      scale: Qc(),
      realScaleType: "band"
    } : s === "radial" && a === "angleAxis" ? {
      scale: yf(),
      realScaleType: "linear"
    } : o === "category" && r && (r.indexOf("LineChart") >= 0 || r.indexOf("AreaChart") >= 0 || r.indexOf("ComposedChart") >= 0 && !i) ? {
      scale: _c(),
      realScaleType: "point"
    } : o === "category" ? {
      scale: Qc(),
      realScaleType: "band"
    } : {
      scale: yf(),
      realScaleType: "linear"
    };
  if (ia(n)) {
    var l = "scale".concat(qg(n));
    return {
      scale: (OA[l] || _c)(),
      realScaleType: OA[l] ? l : "point"
    };
  }
  return Le(n) ? {
    scale: n
  } : {
    scale: _c(),
    realScaleType: "point"
  };
}, VA = 1e-4, oM = function(t) {
  var r = t.domain();
  if (!(!r || r.length <= 2)) {
    var i = r.length, n = t.range(), o = Math.min(n[0], n[1]) - VA, s = Math.max(n[0], n[1]) + VA, a = t(r[0]), l = t(r[i - 1]);
    (a < o || a > s || l < o || l > s) && t.domain([r[0], r[i - 1]]);
  }
}, EZ = function(t, r) {
  if (!t)
    return null;
  for (var i = 0, n = t.length; i < n; i++)
    if (t[i].item === r)
      return t[i].position;
  return null;
}, xZ = function(t, r) {
  if (!r || r.length !== 2 || !ue(r[0]) || !ue(r[1]))
    return t;
  var i = Math.min(r[0], r[1]), n = Math.max(r[0], r[1]), o = [t[0], t[1]];
  return (!ue(t[0]) || t[0] < i) && (o[0] = i), (!ue(t[1]) || t[1] > n) && (o[1] = n), o[0] > n && (o[0] = n), o[1] < i && (o[1] = i), o;
}, AZ = function(t) {
  var r = t.length;
  if (!(r <= 0))
    for (var i = 0, n = t[0].length; i < n; ++i)
      for (var o = 0, s = 0, a = 0; a < r; ++a) {
        var l = uh(t[a][i][1]) ? t[a][i][0] : t[a][i][1];
        l >= 0 ? (t[a][i][0] = o, t[a][i][1] = o + l, o = t[a][i][1]) : (t[a][i][0] = s, t[a][i][1] = s + l, s = t[a][i][1]);
      }
}, DZ = function(t) {
  var r = t.length;
  if (!(r <= 0))
    for (var i = 0, n = t[0].length; i < n; ++i)
      for (var o = 0, s = 0; s < r; ++s) {
        var a = uh(t[s][i][1]) ? t[s][i][0] : t[s][i][1];
        a >= 0 ? (t[s][i][0] = o, t[s][i][1] = o + a, o = t[s][i][1]) : (t[s][i][0] = 0, t[s][i][1] = 0);
      }
}, TZ = {
  sign: AZ,
  // @ts-expect-error definitelytyped types are incorrect
  expand: UW,
  // @ts-expect-error definitelytyped types are incorrect
  none: Sl,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: YW,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: XW,
  positive: DZ
}, RZ = function(t, r, i) {
  var n = r.map(function(a) {
    return a.props.dataKey;
  }), o = TZ[i], s = zW().keys(n).value(function(a, l) {
    return +cr(a, l, 0);
  }).order(ly).offset(o);
  return s(t);
}, PZ = function(t, r, i, n, o, s) {
  if (!t)
    return null;
  var a = s ? r.reverse() : r, l = {}, u = a.reduce(function(d, h) {
    var p, g = (p = h.type) !== null && p !== void 0 && p.defaultProps ? Vt(Vt({}, h.type.defaultProps), h.props) : h.props, m = g.stackId, f = g.hide;
    if (f)
      return d;
    var C = g[i], w = d[C] || {
      hasStack: !1,
      stackGroups: {}
    };
    if (dr(m)) {
      var E = w.stackGroups[m] || {
        numericAxisId: i,
        cateAxisId: n,
        items: []
      };
      E.items.push(h), w.hasStack = !0, w.stackGroups[m] = E;
    } else
      w.stackGroups[Ru("_stackId_")] = {
        numericAxisId: i,
        cateAxisId: n,
        items: [h]
      };
    return Vt(Vt({}, d), {}, gl({}, C, w));
  }, l), c = {};
  return Object.keys(u).reduce(function(d, h) {
    var p = u[h];
    if (p.hasStack) {
      var g = {};
      p.stackGroups = Object.keys(p.stackGroups).reduce(function(m, f) {
        var C = p.stackGroups[f];
        return Vt(Vt({}, m), {}, gl({}, f, {
          numericAxisId: i,
          cateAxisId: n,
          items: C.items,
          stackedData: RZ(t, C.items, o)
        }));
      }, g);
    }
    return Vt(Vt({}, d), {}, gl({}, h, p));
  }, c);
}, sM = function(t, r) {
  var i = r.realScaleType, n = r.type, o = r.tickCount, s = r.originalDomain, a = r.allowDecimals, l = i || r.scale;
  if (l !== "auto" && l !== "linear")
    return null;
  if (o && n === "number" && s && (s[0] === "auto" || s[1] === "auto")) {
    var u = t.domain();
    if (!u.length)
      return null;
    var c = $q(u, o, a);
    return t.domain([hm(c), dm(c)]), {
      niceTicks: c
    };
  }
  if (o && n === "number") {
    var d = t.domain(), h = jq(d, o, a);
    return {
      niceTicks: h
    };
  }
  return null;
};
function HA(e) {
  var t = e.axis, r = e.ticks, i = e.bandSize, n = e.entry, o = e.index, s = e.dataKey;
  if (t.type === "category") {
    if (!t.allowDuplicatedCategory && t.dataKey && !ke(n[t.dataKey])) {
      var a = Zp(r, "value", n[t.dataKey]);
      if (a)
        return a.coordinate + i / 2;
    }
    return r[o] ? r[o].coordinate + i / 2 : null;
  }
  var l = cr(n, ke(s) ? t.dataKey : s);
  return ke(l) ? null : t.scale(l);
}
var BA = function(t) {
  var r = t.axis, i = t.ticks, n = t.offset, o = t.bandSize, s = t.entry, a = t.index;
  if (r.type === "category")
    return i[a] ? i[a].coordinate + n : null;
  var l = cr(s, r.dataKey, r.domain[a]);
  return ke(l) ? null : r.scale(l) - o / 2 + n;
}, IZ = function(t) {
  var r = t.numericAxis, i = r.scale.domain();
  if (r.type === "number") {
    var n = Math.min(i[0], i[1]), o = Math.max(i[0], i[1]);
    return n <= 0 && o >= 0 ? 0 : o < 0 ? o : n;
  }
  return i[0];
}, OZ = function(t, r) {
  var i, n = (i = t.type) !== null && i !== void 0 && i.defaultProps ? Vt(Vt({}, t.type.defaultProps), t.props) : t.props, o = n.stackId;
  if (dr(o)) {
    var s = r[o];
    if (s) {
      var a = s.items.indexOf(t);
      return a >= 0 ? s.stackedData[a] : null;
    }
  }
  return null;
}, MZ = function(t) {
  return t.reduce(function(r, i) {
    return [hm(i.concat([r[0]]).filter(ue)), dm(i.concat([r[1]]).filter(ue))];
  }, [1 / 0, -1 / 0]);
}, aM = function(t, r, i) {
  return Object.keys(t).reduce(function(n, o) {
    var s = t[o], a = s.stackedData, l = a.reduce(function(u, c) {
      var d = MZ(c.slice(r, i + 1));
      return [Math.min(u[0], d[0]), Math.max(u[1], d[1])];
    }, [1 / 0, -1 / 0]);
    return [Math.min(l[0], n[0]), Math.max(l[1], n[1])];
  }, [1 / 0, -1 / 0]).map(function(n) {
    return n === 1 / 0 || n === -1 / 0 ? 0 : n;
  });
}, WA = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, $A = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, ky = function(t, r, i) {
  if (Le(t))
    return t(r, i);
  if (!Array.isArray(t))
    return r;
  var n = [];
  if (ue(t[0]))
    n[0] = i ? t[0] : Math.min(t[0], r[0]);
  else if (WA.test(t[0])) {
    var o = +WA.exec(t[0])[1];
    n[0] = r[0] - o;
  } else Le(t[0]) ? n[0] = t[0](r[0]) : n[0] = r[0];
  if (ue(t[1]))
    n[1] = i ? t[1] : Math.max(t[1], r[1]);
  else if ($A.test(t[1])) {
    var s = +$A.exec(t[1])[1];
    n[1] = r[1] + s;
  } else Le(t[1]) ? n[1] = t[1](r[1]) : n[1] = r[1];
  return n;
}, Df = function(t, r, i) {
  if (t && t.scale && t.scale.bandwidth) {
    var n = t.scale.bandwidth();
    if (!i || n > 0)
      return n;
  }
  if (t && r && r.length >= 2) {
    for (var o = zw(r, function(d) {
      return d.coordinate;
    }), s = 1 / 0, a = 1, l = o.length; a < l; a++) {
      var u = o[a], c = o[a - 1];
      s = Math.min((u.coordinate || 0) - (c.coordinate || 0), s);
    }
    return s === 1 / 0 ? 0 : s;
  }
  return i ? void 0 : 0;
}, jA = function(t, r, i) {
  return !t || !t.length || gh(t, vi(i, "type.defaultProps.domain")) ? r : t;
}, lM = function(t, r) {
  var i = t.type.defaultProps ? Vt(Vt({}, t.type.defaultProps), t.props) : t.props, n = i.dataKey, o = i.name, s = i.unit, a = i.formatter, l = i.tooltipType, u = i.chartType, c = i.hide;
  return Vt(Vt({}, Ie(t, !1)), {}, {
    dataKey: n,
    unit: s,
    formatter: a,
    name: o || n,
    color: CS(t),
    value: cr(r, n),
    type: l,
    payload: r,
    chartType: u,
    hide: c
  });
};
function ld(e) {
  "@babel/helpers - typeof";
  return ld = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ld(e);
}
function zA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function to(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zA(Object(r), !0).forEach(function(i) {
      uM(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : zA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function uM(e, t, r) {
  return t = FZ(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function FZ(e) {
  var t = _Z(e, "string");
  return ld(t) == "symbol" ? t : t + "";
}
function _Z(e, t) {
  if (ld(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (ld(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function NZ(e, t) {
  return VZ(e) || kZ(e, t) || GZ(e, t) || LZ();
}
function LZ() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function GZ(e, t) {
  if (e) {
    if (typeof e == "string") return UA(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return UA(e, t);
  }
}
function UA(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function kZ(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function VZ(e) {
  if (Array.isArray(e)) return e;
}
var Tf = Math.PI / 180, HZ = function(t) {
  return t * 180 / Math.PI;
}, At = function(t, r, i, n) {
  return {
    x: t + Math.cos(-Tf * n) * i,
    y: r + Math.sin(-Tf * n) * i
  };
}, cM = function(t, r) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(t - (i.left || 0) - (i.right || 0)), Math.abs(r - (i.top || 0) - (i.bottom || 0))) / 2;
}, BZ = function(t, r, i, n, o) {
  var s = t.width, a = t.height, l = t.startAngle, u = t.endAngle, c = Lr(t.cx, s, s / 2), d = Lr(t.cy, a, a / 2), h = cM(s, a, i), p = Lr(t.innerRadius, h, 0), g = Lr(t.outerRadius, h, h * 0.8), m = Object.keys(r);
  return m.reduce(function(f, C) {
    var w = r[C], E = w.domain, b = w.reversed, y;
    if (ke(w.range))
      n === "angleAxis" ? y = [l, u] : n === "radiusAxis" && (y = [p, g]), b && (y = [y[1], y[0]]);
    else {
      y = w.range;
      var S = y, x = NZ(S, 2);
      l = x[0], u = x[1];
    }
    var R = nM(w, o), P = R.realScaleType, O = R.scale;
    O.domain(E).range(y), oM(O);
    var I = sM(O, to(to({}, w), {}, {
      realScaleType: P
    })), M = to(to(to({}, w), I), {}, {
      range: y,
      radius: g,
      realScaleType: P,
      scale: O,
      cx: c,
      cy: d,
      innerRadius: p,
      outerRadius: g,
      startAngle: l,
      endAngle: u
    });
    return to(to({}, f), {}, uM({}, C, M));
  }, {});
}, WZ = function(t, r) {
  var i = t.x, n = t.y, o = r.x, s = r.y;
  return Math.sqrt(Math.pow(i - o, 2) + Math.pow(n - s, 2));
}, $Z = function(t, r) {
  var i = t.x, n = t.y, o = r.cx, s = r.cy, a = WZ({
    x: i,
    y: n
  }, {
    x: o,
    y: s
  });
  if (a <= 0)
    return {
      radius: a
    };
  var l = (i - o) / a, u = Math.acos(l);
  return n > s && (u = 2 * Math.PI - u), {
    radius: a,
    angle: HZ(u),
    angleInRadian: u
  };
}, jZ = function(t) {
  var r = t.startAngle, i = t.endAngle, n = Math.floor(r / 360), o = Math.floor(i / 360), s = Math.min(n, o);
  return {
    startAngle: r - s * 360,
    endAngle: i - s * 360
  };
}, zZ = function(t, r) {
  var i = r.startAngle, n = r.endAngle, o = Math.floor(i / 360), s = Math.floor(n / 360), a = Math.min(o, s);
  return t + a * 360;
}, YA = function(t, r) {
  var i = t.x, n = t.y, o = $Z({
    x: i,
    y: n
  }, r), s = o.radius, a = o.angle, l = r.innerRadius, u = r.outerRadius;
  if (s < l || s > u)
    return !1;
  if (s === 0)
    return !0;
  var c = jZ(r), d = c.startAngle, h = c.endAngle, p = a, g;
  if (d <= h) {
    for (; p > h; )
      p -= 360;
    for (; p < d; )
      p += 360;
    g = p >= d && p <= h;
  } else {
    for (; p > d; )
      p -= 360;
    for (; p < h; )
      p += 360;
    g = p >= h && p <= d;
  }
  return g ? to(to({}, r), {}, {
    radius: s,
    angle: zZ(p, r)
  }) : null;
}, dM = function(t) {
  return !/* @__PURE__ */ cn(t) && !Le(t) && typeof t != "boolean" ? t.className : "";
};
function ud(e) {
  "@babel/helpers - typeof";
  return ud = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ud(e);
}
var UZ = ["offset"];
function YZ(e) {
  return ZZ(e) || qZ(e) || KZ(e) || XZ();
}
function XZ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function KZ(e, t) {
  if (e) {
    if (typeof e == "string") return Vy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Vy(e, t);
  }
}
function qZ(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function ZZ(e) {
  if (Array.isArray(e)) return Vy(e);
}
function Vy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function JZ(e, t) {
  if (e == null) return {};
  var r = QZ(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function QZ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function XA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function ar(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XA(Object(r), !0).forEach(function(i) {
      e6(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : XA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function e6(e, t, r) {
  return t = t6(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function t6(e) {
  var t = r6(e, "string");
  return ud(t) == "symbol" ? t : t + "";
}
function r6(e, t) {
  if (ud(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (ud(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cd() {
  return cd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, cd.apply(this, arguments);
}
var i6 = function(t) {
  var r = t.value, i = t.formatter, n = ke(t.children) ? r : t.children;
  return Le(i) ? i(n) : n;
}, n6 = function(t, r) {
  var i = Nr(r - t), n = Math.min(Math.abs(r - t), 360);
  return i * n;
}, o6 = function(t, r, i) {
  var n = t.position, o = t.viewBox, s = t.offset, a = t.className, l = o, u = l.cx, c = l.cy, d = l.innerRadius, h = l.outerRadius, p = l.startAngle, g = l.endAngle, m = l.clockWise, f = (d + h) / 2, C = n6(p, g), w = C >= 0 ? 1 : -1, E, b;
  n === "insideStart" ? (E = p + w * s, b = m) : n === "insideEnd" ? (E = g - w * s, b = !m) : n === "end" && (E = g + w * s, b = m), b = C <= 0 ? b : !b;
  var y = At(u, c, f, E), S = At(u, c, f, E + (b ? 1 : -1) * 359), x = "M".concat(y.x, ",").concat(y.y, `
    A`).concat(f, ",").concat(f, ",0,1,").concat(b ? 0 : 1, `,
    `).concat(S.x, ",").concat(S.y), R = ke(t.id) ? Ru("recharts-radial-line-") : t.id;
  return /* @__PURE__ */ D.createElement("text", cd({}, i, {
    dominantBaseline: "central",
    className: xe("recharts-radial-bar-label", a)
  }), /* @__PURE__ */ D.createElement("defs", null, /* @__PURE__ */ D.createElement("path", {
    id: R,
    d: x
  })), /* @__PURE__ */ D.createElement("textPath", {
    xlinkHref: "#".concat(R)
  }, r));
}, s6 = function(t) {
  var r = t.viewBox, i = t.offset, n = t.position, o = r, s = o.cx, a = o.cy, l = o.innerRadius, u = o.outerRadius, c = o.startAngle, d = o.endAngle, h = (c + d) / 2;
  if (n === "outside") {
    var p = At(s, a, u + i, h), g = p.x, m = p.y;
    return {
      x: g,
      y: m,
      textAnchor: g >= s ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (n === "center")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (n === "centerTop")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (n === "centerBottom")
    return {
      x: s,
      y: a,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var f = (l + u) / 2, C = At(s, a, f, h), w = C.x, E = C.y;
  return {
    x: w,
    y: E,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, a6 = function(t) {
  var r = t.viewBox, i = t.parentViewBox, n = t.offset, o = t.position, s = r, a = s.x, l = s.y, u = s.width, c = s.height, d = c >= 0 ? 1 : -1, h = d * n, p = d > 0 ? "end" : "start", g = d > 0 ? "start" : "end", m = u >= 0 ? 1 : -1, f = m * n, C = m > 0 ? "end" : "start", w = m > 0 ? "start" : "end";
  if (o === "top") {
    var E = {
      x: a + u / 2,
      y: l - d * n,
      textAnchor: "middle",
      verticalAnchor: p
    };
    return ar(ar({}, E), i ? {
      height: Math.max(l - i.y, 0),
      width: u
    } : {});
  }
  if (o === "bottom") {
    var b = {
      x: a + u / 2,
      y: l + c + h,
      textAnchor: "middle",
      verticalAnchor: g
    };
    return ar(ar({}, b), i ? {
      height: Math.max(i.y + i.height - (l + c), 0),
      width: u
    } : {});
  }
  if (o === "left") {
    var y = {
      x: a - f,
      y: l + c / 2,
      textAnchor: C,
      verticalAnchor: "middle"
    };
    return ar(ar({}, y), i ? {
      width: Math.max(y.x - i.x, 0),
      height: c
    } : {});
  }
  if (o === "right") {
    var S = {
      x: a + u + f,
      y: l + c / 2,
      textAnchor: w,
      verticalAnchor: "middle"
    };
    return ar(ar({}, S), i ? {
      width: Math.max(i.x + i.width - S.x, 0),
      height: c
    } : {});
  }
  var x = i ? {
    width: u,
    height: c
  } : {};
  return o === "insideLeft" ? ar({
    x: a + f,
    y: l + c / 2,
    textAnchor: w,
    verticalAnchor: "middle"
  }, x) : o === "insideRight" ? ar({
    x: a + u - f,
    y: l + c / 2,
    textAnchor: C,
    verticalAnchor: "middle"
  }, x) : o === "insideTop" ? ar({
    x: a + u / 2,
    y: l + h,
    textAnchor: "middle",
    verticalAnchor: g
  }, x) : o === "insideBottom" ? ar({
    x: a + u / 2,
    y: l + c - h,
    textAnchor: "middle",
    verticalAnchor: p
  }, x) : o === "insideTopLeft" ? ar({
    x: a + f,
    y: l + h,
    textAnchor: w,
    verticalAnchor: g
  }, x) : o === "insideTopRight" ? ar({
    x: a + u - f,
    y: l + h,
    textAnchor: C,
    verticalAnchor: g
  }, x) : o === "insideBottomLeft" ? ar({
    x: a + f,
    y: l + c - h,
    textAnchor: w,
    verticalAnchor: p
  }, x) : o === "insideBottomRight" ? ar({
    x: a + u - f,
    y: l + c - h,
    textAnchor: C,
    verticalAnchor: p
  }, x) : xu(o) && (ue(o.x) || _s(o.x)) && (ue(o.y) || _s(o.y)) ? ar({
    x: a + Lr(o.x, u),
    y: l + Lr(o.y, c),
    textAnchor: "end",
    verticalAnchor: "end"
  }, x) : ar({
    x: a + u / 2,
    y: l + c / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, x);
}, l6 = function(t) {
  return "cx" in t && ue(t.cx);
};
function gr(e) {
  var t = e.offset, r = t === void 0 ? 5 : t, i = JZ(e, UZ), n = ar({
    offset: r
  }, i), o = n.viewBox, s = n.position, a = n.value, l = n.children, u = n.content, c = n.className, d = c === void 0 ? "" : c, h = n.textBreakAll;
  if (!o || ke(a) && ke(l) && !/* @__PURE__ */ cn(u) && !Le(u))
    return null;
  if (/* @__PURE__ */ cn(u))
    return /* @__PURE__ */ Gt(u, n);
  var p;
  if (Le(u)) {
    if (p = /* @__PURE__ */ zc(u, n), /* @__PURE__ */ cn(p))
      return p;
  } else
    p = i6(n);
  var g = l6(o), m = Ie(n, !0);
  if (g && (s === "insideStart" || s === "insideEnd" || s === "end"))
    return o6(n, p, m);
  var f = g ? s6(n) : a6(n);
  return /* @__PURE__ */ D.createElement(oa, cd({
    className: xe("recharts-label", d)
  }, m, f, {
    breakAll: h
  }), p);
}
gr.displayName = "Label";
var hM = function(t) {
  var r = t.cx, i = t.cy, n = t.angle, o = t.startAngle, s = t.endAngle, a = t.r, l = t.radius, u = t.innerRadius, c = t.outerRadius, d = t.x, h = t.y, p = t.top, g = t.left, m = t.width, f = t.height, C = t.clockWise, w = t.labelViewBox;
  if (w)
    return w;
  if (ue(m) && ue(f)) {
    if (ue(d) && ue(h))
      return {
        x: d,
        y: h,
        width: m,
        height: f
      };
    if (ue(p) && ue(g))
      return {
        x: p,
        y: g,
        width: m,
        height: f
      };
  }
  return ue(d) && ue(h) ? {
    x: d,
    y: h,
    width: 0,
    height: 0
  } : ue(r) && ue(i) ? {
    cx: r,
    cy: i,
    startAngle: o || n || 0,
    endAngle: s || n || 0,
    innerRadius: u || 0,
    outerRadius: c || l || a || 0,
    clockWise: C
  } : t.viewBox ? t.viewBox : {};
}, u6 = function(t, r) {
  return t ? t === !0 ? /* @__PURE__ */ D.createElement(gr, {
    key: "label-implicit",
    viewBox: r
  }) : dr(t) ? /* @__PURE__ */ D.createElement(gr, {
    key: "label-implicit",
    viewBox: r,
    value: t
  }) : /* @__PURE__ */ cn(t) ? t.type === gr ? /* @__PURE__ */ Gt(t, {
    key: "label-implicit",
    viewBox: r
  }) : /* @__PURE__ */ D.createElement(gr, {
    key: "label-implicit",
    content: t,
    viewBox: r
  }) : Le(t) ? /* @__PURE__ */ D.createElement(gr, {
    key: "label-implicit",
    content: t,
    viewBox: r
  }) : xu(t) ? /* @__PURE__ */ D.createElement(gr, cd({
    viewBox: r
  }, t, {
    key: "label-implicit"
  })) : null : null;
}, c6 = function(t, r) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!t || !t.children && i && !t.label)
    return null;
  var n = t.children, o = hM(t), s = Ci(n, gr).map(function(l, u) {
    return /* @__PURE__ */ Gt(l, {
      viewBox: r || o,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(u)
    });
  });
  if (!i)
    return s;
  var a = u6(t.label, r || o);
  return [a].concat(YZ(s));
};
gr.parseViewBox = hM;
gr.renderCallByParent = c6;
function d6(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var h6 = d6;
const p6 = /* @__PURE__ */ Ct(h6);
function dd(e) {
  "@babel/helpers - typeof";
  return dd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dd(e);
}
var f6 = ["valueAccessor"], g6 = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
function m6(e) {
  return b6(e) || y6(e) || C6(e) || v6();
}
function v6() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function C6(e, t) {
  if (e) {
    if (typeof e == "string") return Hy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Hy(e, t);
  }
}
function y6(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function b6(e) {
  if (Array.isArray(e)) return Hy(e);
}
function Hy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function KA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function qA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KA(Object(r), !0).forEach(function(i) {
      w6(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : KA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function w6(e, t, r) {
  return t = S6(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function S6(e) {
  var t = E6(e, "string");
  return dd(t) == "symbol" ? t : t + "";
}
function E6(e, t) {
  if (dd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (dd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ZA(e, t) {
  if (e == null) return {};
  var r = x6(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function x6(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
var A6 = function(t) {
  return Array.isArray(t.value) ? p6(t.value) : t.value;
};
function ho(e) {
  var t = e.valueAccessor, r = t === void 0 ? A6 : t, i = ZA(e, f6), n = i.data, o = i.dataKey, s = i.clockWise, a = i.id, l = i.textBreakAll, u = ZA(i, g6);
  return !n || !n.length ? null : /* @__PURE__ */ D.createElement(Ze, {
    className: "recharts-label-list"
  }, n.map(function(c, d) {
    var h = ke(o) ? r(c, d) : cr(c && c.payload, o), p = ke(a) ? {} : {
      id: "".concat(a, "-").concat(d)
    };
    return /* @__PURE__ */ D.createElement(gr, Rf({}, Ie(c, !0), u, p, {
      parentViewBox: c.parentViewBox,
      value: h,
      textBreakAll: l,
      viewBox: gr.parseViewBox(ke(s) ? c : qA(qA({}, c), {}, {
        clockWise: s
      })),
      key: "label-".concat(d),
      index: d
    }));
  }));
}
ho.displayName = "LabelList";
function D6(e, t) {
  return e ? e === !0 ? /* @__PURE__ */ D.createElement(ho, {
    key: "labelList-implicit",
    data: t
  }) : /* @__PURE__ */ D.isValidElement(e) || Le(e) ? /* @__PURE__ */ D.createElement(ho, {
    key: "labelList-implicit",
    data: t,
    content: e
  }) : xu(e) ? /* @__PURE__ */ D.createElement(ho, Rf({
    data: t
  }, e, {
    key: "labelList-implicit"
  })) : null : null;
}
function T6(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!e || !e.children && r && !e.label)
    return null;
  var i = e.children, n = Ci(i, ho).map(function(s, a) {
    return /* @__PURE__ */ Gt(s, {
      data: t,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(a)
    });
  });
  if (!r)
    return n;
  var o = D6(e.label, t);
  return [o].concat(m6(n));
}
ho.renderCallByParent = T6;
function hd(e) {
  "@babel/helpers - typeof";
  return hd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hd(e);
}
function By() {
  return By = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, By.apply(this, arguments);
}
function JA(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function QA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JA(Object(r), !0).forEach(function(i) {
      R6(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : JA(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function R6(e, t, r) {
  return t = P6(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function P6(e) {
  var t = I6(e, "string");
  return hd(t) == "symbol" ? t : t + "";
}
function I6(e, t) {
  if (hd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (hd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var O6 = function(t, r) {
  var i = Nr(r - t), n = Math.min(Math.abs(r - t), 359.999);
  return i * n;
}, sp = function(t) {
  var r = t.cx, i = t.cy, n = t.radius, o = t.angle, s = t.sign, a = t.isExternal, l = t.cornerRadius, u = t.cornerIsExternal, c = l * (a ? 1 : -1) + n, d = Math.asin(l / c) / Tf, h = u ? o : o + s * d, p = At(r, i, c, h), g = At(r, i, n, h), m = u ? o - s * d : o, f = At(r, i, c * Math.cos(d * Tf), m);
  return {
    center: p,
    circleTangency: g,
    lineTangency: f,
    theta: d
  };
}, pM = function(t) {
  var r = t.cx, i = t.cy, n = t.innerRadius, o = t.outerRadius, s = t.startAngle, a = t.endAngle, l = O6(s, a), u = s + l, c = At(r, i, o, s), d = At(r, i, o, u), h = "M ".concat(c.x, ",").concat(c.y, `
    A `).concat(o, ",").concat(o, `,0,
    `).concat(+(Math.abs(l) > 180), ",").concat(+(s > u), `,
    `).concat(d.x, ",").concat(d.y, `
  `);
  if (n > 0) {
    var p = At(r, i, n, s), g = At(r, i, n, u);
    h += "L ".concat(g.x, ",").concat(g.y, `
            A `).concat(n, ",").concat(n, `,0,
            `).concat(+(Math.abs(l) > 180), ",").concat(+(s <= u), `,
            `).concat(p.x, ",").concat(p.y, " Z");
  } else
    h += "L ".concat(r, ",").concat(i, " Z");
  return h;
}, M6 = function(t) {
  var r = t.cx, i = t.cy, n = t.innerRadius, o = t.outerRadius, s = t.cornerRadius, a = t.forceCornerRadius, l = t.cornerIsExternal, u = t.startAngle, c = t.endAngle, d = Nr(c - u), h = sp({
    cx: r,
    cy: i,
    radius: o,
    angle: u,
    sign: d,
    cornerRadius: s,
    cornerIsExternal: l
  }), p = h.circleTangency, g = h.lineTangency, m = h.theta, f = sp({
    cx: r,
    cy: i,
    radius: o,
    angle: c,
    sign: -d,
    cornerRadius: s,
    cornerIsExternal: l
  }), C = f.circleTangency, w = f.lineTangency, E = f.theta, b = l ? Math.abs(u - c) : Math.abs(u - c) - m - E;
  if (b < 0)
    return a ? "M ".concat(g.x, ",").concat(g.y, `
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(s * 2, `,0
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(-s * 2, `,0
      `) : pM({
      cx: r,
      cy: i,
      innerRadius: n,
      outerRadius: o,
      startAngle: u,
      endAngle: c
    });
  var y = "M ".concat(g.x, ",").concat(g.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(d < 0), ",").concat(p.x, ",").concat(p.y, `
    A`).concat(o, ",").concat(o, ",0,").concat(+(b > 180), ",").concat(+(d < 0), ",").concat(C.x, ",").concat(C.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(d < 0), ",").concat(w.x, ",").concat(w.y, `
  `);
  if (n > 0) {
    var S = sp({
      cx: r,
      cy: i,
      radius: n,
      angle: u,
      sign: d,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: l
    }), x = S.circleTangency, R = S.lineTangency, P = S.theta, O = sp({
      cx: r,
      cy: i,
      radius: n,
      angle: c,
      sign: -d,
      isExternal: !0,
      cornerRadius: s,
      cornerIsExternal: l
    }), I = O.circleTangency, M = O.lineTangency, _ = O.theta, G = l ? Math.abs(u - c) : Math.abs(u - c) - P - _;
    if (G < 0 && s === 0)
      return "".concat(y, "L").concat(r, ",").concat(i, "Z");
    y += "L".concat(M.x, ",").concat(M.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(d < 0), ",").concat(I.x, ",").concat(I.y, `
      A`).concat(n, ",").concat(n, ",0,").concat(+(G > 180), ",").concat(+(d > 0), ",").concat(x.x, ",").concat(x.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(d < 0), ",").concat(R.x, ",").concat(R.y, "Z");
  } else
    y += "L".concat(r, ",").concat(i, "Z");
  return y;
}, F6 = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, fM = function(t) {
  var r = QA(QA({}, F6), t), i = r.cx, n = r.cy, o = r.innerRadius, s = r.outerRadius, a = r.cornerRadius, l = r.forceCornerRadius, u = r.cornerIsExternal, c = r.startAngle, d = r.endAngle, h = r.className;
  if (s < o || c === d)
    return null;
  var p = xe("recharts-sector", h), g = s - o, m = Lr(a, g, 0, !0), f;
  return m > 0 && Math.abs(c - d) < 360 ? f = M6({
    cx: i,
    cy: n,
    innerRadius: o,
    outerRadius: s,
    cornerRadius: Math.min(m, g / 2),
    forceCornerRadius: l,
    cornerIsExternal: u,
    startAngle: c,
    endAngle: d
  }) : f = pM({
    cx: i,
    cy: n,
    innerRadius: o,
    outerRadius: s,
    startAngle: c,
    endAngle: d
  }), /* @__PURE__ */ D.createElement("path", By({}, Ie(r, !0), {
    className: p,
    d: f,
    role: "img"
  }));
};
function pd(e) {
  "@babel/helpers - typeof";
  return pd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pd(e);
}
function Wy() {
  return Wy = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Wy.apply(this, arguments);
}
function eD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function tD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eD(Object(r), !0).forEach(function(i) {
      _6(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : eD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function _6(e, t, r) {
  return t = N6(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function N6(e) {
  var t = L6(e, "string");
  return pd(t) == "symbol" ? t : t + "";
}
function L6(e, t) {
  if (pd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (pd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var rD = {
  curveBasisClosed: _W,
  curveBasisOpen: NW,
  curveBasis: FW,
  curveBumpX: yW,
  curveBumpY: bW,
  curveLinearClosed: LW,
  curveLinear: Jg,
  curveMonotoneX: GW,
  curveMonotoneY: kW,
  curveNatural: VW,
  curveStep: HW,
  curveStepAfter: WW,
  curveStepBefore: BW
}, ap = function(t) {
  return t.x === +t.x && t.y === +t.y;
}, cc = function(t) {
  return t.x;
}, dc = function(t) {
  return t.y;
}, G6 = function(t, r) {
  if (Le(t))
    return t;
  var i = "curve".concat(qg(t));
  return (i === "curveMonotone" || i === "curveBump") && r ? rD["".concat(i).concat(r === "vertical" ? "Y" : "X")] : rD[i] || Jg;
}, k6 = function(t) {
  var r = t.type, i = r === void 0 ? "linear" : r, n = t.points, o = n === void 0 ? [] : n, s = t.baseLine, a = t.layout, l = t.connectNulls, u = l === void 0 ? !1 : l, c = G6(i, a), d = u ? o.filter(function(m) {
    return ap(m);
  }) : o, h;
  if (Array.isArray(s)) {
    var p = u ? s.filter(function(m) {
      return ap(m);
    }) : s, g = d.map(function(m, f) {
      return tD(tD({}, m), {}, {
        base: p[f]
      });
    });
    return a === "vertical" ? h = Zh().y(dc).x1(cc).x0(function(m) {
      return m.base.x;
    }) : h = Zh().x(cc).y1(dc).y0(function(m) {
      return m.base.y;
    }), h.defined(ap).curve(c), h(g);
  }
  return a === "vertical" && ue(s) ? h = Zh().y(dc).x1(cc).x0(s) : ue(s) ? h = Zh().x(cc).y1(dc).y0(s) : h = lI().x(cc).y(dc), h.defined(ap).curve(c), h(d);
}, Pf = function(t) {
  var r = t.className, i = t.points, n = t.path, o = t.pathRef;
  if ((!i || !i.length) && !n)
    return null;
  var s = i && i.length ? k6(t) : n;
  return /* @__PURE__ */ Y.createElement("path", Wy({}, Ie(t, !1), Jp(t), {
    className: xe("recharts-curve", r),
    d: s,
    ref: o
  }));
}, $y = { exports: {} }, jy = { exports: {} }, st = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iD;
function V6() {
  if (iD) return st;
  iD = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, i = e ? Symbol.for("react.fragment") : 60107, n = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, f = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function E(y) {
    if (typeof y == "object" && y !== null) {
      var S = y.$$typeof;
      switch (S) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case i:
            case o:
            case n:
            case d:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case g:
                case p:
                case s:
                  return y;
                default:
                  return S;
              }
          }
        case r:
          return S;
      }
    }
  }
  function b(y) {
    return E(y) === u;
  }
  return st.AsyncMode = l, st.ConcurrentMode = u, st.ContextConsumer = a, st.ContextProvider = s, st.Element = t, st.ForwardRef = c, st.Fragment = i, st.Lazy = g, st.Memo = p, st.Portal = r, st.Profiler = o, st.StrictMode = n, st.Suspense = d, st.isAsyncMode = function(y) {
    return b(y) || E(y) === l;
  }, st.isConcurrentMode = b, st.isContextConsumer = function(y) {
    return E(y) === a;
  }, st.isContextProvider = function(y) {
    return E(y) === s;
  }, st.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, st.isForwardRef = function(y) {
    return E(y) === c;
  }, st.isFragment = function(y) {
    return E(y) === i;
  }, st.isLazy = function(y) {
    return E(y) === g;
  }, st.isMemo = function(y) {
    return E(y) === p;
  }, st.isPortal = function(y) {
    return E(y) === r;
  }, st.isProfiler = function(y) {
    return E(y) === o;
  }, st.isStrictMode = function(y) {
    return E(y) === n;
  }, st.isSuspense = function(y) {
    return E(y) === d;
  }, st.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === i || y === u || y === o || y === n || y === d || y === h || typeof y == "object" && y !== null && (y.$$typeof === g || y.$$typeof === p || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === f || y.$$typeof === C || y.$$typeof === w || y.$$typeof === m);
  }, st.typeOf = E, st;
}
var at = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nD;
function H6() {
  return nD || (nD = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, i = e ? Symbol.for("react.fragment") : 60107, n = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, f = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function E(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === i || W === u || W === o || W === n || W === d || W === h || typeof W == "object" && W !== null && (W.$$typeof === g || W.$$typeof === p || W.$$typeof === s || W.$$typeof === a || W.$$typeof === c || W.$$typeof === f || W.$$typeof === C || W.$$typeof === w || W.$$typeof === m);
    }
    function b(W) {
      if (typeof W == "object" && W !== null) {
        var be = W.$$typeof;
        switch (be) {
          case t:
            var X = W.type;
            switch (X) {
              case l:
              case u:
              case i:
              case o:
              case n:
              case d:
                return X;
              default:
                var Te = X && X.$$typeof;
                switch (Te) {
                  case a:
                  case c:
                  case g:
                  case p:
                  case s:
                    return Te;
                  default:
                    return be;
                }
            }
          case r:
            return be;
        }
      }
    }
    var y = l, S = u, x = a, R = s, P = t, O = c, I = i, M = g, _ = p, G = r, F = o, N = n, V = d, B = !1;
    function $(W) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(W) || b(W) === l;
    }
    function L(W) {
      return b(W) === u;
    }
    function z(W) {
      return b(W) === a;
    }
    function j(W) {
      return b(W) === s;
    }
    function U(W) {
      return typeof W == "object" && W !== null && W.$$typeof === t;
    }
    function oe(W) {
      return b(W) === c;
    }
    function ie(W) {
      return b(W) === i;
    }
    function le(W) {
      return b(W) === g;
    }
    function ce(W) {
      return b(W) === p;
    }
    function he(W) {
      return b(W) === r;
    }
    function Z(W) {
      return b(W) === o;
    }
    function se(W) {
      return b(W) === n;
    }
    function ae(W) {
      return b(W) === d;
    }
    at.AsyncMode = y, at.ConcurrentMode = S, at.ContextConsumer = x, at.ContextProvider = R, at.Element = P, at.ForwardRef = O, at.Fragment = I, at.Lazy = M, at.Memo = _, at.Portal = G, at.Profiler = F, at.StrictMode = N, at.Suspense = V, at.isAsyncMode = $, at.isConcurrentMode = L, at.isContextConsumer = z, at.isContextProvider = j, at.isElement = U, at.isForwardRef = oe, at.isFragment = ie, at.isLazy = le, at.isMemo = ce, at.isPortal = he, at.isProfiler = Z, at.isStrictMode = se, at.isSuspense = ae, at.isValidElementType = E, at.typeOf = b;
  }()), at;
}
process.env.NODE_ENV === "production" ? jy.exports = V6() : jy.exports = H6();
var yS = jy.exports;
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Xv, oD;
function B6() {
  if (oD) return Xv;
  oD = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function i(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function n() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Xv = n() ? Object.assign : function(o, s) {
    for (var a, l = i(o), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var h = 0; h < u.length; h++)
          r.call(a, u[h]) && (l[u[h]] = a[u[h]]);
      }
    }
    return l;
  }, Xv;
}
var Kv, sD;
function bS() {
  if (sD) return Kv;
  sD = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Kv = e, Kv;
}
var qv, aD;
function gM() {
  return aD || (aD = 1, qv = Function.call.bind(Object.prototype.hasOwnProperty)), qv;
}
var Zv, lD;
function W6() {
  if (lD) return Zv;
  lD = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = bS(), r = {}, i = gM();
    e = function(o) {
      var s = "Warning: " + o;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function n(o, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (i(o, c)) {
          var d;
          try {
            if (typeof o[c] != "function") {
              var h = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            d = o[c](s, c, l, a, null, t);
          } catch (g) {
            d = g;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in r)) {
            r[d.message] = !0;
            var p = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (p ?? "")
            );
          }
        }
    }
  }
  return n.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, Zv = n, Zv;
}
var Jv, uD;
function $6() {
  if (uD) return Jv;
  uD = 1;
  var e = yS, t = B6(), r = bS(), i = gM(), n = W6(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Jv = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(L) {
      var z = L && (u && L[u] || L[c]);
      if (typeof z == "function")
        return z;
    }
    var h = "<<anonymous>>", p = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: E,
      element: b(),
      elementType: y(),
      instanceOf: S,
      node: O(),
      objectOf: R,
      oneOf: x,
      oneOfType: P,
      shape: M,
      exact: _
    };
    function g(L, z) {
      return L === z ? L !== 0 || 1 / L === 1 / z : L !== L && z !== z;
    }
    function m(L, z) {
      this.message = L, this.data = z && typeof z == "object" ? z : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function f(L) {
      if (process.env.NODE_ENV !== "production")
        var z = {}, j = 0;
      function U(ie, le, ce, he, Z, se, ae) {
        if (he = he || h, se = se || ce, ae !== r) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var be = he + ":" + ce;
            !z[be] && // Avoid spamming the console because they are often not actionable except for lib authors
            j < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + se + "` prop on `" + he + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), z[be] = !0, j++);
          }
        }
        return le[ce] == null ? ie ? le[ce] === null ? new m("The " + Z + " `" + se + "` is marked as required " + ("in `" + he + "`, but its value is `null`.")) : new m("The " + Z + " `" + se + "` is marked as required in " + ("`" + he + "`, but its value is `undefined`.")) : null : L(le, ce, he, Z, se);
      }
      var oe = U.bind(null, !1);
      return oe.isRequired = U.bind(null, !0), oe;
    }
    function C(L) {
      function z(j, U, oe, ie, le, ce) {
        var he = j[U], Z = N(he);
        if (Z !== L) {
          var se = V(he);
          return new m(
            "Invalid " + ie + " `" + le + "` of type " + ("`" + se + "` supplied to `" + oe + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return f(z);
    }
    function w() {
      return f(s);
    }
    function E(L) {
      function z(j, U, oe, ie, le) {
        if (typeof L != "function")
          return new m("Property `" + le + "` of component `" + oe + "` has invalid PropType notation inside arrayOf.");
        var ce = j[U];
        if (!Array.isArray(ce)) {
          var he = N(ce);
          return new m("Invalid " + ie + " `" + le + "` of type " + ("`" + he + "` supplied to `" + oe + "`, expected an array."));
        }
        for (var Z = 0; Z < ce.length; Z++) {
          var se = L(ce, Z, oe, ie, le + "[" + Z + "]", r);
          if (se instanceof Error)
            return se;
        }
        return null;
      }
      return f(z);
    }
    function b() {
      function L(z, j, U, oe, ie) {
        var le = z[j];
        if (!a(le)) {
          var ce = N(le);
          return new m("Invalid " + oe + " `" + ie + "` of type " + ("`" + ce + "` supplied to `" + U + "`, expected a single ReactElement."));
        }
        return null;
      }
      return f(L);
    }
    function y() {
      function L(z, j, U, oe, ie) {
        var le = z[j];
        if (!e.isValidElementType(le)) {
          var ce = N(le);
          return new m("Invalid " + oe + " `" + ie + "` of type " + ("`" + ce + "` supplied to `" + U + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return f(L);
    }
    function S(L) {
      function z(j, U, oe, ie, le) {
        if (!(j[U] instanceof L)) {
          var ce = L.name || h, he = $(j[U]);
          return new m("Invalid " + ie + " `" + le + "` of type " + ("`" + he + "` supplied to `" + oe + "`, expected ") + ("instance of `" + ce + "`."));
        }
        return null;
      }
      return f(z);
    }
    function x(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
      function z(j, U, oe, ie, le) {
        for (var ce = j[U], he = 0; he < L.length; he++)
          if (g(ce, L[he]))
            return null;
        var Z = JSON.stringify(L, function(ae, W) {
          var be = V(W);
          return be === "symbol" ? String(W) : W;
        });
        return new m("Invalid " + ie + " `" + le + "` of value `" + String(ce) + "` " + ("supplied to `" + oe + "`, expected one of " + Z + "."));
      }
      return f(z);
    }
    function R(L) {
      function z(j, U, oe, ie, le) {
        if (typeof L != "function")
          return new m("Property `" + le + "` of component `" + oe + "` has invalid PropType notation inside objectOf.");
        var ce = j[U], he = N(ce);
        if (he !== "object")
          return new m("Invalid " + ie + " `" + le + "` of type " + ("`" + he + "` supplied to `" + oe + "`, expected an object."));
        for (var Z in ce)
          if (i(ce, Z)) {
            var se = L(ce, Z, oe, ie, le + "." + Z, r);
            if (se instanceof Error)
              return se;
          }
        return null;
      }
      return f(z);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var z = 0; z < L.length; z++) {
        var j = L[z];
        if (typeof j != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + B(j) + " at index " + z + "."
          ), s;
      }
      function U(oe, ie, le, ce, he) {
        for (var Z = [], se = 0; se < L.length; se++) {
          var ae = L[se], W = ae(oe, ie, le, ce, he, r);
          if (W == null)
            return null;
          W.data && i(W.data, "expectedType") && Z.push(W.data.expectedType);
        }
        var be = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + ce + " `" + he + "` supplied to " + ("`" + le + "`" + be + "."));
      }
      return f(U);
    }
    function O() {
      function L(z, j, U, oe, ie) {
        return G(z[j]) ? null : new m("Invalid " + oe + " `" + ie + "` supplied to " + ("`" + U + "`, expected a ReactNode."));
      }
      return f(L);
    }
    function I(L, z, j, U, oe) {
      return new m(
        (L || "React class") + ": " + z + " type `" + j + "." + U + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + oe + "`."
      );
    }
    function M(L) {
      function z(j, U, oe, ie, le) {
        var ce = j[U], he = N(ce);
        if (he !== "object")
          return new m("Invalid " + ie + " `" + le + "` of type `" + he + "` " + ("supplied to `" + oe + "`, expected `object`."));
        for (var Z in L) {
          var se = L[Z];
          if (typeof se != "function")
            return I(oe, ie, le, Z, V(se));
          var ae = se(ce, Z, oe, ie, le + "." + Z, r);
          if (ae)
            return ae;
        }
        return null;
      }
      return f(z);
    }
    function _(L) {
      function z(j, U, oe, ie, le) {
        var ce = j[U], he = N(ce);
        if (he !== "object")
          return new m("Invalid " + ie + " `" + le + "` of type `" + he + "` " + ("supplied to `" + oe + "`, expected `object`."));
        var Z = t({}, j[U], L);
        for (var se in Z) {
          var ae = L[se];
          if (i(L, se) && typeof ae != "function")
            return I(oe, ie, le, se, V(ae));
          if (!ae)
            return new m(
              "Invalid " + ie + " `" + le + "` key `" + se + "` supplied to `" + oe + "`.\nBad object: " + JSON.stringify(j[U], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var W = ae(ce, se, oe, ie, le + "." + se, r);
          if (W)
            return W;
        }
        return null;
      }
      return f(z);
    }
    function G(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(G);
          if (L === null || a(L))
            return !0;
          var z = d(L);
          if (z) {
            var j = z.call(L), U;
            if (z !== L.entries) {
              for (; !(U = j.next()).done; )
                if (!G(U.value))
                  return !1;
            } else
              for (; !(U = j.next()).done; ) {
                var oe = U.value;
                if (oe && !G(oe[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function F(L, z) {
      return L === "symbol" ? !0 : z ? z["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && z instanceof Symbol : !1;
    }
    function N(L) {
      var z = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : F(z, L) ? "symbol" : z;
    }
    function V(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var z = N(L);
      if (z === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return z;
    }
    function B(L) {
      var z = V(L);
      switch (z) {
        case "array":
        case "object":
          return "an " + z;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + z;
        default:
          return z;
      }
    }
    function $(L) {
      return !L.constructor || !L.constructor.name ? h : L.constructor.name;
    }
    return p.checkPropTypes = n, p.resetWarningCache = n.resetWarningCache, p.PropTypes = p, p;
  }, Jv;
}
var Qv, cD;
function j6() {
  if (cD) return Qv;
  cD = 1;
  var e = bS();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, Qv = function() {
    function i(s, a, l, u, c, d) {
      if (d !== e) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    i.isRequired = i;
    function n() {
      return i;
    }
    var o = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: n,
      element: i,
      elementType: i,
      instanceOf: n,
      node: i,
      objectOf: n,
      oneOf: n,
      oneOfType: n,
      shape: n,
      exact: n,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, Qv;
}
if (process.env.NODE_ENV !== "production") {
  var z6 = yS, U6 = !0;
  $y.exports = $6()(z6.isElement, U6);
} else
  $y.exports = j6()();
var Y6 = $y.exports;
const lt = /* @__PURE__ */ Ct(Y6);
var X6 = Object.getOwnPropertyNames, K6 = Object.getOwnPropertySymbols, q6 = Object.prototype.hasOwnProperty;
function dD(e, t) {
  return function(i, n, o) {
    return e(i, n, o) && t(i, n, o);
  };
}
function lp(e) {
  return function(r, i, n) {
    if (!r || !i || typeof r != "object" || typeof i != "object")
      return e(r, i, n);
    var o = n.cache, s = o.get(r), a = o.get(i);
    if (s && a)
      return s === i && a === r;
    o.set(r, i), o.set(i, r);
    var l = e(r, i, n);
    return o.delete(r), o.delete(i), l;
  };
}
function hD(e) {
  return X6(e).concat(K6(e));
}
var Z6 = Object.hasOwn || function(e, t) {
  return q6.call(e, t);
};
function Pa(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
var J6 = "__v", Q6 = "__o", eJ = "_owner", pD = Object.getOwnPropertyDescriptor, fD = Object.keys;
function tJ(e, t, r) {
  var i = e.length;
  if (t.length !== i)
    return !1;
  for (; i-- > 0; )
    if (!r.equals(e[i], t[i], i, i, e, t, r))
      return !1;
  return !0;
}
function rJ(e, t) {
  return Pa(e.getTime(), t.getTime());
}
function iJ(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function nJ(e, t) {
  return e === t;
}
function gD(e, t, r) {
  var i = e.size;
  if (i !== t.size)
    return !1;
  if (!i)
    return !0;
  for (var n = new Array(i), o = e.entries(), s, a, l = 0; (s = o.next()) && !s.done; ) {
    for (var u = t.entries(), c = !1, d = 0; (a = u.next()) && !a.done; ) {
      if (n[d]) {
        d++;
        continue;
      }
      var h = s.value, p = a.value;
      if (r.equals(h[0], p[0], l, d, e, t, r) && r.equals(h[1], p[1], h[0], p[0], e, t, r)) {
        c = n[d] = !0;
        break;
      }
      d++;
    }
    if (!c)
      return !1;
    l++;
  }
  return !0;
}
var oJ = Pa;
function sJ(e, t, r) {
  var i = fD(e), n = i.length;
  if (fD(t).length !== n)
    return !1;
  for (; n-- > 0; )
    if (!mM(e, t, r, i[n]))
      return !1;
  return !0;
}
function hc(e, t, r) {
  var i = hD(e), n = i.length;
  if (hD(t).length !== n)
    return !1;
  for (var o, s, a; n-- > 0; )
    if (o = i[n], !mM(e, t, r, o) || (s = pD(e, o), a = pD(t, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function aJ(e, t) {
  return Pa(e.valueOf(), t.valueOf());
}
function lJ(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function mD(e, t, r) {
  var i = e.size;
  if (i !== t.size)
    return !1;
  if (!i)
    return !0;
  for (var n = new Array(i), o = e.values(), s, a; (s = o.next()) && !s.done; ) {
    for (var l = t.values(), u = !1, c = 0; (a = l.next()) && !a.done; ) {
      if (!n[c] && r.equals(s.value, a.value, s.value, a.value, e, t, r)) {
        u = n[c] = !0;
        break;
      }
      c++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function uJ(e, t) {
  var r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function cJ(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function mM(e, t, r, i) {
  return (i === eJ || i === Q6 || i === J6) && (e.$$typeof || t.$$typeof) ? !0 : Z6(t, i) && r.equals(e[i], t[i], i, i, e, t, r);
}
var dJ = "[object Arguments]", hJ = "[object Boolean]", pJ = "[object Date]", fJ = "[object Error]", gJ = "[object Map]", mJ = "[object Number]", vJ = "[object Object]", CJ = "[object RegExp]", yJ = "[object Set]", bJ = "[object String]", wJ = "[object URL]", SJ = Array.isArray, vD = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, CD = Object.assign, EJ = Object.prototype.toString.call.bind(Object.prototype.toString);
function xJ(e) {
  var t = e.areArraysEqual, r = e.areDatesEqual, i = e.areErrorsEqual, n = e.areFunctionsEqual, o = e.areMapsEqual, s = e.areNumbersEqual, a = e.areObjectsEqual, l = e.arePrimitiveWrappersEqual, u = e.areRegExpsEqual, c = e.areSetsEqual, d = e.areTypedArraysEqual, h = e.areUrlsEqual;
  return function(g, m, f) {
    if (g === m)
      return !0;
    if (g == null || m == null)
      return !1;
    var C = typeof g;
    if (C !== typeof m)
      return !1;
    if (C !== "object")
      return C === "number" ? s(g, m, f) : C === "function" ? n(g, m, f) : !1;
    var w = g.constructor;
    if (w !== m.constructor)
      return !1;
    if (w === Object)
      return a(g, m, f);
    if (SJ(g))
      return t(g, m, f);
    if (vD != null && vD(g))
      return d(g, m, f);
    if (w === Date)
      return r(g, m, f);
    if (w === RegExp)
      return u(g, m, f);
    if (w === Map)
      return o(g, m, f);
    if (w === Set)
      return c(g, m, f);
    var E = EJ(g);
    return E === pJ ? r(g, m, f) : E === CJ ? u(g, m, f) : E === gJ ? o(g, m, f) : E === yJ ? c(g, m, f) : E === vJ ? typeof g.then != "function" && typeof m.then != "function" && a(g, m, f) : E === wJ ? h(g, m, f) : E === fJ ? i(g, m, f) : E === dJ ? a(g, m, f) : E === hJ || E === mJ || E === bJ ? l(g, m, f) : !1;
  };
}
function AJ(e) {
  var t = e.circular, r = e.createCustomConfig, i = e.strict, n = {
    areArraysEqual: i ? hc : tJ,
    areDatesEqual: rJ,
    areErrorsEqual: iJ,
    areFunctionsEqual: nJ,
    areMapsEqual: i ? dD(gD, hc) : gD,
    areNumbersEqual: oJ,
    areObjectsEqual: i ? hc : sJ,
    arePrimitiveWrappersEqual: aJ,
    areRegExpsEqual: lJ,
    areSetsEqual: i ? dD(mD, hc) : mD,
    areTypedArraysEqual: i ? hc : uJ,
    areUrlsEqual: cJ
  };
  if (r && (n = CD({}, n, r(n))), t) {
    var o = lp(n.areArraysEqual), s = lp(n.areMapsEqual), a = lp(n.areObjectsEqual), l = lp(n.areSetsEqual);
    n = CD({}, n, {
      areArraysEqual: o,
      areMapsEqual: s,
      areObjectsEqual: a,
      areSetsEqual: l
    });
  }
  return n;
}
function DJ(e) {
  return function(t, r, i, n, o, s, a) {
    return e(t, r, a);
  };
}
function TJ(e) {
  var t = e.circular, r = e.comparator, i = e.createState, n = e.equals, o = e.strict;
  if (i)
    return function(l, u) {
      var c = i(), d = c.cache, h = d === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : d, p = c.meta;
      return r(l, u, {
        cache: h,
        equals: n,
        meta: p,
        strict: o
      });
    };
  if (t)
    return function(l, u) {
      return r(l, u, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: n,
        meta: void 0,
        strict: o
      });
    };
  var s = {
    cache: void 0,
    equals: n,
    meta: void 0,
    strict: o
  };
  return function(l, u) {
    return r(l, u, s);
  };
}
var RJ = ls();
ls({ strict: !0 });
ls({ circular: !0 });
ls({
  circular: !0,
  strict: !0
});
ls({
  createInternalComparator: function() {
    return Pa;
  }
});
ls({
  strict: !0,
  createInternalComparator: function() {
    return Pa;
  }
});
ls({
  circular: !0,
  createInternalComparator: function() {
    return Pa;
  }
});
ls({
  circular: !0,
  createInternalComparator: function() {
    return Pa;
  },
  strict: !0
});
function ls(e) {
  e === void 0 && (e = {});
  var t = e.circular, r = t === void 0 ? !1 : t, i = e.createInternalComparator, n = e.createState, o = e.strict, s = o === void 0 ? !1 : o, a = AJ(e), l = xJ(a), u = i ? i(l) : DJ(l);
  return TJ({ circular: r, comparator: l, createState: n, equals: u, strict: s });
}
function PJ(e) {
  typeof requestAnimationFrame < "u" && requestAnimationFrame(e);
}
function yD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = -1, i = function n(o) {
    r < 0 && (r = o), o - r > t ? (e(o), r = -1) : PJ(n);
  };
  requestAnimationFrame(i);
}
function zy(e) {
  "@babel/helpers - typeof";
  return zy = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zy(e);
}
function IJ(e) {
  return _J(e) || FJ(e) || MJ(e) || OJ();
}
function OJ() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function MJ(e, t) {
  if (e) {
    if (typeof e == "string") return bD(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return bD(e, t);
  }
}
function bD(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function FJ(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function _J(e) {
  if (Array.isArray(e)) return e;
}
function NJ() {
  var e = {}, t = function() {
    return null;
  }, r = !1, i = function n(o) {
    if (!r) {
      if (Array.isArray(o)) {
        if (!o.length)
          return;
        var s = o, a = IJ(s), l = a[0], u = a.slice(1);
        if (typeof l == "number") {
          yD(n.bind(null, u), l);
          return;
        }
        n(l), yD(n.bind(null, u));
        return;
      }
      zy(o) === "object" && (e = o, t(e)), typeof o == "function" && o();
    }
  };
  return {
    stop: function() {
      r = !0;
    },
    start: function(o) {
      r = !1, i(o);
    },
    subscribe: function(o) {
      return t = o, function() {
        t = function() {
          return null;
        };
      };
    }
  };
}
function fd(e) {
  "@babel/helpers - typeof";
  return fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fd(e);
}
function wD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function SD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wD(Object(r), !0).forEach(function(i) {
      vM(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : wD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function vM(e, t, r) {
  return t = LJ(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function LJ(e) {
  var t = GJ(e, "string");
  return fd(t) === "symbol" ? t : String(t);
}
function GJ(e, t) {
  if (fd(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (fd(i) !== "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var kJ = function(t, r) {
  return [Object.keys(t), Object.keys(r)].reduce(function(i, n) {
    return i.filter(function(o) {
      return n.includes(o);
    });
  });
}, VJ = function(t) {
  return t;
}, HJ = function(t) {
  return t.replace(/([A-Z])/g, function(r) {
    return "-".concat(r.toLowerCase());
  });
}, Lc = function(t, r) {
  return Object.keys(r).reduce(function(i, n) {
    return SD(SD({}, i), {}, vM({}, n, t(n, r[n])));
  }, {});
}, ED = function(t, r, i) {
  return t.map(function(n) {
    return "".concat(HJ(n), " ").concat(r, "ms ").concat(i);
  }).join(",");
}, BJ = process.env.NODE_ENV !== "production", If = function(t, r, i, n, o, s, a, l) {
  if (BJ && typeof console < "u" && console.warn && (r === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (r === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var u = [i, n, o, s, a, l], c = 0;
      console.warn(r.replace(/%s/g, function() {
        return u[c++];
      }));
    }
};
function WJ(e, t) {
  return zJ(e) || jJ(e, t) || CM(e, t) || $J();
}
function $J() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jJ(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function zJ(e) {
  if (Array.isArray(e)) return e;
}
function UJ(e) {
  return KJ(e) || XJ(e) || CM(e) || YJ();
}
function YJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function CM(e, t) {
  if (e) {
    if (typeof e == "string") return Uy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Uy(e, t);
  }
}
function XJ(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function KJ(e) {
  if (Array.isArray(e)) return Uy(e);
}
function Uy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
var Of = 1e-4, yM = function(t, r) {
  return [0, 3 * t, 3 * r - 6 * t, 3 * t - 3 * r + 1];
}, bM = function(t, r) {
  return t.map(function(i, n) {
    return i * Math.pow(r, n);
  }).reduce(function(i, n) {
    return i + n;
  });
}, xD = function(t, r) {
  return function(i) {
    var n = yM(t, r);
    return bM(n, i);
  };
}, qJ = function(t, r) {
  return function(i) {
    var n = yM(t, r), o = [].concat(UJ(n.map(function(s, a) {
      return s * a;
    }).slice(1)), [0]);
    return bM(o, i);
  };
}, AD = function() {
  for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
    r[i] = arguments[i];
  var n = r[0], o = r[1], s = r[2], a = r[3];
  if (r.length === 1)
    switch (r[0]) {
      case "linear":
        n = 0, o = 0, s = 1, a = 1;
        break;
      case "ease":
        n = 0.25, o = 0.1, s = 0.25, a = 1;
        break;
      case "ease-in":
        n = 0.42, o = 0, s = 1, a = 1;
        break;
      case "ease-out":
        n = 0.42, o = 0, s = 0.58, a = 1;
        break;
      case "ease-in-out":
        n = 0, o = 0, s = 0.58, a = 1;
        break;
      default: {
        var l = r[0].split("(");
        if (l[0] === "cubic-bezier" && l[1].split(")")[0].split(",").length === 4) {
          var u = l[1].split(")")[0].split(",").map(function(f) {
            return parseFloat(f);
          }), c = WJ(u, 4);
          n = c[0], o = c[1], s = c[2], a = c[3];
        } else
          If(!1, "[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", r);
      }
    }
  If([n, s, o, a].every(function(f) {
    return typeof f == "number" && f >= 0 && f <= 1;
  }), "[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s", r);
  var d = xD(n, s), h = xD(o, a), p = qJ(n, s), g = function(C) {
    return C > 1 ? 1 : C < 0 ? 0 : C;
  }, m = function(C) {
    for (var w = C > 1 ? 1 : C, E = w, b = 0; b < 8; ++b) {
      var y = d(E) - w, S = p(E);
      if (Math.abs(y - w) < Of || S < Of)
        return h(E);
      E = g(E - y / S);
    }
    return h(E);
  };
  return m.isStepper = !1, m;
}, ZJ = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = t.stiff, i = r === void 0 ? 100 : r, n = t.damping, o = n === void 0 ? 8 : n, s = t.dt, a = s === void 0 ? 17 : s, l = function(c, d, h) {
    var p = -(c - d) * i, g = h * o, m = h + (p - g) * a / 1e3, f = h * a / 1e3 + c;
    return Math.abs(f - d) < Of && Math.abs(m) < Of ? [d, 0] : [f, m];
  };
  return l.isStepper = !0, l.dt = a, l;
}, JJ = function() {
  for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
    r[i] = arguments[i];
  var n = r[0];
  if (typeof n == "string")
    switch (n) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return AD(n);
      case "spring":
        return ZJ();
      default:
        if (n.split("(")[0] === "cubic-bezier")
          return AD(n);
        If(!1, "[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", r);
    }
  return typeof n == "function" ? n : (If(!1, "[configEasing]: first argument type should be function or string, instead received %s", r), null);
};
function gd(e) {
  "@babel/helpers - typeof";
  return gd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gd(e);
}
function DD(e) {
  return t8(e) || e8(e) || wM(e) || QJ();
}
function QJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function e8(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function t8(e) {
  if (Array.isArray(e)) return Xy(e);
}
function TD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TD(Object(r), !0).forEach(function(i) {
      Yy(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : TD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Yy(e, t, r) {
  return t = r8(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function r8(e) {
  var t = i8(e, "string");
  return gd(t) === "symbol" ? t : String(t);
}
function i8(e, t) {
  if (gd(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (gd(i) !== "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function n8(e, t) {
  return a8(e) || s8(e, t) || wM(e, t) || o8();
}
function o8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function wM(e, t) {
  if (e) {
    if (typeof e == "string") return Xy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Xy(e, t);
  }
}
function Xy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function s8(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function a8(e) {
  if (Array.isArray(e)) return e;
}
var Mf = function(t, r, i) {
  return t + (r - t) * i;
}, Ky = function(t) {
  var r = t.from, i = t.to;
  return r !== i;
}, l8 = function e(t, r, i) {
  var n = Lc(function(o, s) {
    if (Ky(s)) {
      var a = t(s.from, s.to, s.velocity), l = n8(a, 2), u = l[0], c = l[1];
      return wr(wr({}, s), {}, {
        from: u,
        velocity: c
      });
    }
    return s;
  }, r);
  return i < 1 ? Lc(function(o, s) {
    return Ky(s) ? wr(wr({}, s), {}, {
      velocity: Mf(s.velocity, n[o].velocity, i),
      from: Mf(s.from, n[o].from, i)
    }) : s;
  }, r) : e(t, n, i - 1);
};
const u8 = function(e, t, r, i, n) {
  var o = kJ(e, t), s = o.reduce(function(f, C) {
    return wr(wr({}, f), {}, Yy({}, C, [e[C], t[C]]));
  }, {}), a = o.reduce(function(f, C) {
    return wr(wr({}, f), {}, Yy({}, C, {
      from: e[C],
      velocity: 0,
      to: t[C]
    }));
  }, {}), l = -1, u, c, d = function() {
    return null;
  }, h = function() {
    return Lc(function(C, w) {
      return w.from;
    }, a);
  }, p = function() {
    return !Object.values(a).filter(Ky).length;
  }, g = function(C) {
    u || (u = C);
    var w = C - u, E = w / r.dt;
    a = l8(r, a, E), n(wr(wr(wr({}, e), t), h())), u = C, p() || (l = requestAnimationFrame(d));
  }, m = function(C) {
    c || (c = C);
    var w = (C - c) / i, E = Lc(function(y, S) {
      return Mf.apply(void 0, DD(S).concat([r(w)]));
    }, s);
    if (n(wr(wr(wr({}, e), t), E)), w < 1)
      l = requestAnimationFrame(d);
    else {
      var b = Lc(function(y, S) {
        return Mf.apply(void 0, DD(S).concat([r(1)]));
      }, s);
      n(wr(wr(wr({}, e), t), b));
    }
  };
  return d = r.isStepper ? g : m, function() {
    return requestAnimationFrame(d), function() {
      cancelAnimationFrame(l);
    };
  };
};
function Ol(e) {
  "@babel/helpers - typeof";
  return Ol = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ol(e);
}
var c8 = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
function d8(e, t) {
  if (e == null) return {};
  var r = h8(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function h8(e, t) {
  if (e == null) return {};
  var r = {}, i = Object.keys(e), n, o;
  for (o = 0; o < i.length; o++)
    n = i[o], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
  return r;
}
function eC(e) {
  return m8(e) || g8(e) || f8(e) || p8();
}
function p8() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function f8(e, t) {
  if (e) {
    if (typeof e == "string") return qy(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return qy(e, t);
  }
}
function g8(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function m8(e) {
  if (Array.isArray(e)) return qy(e);
}
function qy(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function RD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function en(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RD(Object(r), !0).forEach(function(i) {
      Ec(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : RD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Ec(e, t, r) {
  return t = SM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function v8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function C8(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, SM(i.key), i);
  }
}
function y8(e, t, r) {
  return t && C8(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function SM(e) {
  var t = b8(e, "string");
  return Ol(t) === "symbol" ? t : String(t);
}
function b8(e, t) {
  if (Ol(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ol(i) !== "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function w8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Zy(e, t);
}
function Zy(e, t) {
  return Zy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Zy(e, t);
}
function S8(e) {
  var t = E8();
  return function() {
    var i = Ff(e), n;
    if (t) {
      var o = Ff(this).constructor;
      n = Reflect.construct(i, arguments, o);
    } else
      n = i.apply(this, arguments);
    return Jy(this, n);
  };
}
function Jy(e, t) {
  if (t && (Ol(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Qy(e);
}
function Qy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function E8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ff(e) {
  return Ff = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Ff(e);
}
var $n = /* @__PURE__ */ function(e) {
  w8(r, e);
  var t = S8(r);
  function r(i, n) {
    var o;
    v8(this, r), o = t.call(this, i, n);
    var s = o.props, a = s.isActive, l = s.attributeName, u = s.from, c = s.to, d = s.steps, h = s.children, p = s.duration;
    if (o.handleStyleChange = o.handleStyleChange.bind(Qy(o)), o.changeStyle = o.changeStyle.bind(Qy(o)), !a || p <= 0)
      return o.state = {
        style: {}
      }, typeof h == "function" && (o.state = {
        style: c
      }), Jy(o);
    if (d && d.length)
      o.state = {
        style: d[0].style
      };
    else if (u) {
      if (typeof h == "function")
        return o.state = {
          style: u
        }, Jy(o);
      o.state = {
        style: l ? Ec({}, l, u) : u
      };
    } else
      o.state = {
        style: {}
      };
    return o;
  }
  return y8(r, [{
    key: "componentDidMount",
    value: function() {
      var n = this.props, o = n.isActive, s = n.canBegin;
      this.mounted = !0, !(!o || !s) && this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function(n) {
      var o = this.props, s = o.isActive, a = o.canBegin, l = o.attributeName, u = o.shouldReAnimate, c = o.to, d = o.from, h = this.state.style;
      if (a) {
        if (!s) {
          var p = {
            style: l ? Ec({}, l, c) : c
          };
          this.state && h && (l && h[l] !== c || !l && h !== c) && this.setState(p);
          return;
        }
        if (!(RJ(n.to, c) && n.canBegin && n.isActive)) {
          var g = !n.canBegin || !n.isActive;
          this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();
          var m = g || u ? d : n.to;
          if (this.state && h) {
            var f = {
              style: l ? Ec({}, l, m) : m
            };
            (l && h[l] !== m || !l && h !== m) && this.setState(f);
          }
          this.runAnimation(en(en({}, this.props), {}, {
            from: m,
            begin: 0
          }));
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.mounted = !1;
      var n = this.props.onAnimationEnd;
      this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), n && n();
    }
  }, {
    key: "handleStyleChange",
    value: function(n) {
      this.changeStyle(n);
    }
  }, {
    key: "changeStyle",
    value: function(n) {
      this.mounted && this.setState({
        style: n
      });
    }
  }, {
    key: "runJSAnimation",
    value: function(n) {
      var o = this, s = n.from, a = n.to, l = n.duration, u = n.easing, c = n.begin, d = n.onAnimationEnd, h = n.onAnimationStart, p = u8(s, a, JJ(u), l, this.changeStyle), g = function() {
        o.stopJSAnimation = p();
      };
      this.manager.start([h, c, g, l, d]);
    }
  }, {
    key: "runStepAnimation",
    value: function(n) {
      var o = this, s = n.steps, a = n.begin, l = n.onAnimationStart, u = s[0], c = u.style, d = u.duration, h = d === void 0 ? 0 : d, p = function(m, f, C) {
        if (C === 0)
          return m;
        var w = f.duration, E = f.easing, b = E === void 0 ? "ease" : E, y = f.style, S = f.properties, x = f.onAnimationEnd, R = C > 0 ? s[C - 1] : f, P = S || Object.keys(y);
        if (typeof b == "function" || b === "spring")
          return [].concat(eC(m), [o.runJSAnimation.bind(o, {
            from: R.style,
            to: y,
            duration: w,
            easing: b
          }), w]);
        var O = ED(P, w, b), I = en(en(en({}, R.style), y), {}, {
          transition: O
        });
        return [].concat(eC(m), [I, w, x]).filter(VJ);
      };
      return this.manager.start([l].concat(eC(s.reduce(p, [c, Math.max(h, a)])), [n.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function(n) {
      this.manager || (this.manager = NJ());
      var o = n.begin, s = n.duration, a = n.attributeName, l = n.to, u = n.easing, c = n.onAnimationStart, d = n.onAnimationEnd, h = n.steps, p = n.children, g = this.manager;
      if (this.unSubscribe = g.subscribe(this.handleStyleChange), typeof u == "function" || typeof p == "function" || u === "spring") {
        this.runJSAnimation(n);
        return;
      }
      if (h.length > 1) {
        this.runStepAnimation(n);
        return;
      }
      var m = a ? Ec({}, a, l) : l, f = ED(Object.keys(m), s, u);
      g.start([c, o, en(en({}, m), {}, {
        transition: f
      }), s, d]);
    }
  }, {
    key: "render",
    value: function() {
      var n = this.props, o = n.children;
      n.begin;
      var s = n.duration;
      n.attributeName, n.easing;
      var a = n.isActive;
      n.steps, n.from, n.to, n.canBegin, n.onAnimationEnd, n.shouldReAnimate, n.onAnimationReStart;
      var l = d8(n, c8), u = Ws.count(o), c = this.state.style;
      if (typeof o == "function")
        return o(c);
      if (!a || u === 0 || s <= 0)
        return o;
      var d = function(p) {
        var g = p.props, m = g.style, f = m === void 0 ? {} : m, C = g.className, w = /* @__PURE__ */ Gt(p, en(en({}, l), {}, {
          style: en(en({}, f), c),
          className: C
        }));
        return w;
      };
      return u === 1 ? d(Ws.only(o)) : /* @__PURE__ */ D.createElement("div", null, Ws.map(o, function(h) {
        return d(h);
      }));
    }
  }]), r;
}(vn);
$n.displayName = "Animate";
$n.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  steps: [],
  onAnimationEnd: function() {
  },
  onAnimationStart: function() {
  }
};
$n.propTypes = {
  from: lt.oneOfType([lt.object, lt.string]),
  to: lt.oneOfType([lt.object, lt.string]),
  attributeName: lt.string,
  // animation duration
  duration: lt.number,
  begin: lt.number,
  easing: lt.oneOfType([lt.string, lt.func]),
  steps: lt.arrayOf(lt.shape({
    duration: lt.number.isRequired,
    style: lt.object.isRequired,
    easing: lt.oneOfType([lt.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), lt.func]),
    // transition css properties(dash case), optional
    properties: lt.arrayOf("string"),
    onAnimationEnd: lt.func
  })),
  children: lt.oneOfType([lt.node, lt.func]),
  isActive: lt.bool,
  canBegin: lt.bool,
  onAnimationEnd: lt.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: lt.bool,
  onAnimationStart: lt.func,
  onAnimationReStart: lt.func
};
function Fe() {
  return Fe = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r) ({}).hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Fe.apply(null, arguments);
}
function x8(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    r[i] = e[i];
  }
  return r;
}
function eb(e, t) {
  return eb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, eb(e, t);
}
function A8(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function md(e) {
  "@babel/helpers - typeof";
  return md = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, md(e);
}
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function D8(e, t) {
  return I8(e) || P8(e, t) || R8(e, t) || T8();
}
function T8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function R8(e, t) {
  if (e) {
    if (typeof e == "string") return PD(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return PD(e, t);
  }
}
function PD(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function P8(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function I8(e) {
  if (Array.isArray(e)) return e;
}
function ID(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function OD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ID(Object(r), !0).forEach(function(i) {
      O8(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ID(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function O8(e, t, r) {
  return t = M8(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function M8(e) {
  var t = F8(e, "string");
  return md(t) == "symbol" ? t : t + "";
}
function F8(e, t) {
  if (md(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (md(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var MD = function(t, r, i, n, o) {
  var s = Math.min(Math.abs(i) / 2, Math.abs(n) / 2), a = n >= 0 ? 1 : -1, l = i >= 0 ? 1 : -1, u = n >= 0 && i >= 0 || n < 0 && i < 0 ? 1 : 0, c;
  if (s > 0 && o instanceof Array) {
    for (var d = [0, 0, 0, 0], h = 0, p = 4; h < p; h++)
      d[h] = o[h] > s ? s : o[h];
    c = "M".concat(t, ",").concat(r + a * d[0]), d[0] > 0 && (c += "A ".concat(d[0], ",").concat(d[0], ",0,0,").concat(u, ",").concat(t + l * d[0], ",").concat(r)), c += "L ".concat(t + i - l * d[1], ",").concat(r), d[1] > 0 && (c += "A ".concat(d[1], ",").concat(d[1], ",0,0,").concat(u, `,
        `).concat(t + i, ",").concat(r + a * d[1])), c += "L ".concat(t + i, ",").concat(r + n - a * d[2]), d[2] > 0 && (c += "A ".concat(d[2], ",").concat(d[2], ",0,0,").concat(u, `,
        `).concat(t + i - l * d[2], ",").concat(r + n)), c += "L ".concat(t + l * d[3], ",").concat(r + n), d[3] > 0 && (c += "A ".concat(d[3], ",").concat(d[3], ",0,0,").concat(u, `,
        `).concat(t, ",").concat(r + n - a * d[3])), c += "Z";
  } else if (s > 0 && o === +o && o > 0) {
    var g = Math.min(s, o);
    c = "M ".concat(t, ",").concat(r + a * g, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(t + l * g, ",").concat(r, `
            L `).concat(t + i - l * g, ",").concat(r, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(t + i, ",").concat(r + a * g, `
            L `).concat(t + i, ",").concat(r + n - a * g, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(t + i - l * g, ",").concat(r + n, `
            L `).concat(t + l * g, ",").concat(r + n, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(t, ",").concat(r + n - a * g, " Z");
  } else
    c = "M ".concat(t, ",").concat(r, " h ").concat(i, " v ").concat(n, " h ").concat(-i, " Z");
  return c;
}, _8 = function(t, r) {
  if (!t || !r)
    return !1;
  var i = t.x, n = t.y, o = r.x, s = r.y, a = r.width, l = r.height;
  if (Math.abs(a) > 0 && Math.abs(l) > 0) {
    var u = Math.min(o, o + a), c = Math.max(o, o + a), d = Math.min(s, s + l), h = Math.max(s, s + l);
    return i >= u && i <= c && n >= d && n <= h;
  }
  return !1;
}, N8 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, wS = function(t) {
  var r = OD(OD({}, N8), t), i = re(), n = ee(-1), o = D8(n, 2), s = o[0], a = o[1];
  gt(function() {
    if (i.current && i.current.getTotalLength)
      try {
        var b = i.current.getTotalLength();
        b && a(b);
      } catch {
      }
  }, []);
  var l = r.x, u = r.y, c = r.width, d = r.height, h = r.radius, p = r.className, g = r.animationEasing, m = r.animationDuration, f = r.animationBegin, C = r.isAnimationActive, w = r.isUpdateAnimationActive;
  if (l !== +l || u !== +u || c !== +c || d !== +d || c === 0 || d === 0)
    return null;
  var E = xe("recharts-rectangle", p);
  return w ? /* @__PURE__ */ D.createElement($n, {
    canBegin: s > 0,
    from: {
      width: c,
      height: d,
      x: l,
      y: u
    },
    to: {
      width: c,
      height: d,
      x: l,
      y: u
    },
    duration: m,
    animationEasing: g,
    isActive: w
  }, function(b) {
    var y = b.width, S = b.height, x = b.x, R = b.y;
    return /* @__PURE__ */ D.createElement($n, {
      canBegin: s > 0,
      from: "0px ".concat(s === -1 ? 1 : s, "px"),
      to: "".concat(s, "px 0px"),
      attributeName: "strokeDasharray",
      begin: f,
      duration: m,
      isActive: C,
      easing: g
    }, /* @__PURE__ */ D.createElement("path", _f({}, Ie(r, !0), {
      className: E,
      d: MD(x, R, y, S, h),
      ref: i
    })));
  }) : /* @__PURE__ */ D.createElement("path", _f({}, Ie(r, !0), {
    className: E,
    d: MD(l, u, c, d, h)
  }));
}, L8 = ["points", "className", "baseLinePoints", "connectNulls"];
function al() {
  return al = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, al.apply(this, arguments);
}
function G8(e, t) {
  if (e == null) return {};
  var r = k8(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function k8(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function FD(e) {
  return W8(e) || B8(e) || H8(e) || V8();
}
function V8() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function H8(e, t) {
  if (e) {
    if (typeof e == "string") return tb(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return tb(e, t);
  }
}
function B8(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function W8(e) {
  if (Array.isArray(e)) return tb(e);
}
function tb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
var _D = function(t) {
  return t && t.x === +t.x && t.y === +t.y;
}, $8 = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], r = [[]];
  return t.forEach(function(i) {
    _D(i) ? r[r.length - 1].push(i) : r[r.length - 1].length > 0 && r.push([]);
  }), _D(t[0]) && r[r.length - 1].push(t[0]), r[r.length - 1].length <= 0 && (r = r.slice(0, -1)), r;
}, Gc = function(t, r) {
  var i = $8(t);
  r && (i = [i.reduce(function(o, s) {
    return [].concat(FD(o), FD(s));
  }, [])]);
  var n = i.map(function(o) {
    return o.reduce(function(s, a, l) {
      return "".concat(s).concat(l === 0 ? "M" : "L").concat(a.x, ",").concat(a.y);
    }, "");
  }).join("");
  return i.length === 1 ? "".concat(n, "Z") : n;
}, j8 = function(t, r, i) {
  var n = Gc(t, i);
  return "".concat(n.slice(-1) === "Z" ? n.slice(0, -1) : n, "L").concat(Gc(r.reverse(), i).slice(1));
}, z8 = function(t) {
  var r = t.points, i = t.className, n = t.baseLinePoints, o = t.connectNulls, s = G8(t, L8);
  if (!r || !r.length)
    return null;
  var a = xe("recharts-polygon", i);
  if (n && n.length) {
    var l = s.stroke && s.stroke !== "none", u = j8(r, n, o);
    return /* @__PURE__ */ D.createElement("g", {
      className: a
    }, /* @__PURE__ */ D.createElement("path", al({}, Ie(s, !0), {
      fill: u.slice(-1) === "Z" ? s.fill : "none",
      stroke: "none",
      d: u
    })), l ? /* @__PURE__ */ D.createElement("path", al({}, Ie(s, !0), {
      fill: "none",
      d: Gc(r, o)
    })) : null, l ? /* @__PURE__ */ D.createElement("path", al({}, Ie(s, !0), {
      fill: "none",
      d: Gc(n, o)
    })) : null);
  }
  var c = Gc(r, o);
  return /* @__PURE__ */ D.createElement("path", al({}, Ie(s, !0), {
    fill: c.slice(-1) === "Z" ? s.fill : "none",
    className: a,
    d: c
  }));
};
function rb() {
  return rb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, rb.apply(this, arguments);
}
var gm = function(t) {
  var r = t.cx, i = t.cy, n = t.r, o = t.className, s = xe("recharts-dot", o);
  return r === +r && i === +i && n === +n ? /* @__PURE__ */ Y.createElement("circle", rb({}, Ie(t, !1), Jp(t), {
    className: s,
    cx: r,
    cy: i,
    r: n
  })) : null;
};
function vd(e) {
  "@babel/helpers - typeof";
  return vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, vd(e);
}
var U8 = ["x", "y", "top", "left", "width", "height", "className"];
function ib() {
  return ib = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ib.apply(this, arguments);
}
function ND(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Y8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ND(Object(r), !0).forEach(function(i) {
      X8(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ND(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function X8(e, t, r) {
  return t = K8(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function K8(e) {
  var t = q8(e, "string");
  return vd(t) == "symbol" ? t : t + "";
}
function q8(e, t) {
  if (vd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (vd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Z8(e, t) {
  if (e == null) return {};
  var r = J8(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function J8(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
var Q8 = function(t, r, i, n, o, s) {
  return "M".concat(t, ",").concat(o, "v").concat(n, "M").concat(s, ",").concat(r, "h").concat(i);
}, eQ = function(t) {
  var r = t.x, i = r === void 0 ? 0 : r, n = t.y, o = n === void 0 ? 0 : n, s = t.top, a = s === void 0 ? 0 : s, l = t.left, u = l === void 0 ? 0 : l, c = t.width, d = c === void 0 ? 0 : c, h = t.height, p = h === void 0 ? 0 : h, g = t.className, m = Z8(t, U8), f = Y8({
    x: i,
    y: o,
    top: a,
    left: u,
    width: d,
    height: p
  }, m);
  return !ue(i) || !ue(o) || !ue(d) || !ue(p) || !ue(a) || !ue(u) ? null : /* @__PURE__ */ D.createElement("path", ib({}, Ie(f, !0), {
    className: xe("recharts-cross", g),
    d: Q8(i, o, d, p, a, u)
  }));
}, tQ = cm, rQ = LO, iQ = Jn;
function nQ(e, t) {
  return e && e.length ? tQ(e, iQ(t), rQ) : void 0;
}
var oQ = nQ;
const sQ = /* @__PURE__ */ Ct(oQ);
var aQ = cm, lQ = Jn, uQ = GO;
function cQ(e, t) {
  return e && e.length ? aQ(e, lQ(t), uQ) : void 0;
}
var dQ = cQ;
const hQ = /* @__PURE__ */ Ct(dQ);
var pQ = ["cx", "cy", "angle", "ticks", "axisLine"], fQ = ["ticks", "tick", "angle", "tickFormatter", "stroke"];
function Ml(e) {
  "@babel/helpers - typeof";
  return Ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ml(e);
}
function kc() {
  return kc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, kc.apply(this, arguments);
}
function LD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Ss(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LD(Object(r), !0).forEach(function(i) {
      mm(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : LD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function GD(e, t) {
  if (e == null) return {};
  var r = gQ(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function gQ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function mQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kD(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, xM(i.key), i);
  }
}
function vQ(e, t, r) {
  return t && kD(e.prototype, t), r && kD(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function CQ(e, t, r) {
  return t = Nf(t), yQ(e, EM() ? Reflect.construct(t, r || [], Nf(e).constructor) : t.apply(e, r));
}
function yQ(e, t) {
  if (t && (Ml(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return bQ(e);
}
function bQ(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function EM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (EM = function() {
    return !!e;
  })();
}
function Nf(e) {
  return Nf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Nf(e);
}
function wQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && nb(e, t);
}
function nb(e, t) {
  return nb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, nb(e, t);
}
function mm(e, t, r) {
  return t = xM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function xM(e) {
  var t = SQ(e, "string");
  return Ml(t) == "symbol" ? t : t + "";
}
function SQ(e, t) {
  if (Ml(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ml(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var vm = /* @__PURE__ */ function(e) {
  function t() {
    return mQ(this, t), CQ(this, t, arguments);
  }
  return wQ(t, e), vQ(t, [{
    key: "getTickValueCoord",
    value: (
      /**
       * Calculate the coordinate of tick
       * @param  {Number} coordinate The radius of tick
       * @return {Object} (x, y)
       */
      function(i) {
        var n = i.coordinate, o = this.props, s = o.angle, a = o.cx, l = o.cy;
        return At(a, l, n, s);
      }
    )
  }, {
    key: "getTickTextAnchor",
    value: function() {
      var i = this.props.orientation, n;
      switch (i) {
        case "left":
          n = "end";
          break;
        case "right":
          n = "start";
          break;
        default:
          n = "middle";
          break;
      }
      return n;
    }
  }, {
    key: "getViewBox",
    value: function() {
      var i = this.props, n = i.cx, o = i.cy, s = i.angle, a = i.ticks, l = sQ(a, function(c) {
        return c.coordinate || 0;
      }), u = hQ(a, function(c) {
        return c.coordinate || 0;
      });
      return {
        cx: n,
        cy: o,
        startAngle: s,
        endAngle: s,
        innerRadius: u.coordinate || 0,
        outerRadius: l.coordinate || 0
      };
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var i = this.props, n = i.cx, o = i.cy, s = i.angle, a = i.ticks, l = i.axisLine, u = GD(i, pQ), c = a.reduce(function(g, m) {
        return [Math.min(g[0], m.coordinate), Math.max(g[1], m.coordinate)];
      }, [1 / 0, -1 / 0]), d = At(n, o, c[0], s), h = At(n, o, c[1], s), p = Ss(Ss(Ss({}, Ie(u, !1)), {}, {
        fill: "none"
      }, Ie(l, !1)), {}, {
        x1: d.x,
        y1: d.y,
        x2: h.x,
        y2: h.y
      });
      return /* @__PURE__ */ D.createElement("line", kc({
        className: "recharts-polar-radius-axis-line"
      }, p));
    }
  }, {
    key: "renderTicks",
    value: function() {
      var i = this, n = this.props, o = n.ticks, s = n.tick, a = n.angle, l = n.tickFormatter, u = n.stroke, c = GD(n, fQ), d = this.getTickTextAnchor(), h = Ie(c, !1), p = Ie(s, !1), g = o.map(function(m, f) {
        var C = i.getTickValueCoord(m), w = Ss(Ss(Ss(Ss({
          textAnchor: d,
          transform: "rotate(".concat(90 - a, ", ").concat(C.x, ", ").concat(C.y, ")")
        }, h), {}, {
          stroke: "none",
          fill: u
        }, p), {}, {
          index: f
        }, C), {}, {
          payload: m
        });
        return /* @__PURE__ */ D.createElement(Ze, kc({
          className: xe("recharts-polar-radius-axis-tick", dM(s)),
          key: "tick-".concat(m.coordinate)
        }, na(i.props, m, f)), t.renderTickItem(s, w, l ? l(m.value, f) : m.value));
      });
      return /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-polar-radius-axis-ticks"
      }, g);
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, n = i.ticks, o = i.axisLine, s = i.tick;
      return !n || !n.length ? null : /* @__PURE__ */ D.createElement(Ze, {
        className: xe("recharts-polar-radius-axis", this.props.className)
      }, o && this.renderAxisLine(), s && this.renderTicks(), gr.renderCallByParent(this.props, this.getViewBox()));
    }
  }], [{
    key: "renderTickItem",
    value: function(i, n, o) {
      var s;
      return /* @__PURE__ */ D.isValidElement(i) ? s = /* @__PURE__ */ D.cloneElement(i, n) : Le(i) ? s = i(n) : s = /* @__PURE__ */ D.createElement(oa, kc({}, n, {
        className: "recharts-polar-radius-axis-tick-value"
      }), o), s;
    }
  }]);
}(vn);
mm(vm, "displayName", "PolarRadiusAxis");
mm(vm, "axisType", "radiusAxis");
mm(vm, "defaultProps", {
  type: "number",
  radiusAxisId: 0,
  cx: 0,
  cy: 0,
  angle: 0,
  orientation: "right",
  stroke: "#ccc",
  axisLine: !0,
  tick: !0,
  tickCount: 5,
  allowDataOverflow: !1,
  scale: "auto",
  allowDuplicatedCategory: !0
});
function Fl(e) {
  "@babel/helpers - typeof";
  return Fl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fl(e);
}
function Ms() {
  return Ms = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Ms.apply(this, arguments);
}
function VD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Es(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VD(Object(r), !0).forEach(function(i) {
      Cm(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : VD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function EQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HD(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, DM(i.key), i);
  }
}
function xQ(e, t, r) {
  return t && HD(e.prototype, t), r && HD(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function AQ(e, t, r) {
  return t = Lf(t), DQ(e, AM() ? Reflect.construct(t, r || [], Lf(e).constructor) : t.apply(e, r));
}
function DQ(e, t) {
  if (t && (Fl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return TQ(e);
}
function TQ(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function AM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (AM = function() {
    return !!e;
  })();
}
function Lf(e) {
  return Lf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Lf(e);
}
function RQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ob(e, t);
}
function ob(e, t) {
  return ob = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, ob(e, t);
}
function Cm(e, t, r) {
  return t = DM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function DM(e) {
  var t = PQ(e, "string");
  return Fl(t) == "symbol" ? t : t + "";
}
function PQ(e, t) {
  if (Fl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Fl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var IQ = Math.PI / 180, BD = 1e-5, ym = /* @__PURE__ */ function(e) {
  function t() {
    return EQ(this, t), AQ(this, t, arguments);
  }
  return RQ(t, e), xQ(t, [{
    key: "getTickLineCoord",
    value: (
      /**
       * Calculate the coordinate of line endpoint
       * @param  {Object} data The Data if ticks
       * @return {Object} (x0, y0): The start point of text,
       *                  (x1, y1): The end point close to text,
       *                  (x2, y2): The end point close to axis
       */
      function(i) {
        var n = this.props, o = n.cx, s = n.cy, a = n.radius, l = n.orientation, u = n.tickSize, c = u || 8, d = At(o, s, a, i.coordinate), h = At(o, s, a + (l === "inner" ? -1 : 1) * c, i.coordinate);
        return {
          x1: d.x,
          y1: d.y,
          x2: h.x,
          y2: h.y
        };
      }
    )
    /**
     * Get the text-anchor of each tick
     * @param  {Object} data Data of ticks
     * @return {String} text-anchor
     */
  }, {
    key: "getTickTextAnchor",
    value: function(i) {
      var n = this.props.orientation, o = Math.cos(-i.coordinate * IQ), s;
      return o > BD ? s = n === "outer" ? "start" : "end" : o < -BD ? s = n === "outer" ? "end" : "start" : s = "middle", s;
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var i = this.props, n = i.cx, o = i.cy, s = i.radius, a = i.axisLine, l = i.axisLineType, u = Es(Es({}, Ie(this.props, !1)), {}, {
        fill: "none"
      }, Ie(a, !1));
      if (l === "circle")
        return /* @__PURE__ */ D.createElement(gm, Ms({
          className: "recharts-polar-angle-axis-line"
        }, u, {
          cx: n,
          cy: o,
          r: s
        }));
      var c = this.props.ticks, d = c.map(function(h) {
        return At(n, o, s, h.coordinate);
      });
      return /* @__PURE__ */ D.createElement(z8, Ms({
        className: "recharts-polar-angle-axis-line"
      }, u, {
        points: d
      }));
    }
  }, {
    key: "renderTicks",
    value: function() {
      var i = this, n = this.props, o = n.ticks, s = n.tick, a = n.tickLine, l = n.tickFormatter, u = n.stroke, c = Ie(this.props, !1), d = Ie(s, !1), h = Es(Es({}, c), {}, {
        fill: "none"
      }, Ie(a, !1)), p = o.map(function(g, m) {
        var f = i.getTickLineCoord(g), C = i.getTickTextAnchor(g), w = Es(Es(Es({
          textAnchor: C
        }, c), {}, {
          stroke: "none",
          fill: u
        }, d), {}, {
          index: m,
          payload: g,
          x: f.x2,
          y: f.y2
        });
        return /* @__PURE__ */ D.createElement(Ze, Ms({
          className: xe("recharts-polar-angle-axis-tick", dM(s)),
          key: "tick-".concat(g.coordinate)
        }, na(i.props, g, m)), a && /* @__PURE__ */ D.createElement("line", Ms({
          className: "recharts-polar-angle-axis-tick-line"
        }, h, f)), s && t.renderTickItem(s, w, l ? l(g.value, m) : g.value));
      });
      return /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-polar-angle-axis-ticks"
      }, p);
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, n = i.ticks, o = i.radius, s = i.axisLine;
      return o <= 0 || !n || !n.length ? null : /* @__PURE__ */ D.createElement(Ze, {
        className: xe("recharts-polar-angle-axis", this.props.className)
      }, s && this.renderAxisLine(), this.renderTicks());
    }
  }], [{
    key: "renderTickItem",
    value: function(i, n, o) {
      var s;
      return /* @__PURE__ */ D.isValidElement(i) ? s = /* @__PURE__ */ D.cloneElement(i, n) : Le(i) ? s = i(n) : s = /* @__PURE__ */ D.createElement(oa, Ms({}, n, {
        className: "recharts-polar-angle-axis-tick-value"
      }), o), s;
    }
  }]);
}(vn);
Cm(ym, "displayName", "PolarAngleAxis");
Cm(ym, "axisType", "angleAxis");
Cm(ym, "defaultProps", {
  type: "category",
  angleAxisId: 0,
  scale: "auto",
  cx: 0,
  cy: 0,
  orientation: "outer",
  axisLine: !0,
  tickLine: !0,
  tickSize: 8,
  tick: !0,
  hide: !1,
  allowDuplicatedCategory: !0
});
var OQ = MI, MQ = OQ(Object.getPrototypeOf, Object), FQ = MQ, _Q = Do, NQ = FQ, LQ = To, GQ = "[object Object]", kQ = Function.prototype, VQ = Object.prototype, TM = kQ.toString, HQ = VQ.hasOwnProperty, BQ = TM.call(Object);
function WQ(e) {
  if (!LQ(e) || _Q(e) != GQ)
    return !1;
  var t = NQ(e);
  if (t === null)
    return !0;
  var r = HQ.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r instanceof r && TM.call(r) == BQ;
}
var $Q = WQ;
const jQ = /* @__PURE__ */ Ct($Q);
var zQ = Do, UQ = To, YQ = "[object Boolean]";
function XQ(e) {
  return e === !0 || e === !1 || UQ(e) && zQ(e) == YQ;
}
var KQ = XQ;
const qQ = /* @__PURE__ */ Ct(KQ);
function Cd(e) {
  "@babel/helpers - typeof";
  return Cd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Cd(e);
}
function Gf() {
  return Gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Gf.apply(this, arguments);
}
function ZQ(e, t) {
  return t7(e) || e7(e, t) || QQ(e, t) || JQ();
}
function JQ() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QQ(e, t) {
  if (e) {
    if (typeof e == "string") return WD(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return WD(e, t);
  }
}
function WD(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function e7(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function t7(e) {
  if (Array.isArray(e)) return e;
}
function $D(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function jD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $D(Object(r), !0).forEach(function(i) {
      r7(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : $D(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function r7(e, t, r) {
  return t = i7(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function i7(e) {
  var t = n7(e, "string");
  return Cd(t) == "symbol" ? t : t + "";
}
function n7(e, t) {
  if (Cd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Cd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var zD = function(t, r, i, n, o) {
  var s = i - n, a;
  return a = "M ".concat(t, ",").concat(r), a += "L ".concat(t + i, ",").concat(r), a += "L ".concat(t + i - s / 2, ",").concat(r + o), a += "L ".concat(t + i - s / 2 - n, ",").concat(r + o), a += "L ".concat(t, ",").concat(r, " Z"), a;
}, o7 = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, s7 = function(t) {
  var r = jD(jD({}, o7), t), i = re(), n = ee(-1), o = ZQ(n, 2), s = o[0], a = o[1];
  gt(function() {
    if (i.current && i.current.getTotalLength)
      try {
        var E = i.current.getTotalLength();
        E && a(E);
      } catch {
      }
  }, []);
  var l = r.x, u = r.y, c = r.upperWidth, d = r.lowerWidth, h = r.height, p = r.className, g = r.animationEasing, m = r.animationDuration, f = r.animationBegin, C = r.isUpdateAnimationActive;
  if (l !== +l || u !== +u || c !== +c || d !== +d || h !== +h || c === 0 && d === 0 || h === 0)
    return null;
  var w = xe("recharts-trapezoid", p);
  return C ? /* @__PURE__ */ D.createElement($n, {
    canBegin: s > 0,
    from: {
      upperWidth: 0,
      lowerWidth: 0,
      height: h,
      x: l,
      y: u
    },
    to: {
      upperWidth: c,
      lowerWidth: d,
      height: h,
      x: l,
      y: u
    },
    duration: m,
    animationEasing: g,
    isActive: C
  }, function(E) {
    var b = E.upperWidth, y = E.lowerWidth, S = E.height, x = E.x, R = E.y;
    return /* @__PURE__ */ D.createElement($n, {
      canBegin: s > 0,
      from: "0px ".concat(s === -1 ? 1 : s, "px"),
      to: "".concat(s, "px 0px"),
      attributeName: "strokeDasharray",
      begin: f,
      duration: m,
      easing: g
    }, /* @__PURE__ */ D.createElement("path", Gf({}, Ie(r, !0), {
      className: w,
      d: zD(x, R, b, y, S),
      ref: i
    })));
  }) : /* @__PURE__ */ D.createElement("g", null, /* @__PURE__ */ D.createElement("path", Gf({}, Ie(r, !0), {
    className: w,
    d: zD(l, u, c, d, h)
  })));
}, a7 = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function yd(e) {
  "@babel/helpers - typeof";
  return yd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, yd(e);
}
function l7(e, t) {
  if (e == null) return {};
  var r = u7(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function u7(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function UD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UD(Object(r), !0).forEach(function(i) {
      c7(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : UD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function c7(e, t, r) {
  return t = d7(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function d7(e) {
  var t = h7(e, "string");
  return yd(t) == "symbol" ? t : t + "";
}
function h7(e, t) {
  if (yd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (yd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function p7(e, t) {
  return kf(kf({}, t), e);
}
function f7(e, t) {
  return e === "symbols";
}
function YD(e) {
  var t = e.shapeType, r = e.elementProps;
  switch (t) {
    case "rectangle":
      return /* @__PURE__ */ D.createElement(wS, r);
    case "trapezoid":
      return /* @__PURE__ */ D.createElement(s7, r);
    case "sector":
      return /* @__PURE__ */ D.createElement(fM, r);
    case "symbols":
      if (f7(t))
        return /* @__PURE__ */ D.createElement(Gw, r);
      break;
    default:
      return null;
  }
}
function g7(e) {
  return /* @__PURE__ */ cn(e) ? e.props : e;
}
function RM(e) {
  var t = e.option, r = e.shapeType, i = e.propTransformer, n = i === void 0 ? p7 : i, o = e.activeClassName, s = o === void 0 ? "recharts-active-shape" : o, a = e.isActive, l = l7(e, a7), u;
  if (/* @__PURE__ */ cn(t))
    u = /* @__PURE__ */ Gt(t, kf(kf({}, l), g7(t)));
  else if (Le(t))
    u = t(l);
  else if (jQ(t) && !qQ(t)) {
    var c = n(t, l);
    u = /* @__PURE__ */ D.createElement(YD, {
      shapeType: r,
      elementProps: c
    });
  } else {
    var d = l;
    u = /* @__PURE__ */ D.createElement(YD, {
      shapeType: r,
      elementProps: d
    });
  }
  return a ? /* @__PURE__ */ D.createElement(Ze, {
    className: s
  }, u) : u;
}
function bm(e, t) {
  return t != null && "trapezoids" in e.props;
}
function wm(e, t) {
  return t != null && "sectors" in e.props;
}
function bd(e, t) {
  return t != null && "points" in e.props;
}
function m7(e, t) {
  var r, i, n = e.x === (t == null || (r = t.labelViewBox) === null || r === void 0 ? void 0 : r.x) || e.x === t.x, o = e.y === (t == null || (i = t.labelViewBox) === null || i === void 0 ? void 0 : i.y) || e.y === t.y;
  return n && o;
}
function v7(e, t) {
  var r = e.endAngle === t.endAngle, i = e.startAngle === t.startAngle;
  return r && i;
}
function C7(e, t) {
  var r = e.x === t.x, i = e.y === t.y, n = e.z === t.z;
  return r && i && n;
}
function y7(e, t) {
  var r;
  return bm(e, t) ? r = m7 : wm(e, t) ? r = v7 : bd(e, t) && (r = C7), r;
}
function b7(e, t) {
  var r;
  return bm(e, t) ? r = "trapezoids" : wm(e, t) ? r = "sectors" : bd(e, t) && (r = "points"), r;
}
function w7(e, t) {
  if (bm(e, t)) {
    var r;
    return (r = t.tooltipPayload) === null || r === void 0 || (r = r[0]) === null || r === void 0 || (r = r.payload) === null || r === void 0 ? void 0 : r.payload;
  }
  if (wm(e, t)) {
    var i;
    return (i = t.tooltipPayload) === null || i === void 0 || (i = i[0]) === null || i === void 0 || (i = i.payload) === null || i === void 0 ? void 0 : i.payload;
  }
  return bd(e, t) ? t.payload : {};
}
function S7(e) {
  var t = e.activeTooltipItem, r = e.graphicalItem, i = e.itemData, n = b7(r, t), o = w7(r, t), s = i.filter(function(l, u) {
    var c = gh(o, l), d = r.props[n].filter(function(g) {
      var m = y7(r, t);
      return m(g, t);
    }), h = r.props[n].indexOf(d[d.length - 1]), p = u === h;
    return c && p;
  }), a = i.indexOf(s[s.length - 1]);
  return a;
}
var Rp;
function _l(e) {
  "@babel/helpers - typeof";
  return _l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _l(e);
}
function ll() {
  return ll = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ll.apply(this, arguments);
}
function XD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Et(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XD(Object(r), !0).forEach(function(i) {
      _i(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : XD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function E7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KD(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, IM(i.key), i);
  }
}
function x7(e, t, r) {
  return t && KD(e.prototype, t), r && KD(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function A7(e, t, r) {
  return t = Vf(t), D7(e, PM() ? Reflect.construct(t, r || [], Vf(e).constructor) : t.apply(e, r));
}
function D7(e, t) {
  if (t && (_l(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return T7(e);
}
function T7(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function PM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (PM = function() {
    return !!e;
  })();
}
function Vf(e) {
  return Vf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Vf(e);
}
function R7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && sb(e, t);
}
function sb(e, t) {
  return sb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, sb(e, t);
}
function _i(e, t, r) {
  return t = IM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function IM(e) {
  var t = P7(e, "string");
  return _l(t) == "symbol" ? t : t + "";
}
function P7(e, t) {
  if (_l(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (_l(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Po = /* @__PURE__ */ function(e) {
  function t(r) {
    var i;
    return E7(this, t), i = A7(this, t, [r]), _i(i, "pieRef", null), _i(i, "sectorRefs", []), _i(i, "id", Ru("recharts-pie-")), _i(i, "handleAnimationEnd", function() {
      var n = i.props.onAnimationEnd;
      i.setState({
        isAnimationFinished: !0
      }), Le(n) && n();
    }), _i(i, "handleAnimationStart", function() {
      var n = i.props.onAnimationStart;
      i.setState({
        isAnimationFinished: !1
      }), Le(n) && n();
    }), i.state = {
      isAnimationFinished: !r.isAnimationActive,
      prevIsAnimationActive: r.isAnimationActive,
      prevAnimationId: r.animationId,
      sectorToFocus: 0
    }, i;
  }
  return R7(t, e), x7(t, [{
    key: "isActiveIndex",
    value: function(i) {
      var n = this.props.activeIndex;
      return Array.isArray(n) ? n.indexOf(i) !== -1 : i === n;
    }
  }, {
    key: "hasActiveIndex",
    value: function() {
      var i = this.props.activeIndex;
      return Array.isArray(i) ? i.length !== 0 : i || i === 0;
    }
  }, {
    key: "renderLabels",
    value: function(i) {
      var n = this.props.isAnimationActive;
      if (n && !this.state.isAnimationFinished)
        return null;
      var o = this.props, s = o.label, a = o.labelLine, l = o.dataKey, u = o.valueKey, c = Ie(this.props, !1), d = Ie(s, !1), h = Ie(a, !1), p = s && s.offsetRadius || 20, g = i.map(function(m, f) {
        var C = (m.startAngle + m.endAngle) / 2, w = At(m.cx, m.cy, m.outerRadius + p, C), E = Et(Et(Et(Et({}, c), m), {}, {
          stroke: "none"
        }, d), {}, {
          index: f,
          textAnchor: t.getTextAnchor(w.x, m.cx)
        }, w), b = Et(Et(Et(Et({}, c), m), {}, {
          fill: "none",
          stroke: m.fill
        }, h), {}, {
          index: f,
          points: [At(m.cx, m.cy, m.outerRadius, C), w]
        }), y = l;
        return ke(l) && ke(u) ? y = "value" : ke(l) && (y = u), // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ D.createElement(Ze, {
          key: "label-".concat(m.startAngle, "-").concat(m.endAngle, "-").concat(m.midAngle, "-").concat(f)
        }, a && t.renderLabelLineItem(a, b, "line"), t.renderLabelItem(s, E, cr(m, y)));
      });
      return /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-pie-labels"
      }, g);
    }
  }, {
    key: "renderSectorsStatically",
    value: function(i) {
      var n = this, o = this.props, s = o.activeShape, a = o.blendStroke, l = o.inactiveShape;
      return i.map(function(u, c) {
        if ((u == null ? void 0 : u.startAngle) === 0 && (u == null ? void 0 : u.endAngle) === 0 && i.length !== 1) return null;
        var d = n.isActiveIndex(c), h = l && n.hasActiveIndex() ? l : null, p = d ? s : h, g = Et(Et({}, u), {}, {
          stroke: a ? u.fill : u.stroke,
          tabIndex: -1
        });
        return /* @__PURE__ */ D.createElement(Ze, ll({
          ref: function(f) {
            f && !n.sectorRefs.includes(f) && n.sectorRefs.push(f);
          },
          tabIndex: -1,
          className: "recharts-pie-sector"
        }, na(n.props, u, c), {
          // eslint-disable-next-line react/no-array-index-key
          key: "sector-".concat(u == null ? void 0 : u.startAngle, "-").concat(u == null ? void 0 : u.endAngle, "-").concat(u.midAngle, "-").concat(c)
        }), /* @__PURE__ */ D.createElement(RM, ll({
          option: p,
          isActive: d,
          shapeType: "sector"
        }, g)));
      });
    }
  }, {
    key: "renderSectorsWithAnimation",
    value: function() {
      var i = this, n = this.props, o = n.sectors, s = n.isAnimationActive, a = n.animationBegin, l = n.animationDuration, u = n.animationEasing, c = n.animationId, d = this.state, h = d.prevSectors, p = d.prevIsAnimationActive;
      return /* @__PURE__ */ D.createElement($n, {
        begin: a,
        duration: l,
        isActive: s,
        easing: u,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "pie-".concat(c, "-").concat(p),
        onAnimationStart: this.handleAnimationStart,
        onAnimationEnd: this.handleAnimationEnd
      }, function(g) {
        var m = g.t, f = [], C = o && o[0], w = C.startAngle;
        return o.forEach(function(E, b) {
          var y = h && h[b], S = b > 0 ? vi(E, "paddingAngle", 0) : 0;
          if (y) {
            var x = fi(y.endAngle - y.startAngle, E.endAngle - E.startAngle), R = Et(Et({}, E), {}, {
              startAngle: w + S,
              endAngle: w + x(m) + S
            });
            f.push(R), w = R.endAngle;
          } else {
            var P = E.endAngle, O = E.startAngle, I = fi(0, P - O), M = I(m), _ = Et(Et({}, E), {}, {
              startAngle: w + S,
              endAngle: w + M + S
            });
            f.push(_), w = _.endAngle;
          }
        }), /* @__PURE__ */ D.createElement(Ze, null, i.renderSectorsStatically(f));
      });
    }
  }, {
    key: "attachKeyboardHandlers",
    value: function(i) {
      var n = this;
      i.onkeydown = function(o) {
        if (!o.altKey)
          switch (o.key) {
            case "ArrowLeft": {
              var s = ++n.state.sectorToFocus % n.sectorRefs.length;
              n.sectorRefs[s].focus(), n.setState({
                sectorToFocus: s
              });
              break;
            }
            case "ArrowRight": {
              var a = --n.state.sectorToFocus < 0 ? n.sectorRefs.length - 1 : n.state.sectorToFocus % n.sectorRefs.length;
              n.sectorRefs[a].focus(), n.setState({
                sectorToFocus: a
              });
              break;
            }
            case "Escape": {
              n.sectorRefs[n.state.sectorToFocus].blur(), n.setState({
                sectorToFocus: 0
              });
              break;
            }
          }
      };
    }
  }, {
    key: "renderSectors",
    value: function() {
      var i = this.props, n = i.sectors, o = i.isAnimationActive, s = this.state.prevSectors;
      return o && n && n.length && (!s || !gh(s, n)) ? this.renderSectorsWithAnimation() : this.renderSectorsStatically(n);
    }
  }, {
    key: "componentDidMount",
    value: function() {
      this.pieRef && this.attachKeyboardHandlers(this.pieRef);
    }
  }, {
    key: "render",
    value: function() {
      var i = this, n = this.props, o = n.hide, s = n.sectors, a = n.className, l = n.label, u = n.cx, c = n.cy, d = n.innerRadius, h = n.outerRadius, p = n.isAnimationActive, g = this.state.isAnimationFinished;
      if (o || !s || !s.length || !ue(u) || !ue(c) || !ue(d) || !ue(h))
        return null;
      var m = xe("recharts-pie", a);
      return /* @__PURE__ */ D.createElement(Ze, {
        tabIndex: this.props.rootTabIndex,
        className: m,
        ref: function(C) {
          i.pieRef = C;
        }
      }, this.renderSectors(), l && this.renderLabels(s), gr.renderCallByParent(this.props, null, !1), (!p || g) && ho.renderCallByParent(this.props, s, !1));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, n) {
      return n.prevIsAnimationActive !== i.isAnimationActive ? {
        prevIsAnimationActive: i.isAnimationActive,
        prevAnimationId: i.animationId,
        curSectors: i.sectors,
        prevSectors: [],
        isAnimationFinished: !0
      } : i.isAnimationActive && i.animationId !== n.prevAnimationId ? {
        prevAnimationId: i.animationId,
        curSectors: i.sectors,
        prevSectors: n.curSectors,
        isAnimationFinished: !0
      } : i.sectors !== n.curSectors ? {
        curSectors: i.sectors,
        isAnimationFinished: !0
      } : null;
    }
  }, {
    key: "getTextAnchor",
    value: function(i, n) {
      return i > n ? "start" : i < n ? "end" : "middle";
    }
  }, {
    key: "renderLabelLineItem",
    value: function(i, n, o) {
      if (/* @__PURE__ */ D.isValidElement(i))
        return /* @__PURE__ */ D.cloneElement(i, n);
      if (Le(i))
        return i(n);
      var s = xe("recharts-pie-label-line", typeof i != "boolean" ? i.className : "");
      return /* @__PURE__ */ D.createElement(Pf, ll({}, n, {
        key: o,
        type: "linear",
        className: s
      }));
    }
  }, {
    key: "renderLabelItem",
    value: function(i, n, o) {
      if (/* @__PURE__ */ D.isValidElement(i))
        return /* @__PURE__ */ D.cloneElement(i, n);
      var s = o;
      if (Le(i) && (s = i(n), /* @__PURE__ */ D.isValidElement(s)))
        return s;
      var a = xe("recharts-pie-label-text", typeof i != "boolean" && !Le(i) ? i.className : "");
      return /* @__PURE__ */ D.createElement(oa, ll({}, n, {
        alignmentBaseline: "middle",
        className: a
      }), s);
    }
  }]);
}(vn);
Rp = Po;
_i(Po, "displayName", "Pie");
_i(Po, "defaultProps", {
  stroke: "#fff",
  fill: "#808080",
  legendType: "rect",
  cx: "50%",
  cy: "50%",
  startAngle: 0,
  endAngle: 360,
  innerRadius: 0,
  outerRadius: "80%",
  paddingAngle: 0,
  labelLine: !0,
  hide: !1,
  minAngle: 0,
  isAnimationActive: !Da.isSsr,
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  nameKey: "name",
  blendStroke: !1,
  rootTabIndex: 0
});
_i(Po, "parseDeltaAngle", function(e, t) {
  var r = Nr(t - e), i = Math.min(Math.abs(t - e), 360);
  return r * i;
});
_i(Po, "getRealPieData", function(e) {
  var t = e.data, r = e.children, i = Ie(e, !1), n = Ci(r, im);
  return t && t.length ? t.map(function(o, s) {
    return Et(Et(Et({
      payload: o
    }, i), o), n && n[s] && n[s].props);
  }) : n && n.length ? n.map(function(o) {
    return Et(Et({}, i), o.props);
  }) : [];
});
_i(Po, "parseCoordinateOfPie", function(e, t) {
  var r = t.top, i = t.left, n = t.width, o = t.height, s = cM(n, o), a = i + Lr(e.cx, n, n / 2), l = r + Lr(e.cy, o, o / 2), u = Lr(e.innerRadius, s, 0), c = Lr(e.outerRadius, s, s * 0.8), d = e.maxRadius || Math.sqrt(n * n + o * o) / 2;
  return {
    cx: a,
    cy: l,
    innerRadius: u,
    outerRadius: c,
    maxRadius: d
  };
});
_i(Po, "getComposedData", function(e) {
  var t = e.item, r = e.offset, i = t.type.defaultProps !== void 0 ? Et(Et({}, t.type.defaultProps), t.props) : t.props, n = Rp.getRealPieData(i);
  if (!n || !n.length)
    return null;
  var o = i.cornerRadius, s = i.startAngle, a = i.endAngle, l = i.paddingAngle, u = i.dataKey, c = i.nameKey, d = i.valueKey, h = i.tooltipType, p = Math.abs(i.minAngle), g = Rp.parseCoordinateOfPie(i, r), m = Rp.parseDeltaAngle(s, a), f = Math.abs(m), C = u;
  ke(u) && ke(d) ? (dn(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), C = "value") : ke(u) && (dn(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), C = d);
  var w = n.filter(function(R) {
    return cr(R, C, 0) !== 0;
  }).length, E = (f >= 360 ? w : w - 1) * l, b = f - w * p - E, y = n.reduce(function(R, P) {
    var O = cr(P, C, 0);
    return R + (ue(O) ? O : 0);
  }, 0), S;
  if (y > 0) {
    var x;
    S = n.map(function(R, P) {
      var O = cr(R, C, 0), I = cr(R, c, P), M = (ue(O) ? O : 0) / y, _;
      P ? _ = x.endAngle + Nr(m) * l * (O !== 0 ? 1 : 0) : _ = s;
      var G = _ + Nr(m) * ((O !== 0 ? p : 0) + M * b), F = (_ + G) / 2, N = (g.innerRadius + g.outerRadius) / 2, V = [{
        name: I,
        value: O,
        payload: R,
        dataKey: C,
        type: h
      }], B = At(g.cx, g.cy, N, F);
      return x = Et(Et(Et({
        percent: M,
        cornerRadius: o,
        name: I,
        tooltipPayload: V,
        midAngle: F,
        middleRadius: N,
        tooltipPosition: B
      }, R), g), {}, {
        value: cr(R, C),
        startAngle: _,
        endAngle: G,
        payload: R,
        paddingAngle: Nr(m) * l
      }), x;
    });
  }
  return Et(Et({}, g), {}, {
    sectors: S,
    data: n
  });
});
var I7 = Math.ceil, O7 = Math.max;
function M7(e, t, r, i) {
  for (var n = -1, o = O7(I7((t - e) / (r || 1)), 0), s = Array(o); o--; )
    s[i ? o : ++n] = e, e += r;
  return s;
}
var F7 = M7, _7 = ZI, qD = 1 / 0, N7 = 17976931348623157e292;
function L7(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = _7(e), e === qD || e === -qD) {
    var t = e < 0 ? -1 : 1;
    return t * N7;
  }
  return e === e ? e : 0;
}
var OM = L7, G7 = F7, k7 = rm, tC = OM;
function V7(e) {
  return function(t, r, i) {
    return i && typeof i != "number" && k7(t, r, i) && (r = i = void 0), t = tC(t), r === void 0 ? (r = t, t = 0) : r = tC(r), i = i === void 0 ? t < r ? 1 : -1 : tC(i), G7(t, r, i, e);
  };
}
var H7 = V7, B7 = H7, W7 = B7(), $7 = W7;
const Hf = /* @__PURE__ */ Ct($7);
function wd(e) {
  "@babel/helpers - typeof";
  return wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wd(e);
}
function ZD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function JD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZD(Object(r), !0).forEach(function(i) {
      MM(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ZD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function MM(e, t, r) {
  return t = j7(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function j7(e) {
  var t = z7(e, "string");
  return wd(t) == "symbol" ? t : t + "";
}
function z7(e, t) {
  if (wd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (wd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var U7 = ["Webkit", "Moz", "O", "ms"], Y7 = function(t, r) {
  var i = t.replace(/(\w)/, function(o) {
    return o.toUpperCase();
  }), n = U7.reduce(function(o, s) {
    return JD(JD({}, o), {}, MM({}, s + i, r));
  }, {});
  return n[t] = r, n;
};
function Nl(e) {
  "@babel/helpers - typeof";
  return Nl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nl(e);
}
function Bf() {
  return Bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Bf.apply(this, arguments);
}
function QD(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function rC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QD(Object(r), !0).forEach(function(i) {
      di(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : QD(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function X7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function eT(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, _M(i.key), i);
  }
}
function K7(e, t, r) {
  return t && eT(e.prototype, t), r && eT(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function q7(e, t, r) {
  return t = Wf(t), Z7(e, FM() ? Reflect.construct(t, r || [], Wf(e).constructor) : t.apply(e, r));
}
function Z7(e, t) {
  if (t && (Nl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return J7(e);
}
function J7(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function FM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (FM = function() {
    return !!e;
  })();
}
function Wf(e) {
  return Wf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Wf(e);
}
function Q7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ab(e, t);
}
function ab(e, t) {
  return ab = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, ab(e, t);
}
function di(e, t, r) {
  return t = _M(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function _M(e) {
  var t = eee(e, "string");
  return Nl(t) == "symbol" ? t : t + "";
}
function eee(e, t) {
  if (Nl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Nl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var tee = function(t) {
  var r = t.data, i = t.startIndex, n = t.endIndex, o = t.x, s = t.width, a = t.travellerWidth;
  if (!r || !r.length)
    return {};
  var l = r.length, u = _c().domain(Hf(0, l)).range([o, o + s - a]), c = u.domain().map(function(d) {
    return u(d);
  });
  return {
    isTextActive: !1,
    isSlideMoving: !1,
    isTravellerMoving: !1,
    isTravellerFocused: !1,
    startX: u(i),
    endX: u(n),
    scale: u,
    scaleValues: c
  };
}, tT = function(t) {
  return t.changedTouches && !!t.changedTouches.length;
}, Ll = /* @__PURE__ */ function(e) {
  function t(r) {
    var i;
    return X7(this, t), i = q7(this, t, [r]), di(i, "handleDrag", function(n) {
      i.leaveTimer && (clearTimeout(i.leaveTimer), i.leaveTimer = null), i.state.isTravellerMoving ? i.handleTravellerMove(n) : i.state.isSlideMoving && i.handleSlideDrag(n);
    }), di(i, "handleTouchMove", function(n) {
      n.changedTouches != null && n.changedTouches.length > 0 && i.handleDrag(n.changedTouches[0]);
    }), di(i, "handleDragEnd", function() {
      i.setState({
        isTravellerMoving: !1,
        isSlideMoving: !1
      }, function() {
        var n = i.props, o = n.endIndex, s = n.onDragEnd, a = n.startIndex;
        s == null || s({
          endIndex: o,
          startIndex: a
        });
      }), i.detachDragEndListener();
    }), di(i, "handleLeaveWrapper", function() {
      (i.state.isTravellerMoving || i.state.isSlideMoving) && (i.leaveTimer = window.setTimeout(i.handleDragEnd, i.props.leaveTimeOut));
    }), di(i, "handleEnterSlideOrTraveller", function() {
      i.setState({
        isTextActive: !0
      });
    }), di(i, "handleLeaveSlideOrTraveller", function() {
      i.setState({
        isTextActive: !1
      });
    }), di(i, "handleSlideDragStart", function(n) {
      var o = tT(n) ? n.changedTouches[0] : n;
      i.setState({
        isTravellerMoving: !1,
        isSlideMoving: !0,
        slideMoveStartX: o.pageX
      }), i.attachDragEndListener();
    }), i.travellerDragStartHandlers = {
      startX: i.handleTravellerDragStart.bind(i, "startX"),
      endX: i.handleTravellerDragStart.bind(i, "endX")
    }, i.state = {}, i;
  }
  return Q7(t, e), K7(t, [{
    key: "componentWillUnmount",
    value: function() {
      this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function(i) {
      var n = i.startX, o = i.endX, s = this.state.scaleValues, a = this.props, l = a.gap, u = a.data, c = u.length - 1, d = Math.min(n, o), h = Math.max(n, o), p = t.getIndexInRange(s, d), g = t.getIndexInRange(s, h);
      return {
        startIndex: p - p % l,
        endIndex: g === c ? c : g - g % l
      };
    }
  }, {
    key: "getTextOfTick",
    value: function(i) {
      var n = this.props, o = n.data, s = n.tickFormatter, a = n.dataKey, l = cr(o[i], a, i);
      return Le(s) ? s(l, i) : l;
    }
  }, {
    key: "attachDragEndListener",
    value: function() {
      window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "detachDragEndListener",
    value: function() {
      window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "handleSlideDrag",
    value: function(i) {
      var n = this.state, o = n.slideMoveStartX, s = n.startX, a = n.endX, l = this.props, u = l.x, c = l.width, d = l.travellerWidth, h = l.startIndex, p = l.endIndex, g = l.onChange, m = i.pageX - o;
      m > 0 ? m = Math.min(m, u + c - d - a, u + c - d - s) : m < 0 && (m = Math.max(m, u - s, u - a));
      var f = this.getIndex({
        startX: s + m,
        endX: a + m
      });
      (f.startIndex !== h || f.endIndex !== p) && g && g(f), this.setState({
        startX: s + m,
        endX: a + m,
        slideMoveStartX: i.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function(i, n) {
      var o = tT(n) ? n.changedTouches[0] : n;
      this.setState({
        isSlideMoving: !1,
        isTravellerMoving: !0,
        movingTravellerId: i,
        brushMoveStartX: o.pageX
      }), this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function(i) {
      var n = this.state, o = n.brushMoveStartX, s = n.movingTravellerId, a = n.endX, l = n.startX, u = this.state[s], c = this.props, d = c.x, h = c.width, p = c.travellerWidth, g = c.onChange, m = c.gap, f = c.data, C = {
        startX: this.state.startX,
        endX: this.state.endX
      }, w = i.pageX - o;
      w > 0 ? w = Math.min(w, d + h - p - u) : w < 0 && (w = Math.max(w, d - u)), C[s] = u + w;
      var E = this.getIndex(C), b = E.startIndex, y = E.endIndex, S = function() {
        var R = f.length - 1;
        return s === "startX" && (a > l ? b % m === 0 : y % m === 0) || a < l && y === R || s === "endX" && (a > l ? y % m === 0 : b % m === 0) || a > l && y === R;
      };
      this.setState(di(di({}, s, u + w), "brushMoveStartX", i.pageX), function() {
        g && S() && g(E);
      });
    }
  }, {
    key: "handleTravellerMoveKeyboard",
    value: function(i, n) {
      var o = this, s = this.state, a = s.scaleValues, l = s.startX, u = s.endX, c = this.state[n], d = a.indexOf(c);
      if (d !== -1) {
        var h = d + i;
        if (!(h === -1 || h >= a.length)) {
          var p = a[h];
          n === "startX" && p >= u || n === "endX" && p <= l || this.setState(di({}, n, p), function() {
            o.props.onChange(o.getIndex({
              startX: o.state.startX,
              endX: o.state.endX
            }));
          });
        }
      }
    }
  }, {
    key: "renderBackground",
    value: function() {
      var i = this.props, n = i.x, o = i.y, s = i.width, a = i.height, l = i.fill, u = i.stroke;
      return /* @__PURE__ */ D.createElement("rect", {
        stroke: u,
        fill: l,
        x: n,
        y: o,
        width: s,
        height: a
      });
    }
  }, {
    key: "renderPanorama",
    value: function() {
      var i = this.props, n = i.x, o = i.y, s = i.width, a = i.height, l = i.data, u = i.children, c = i.padding, d = Ws.only(u);
      return d ? /* @__PURE__ */ D.cloneElement(d, {
        x: n,
        y: o,
        width: s,
        height: a,
        margin: c,
        compact: !0,
        data: l
      }) : null;
    }
  }, {
    key: "renderTravellerLayer",
    value: function(i, n) {
      var o, s, a = this, l = this.props, u = l.y, c = l.travellerWidth, d = l.height, h = l.traveller, p = l.ariaLabel, g = l.data, m = l.startIndex, f = l.endIndex, C = Math.max(i, this.props.x), w = rC(rC({}, Ie(this.props, !1)), {}, {
        x: C,
        y: u,
        width: c,
        height: d
      }), E = p || "Min value: ".concat((o = g[m]) === null || o === void 0 ? void 0 : o.name, ", Max value: ").concat((s = g[f]) === null || s === void 0 ? void 0 : s.name);
      return /* @__PURE__ */ D.createElement(Ze, {
        tabIndex: 0,
        role: "slider",
        "aria-label": E,
        "aria-valuenow": i,
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[n],
        onTouchStart: this.travellerDragStartHandlers[n],
        onKeyDown: function(y) {
          ["ArrowLeft", "ArrowRight"].includes(y.key) && (y.preventDefault(), y.stopPropagation(), a.handleTravellerMoveKeyboard(y.key === "ArrowRight" ? 1 : -1, n));
        },
        onFocus: function() {
          a.setState({
            isTravellerFocused: !0
          });
        },
        onBlur: function() {
          a.setState({
            isTravellerFocused: !1
          });
        },
        style: {
          cursor: "col-resize"
        }
      }, t.renderTraveller(h, w));
    }
  }, {
    key: "renderSlide",
    value: function(i, n) {
      var o = this.props, s = o.y, a = o.height, l = o.stroke, u = o.travellerWidth, c = Math.min(i, n) + u, d = Math.max(Math.abs(n - i) - u, 0);
      return /* @__PURE__ */ D.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: l,
        fillOpacity: 0.2,
        x: c,
        y: s,
        width: d,
        height: a
      });
    }
  }, {
    key: "renderText",
    value: function() {
      var i = this.props, n = i.startIndex, o = i.endIndex, s = i.y, a = i.height, l = i.travellerWidth, u = i.stroke, c = this.state, d = c.startX, h = c.endX, p = 5, g = {
        pointerEvents: "none",
        fill: u
      };
      return /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ D.createElement(oa, Bf({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(d, h) - p,
        y: s + a / 2
      }, g), this.getTextOfTick(n)), /* @__PURE__ */ D.createElement(oa, Bf({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(d, h) + l + p,
        y: s + a / 2
      }, g), this.getTextOfTick(o)));
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, n = i.data, o = i.className, s = i.children, a = i.x, l = i.y, u = i.width, c = i.height, d = i.alwaysShowText, h = this.state, p = h.startX, g = h.endX, m = h.isTextActive, f = h.isSlideMoving, C = h.isTravellerMoving, w = h.isTravellerFocused;
      if (!n || !n.length || !ue(a) || !ue(l) || !ue(u) || !ue(c) || u <= 0 || c <= 0)
        return null;
      var E = xe("recharts-brush", o), b = D.Children.count(s) === 1, y = Y7("userSelect", "none");
      return /* @__PURE__ */ D.createElement(Ze, {
        className: E,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style: y
      }, this.renderBackground(), b && this.renderPanorama(), this.renderSlide(p, g), this.renderTravellerLayer(p, "startX"), this.renderTravellerLayer(g, "endX"), (m || f || C || w || d) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function(i) {
      var n = i.x, o = i.y, s = i.width, a = i.height, l = i.stroke, u = Math.floor(o + a / 2) - 1;
      return /* @__PURE__ */ D.createElement(D.Fragment, null, /* @__PURE__ */ D.createElement("rect", {
        x: n,
        y: o,
        width: s,
        height: a,
        fill: l,
        stroke: "none"
      }), /* @__PURE__ */ D.createElement("line", {
        x1: n + 1,
        y1: u,
        x2: n + s - 1,
        y2: u,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ D.createElement("line", {
        x1: n + 1,
        y1: u + 2,
        x2: n + s - 1,
        y2: u + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function(i, n) {
      var o;
      return /* @__PURE__ */ D.isValidElement(i) ? o = /* @__PURE__ */ D.cloneElement(i, n) : Le(i) ? o = i(n) : o = t.renderDefaultTraveller(n), o;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function(i, n) {
      var o = i.data, s = i.width, a = i.x, l = i.travellerWidth, u = i.updateId, c = i.startIndex, d = i.endIndex;
      if (o !== n.prevData || u !== n.prevUpdateId)
        return rC({
          prevData: o,
          prevTravellerWidth: l,
          prevUpdateId: u,
          prevX: a,
          prevWidth: s
        }, o && o.length ? tee({
          data: o,
          width: s,
          x: a,
          travellerWidth: l,
          startIndex: c,
          endIndex: d
        }) : {
          scale: null,
          scaleValues: null
        });
      if (n.scale && (s !== n.prevWidth || a !== n.prevX || l !== n.prevTravellerWidth)) {
        n.scale.range([a, a + s - l]);
        var h = n.scale.domain().map(function(p) {
          return n.scale(p);
        });
        return {
          prevData: o,
          prevTravellerWidth: l,
          prevUpdateId: u,
          prevX: a,
          prevWidth: s,
          startX: n.scale(i.startIndex),
          endX: n.scale(i.endIndex),
          scaleValues: h
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function(i, n) {
      for (var o = i.length, s = 0, a = o - 1; a - s > 1; ) {
        var l = Math.floor((s + a) / 2);
        i[l] > n ? a = l : s = l;
      }
      return n >= i[a] ? a : s;
    }
  }]);
}(vn);
di(Ll, "displayName", "Brush");
di(Ll, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: !1
});
var ree = jw;
function iee(e, t) {
  var r;
  return ree(e, function(i, n, o) {
    return r = t(i, n, o), !r;
  }), !!r;
}
var nee = iee, oee = xI, see = Jn, aee = nee, lee = oi, uee = rm;
function cee(e, t, r) {
  var i = lee(e) ? oee : aee;
  return r && uee(e, t, r) && (t = void 0), i(e, see(t));
}
var dee = cee;
const hee = /* @__PURE__ */ Ct(dee);
var _n = function(t, r) {
  var i = t.alwaysShow, n = t.ifOverflow;
  return i && (n = "extendDomain"), n === r;
}, rT = UI;
function pee(e, t, r) {
  t == "__proto__" && rT ? rT(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
var fee = pee, gee = fee, mee = jI, vee = Jn;
function Cee(e, t) {
  var r = {};
  return t = vee(t), mee(e, function(i, n, o) {
    gee(r, n, t(i, n, o));
  }), r;
}
var yee = Cee;
const bee = /* @__PURE__ */ Ct(yee);
function wee(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (!t(e[r], r, e))
      return !1;
  return !0;
}
var See = wee, Eee = jw;
function xee(e, t) {
  var r = !0;
  return Eee(e, function(i, n, o) {
    return r = !!t(i, n, o), r;
  }), r;
}
var Aee = xee, Dee = See, Tee = Aee, Ree = Jn, Pee = oi, Iee = rm;
function Oee(e, t, r) {
  var i = Pee(e) ? Dee : Tee;
  return r && Iee(e, t, r) && (t = void 0), i(e, Ree(t));
}
var Mee = Oee;
const NM = /* @__PURE__ */ Ct(Mee);
var Fee = ["x", "y"];
function Gl(e) {
  "@babel/helpers - typeof";
  return Gl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gl(e);
}
function lb() {
  return lb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, lb.apply(this, arguments);
}
function iT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function pc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iT(Object(r), !0).forEach(function(i) {
      _ee(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : iT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function _ee(e, t, r) {
  return t = Nee(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Nee(e) {
  var t = Lee(e, "string");
  return Gl(t) == "symbol" ? t : t + "";
}
function Lee(e, t) {
  if (Gl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Gl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Gee(e, t) {
  if (e == null) return {};
  var r = kee(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function kee(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function Vee(e, t) {
  var r = e.x, i = e.y, n = Gee(e, Fee), o = "".concat(r), s = parseInt(o, 10), a = "".concat(i), l = parseInt(a, 10), u = "".concat(t.height || n.height), c = parseInt(u, 10), d = "".concat(t.width || n.width), h = parseInt(d, 10);
  return pc(pc(pc(pc(pc({}, t), n), s ? {
    x: s
  } : {}), l ? {
    y: l
  } : {}), {}, {
    height: c,
    width: h,
    name: t.name,
    radius: t.radius
  });
}
function nT(e) {
  return /* @__PURE__ */ D.createElement(RM, lb({
    shapeType: "rectangle",
    propTransformer: Vee,
    activeClassName: "recharts-active-bar"
  }, e));
}
var Hee = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return function(i, n) {
    if (typeof t == "number") return t;
    var o = ue(i) || iB(i);
    return o ? t(i, n) : (o || (process.env.NODE_ENV !== "production" ? qr(!1, "minPointSize callback function received a value with type of ".concat(Gl(i), ". Currently only numbers or null/undefined are supported.")) : qr()), r);
  };
}, Bee = ["value", "background"], LM;
function kl(e) {
  "@babel/helpers - typeof";
  return kl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, kl(e);
}
function Wee(e, t) {
  if (e == null) return {};
  var r = $ee(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function $ee(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function $f() {
  return $f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, $f.apply(this, arguments);
}
function oT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function tr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oT(Object(r), !0).forEach(function(i) {
      $o(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : oT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function jee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sT(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, kM(i.key), i);
  }
}
function zee(e, t, r) {
  return t && sT(e.prototype, t), r && sT(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Uee(e, t, r) {
  return t = jf(t), Yee(e, GM() ? Reflect.construct(t, r || [], jf(e).constructor) : t.apply(e, r));
}
function Yee(e, t) {
  if (t && (kl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Xee(e);
}
function Xee(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function GM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (GM = function() {
    return !!e;
  })();
}
function jf(e) {
  return jf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, jf(e);
}
function Kee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ub(e, t);
}
function ub(e, t) {
  return ub = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, ub(e, t);
}
function $o(e, t, r) {
  return t = kM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function kM(e) {
  var t = qee(e, "string");
  return kl(t) == "symbol" ? t : t + "";
}
function qee(e, t) {
  if (kl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (kl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Ia = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    jee(this, t);
    for (var i = arguments.length, n = new Array(i), o = 0; o < i; o++)
      n[o] = arguments[o];
    return r = Uee(this, t, [].concat(n)), $o(r, "state", {
      isAnimationFinished: !1
    }), $o(r, "id", Ru("recharts-bar-")), $o(r, "handleAnimationEnd", function() {
      var s = r.props.onAnimationEnd;
      r.setState({
        isAnimationFinished: !0
      }), s && s();
    }), $o(r, "handleAnimationStart", function() {
      var s = r.props.onAnimationStart;
      r.setState({
        isAnimationFinished: !1
      }), s && s();
    }), r;
  }
  return Kee(t, e), zee(t, [{
    key: "renderRectanglesStatically",
    value: function(i) {
      var n = this, o = this.props, s = o.shape, a = o.dataKey, l = o.activeIndex, u = o.activeBar, c = Ie(this.props, !1);
      return i && i.map(function(d, h) {
        var p = h === l, g = p ? u : s, m = tr(tr(tr({}, c), d), {}, {
          isActive: p,
          option: g,
          index: h,
          dataKey: a,
          onAnimationStart: n.handleAnimationStart,
          onAnimationEnd: n.handleAnimationEnd
        });
        return /* @__PURE__ */ D.createElement(Ze, $f({
          className: "recharts-bar-rectangle"
        }, na(n.props, d, h), {
          // https://github.com/recharts/recharts/issues/5415
          // eslint-disable-next-line react/no-array-index-key
          key: "rectangle-".concat(d == null ? void 0 : d.x, "-").concat(d == null ? void 0 : d.y, "-").concat(d == null ? void 0 : d.value, "-").concat(h)
        }), /* @__PURE__ */ D.createElement(nT, m));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function() {
      var i = this, n = this.props, o = n.data, s = n.layout, a = n.isAnimationActive, l = n.animationBegin, u = n.animationDuration, c = n.animationEasing, d = n.animationId, h = this.state.prevData;
      return /* @__PURE__ */ D.createElement($n, {
        begin: l,
        duration: u,
        isActive: a,
        easing: c,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(d),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(p) {
        var g = p.t, m = o.map(function(f, C) {
          var w = h && h[C];
          if (w) {
            var E = fi(w.x, f.x), b = fi(w.y, f.y), y = fi(w.width, f.width), S = fi(w.height, f.height);
            return tr(tr({}, f), {}, {
              x: E(g),
              y: b(g),
              width: y(g),
              height: S(g)
            });
          }
          if (s === "horizontal") {
            var x = fi(0, f.height), R = x(g);
            return tr(tr({}, f), {}, {
              y: f.y + f.height - R,
              height: R
            });
          }
          var P = fi(0, f.width), O = P(g);
          return tr(tr({}, f), {}, {
            width: O
          });
        });
        return /* @__PURE__ */ D.createElement(Ze, null, i.renderRectanglesStatically(m));
      });
    }
  }, {
    key: "renderRectangles",
    value: function() {
      var i = this.props, n = i.data, o = i.isAnimationActive, s = this.state.prevData;
      return o && n && n.length && (!s || !gh(s, n)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(n);
    }
  }, {
    key: "renderBackground",
    value: function() {
      var i = this, n = this.props, o = n.data, s = n.dataKey, a = n.activeIndex, l = Ie(this.props.background, !1);
      return o.map(function(u, c) {
        u.value;
        var d = u.background, h = Wee(u, Bee);
        if (!d)
          return null;
        var p = tr(tr(tr(tr(tr({}, h), {}, {
          fill: "#eee"
        }, d), l), na(i.props, u, c)), {}, {
          onAnimationStart: i.handleAnimationStart,
          onAnimationEnd: i.handleAnimationEnd,
          dataKey: s,
          index: c,
          className: "recharts-bar-background-rectangle"
        });
        return /* @__PURE__ */ D.createElement(nT, $f({
          key: "background-bar-".concat(c),
          option: i.props.background,
          isActive: c === a
        }, p));
      });
    }
  }, {
    key: "renderErrorBar",
    value: function(i, n) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished)
        return null;
      var o = this.props, s = o.data, a = o.xAxis, l = o.yAxis, u = o.layout, c = o.children, d = Ci(c, mh);
      if (!d)
        return null;
      var h = u === "vertical" ? s[0].height / 2 : s[0].width / 2, p = function(f, C) {
        var w = Array.isArray(f.value) ? f.value[1] : f.value;
        return {
          x: f.x,
          y: f.y,
          value: w,
          errorVal: cr(f, C)
        };
      }, g = {
        clipPath: i ? "url(#clipPath-".concat(n, ")") : null
      };
      return /* @__PURE__ */ D.createElement(Ze, g, d.map(function(m) {
        return /* @__PURE__ */ D.cloneElement(m, {
          key: "error-bar-".concat(n, "-").concat(m.props.dataKey),
          data: s,
          xAxis: a,
          yAxis: l,
          layout: u,
          offset: h,
          dataPointFormatter: p
        });
      }));
    }
  }, {
    key: "render",
    value: function() {
      var i = this.props, n = i.hide, o = i.data, s = i.className, a = i.xAxis, l = i.yAxis, u = i.left, c = i.top, d = i.width, h = i.height, p = i.isAnimationActive, g = i.background, m = i.id;
      if (n || !o || !o.length)
        return null;
      var f = this.state.isAnimationFinished, C = xe("recharts-bar", s), w = a && a.allowDataOverflow, E = l && l.allowDataOverflow, b = w || E, y = ke(m) ? this.id : m;
      return /* @__PURE__ */ D.createElement(Ze, {
        className: C
      }, w || E ? /* @__PURE__ */ D.createElement("defs", null, /* @__PURE__ */ D.createElement("clipPath", {
        id: "clipPath-".concat(y)
      }, /* @__PURE__ */ D.createElement("rect", {
        x: w ? u : u - d / 2,
        y: E ? c : c - h / 2,
        width: w ? d : d * 2,
        height: E ? h : h * 2
      }))) : null, /* @__PURE__ */ D.createElement(Ze, {
        className: "recharts-bar-rectangles",
        clipPath: b ? "url(#clipPath-".concat(y, ")") : null
      }, g ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(b, y), (!p || f) && ho.renderCallByParent(this.props, o));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, n) {
      return i.animationId !== n.prevAnimationId ? {
        prevAnimationId: i.animationId,
        curData: i.data,
        prevData: n.curData
      } : i.data !== n.curData ? {
        curData: i.data
      } : null;
    }
  }]);
}(vn);
LM = Ia;
$o(Ia, "displayName", "Bar");
$o(Ia, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: !1,
  data: [],
  layout: "vertical",
  activeBar: !1,
  isAnimationActive: !Da.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
$o(Ia, "getComposedData", function(e) {
  var t = e.props, r = e.item, i = e.barPosition, n = e.bandSize, o = e.xAxis, s = e.yAxis, a = e.xAxisTicks, l = e.yAxisTicks, u = e.stackedData, c = e.dataStartIndex, d = e.displayedData, h = e.offset, p = EZ(i, r);
  if (!p)
    return null;
  var g = t.layout, m = r.type.defaultProps, f = m !== void 0 ? tr(tr({}, m), r.props) : r.props, C = f.dataKey, w = f.children, E = f.minPointSize, b = g === "horizontal" ? s : o, y = u ? b.scale.domain() : null, S = IZ({
    numericAxis: b
  }), x = Ci(w, im), R = d.map(function(P, O) {
    var I, M, _, G, F, N;
    u ? I = xZ(u[c + O], y) : (I = cr(P, C), Array.isArray(I) || (I = [S, I]));
    var V = Hee(E, LM.defaultProps.minPointSize)(I[1], O);
    if (g === "horizontal") {
      var B, $ = [s.scale(I[0]), s.scale(I[1])], L = $[0], z = $[1];
      M = BA({
        axis: o,
        ticks: a,
        bandSize: n,
        offset: p.offset,
        entry: P,
        index: O
      }), _ = (B = z ?? L) !== null && B !== void 0 ? B : void 0, G = p.size;
      var j = L - z;
      if (F = Number.isNaN(j) ? 0 : j, N = {
        x: M,
        y: s.y,
        width: G,
        height: s.height
      }, Math.abs(V) > 0 && Math.abs(F) < Math.abs(V)) {
        var U = Nr(F || V) * (Math.abs(V) - Math.abs(F));
        _ -= U, F += U;
      }
    } else {
      var oe = [o.scale(I[0]), o.scale(I[1])], ie = oe[0], le = oe[1];
      if (M = ie, _ = BA({
        axis: s,
        ticks: l,
        bandSize: n,
        offset: p.offset,
        entry: P,
        index: O
      }), G = le - ie, F = p.size, N = {
        x: o.x,
        y: _,
        width: o.width,
        height: F
      }, Math.abs(V) > 0 && Math.abs(G) < Math.abs(V)) {
        var ce = Nr(G || V) * (Math.abs(V) - Math.abs(G));
        G += ce;
      }
    }
    return tr(tr(tr({}, P), {}, {
      x: M,
      y: _,
      width: G,
      height: F,
      value: u ? I : I[1],
      payload: P,
      background: N
    }, x && x[O] && x[O].props), {}, {
      tooltipPayload: [lM(r, P)],
      tooltipPosition: {
        x: M + G / 2,
        y: _ + F / 2
      }
    });
  });
  return tr({
    data: R,
    layout: g
  }, h);
});
function Sd(e) {
  "@babel/helpers - typeof";
  return Sd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sd(e);
}
function Zee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aT(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, VM(i.key), i);
  }
}
function Jee(e, t, r) {
  return t && aT(e.prototype, t), r && aT(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function lT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function tn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lT(Object(r), !0).forEach(function(i) {
      Sm(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : lT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Sm(e, t, r) {
  return t = VM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function VM(e) {
  var t = Qee(e, "string");
  return Sd(t) == "symbol" ? t : t + "";
}
function Qee(e, t) {
  if (Sd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Sd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var HM = function(t, r, i, n, o) {
  var s = t.width, a = t.height, l = t.layout, u = t.children, c = Object.keys(r), d = {
    left: i.left,
    leftMirror: i.left,
    right: s - i.right,
    rightMirror: s - i.right,
    top: i.top,
    topMirror: i.top,
    bottom: a - i.bottom,
    bottomMirror: a - i.bottom
  }, h = !!hi(u, Ia);
  return c.reduce(function(p, g) {
    var m = r[g], f = m.orientation, C = m.domain, w = m.padding, E = w === void 0 ? {} : w, b = m.mirror, y = m.reversed, S = "".concat(f).concat(b ? "Mirror" : ""), x, R, P, O, I;
    if (m.type === "number" && (m.padding === "gap" || m.padding === "no-gap")) {
      var M = C[1] - C[0], _ = 1 / 0, G = m.categoricalDomain.sort(sB);
      if (G.forEach(function(oe, ie) {
        ie > 0 && (_ = Math.min((oe || 0) - (G[ie - 1] || 0), _));
      }), Number.isFinite(_)) {
        var F = _ / M, N = m.layout === "vertical" ? i.height : i.width;
        if (m.padding === "gap" && (x = F * N / 2), m.padding === "no-gap") {
          var V = Lr(t.barCategoryGap, F * N), B = F * N / 2;
          x = B - V - (B - V) / N * V;
        }
      }
    }
    n === "xAxis" ? R = [i.left + (E.left || 0) + (x || 0), i.left + i.width - (E.right || 0) - (x || 0)] : n === "yAxis" ? R = l === "horizontal" ? [i.top + i.height - (E.bottom || 0), i.top + (E.top || 0)] : [i.top + (E.top || 0) + (x || 0), i.top + i.height - (E.bottom || 0) - (x || 0)] : R = m.range, y && (R = [R[1], R[0]]);
    var $ = nM(m, o, h), L = $.scale, z = $.realScaleType;
    L.domain(C).range(R), oM(L);
    var j = sM(L, tn(tn({}, m), {}, {
      realScaleType: z
    }));
    n === "xAxis" ? (I = f === "top" && !b || f === "bottom" && b, P = i.left, O = d[S] - I * m.height) : n === "yAxis" && (I = f === "left" && !b || f === "right" && b, P = d[S] - I * m.width, O = i.top);
    var U = tn(tn(tn({}, m), j), {}, {
      realScaleType: z,
      x: P,
      y: O,
      scale: L,
      width: n === "xAxis" ? i.width : m.width,
      height: n === "yAxis" ? i.height : m.height
    });
    return U.bandSize = Df(U, j), !m.hide && n === "xAxis" ? d[S] += (I ? -1 : 1) * U.height : m.hide || (d[S] += (I ? -1 : 1) * U.width), tn(tn({}, p), {}, Sm({}, g, U));
  }, {});
}, BM = function(t, r) {
  var i = t.x, n = t.y, o = r.x, s = r.y;
  return {
    x: Math.min(i, o),
    y: Math.min(n, s),
    width: Math.abs(o - i),
    height: Math.abs(s - n)
  };
}, ete = function(t) {
  var r = t.x1, i = t.y1, n = t.x2, o = t.y2;
  return BM({
    x: r,
    y: i
  }, {
    x: n,
    y: o
  });
}, WM = /* @__PURE__ */ function() {
  function e(t) {
    Zee(this, e), this.scale = t;
  }
  return Jee(e, [{
    key: "domain",
    get: function() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function(r) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = i.bandAware, o = i.position;
      if (r !== void 0) {
        if (o)
          switch (o) {
            case "start":
              return this.scale(r);
            case "middle": {
              var s = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(r) + s;
            }
            case "end": {
              var a = this.bandwidth ? this.bandwidth() : 0;
              return this.scale(r) + a;
            }
            default:
              return this.scale(r);
          }
        if (n) {
          var l = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(r) + l;
        }
        return this.scale(r);
      }
    }
  }, {
    key: "isInRange",
    value: function(r) {
      var i = this.range(), n = i[0], o = i[i.length - 1];
      return n <= o ? r >= n && r <= o : r >= o && r <= n;
    }
  }], [{
    key: "create",
    value: function(r) {
      return new e(r);
    }
  }]);
}();
Sm(WM, "EPS", 1e-4);
var SS = function(t) {
  var r = Object.keys(t).reduce(function(i, n) {
    return tn(tn({}, i), {}, Sm({}, n, WM.create(t[n])));
  }, {});
  return tn(tn({}, r), {}, {
    apply: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = o.bandAware, a = o.position;
      return bee(n, function(l, u) {
        return r[u].apply(l, {
          bandAware: s,
          position: a
        });
      });
    },
    isInRange: function(n) {
      return NM(n, function(o, s) {
        return r[s].isInRange(o);
      });
    }
  });
};
function tte(e) {
  return (e % 180 + 180) % 180;
}
var rte = function(t) {
  var r = t.width, i = t.height, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = tte(n), s = o * Math.PI / 180, a = Math.atan(i / r), l = s > a && s < Math.PI - a ? i / Math.sin(s) : r / Math.cos(s);
  return Math.abs(l);
}, ite = Jn, nte = ch, ote = em;
function ste(e) {
  return function(t, r, i) {
    var n = Object(t);
    if (!nte(t)) {
      var o = ite(r);
      t = ote(t), r = function(a) {
        return o(n[a], a, n);
      };
    }
    var s = e(t, r, i);
    return s > -1 ? n[o ? t[s] : s] : void 0;
  };
}
var ate = ste, lte = OM;
function ute(e) {
  var t = lte(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
var cte = ute, dte = kI, hte = Jn, pte = cte, fte = Math.max;
function gte(e, t, r) {
  var i = e == null ? 0 : e.length;
  if (!i)
    return -1;
  var n = r == null ? 0 : pte(r);
  return n < 0 && (n = fte(i + n, 0)), dte(e, hte(t), n);
}
var mte = gte, vte = ate, Cte = mte, yte = vte(Cte), bte = yte;
const wte = /* @__PURE__ */ Ct(bte);
var Ste = uH(function(e) {
  return {
    x: e.left,
    y: e.top,
    width: e.width,
    height: e.height
  };
}, function(e) {
  return ["l", e.left, "t", e.top, "w", e.width, "h", e.height].join("");
});
function zf(e) {
  "@babel/helpers - typeof";
  return zf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zf(e);
}
var ES = /* @__PURE__ */ Cn(void 0), xS = /* @__PURE__ */ Cn(void 0), $M = /* @__PURE__ */ Cn(void 0), jM = /* @__PURE__ */ Cn({}), zM = /* @__PURE__ */ Cn(void 0), UM = /* @__PURE__ */ Cn(0), YM = /* @__PURE__ */ Cn(0), uT = function(t) {
  var r = t.state, i = r.xAxisMap, n = r.yAxisMap, o = r.offset, s = t.clipPathId, a = t.children, l = t.width, u = t.height, c = Ste(o);
  return /* @__PURE__ */ D.createElement(ES.Provider, {
    value: i
  }, /* @__PURE__ */ D.createElement(xS.Provider, {
    value: n
  }, /* @__PURE__ */ D.createElement(jM.Provider, {
    value: o
  }, /* @__PURE__ */ D.createElement($M.Provider, {
    value: c
  }, /* @__PURE__ */ D.createElement(zM.Provider, {
    value: s
  }, /* @__PURE__ */ D.createElement(UM.Provider, {
    value: u
  }, /* @__PURE__ */ D.createElement(YM.Provider, {
    value: l
  }, a)))))));
}, Ete = function() {
  return bt(zM);
};
function XM(e) {
  var t = Object.keys(e);
  return t.length === 0 ? "There are no available ids." : "Available ids are: ".concat(t, ".");
}
var KM = function(t) {
  var r = bt(ES);
  r == null && (process.env.NODE_ENV !== "production" ? qr(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : qr());
  var i = r[t];
  return i == null && (process.env.NODE_ENV !== "production" ? qr(!1, 'Could not find xAxis by id "'.concat(t, '" [').concat(zf(t), "]. ").concat(XM(r))) : qr()), i;
}, xte = function() {
  var t = bt(ES);
  return Bo(t);
}, Ate = function() {
  var t = bt(xS), r = wte(t, function(i) {
    return NM(i.domain, Number.isFinite);
  });
  return r || Bo(t);
}, qM = function(t) {
  var r = bt(xS);
  r == null && (process.env.NODE_ENV !== "production" ? qr(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : qr());
  var i = r[t];
  return i == null && (process.env.NODE_ENV !== "production" ? qr(!1, 'Could not find yAxis by id "'.concat(t, '" [').concat(zf(t), "]. ").concat(XM(r))) : qr()), i;
}, Dte = function() {
  var t = bt($M);
  return t;
}, Tte = function() {
  return bt(jM);
}, AS = function() {
  return bt(YM);
}, DS = function() {
  return bt(UM);
};
function Vl(e) {
  "@babel/helpers - typeof";
  return Vl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vl(e);
}
function Rte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Pte(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, JM(i.key), i);
  }
}
function Ite(e, t, r) {
  return t && Pte(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Ote(e, t, r) {
  return t = Uf(t), Mte(e, ZM() ? Reflect.construct(t, r || [], Uf(e).constructor) : t.apply(e, r));
}
function Mte(e, t) {
  if (t && (Vl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Fte(e);
}
function Fte(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ZM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (ZM = function() {
    return !!e;
  })();
}
function Uf(e) {
  return Uf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Uf(e);
}
function _te(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && cb(e, t);
}
function cb(e, t) {
  return cb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, cb(e, t);
}
function cT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function dT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cT(Object(r), !0).forEach(function(i) {
      TS(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : cT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function TS(e, t, r) {
  return t = JM(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function JM(e) {
  var t = Nte(e, "string");
  return Vl(t) == "symbol" ? t : t + "";
}
function Nte(e, t) {
  if (Vl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Vl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function Lte(e, t) {
  return Hte(e) || Vte(e, t) || kte(e, t) || Gte();
}
function Gte() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function kte(e, t) {
  if (e) {
    if (typeof e == "string") return hT(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return hT(e, t);
  }
}
function hT(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function Vte(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function Hte(e) {
  if (Array.isArray(e)) return e;
}
function db() {
  return db = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, db.apply(this, arguments);
}
var Bte = function(t, r) {
  var i;
  return /* @__PURE__ */ D.isValidElement(t) ? i = /* @__PURE__ */ D.cloneElement(t, r) : Le(t) ? i = t(r) : i = /* @__PURE__ */ D.createElement("line", db({}, r, {
    className: "recharts-reference-line-line"
  })), i;
}, Wte = function(t, r, i, n, o, s, a, l, u) {
  var c = o.x, d = o.y, h = o.width, p = o.height;
  if (i) {
    var g = u.y, m = t.y.apply(g, {
      position: s
    });
    if (_n(u, "discard") && !t.y.isInRange(m))
      return null;
    var f = [{
      x: c + h,
      y: m
    }, {
      x: c,
      y: m
    }];
    return l === "left" ? f.reverse() : f;
  }
  if (r) {
    var C = u.x, w = t.x.apply(C, {
      position: s
    });
    if (_n(u, "discard") && !t.x.isInRange(w))
      return null;
    var E = [{
      x: w,
      y: d + p
    }, {
      x: w,
      y: d
    }];
    return a === "top" ? E.reverse() : E;
  }
  if (n) {
    var b = u.segment, y = b.map(function(S) {
      return t.apply(S, {
        position: s
      });
    });
    return _n(u, "discard") && hee(y, function(S) {
      return !t.isInRange(S);
    }) ? null : y;
  }
  return null;
};
function $te(e) {
  var t = e.x, r = e.y, i = e.segment, n = e.xAxisId, o = e.yAxisId, s = e.shape, a = e.className, l = e.alwaysShow, u = Ete(), c = KM(n), d = qM(o), h = Dte();
  if (!u || !h)
    return null;
  dn(l === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var p = SS({
    x: c.scale,
    y: d.scale
  }), g = dr(t), m = dr(r), f = i && i.length === 2, C = Wte(p, g, m, f, h, e.position, c.orientation, d.orientation, e);
  if (!C)
    return null;
  var w = Lte(C, 2), E = w[0], b = E.x, y = E.y, S = w[1], x = S.x, R = S.y, P = _n(e, "hidden") ? "url(#".concat(u, ")") : void 0, O = dT(dT({
    clipPath: P
  }, Ie(e, !0)), {}, {
    x1: b,
    y1: y,
    x2: x,
    y2: R
  });
  return /* @__PURE__ */ D.createElement(Ze, {
    className: xe("recharts-reference-line", a)
  }, Bte(s, O), gr.renderCallByParent(e, ete({
    x1: b,
    y1: y,
    x2: x,
    y2: R
  })));
}
var RS = /* @__PURE__ */ function(e) {
  function t() {
    return Rte(this, t), Ote(this, t, arguments);
  }
  return _te(t, e), Ite(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ D.createElement($te, this.props);
    }
  }]);
}(D.Component);
TS(RS, "displayName", "ReferenceLine");
TS(RS, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
});
function hb() {
  return hb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, hb.apply(this, arguments);
}
function Hl(e) {
  "@babel/helpers - typeof";
  return Hl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hl(e);
}
function pT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function fT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pT(Object(r), !0).forEach(function(i) {
      Em(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : pT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function jte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zte(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, eF(i.key), i);
  }
}
function Ute(e, t, r) {
  return t && zte(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Yte(e, t, r) {
  return t = Yf(t), Xte(e, QM() ? Reflect.construct(t, r || [], Yf(e).constructor) : t.apply(e, r));
}
function Xte(e, t) {
  if (t && (Hl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Kte(e);
}
function Kte(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function QM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (QM = function() {
    return !!e;
  })();
}
function Yf(e) {
  return Yf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Yf(e);
}
function qte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && pb(e, t);
}
function pb(e, t) {
  return pb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, pb(e, t);
}
function Em(e, t, r) {
  return t = eF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function eF(e) {
  var t = Zte(e, "string");
  return Hl(t) == "symbol" ? t : t + "";
}
function Zte(e, t) {
  if (Hl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Hl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Jte = function(t) {
  var r = t.x, i = t.y, n = t.xAxis, o = t.yAxis, s = SS({
    x: n.scale,
    y: o.scale
  }), a = s.apply({
    x: r,
    y: i
  }, {
    bandAware: !0
  });
  return _n(t, "discard") && !s.isInRange(a) ? null : a;
}, xm = /* @__PURE__ */ function(e) {
  function t() {
    return jte(this, t), Yte(this, t, arguments);
  }
  return qte(t, e), Ute(t, [{
    key: "render",
    value: function() {
      var i = this.props, n = i.x, o = i.y, s = i.r, a = i.alwaysShow, l = i.clipPathId, u = dr(n), c = dr(o);
      if (dn(a === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !u || !c)
        return null;
      var d = Jte(this.props);
      if (!d)
        return null;
      var h = d.x, p = d.y, g = this.props, m = g.shape, f = g.className, C = _n(this.props, "hidden") ? "url(#".concat(l, ")") : void 0, w = fT(fT({
        clipPath: C
      }, Ie(this.props, !0)), {}, {
        cx: h,
        cy: p
      });
      return /* @__PURE__ */ D.createElement(Ze, {
        className: xe("recharts-reference-dot", f)
      }, t.renderDot(m, w), gr.renderCallByParent(this.props, {
        x: h - s,
        y: p - s,
        width: 2 * s,
        height: 2 * s
      }));
    }
  }]);
}(D.Component);
Em(xm, "displayName", "ReferenceDot");
Em(xm, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
});
Em(xm, "renderDot", function(e, t) {
  var r;
  return /* @__PURE__ */ D.isValidElement(e) ? r = /* @__PURE__ */ D.cloneElement(e, t) : Le(e) ? r = e(t) : r = /* @__PURE__ */ D.createElement(gm, hb({}, t, {
    cx: t.cx,
    cy: t.cy,
    className: "recharts-reference-dot-dot"
  })), r;
});
function fb() {
  return fb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, fb.apply(this, arguments);
}
function Bl(e) {
  "@babel/helpers - typeof";
  return Bl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bl(e);
}
function gT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function mT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gT(Object(r), !0).forEach(function(i) {
      Am(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : gT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Qte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ere(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, rF(i.key), i);
  }
}
function tre(e, t, r) {
  return t && ere(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function rre(e, t, r) {
  return t = Xf(t), ire(e, tF() ? Reflect.construct(t, r || [], Xf(e).constructor) : t.apply(e, r));
}
function ire(e, t) {
  if (t && (Bl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return nre(e);
}
function nre(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function tF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (tF = function() {
    return !!e;
  })();
}
function Xf(e) {
  return Xf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Xf(e);
}
function ore(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && gb(e, t);
}
function gb(e, t) {
  return gb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, gb(e, t);
}
function Am(e, t, r) {
  return t = rF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function rF(e) {
  var t = sre(e, "string");
  return Bl(t) == "symbol" ? t : t + "";
}
function sre(e, t) {
  if (Bl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Bl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var are = function(t, r, i, n, o) {
  var s = o.x1, a = o.x2, l = o.y1, u = o.y2, c = o.xAxis, d = o.yAxis;
  if (!c || !d) return null;
  var h = SS({
    x: c.scale,
    y: d.scale
  }), p = {
    x: t ? h.x.apply(s, {
      position: "start"
    }) : h.x.rangeMin,
    y: i ? h.y.apply(l, {
      position: "start"
    }) : h.y.rangeMin
  }, g = {
    x: r ? h.x.apply(a, {
      position: "end"
    }) : h.x.rangeMax,
    y: n ? h.y.apply(u, {
      position: "end"
    }) : h.y.rangeMax
  };
  return _n(o, "discard") && (!h.isInRange(p) || !h.isInRange(g)) ? null : BM(p, g);
}, Dm = /* @__PURE__ */ function(e) {
  function t() {
    return Qte(this, t), rre(this, t, arguments);
  }
  return ore(t, e), tre(t, [{
    key: "render",
    value: function() {
      var i = this.props, n = i.x1, o = i.x2, s = i.y1, a = i.y2, l = i.className, u = i.alwaysShow, c = i.clipPathId;
      dn(u === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      var d = dr(n), h = dr(o), p = dr(s), g = dr(a), m = this.props.shape;
      if (!d && !h && !p && !g && !m)
        return null;
      var f = are(d, h, p, g, this.props);
      if (!f && !m)
        return null;
      var C = _n(this.props, "hidden") ? "url(#".concat(c, ")") : void 0;
      return /* @__PURE__ */ D.createElement(Ze, {
        className: xe("recharts-reference-area", l)
      }, t.renderRect(m, mT(mT({
        clipPath: C
      }, Ie(this.props, !0)), f)), gr.renderCallByParent(this.props, f));
    }
  }]);
}(D.Component);
Am(Dm, "displayName", "ReferenceArea");
Am(Dm, "defaultProps", {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
});
Am(Dm, "renderRect", function(e, t) {
  var r;
  return /* @__PURE__ */ D.isValidElement(e) ? r = /* @__PURE__ */ D.cloneElement(e, t) : Le(e) ? r = e(t) : r = /* @__PURE__ */ D.createElement(wS, fb({}, t, {
    className: "recharts-reference-area-rect"
  })), r;
});
function iF(e, t, r) {
  if (t < 1)
    return [];
  if (t === 1 && r === void 0)
    return e;
  for (var i = [], n = 0; n < e.length; n += t)
    i.push(e[n]);
  return i;
}
function lre(e, t, r) {
  var i = {
    width: e.width + t.width,
    height: e.height + t.height
  };
  return rte(i, r);
}
function ure(e, t, r) {
  var i = r === "width", n = e.x, o = e.y, s = e.width, a = e.height;
  return t === 1 ? {
    start: i ? n : o,
    end: i ? n + s : o + a
  } : {
    start: i ? n + s : o + a,
    end: i ? n : o
  };
}
function Kf(e, t, r, i, n) {
  if (e * t < e * i || e * t > e * n)
    return !1;
  var o = r();
  return e * (t - e * o / 2 - i) >= 0 && e * (t + e * o / 2 - n) <= 0;
}
function cre(e, t) {
  return iF(e, t + 1);
}
function dre(e, t, r, i, n) {
  for (var o = (i || []).slice(), s = t.start, a = t.end, l = 0, u = 1, c = s, d = function() {
    var g = i == null ? void 0 : i[l];
    if (g === void 0)
      return {
        v: iF(i, u)
      };
    var m = l, f, C = function() {
      return f === void 0 && (f = r(g, m)), f;
    }, w = g.coordinate, E = l === 0 || Kf(e, w, C, c, a);
    E || (l = 0, c = s, u += 1), E && (c = w + e * (C() / 2 + n), l += u);
  }, h; u <= o.length; )
    if (h = d(), h) return h.v;
  return [];
}
function Ed(e) {
  "@babel/helpers - typeof";
  return Ed = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ed(e);
}
function vT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Ar(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vT(Object(r), !0).forEach(function(i) {
      hre(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : vT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function hre(e, t, r) {
  return t = pre(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function pre(e) {
  var t = fre(e, "string");
  return Ed(t) == "symbol" ? t : t + "";
}
function fre(e, t) {
  if (Ed(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ed(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function gre(e, t, r, i, n) {
  for (var o = (i || []).slice(), s = o.length, a = t.start, l = t.end, u = function(h) {
    var p = o[h], g, m = function() {
      return g === void 0 && (g = r(p, h)), g;
    };
    if (h === s - 1) {
      var f = e * (p.coordinate + e * m() / 2 - l);
      o[h] = p = Ar(Ar({}, p), {}, {
        tickCoord: f > 0 ? p.coordinate - f * e : p.coordinate
      });
    } else
      o[h] = p = Ar(Ar({}, p), {}, {
        tickCoord: p.coordinate
      });
    var C = Kf(e, p.tickCoord, m, a, l);
    C && (l = p.tickCoord - e * (m() / 2 + n), o[h] = Ar(Ar({}, p), {}, {
      isShow: !0
    }));
  }, c = s - 1; c >= 0; c--)
    u(c);
  return o;
}
function mre(e, t, r, i, n, o) {
  var s = (i || []).slice(), a = s.length, l = t.start, u = t.end;
  if (o) {
    var c = i[a - 1], d = r(c, a - 1), h = e * (c.coordinate + e * d / 2 - u);
    s[a - 1] = c = Ar(Ar({}, c), {}, {
      tickCoord: h > 0 ? c.coordinate - h * e : c.coordinate
    });
    var p = Kf(e, c.tickCoord, function() {
      return d;
    }, l, u);
    p && (u = c.tickCoord - e * (d / 2 + n), s[a - 1] = Ar(Ar({}, c), {}, {
      isShow: !0
    }));
  }
  for (var g = o ? a - 1 : a, m = function(w) {
    var E = s[w], b, y = function() {
      return b === void 0 && (b = r(E, w)), b;
    };
    if (w === 0) {
      var S = e * (E.coordinate - e * y() / 2 - l);
      s[w] = E = Ar(Ar({}, E), {}, {
        tickCoord: S < 0 ? E.coordinate - S * e : E.coordinate
      });
    } else
      s[w] = E = Ar(Ar({}, E), {}, {
        tickCoord: E.coordinate
      });
    var x = Kf(e, E.tickCoord, y, l, u);
    x && (l = E.tickCoord + e * (y() / 2 + n), s[w] = Ar(Ar({}, E), {}, {
      isShow: !0
    }));
  }, f = 0; f < g; f++)
    m(f);
  return s;
}
function PS(e, t, r) {
  var i = e.tick, n = e.ticks, o = e.viewBox, s = e.minTickGap, a = e.orientation, l = e.interval, u = e.tickFormatter, c = e.unit, d = e.angle;
  if (!n || !n.length || !i)
    return [];
  if (ue(l) || Da.isSsr)
    return cre(n, typeof l == "number" && ue(l) ? l : 0);
  var h = [], p = a === "top" || a === "bottom" ? "width" : "height", g = c && p === "width" ? Fc(c, {
    fontSize: t,
    letterSpacing: r
  }) : {
    width: 0,
    height: 0
  }, m = function(E, b) {
    var y = Le(u) ? u(E.value, b) : E.value;
    return p === "width" ? lre(Fc(y, {
      fontSize: t,
      letterSpacing: r
    }), g, d) : Fc(y, {
      fontSize: t,
      letterSpacing: r
    })[p];
  }, f = n.length >= 2 ? Nr(n[1].coordinate - n[0].coordinate) : 1, C = ure(o, f, p);
  return l === "equidistantPreserveStart" ? dre(f, C, m, n, s) : (l === "preserveStart" || l === "preserveStartEnd" ? h = mre(f, C, m, n, s, l === "preserveStartEnd") : h = gre(f, C, m, n, s), h.filter(function(w) {
    return w.isShow;
  }));
}
var vre = ["viewBox"], Cre = ["viewBox"], yre = ["ticks"];
function Wl(e) {
  "@babel/helpers - typeof";
  return Wl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wl(e);
}
function ul() {
  return ul = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ul.apply(this, arguments);
}
function CT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function sr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CT(Object(r), !0).forEach(function(i) {
      IS(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : CT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function iC(e, t) {
  if (e == null) return {};
  var r = bre(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function bre(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function wre(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yT(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, oF(i.key), i);
  }
}
function Sre(e, t, r) {
  return t && yT(e.prototype, t), r && yT(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Ere(e, t, r) {
  return t = qf(t), xre(e, nF() ? Reflect.construct(t, r || [], qf(e).constructor) : t.apply(e, r));
}
function xre(e, t) {
  if (t && (Wl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Are(e);
}
function Are(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function nF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (nF = function() {
    return !!e;
  })();
}
function qf(e) {
  return qf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, qf(e);
}
function Dre(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && mb(e, t);
}
function mb(e, t) {
  return mb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, mb(e, t);
}
function IS(e, t, r) {
  return t = oF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function oF(e) {
  var t = Tre(e, "string");
  return Wl(t) == "symbol" ? t : t + "";
}
function Tre(e, t) {
  if (Wl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Wl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Nu = /* @__PURE__ */ function(e) {
  function t(r) {
    var i;
    return wre(this, t), i = Ere(this, t, [r]), i.state = {
      fontSize: "",
      letterSpacing: ""
    }, i;
  }
  return Dre(t, e), Sre(t, [{
    key: "shouldComponentUpdate",
    value: function(i, n) {
      var o = i.viewBox, s = iC(i, vre), a = this.props, l = a.viewBox, u = iC(a, Cre);
      return !pl(o, l) || !pl(s, u) || !pl(n, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function() {
      var i = this.layerReference;
      if (i) {
        var n = i.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
        n && this.setState({
          fontSize: window.getComputedStyle(n).fontSize,
          letterSpacing: window.getComputedStyle(n).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function(i) {
      var n = this.props, o = n.x, s = n.y, a = n.width, l = n.height, u = n.orientation, c = n.tickSize, d = n.mirror, h = n.tickMargin, p, g, m, f, C, w, E = d ? -1 : 1, b = i.tickSize || c, y = ue(i.tickCoord) ? i.tickCoord : i.coordinate;
      switch (u) {
        case "top":
          p = g = i.coordinate, f = s + +!d * l, m = f - E * b, w = m - E * h, C = y;
          break;
        case "left":
          m = f = i.coordinate, g = o + +!d * a, p = g - E * b, C = p - E * h, w = y;
          break;
        case "right":
          m = f = i.coordinate, g = o + +d * a, p = g + E * b, C = p + E * h, w = y;
          break;
        default:
          p = g = i.coordinate, f = s + +d * l, m = f + E * b, w = m + E * h, C = y;
          break;
      }
      return {
        line: {
          x1: p,
          y1: m,
          x2: g,
          y2: f
        },
        tick: {
          x: C,
          y: w
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function() {
      var i = this.props, n = i.orientation, o = i.mirror, s;
      switch (n) {
        case "left":
          s = o ? "start" : "end";
          break;
        case "right":
          s = o ? "end" : "start";
          break;
        default:
          s = "middle";
          break;
      }
      return s;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function() {
      var i = this.props, n = i.orientation, o = i.mirror, s = "end";
      switch (n) {
        case "left":
        case "right":
          s = "middle";
          break;
        case "top":
          s = o ? "start" : "end";
          break;
        default:
          s = o ? "end" : "start";
          break;
      }
      return s;
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var i = this.props, n = i.x, o = i.y, s = i.width, a = i.height, l = i.orientation, u = i.mirror, c = i.axisLine, d = sr(sr(sr({}, Ie(this.props, !1)), Ie(c, !1)), {}, {
        fill: "none"
      });
      if (l === "top" || l === "bottom") {
        var h = +(l === "top" && !u || l === "bottom" && u);
        d = sr(sr({}, d), {}, {
          x1: n,
          y1: o + h * a,
          x2: n + s,
          y2: o + h * a
        });
      } else {
        var p = +(l === "left" && !u || l === "right" && u);
        d = sr(sr({}, d), {}, {
          x1: n + p * s,
          y1: o,
          x2: n + p * s,
          y2: o + a
        });
      }
      return /* @__PURE__ */ D.createElement("line", ul({}, d, {
        className: xe("recharts-cartesian-axis-line", vi(c, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function(i, n, o) {
        var s = this, a = this.props, l = a.tickLine, u = a.stroke, c = a.tick, d = a.tickFormatter, h = a.unit, p = PS(sr(sr({}, this.props), {}, {
          ticks: i
        }), n, o), g = this.getTickTextAnchor(), m = this.getTickVerticalAnchor(), f = Ie(this.props, !1), C = Ie(c, !1), w = sr(sr({}, f), {}, {
          fill: "none"
        }, Ie(l, !1)), E = p.map(function(b, y) {
          var S = s.getTickLineCoord(b), x = S.line, R = S.tick, P = sr(sr(sr(sr({
            textAnchor: g,
            verticalAnchor: m
          }, f), {}, {
            stroke: "none",
            fill: u
          }, C), R), {}, {
            index: y,
            payload: b,
            visibleTicksCount: p.length,
            tickFormatter: d
          });
          return /* @__PURE__ */ D.createElement(Ze, ul({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(b.value, "-").concat(b.coordinate, "-").concat(b.tickCoord)
          }, na(s.props, b, y)), l && /* @__PURE__ */ D.createElement("line", ul({}, w, x, {
            className: xe("recharts-cartesian-axis-tick-line", vi(l, "className"))
          })), c && t.renderTickItem(c, P, "".concat(Le(d) ? d(b.value, y) : b.value).concat(h || "")));
        });
        return /* @__PURE__ */ D.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, E);
      }
    )
  }, {
    key: "render",
    value: function() {
      var i = this, n = this.props, o = n.axisLine, s = n.width, a = n.height, l = n.ticksGenerator, u = n.className, c = n.hide;
      if (c)
        return null;
      var d = this.props, h = d.ticks, p = iC(d, yre), g = h;
      return Le(l) && (g = h && h.length > 0 ? l(this.props) : l(p)), s <= 0 || a <= 0 || !g || !g.length ? null : /* @__PURE__ */ D.createElement(Ze, {
        className: xe("recharts-cartesian-axis", u),
        ref: function(f) {
          i.layerReference = f;
        }
      }, o && this.renderAxisLine(), this.renderTicks(g, this.state.fontSize, this.state.letterSpacing), gr.renderCallByParent(this.props));
    }
  }], [{
    key: "renderTickItem",
    value: function(i, n, o) {
      var s, a = xe(n.className, "recharts-cartesian-axis-tick-value");
      return /* @__PURE__ */ D.isValidElement(i) ? s = /* @__PURE__ */ D.cloneElement(i, sr(sr({}, n), {}, {
        className: a
      })) : Le(i) ? s = i(sr(sr({}, n), {}, {
        className: a
      })) : s = /* @__PURE__ */ D.createElement(oa, ul({}, n, {
        className: "recharts-cartesian-axis-tick-value"
      }), o), s;
    }
  }]);
}($t);
IS(Nu, "displayName", "CartesianAxis");
IS(Nu, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var Rre = ["x1", "y1", "x2", "y2", "key"], Pre = ["offset"];
function aa(e) {
  "@babel/helpers - typeof";
  return aa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, aa(e);
}
function bT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Dr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bT(Object(r), !0).forEach(function(i) {
      Ire(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : bT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Ire(e, t, r) {
  return t = Ore(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Ore(e) {
  var t = Mre(e, "string");
  return aa(t) == "symbol" ? t : t + "";
}
function Mre(e, t) {
  if (aa(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (aa(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Gs() {
  return Gs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Gs.apply(this, arguments);
}
function wT(e, t) {
  if (e == null) return {};
  var r = Fre(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function Fre(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
var _re = function(t) {
  var r = t.fill;
  if (!r || r === "none")
    return null;
  var i = t.fillOpacity, n = t.x, o = t.y, s = t.width, a = t.height, l = t.ry;
  return /* @__PURE__ */ D.createElement("rect", {
    x: n,
    y: o,
    ry: l,
    width: s,
    height: a,
    stroke: "none",
    fill: r,
    fillOpacity: i,
    className: "recharts-cartesian-grid-bg"
  });
};
function sF(e, t) {
  var r;
  if (/* @__PURE__ */ D.isValidElement(e))
    r = /* @__PURE__ */ D.cloneElement(e, t);
  else if (Le(e))
    r = e(t);
  else {
    var i = t.x1, n = t.y1, o = t.x2, s = t.y2, a = t.key, l = wT(t, Rre), u = Ie(l, !1);
    u.offset;
    var c = wT(u, Pre);
    r = /* @__PURE__ */ D.createElement("line", Gs({}, c, {
      x1: i,
      y1: n,
      x2: o,
      y2: s,
      fill: "none",
      key: a
    }));
  }
  return r;
}
function Nre(e) {
  var t = e.x, r = e.width, i = e.horizontal, n = i === void 0 ? !0 : i, o = e.horizontalPoints;
  if (!n || !o || !o.length)
    return null;
  var s = o.map(function(a, l) {
    var u = Dr(Dr({}, e), {}, {
      x1: t,
      y1: a,
      x2: t + r,
      y2: a,
      key: "line-".concat(l),
      index: l
    });
    return sF(n, u);
  });
  return /* @__PURE__ */ D.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, s);
}
function Lre(e) {
  var t = e.y, r = e.height, i = e.vertical, n = i === void 0 ? !0 : i, o = e.verticalPoints;
  if (!n || !o || !o.length)
    return null;
  var s = o.map(function(a, l) {
    var u = Dr(Dr({}, e), {}, {
      x1: a,
      y1: t,
      x2: a,
      y2: t + r,
      key: "line-".concat(l),
      index: l
    });
    return sF(n, u);
  });
  return /* @__PURE__ */ D.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, s);
}
function Gre(e) {
  var t = e.horizontalFill, r = e.fillOpacity, i = e.x, n = e.y, o = e.width, s = e.height, a = e.horizontalPoints, l = e.horizontal, u = l === void 0 ? !0 : l;
  if (!u || !t || !t.length)
    return null;
  var c = a.map(function(h) {
    return Math.round(h + n - n);
  }).sort(function(h, p) {
    return h - p;
  });
  n !== c[0] && c.unshift(0);
  var d = c.map(function(h, p) {
    var g = !c[p + 1], m = g ? n + s - h : c[p + 1] - h;
    if (m <= 0)
      return null;
    var f = p % t.length;
    return /* @__PURE__ */ D.createElement("rect", {
      key: "react-".concat(p),
      y: h,
      x: i,
      height: m,
      width: o,
      stroke: "none",
      fill: t[f],
      fillOpacity: r,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ D.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, d);
}
function kre(e) {
  var t = e.vertical, r = t === void 0 ? !0 : t, i = e.verticalFill, n = e.fillOpacity, o = e.x, s = e.y, a = e.width, l = e.height, u = e.verticalPoints;
  if (!r || !i || !i.length)
    return null;
  var c = u.map(function(h) {
    return Math.round(h + o - o);
  }).sort(function(h, p) {
    return h - p;
  });
  o !== c[0] && c.unshift(0);
  var d = c.map(function(h, p) {
    var g = !c[p + 1], m = g ? o + a - h : c[p + 1] - h;
    if (m <= 0)
      return null;
    var f = p % i.length;
    return /* @__PURE__ */ D.createElement("rect", {
      key: "react-".concat(p),
      x: h,
      y: s,
      width: m,
      height: l,
      stroke: "none",
      fill: i[f],
      fillOpacity: n,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ D.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, d);
}
var Vre = function(t, r) {
  var i = t.xAxis, n = t.width, o = t.height, s = t.offset;
  return iM(PS(Dr(Dr(Dr({}, Nu.defaultProps), i), {}, {
    ticks: ao(i, !0),
    viewBox: {
      x: 0,
      y: 0,
      width: n,
      height: o
    }
  })), s.left, s.left + s.width, r);
}, Hre = function(t, r) {
  var i = t.yAxis, n = t.width, o = t.height, s = t.offset;
  return iM(PS(Dr(Dr(Dr({}, Nu.defaultProps), i), {}, {
    ticks: ao(i, !0),
    viewBox: {
      x: 0,
      y: 0,
      width: n,
      height: o
    }
  })), s.top, s.top + s.height, r);
}, Ka = {
  horizontal: !0,
  vertical: !0,
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: []
};
function OS(e) {
  var t, r, i, n, o, s, a = AS(), l = DS(), u = Tte(), c = Dr(Dr({}, e), {}, {
    stroke: (t = e.stroke) !== null && t !== void 0 ? t : Ka.stroke,
    fill: (r = e.fill) !== null && r !== void 0 ? r : Ka.fill,
    horizontal: (i = e.horizontal) !== null && i !== void 0 ? i : Ka.horizontal,
    horizontalFill: (n = e.horizontalFill) !== null && n !== void 0 ? n : Ka.horizontalFill,
    vertical: (o = e.vertical) !== null && o !== void 0 ? o : Ka.vertical,
    verticalFill: (s = e.verticalFill) !== null && s !== void 0 ? s : Ka.verticalFill,
    x: ue(e.x) ? e.x : u.left,
    y: ue(e.y) ? e.y : u.top,
    width: ue(e.width) ? e.width : u.width,
    height: ue(e.height) ? e.height : u.height
  }), d = c.x, h = c.y, p = c.width, g = c.height, m = c.syncWithTicks, f = c.horizontalValues, C = c.verticalValues, w = xte(), E = Ate();
  if (!ue(p) || p <= 0 || !ue(g) || g <= 0 || !ue(d) || d !== +d || !ue(h) || h !== +h)
    return null;
  var b = c.verticalCoordinatesGenerator || Vre, y = c.horizontalCoordinatesGenerator || Hre, S = c.horizontalPoints, x = c.verticalPoints;
  if ((!S || !S.length) && Le(y)) {
    var R = f && f.length, P = y({
      yAxis: E ? Dr(Dr({}, E), {}, {
        ticks: R ? f : E.ticks
      }) : void 0,
      width: a,
      height: l,
      offset: u
    }, R ? !0 : m);
    dn(Array.isArray(P), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(aa(P), "]")), Array.isArray(P) && (S = P);
  }
  if ((!x || !x.length) && Le(b)) {
    var O = C && C.length, I = b({
      xAxis: w ? Dr(Dr({}, w), {}, {
        ticks: O ? C : w.ticks
      }) : void 0,
      width: a,
      height: l,
      offset: u
    }, O ? !0 : m);
    dn(Array.isArray(I), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(aa(I), "]")), Array.isArray(I) && (x = I);
  }
  return /* @__PURE__ */ D.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ D.createElement(_re, {
    fill: c.fill,
    fillOpacity: c.fillOpacity,
    x: c.x,
    y: c.y,
    width: c.width,
    height: c.height,
    ry: c.ry
  }), /* @__PURE__ */ D.createElement(Nre, Gs({}, c, {
    offset: u,
    horizontalPoints: S,
    xAxis: w,
    yAxis: E
  })), /* @__PURE__ */ D.createElement(Lre, Gs({}, c, {
    offset: u,
    verticalPoints: x,
    xAxis: w,
    yAxis: E
  })), /* @__PURE__ */ D.createElement(Gre, Gs({}, c, {
    horizontalPoints: S
  })), /* @__PURE__ */ D.createElement(kre, Gs({}, c, {
    verticalPoints: x
  })));
}
OS.displayName = "CartesianGrid";
var Bre = ["type", "layout", "connectNulls", "ref"], Wre = ["key"];
function $l(e) {
  "@babel/helpers - typeof";
  return $l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $l(e);
}
function ST(e, t) {
  if (e == null) return {};
  var r = $re(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function $re(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function Vc() {
  return Vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Vc.apply(this, arguments);
}
function ET(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function ci(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ET(Object(r), !0).forEach(function(i) {
      rn(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ET(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function qa(e) {
  return Yre(e) || Ure(e) || zre(e) || jre();
}
function jre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function zre(e, t) {
  if (e) {
    if (typeof e == "string") return vb(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return vb(e, t);
  }
}
function Ure(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Yre(e) {
  if (Array.isArray(e)) return vb(e);
}
function vb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function Xre(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xT(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, lF(i.key), i);
  }
}
function Kre(e, t, r) {
  return t && xT(e.prototype, t), r && xT(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function qre(e, t, r) {
  return t = Zf(t), Zre(e, aF() ? Reflect.construct(t, r || [], Zf(e).constructor) : t.apply(e, r));
}
function Zre(e, t) {
  if (t && ($l(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Jre(e);
}
function Jre(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function aF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (aF = function() {
    return !!e;
  })();
}
function Zf(e) {
  return Zf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Zf(e);
}
function Qre(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Cb(e, t);
}
function Cb(e, t) {
  return Cb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Cb(e, t);
}
function rn(e, t, r) {
  return t = lF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function lF(e) {
  var t = eie(e, "string");
  return $l(t) == "symbol" ? t : t + "";
}
function eie(e, t) {
  if ($l(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if ($l(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var vh = /* @__PURE__ */ function(e) {
  function t() {
    var r;
    Xre(this, t);
    for (var i = arguments.length, n = new Array(i), o = 0; o < i; o++)
      n[o] = arguments[o];
    return r = qre(this, t, [].concat(n)), rn(r, "state", {
      isAnimationFinished: !0,
      totalLength: 0
    }), rn(r, "generateSimpleStrokeDasharray", function(s, a) {
      return "".concat(a, "px ").concat(s - a, "px");
    }), rn(r, "getStrokeDasharray", function(s, a, l) {
      var u = l.reduce(function(C, w) {
        return C + w;
      });
      if (!u)
        return r.generateSimpleStrokeDasharray(a, s);
      for (var c = Math.floor(s / u), d = s % u, h = a - s, p = [], g = 0, m = 0; g < l.length; m += l[g], ++g)
        if (m + l[g] > d) {
          p = [].concat(qa(l.slice(0, g)), [d - m]);
          break;
        }
      var f = p.length % 2 === 0 ? [0, h] : [h];
      return [].concat(qa(t.repeat(l, c)), qa(p), f).map(function(C) {
        return "".concat(C, "px");
      }).join(", ");
    }), rn(r, "id", Ru("recharts-line-")), rn(r, "pathRef", function(s) {
      r.mainCurve = s;
    }), rn(r, "handleAnimationEnd", function() {
      r.setState({
        isAnimationFinished: !0
      }), r.props.onAnimationEnd && r.props.onAnimationEnd();
    }), rn(r, "handleAnimationStart", function() {
      r.setState({
        isAnimationFinished: !1
      }), r.props.onAnimationStart && r.props.onAnimationStart();
    }), r;
  }
  return Qre(t, e), Kre(t, [{
    key: "componentDidMount",
    value: function() {
      if (this.props.isAnimationActive) {
        var i = this.getTotalLength();
        this.setState({
          totalLength: i
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      if (this.props.isAnimationActive) {
        var i = this.getTotalLength();
        i !== this.state.totalLength && this.setState({
          totalLength: i
        });
      }
    }
  }, {
    key: "getTotalLength",
    value: function() {
      var i = this.mainCurve;
      try {
        return i && i.getTotalLength && i.getTotalLength() || 0;
      } catch {
        return 0;
      }
    }
  }, {
    key: "renderErrorBar",
    value: function(i, n) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished)
        return null;
      var o = this.props, s = o.points, a = o.xAxis, l = o.yAxis, u = o.layout, c = o.children, d = Ci(c, mh);
      if (!d)
        return null;
      var h = function(m, f) {
        return {
          x: m.x,
          y: m.y,
          value: m.value,
          errorVal: cr(m.payload, f)
        };
      }, p = {
        clipPath: i ? "url(#clipPath-".concat(n, ")") : null
      };
      return /* @__PURE__ */ D.createElement(Ze, p, d.map(function(g) {
        return /* @__PURE__ */ D.cloneElement(g, {
          key: "bar-".concat(g.props.dataKey),
          data: s,
          xAxis: a,
          yAxis: l,
          layout: u,
          dataPointFormatter: h
        });
      }));
    }
  }, {
    key: "renderDots",
    value: function(i, n, o) {
      var s = this.props.isAnimationActive;
      if (s && !this.state.isAnimationFinished)
        return null;
      var a = this.props, l = a.dot, u = a.points, c = a.dataKey, d = Ie(this.props, !1), h = Ie(l, !0), p = u.map(function(m, f) {
        var C = ci(ci(ci({
          key: "dot-".concat(f),
          r: 3
        }, d), h), {}, {
          index: f,
          cx: m.x,
          cy: m.y,
          value: m.value,
          dataKey: c,
          payload: m.payload,
          points: u
        });
        return t.renderDotItem(l, C);
      }), g = {
        clipPath: i ? "url(#clipPath-".concat(n ? "" : "dots-").concat(o, ")") : null
      };
      return /* @__PURE__ */ D.createElement(Ze, Vc({
        className: "recharts-line-dots",
        key: "dots"
      }, g), p);
    }
  }, {
    key: "renderCurveStatically",
    value: function(i, n, o, s) {
      var a = this.props, l = a.type, u = a.layout, c = a.connectNulls;
      a.ref;
      var d = ST(a, Bre), h = ci(ci(ci({}, Ie(d, !0)), {}, {
        fill: "none",
        className: "recharts-line-curve",
        clipPath: n ? "url(#clipPath-".concat(o, ")") : null,
        points: i
      }, s), {}, {
        type: l,
        layout: u,
        connectNulls: c
      });
      return /* @__PURE__ */ D.createElement(Pf, Vc({}, h, {
        pathRef: this.pathRef
      }));
    }
  }, {
    key: "renderCurveWithAnimation",
    value: function(i, n) {
      var o = this, s = this.props, a = s.points, l = s.strokeDasharray, u = s.isAnimationActive, c = s.animationBegin, d = s.animationDuration, h = s.animationEasing, p = s.animationId, g = s.animateNewValues, m = s.width, f = s.height, C = this.state, w = C.prevPoints, E = C.totalLength;
      return /* @__PURE__ */ D.createElement($n, {
        begin: c,
        duration: d,
        isActive: u,
        easing: h,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "line-".concat(p),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(b) {
        var y = b.t;
        if (w) {
          var S = w.length / a.length, x = a.map(function(M, _) {
            var G = Math.floor(_ * S);
            if (w[G]) {
              var F = w[G], N = fi(F.x, M.x), V = fi(F.y, M.y);
              return ci(ci({}, M), {}, {
                x: N(y),
                y: V(y)
              });
            }
            if (g) {
              var B = fi(m * 2, M.x), $ = fi(f / 2, M.y);
              return ci(ci({}, M), {}, {
                x: B(y),
                y: $(y)
              });
            }
            return ci(ci({}, M), {}, {
              x: M.x,
              y: M.y
            });
          });
          return o.renderCurveStatically(x, i, n);
        }
        var R = fi(0, E), P = R(y), O;
        if (l) {
          var I = "".concat(l).split(/[,\s]+/gim).map(function(M) {
            return parseFloat(M);
          });
          O = o.getStrokeDasharray(P, E, I);
        } else
          O = o.generateSimpleStrokeDasharray(E, P);
        return o.renderCurveStatically(a, i, n, {
          strokeDasharray: O
        });
      });
    }
  }, {
    key: "renderCurve",
    value: function(i, n) {
      var o = this.props, s = o.points, a = o.isAnimationActive, l = this.state, u = l.prevPoints, c = l.totalLength;
      return a && s && s.length && (!u && c > 0 || !gh(u, s)) ? this.renderCurveWithAnimation(i, n) : this.renderCurveStatically(s, i, n);
    }
  }, {
    key: "render",
    value: function() {
      var i, n = this.props, o = n.hide, s = n.dot, a = n.points, l = n.className, u = n.xAxis, c = n.yAxis, d = n.top, h = n.left, p = n.width, g = n.height, m = n.isAnimationActive, f = n.id;
      if (o || !a || !a.length)
        return null;
      var C = this.state.isAnimationFinished, w = a.length === 1, E = xe("recharts-line", l), b = u && u.allowDataOverflow, y = c && c.allowDataOverflow, S = b || y, x = ke(f) ? this.id : f, R = (i = Ie(s, !1)) !== null && i !== void 0 ? i : {
        r: 3,
        strokeWidth: 2
      }, P = R.r, O = P === void 0 ? 3 : P, I = R.strokeWidth, M = I === void 0 ? 2 : I, _ = gB(s) ? s : {}, G = _.clipDot, F = G === void 0 ? !0 : G, N = O * 2 + M;
      return /* @__PURE__ */ D.createElement(Ze, {
        className: E
      }, b || y ? /* @__PURE__ */ D.createElement("defs", null, /* @__PURE__ */ D.createElement("clipPath", {
        id: "clipPath-".concat(x)
      }, /* @__PURE__ */ D.createElement("rect", {
        x: b ? h : h - p / 2,
        y: y ? d : d - g / 2,
        width: b ? p : p * 2,
        height: y ? g : g * 2
      })), !F && /* @__PURE__ */ D.createElement("clipPath", {
        id: "clipPath-dots-".concat(x)
      }, /* @__PURE__ */ D.createElement("rect", {
        x: h - N / 2,
        y: d - N / 2,
        width: p + N,
        height: g + N
      }))) : null, !w && this.renderCurve(S, x), this.renderErrorBar(S, x), (w || s) && this.renderDots(S, F, x), (!m || C) && ho.renderCallByParent(this.props, a));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, n) {
      return i.animationId !== n.prevAnimationId ? {
        prevAnimationId: i.animationId,
        curPoints: i.points,
        prevPoints: n.curPoints
      } : i.points !== n.curPoints ? {
        curPoints: i.points
      } : null;
    }
  }, {
    key: "repeat",
    value: function(i, n) {
      for (var o = i.length % 2 !== 0 ? [].concat(qa(i), [0]) : i, s = [], a = 0; a < n; ++a)
        s = [].concat(qa(s), qa(o));
      return s;
    }
  }, {
    key: "renderDotItem",
    value: function(i, n) {
      var o;
      if (/* @__PURE__ */ D.isValidElement(i))
        o = /* @__PURE__ */ D.cloneElement(i, n);
      else if (Le(i))
        o = i(n);
      else {
        var s = n.key, a = ST(n, Wre), l = xe("recharts-line-dot", typeof i != "boolean" ? i.className : "");
        o = /* @__PURE__ */ D.createElement(gm, Vc({
          key: s
        }, a, {
          className: l
        }));
      }
      return o;
    }
  }]);
}(vn);
rn(vh, "displayName", "Line");
rn(vh, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  connectNulls: !1,
  activeDot: !0,
  dot: !0,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  fill: "#fff",
  points: [],
  isAnimationActive: !Da.isSsr,
  animateNewValues: !0,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  hide: !1,
  label: !1
});
rn(vh, "getComposedData", function(e) {
  var t = e.props, r = e.xAxis, i = e.yAxis, n = e.xAxisTicks, o = e.yAxisTicks, s = e.dataKey, a = e.bandSize, l = e.displayedData, u = e.offset, c = t.layout, d = l.map(function(h, p) {
    var g = cr(h, s);
    return c === "horizontal" ? {
      x: HA({
        axis: r,
        ticks: n,
        bandSize: a,
        entry: h,
        index: p
      }),
      y: ke(g) ? null : i.scale(g),
      value: g,
      payload: h
    } : {
      x: ke(g) ? null : r.scale(g),
      y: HA({
        axis: i,
        ticks: o,
        bandSize: a,
        entry: h,
        index: p
      }),
      value: g,
      payload: h
    };
  });
  return ci({
    points: d,
    layout: c
  }, u);
});
function jl(e) {
  "@babel/helpers - typeof";
  return jl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jl(e);
}
function tie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rie(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, dF(i.key), i);
  }
}
function iie(e, t, r) {
  return t && rie(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function nie(e, t, r) {
  return t = Jf(t), oie(e, uF() ? Reflect.construct(t, r || [], Jf(e).constructor) : t.apply(e, r));
}
function oie(e, t) {
  if (t && (jl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return sie(e);
}
function sie(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function uF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (uF = function() {
    return !!e;
  })();
}
function Jf(e) {
  return Jf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Jf(e);
}
function aie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && yb(e, t);
}
function yb(e, t) {
  return yb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, yb(e, t);
}
function cF(e, t, r) {
  return t = dF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function dF(e) {
  var t = lie(e, "string");
  return jl(t) == "symbol" ? t : t + "";
}
function lie(e, t) {
  if (jl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (jl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function bb() {
  return bb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, bb.apply(this, arguments);
}
function uie(e) {
  var t = e.xAxisId, r = AS(), i = DS(), n = KM(t);
  return n == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ Y.createElement(Nu, bb({}, n, {
      className: xe("recharts-".concat(n.axisType, " ").concat(n.axisType), n.className),
      viewBox: {
        x: 0,
        y: 0,
        width: r,
        height: i
      },
      ticksGenerator: function(s) {
        return ao(s, !0);
      }
    }))
  );
}
var Lu = /* @__PURE__ */ function(e) {
  function t() {
    return tie(this, t), nie(this, t, arguments);
  }
  return aie(t, e), iie(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ Y.createElement(uie, this.props);
    }
  }]);
}(Y.Component);
cF(Lu, "displayName", "XAxis");
cF(Lu, "defaultProps", {
  allowDecimals: !0,
  hide: !1,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: !1,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1,
  allowDuplicatedCategory: !0
});
function zl(e) {
  "@babel/helpers - typeof";
  return zl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zl(e);
}
function cie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function die(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, fF(i.key), i);
  }
}
function hie(e, t, r) {
  return t && die(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function pie(e, t, r) {
  return t = Qf(t), fie(e, hF() ? Reflect.construct(t, r || [], Qf(e).constructor) : t.apply(e, r));
}
function fie(e, t) {
  if (t && (zl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return gie(e);
}
function gie(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function hF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (hF = function() {
    return !!e;
  })();
}
function Qf(e) {
  return Qf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Qf(e);
}
function mie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && wb(e, t);
}
function wb(e, t) {
  return wb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, wb(e, t);
}
function pF(e, t, r) {
  return t = fF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function fF(e) {
  var t = vie(e, "string");
  return zl(t) == "symbol" ? t : t + "";
}
function vie(e, t) {
  if (zl(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (zl(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function Sb() {
  return Sb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Sb.apply(this, arguments);
}
var Cie = function(t) {
  var r = t.yAxisId, i = AS(), n = DS(), o = qM(r);
  return o == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ Y.createElement(Nu, Sb({}, o, {
      className: xe("recharts-".concat(o.axisType, " ").concat(o.axisType), o.className),
      viewBox: {
        x: 0,
        y: 0,
        width: i,
        height: n
      },
      ticksGenerator: function(a) {
        return ao(a, !0);
      }
    }))
  );
}, Gu = /* @__PURE__ */ function(e) {
  function t() {
    return cie(this, t), pie(this, t, arguments);
  }
  return mie(t, e), hie(t, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ Y.createElement(Cie, this.props);
    }
  }]);
}(Y.Component);
pF(Gu, "displayName", "YAxis");
pF(Gu, "defaultProps", {
  allowDuplicatedCategory: !0,
  allowDecimals: !0,
  hide: !1,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: !1,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1
});
function AT(e) {
  return Sie(e) || wie(e) || bie(e) || yie();
}
function yie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bie(e, t) {
  if (e) {
    if (typeof e == "string") return Eb(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Eb(e, t);
  }
}
function wie(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Sie(e) {
  if (Array.isArray(e)) return Eb(e);
}
function Eb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
var xb = function(t, r, i, n, o) {
  var s = Ci(t, RS), a = Ci(t, xm), l = [].concat(AT(s), AT(a)), u = Ci(t, Dm), c = "".concat(n, "Id"), d = n[0], h = r;
  if (l.length && (h = l.reduce(function(m, f) {
    if (f.props[c] === i && _n(f.props, "extendDomain") && ue(f.props[d])) {
      var C = f.props[d];
      return [Math.min(m[0], C), Math.max(m[1], C)];
    }
    return m;
  }, h)), u.length) {
    var p = "".concat(d, "1"), g = "".concat(d, "2");
    h = u.reduce(function(m, f) {
      if (f.props[c] === i && _n(f.props, "extendDomain") && ue(f.props[p]) && ue(f.props[g])) {
        var C = f.props[p], w = f.props[g];
        return [Math.min(m[0], C, w), Math.max(m[1], C, w)];
      }
      return m;
    }, h);
  }
  return o && o.length && (h = o.reduce(function(m, f) {
    return ue(f) ? [Math.min(m[0], f), Math.max(m[1], f)] : m;
  }, h)), h;
}, gF = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (r = !1));
  function n(l, u, c) {
    this.fn = l, this.context = u, this.once = c || !1;
  }
  function o(l, u, c, d, h) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var p = new n(c, d || l, h), g = r ? r + u : u;
    return l._events[g] ? l._events[g].fn ? l._events[g] = [l._events[g], p] : l._events[g].push(p) : (l._events[g] = p, l._eventsCount++), l;
  }
  function s(l, u) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[u];
  }
  function a() {
    this._events = new i(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var u = [], c, d;
    if (this._eventsCount === 0) return u;
    for (d in c = this._events)
      t.call(c, d) && u.push(r ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
  }, a.prototype.listeners = function(u) {
    var c = r ? r + u : u, d = this._events[c];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var h = 0, p = d.length, g = new Array(p); h < p; h++)
      g[h] = d[h].fn;
    return g;
  }, a.prototype.listenerCount = function(u) {
    var c = r ? r + u : u, d = this._events[c];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(u, c, d, h, p, g) {
    var m = r ? r + u : u;
    if (!this._events[m]) return !1;
    var f = this._events[m], C = arguments.length, w, E;
    if (f.fn) {
      switch (f.once && this.removeListener(u, f.fn, void 0, !0), C) {
        case 1:
          return f.fn.call(f.context), !0;
        case 2:
          return f.fn.call(f.context, c), !0;
        case 3:
          return f.fn.call(f.context, c, d), !0;
        case 4:
          return f.fn.call(f.context, c, d, h), !0;
        case 5:
          return f.fn.call(f.context, c, d, h, p), !0;
        case 6:
          return f.fn.call(f.context, c, d, h, p, g), !0;
      }
      for (E = 1, w = new Array(C - 1); E < C; E++)
        w[E - 1] = arguments[E];
      f.fn.apply(f.context, w);
    } else {
      var b = f.length, y;
      for (E = 0; E < b; E++)
        switch (f[E].once && this.removeListener(u, f[E].fn, void 0, !0), C) {
          case 1:
            f[E].fn.call(f[E].context);
            break;
          case 2:
            f[E].fn.call(f[E].context, c);
            break;
          case 3:
            f[E].fn.call(f[E].context, c, d);
            break;
          case 4:
            f[E].fn.call(f[E].context, c, d, h);
            break;
          default:
            if (!w) for (y = 1, w = new Array(C - 1); y < C; y++)
              w[y - 1] = arguments[y];
            f[E].fn.apply(f[E].context, w);
        }
    }
    return !0;
  }, a.prototype.on = function(u, c, d) {
    return o(this, u, c, d, !1);
  }, a.prototype.once = function(u, c, d) {
    return o(this, u, c, d, !0);
  }, a.prototype.removeListener = function(u, c, d, h) {
    var p = r ? r + u : u;
    if (!this._events[p]) return this;
    if (!c)
      return s(this, p), this;
    var g = this._events[p];
    if (g.fn)
      g.fn === c && (!h || g.once) && (!d || g.context === d) && s(this, p);
    else {
      for (var m = 0, f = [], C = g.length; m < C; m++)
        (g[m].fn !== c || h && !g[m].once || d && g[m].context !== d) && f.push(g[m]);
      f.length ? this._events[p] = f.length === 1 ? f[0] : f : s(this, p);
    }
    return this;
  }, a.prototype.removeAllListeners = function(u) {
    var c;
    return u ? (c = r ? r + u : u, this._events[c] && s(this, c)) : (this._events = new i(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a;
})(gF);
var Eie = gF.exports;
const xie = /* @__PURE__ */ Ct(Eie);
var nC = new xie(), oC = "recharts.syncMouseEvents";
function xd(e) {
  "@babel/helpers - typeof";
  return xd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xd(e);
}
function Aie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Die(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, mF(i.key), i);
  }
}
function Tie(e, t, r) {
  return t && Die(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function sC(e, t, r) {
  return t = mF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function mF(e) {
  var t = Rie(e, "string");
  return xd(t) == "symbol" ? t : t + "";
}
function Rie(e, t) {
  if (xd(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (xd(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var Pie = /* @__PURE__ */ function() {
  function e() {
    Aie(this, e), sC(this, "activeIndex", 0), sC(this, "coordinateList", []), sC(this, "layout", "horizontal");
  }
  return Tie(e, [{
    key: "setDetails",
    value: function(r) {
      var i, n = r.coordinateList, o = n === void 0 ? null : n, s = r.container, a = s === void 0 ? null : s, l = r.layout, u = l === void 0 ? null : l, c = r.offset, d = c === void 0 ? null : c, h = r.mouseHandlerCallback, p = h === void 0 ? null : h;
      this.coordinateList = (i = o ?? this.coordinateList) !== null && i !== void 0 ? i : [], this.container = a ?? this.container, this.layout = u ?? this.layout, this.offset = d ?? this.offset, this.mouseHandlerCallback = p ?? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
    }
  }, {
    key: "focus",
    value: function() {
      this.spoofMouse();
    }
  }, {
    key: "keyboardEvent",
    value: function(r) {
      if (this.coordinateList.length !== 0)
        switch (r.key) {
          case "ArrowRight": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1), this.spoofMouse();
            break;
          }
          case "ArrowLeft": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.max(this.activeIndex - 1, 0), this.spoofMouse();
            break;
          }
        }
    }
  }, {
    key: "setIndex",
    value: function(r) {
      this.activeIndex = r;
    }
  }, {
    key: "spoofMouse",
    value: function() {
      var r, i;
      if (this.layout === "horizontal" && this.coordinateList.length !== 0) {
        var n = this.container.getBoundingClientRect(), o = n.x, s = n.y, a = n.height, l = this.coordinateList[this.activeIndex].coordinate, u = ((r = window) === null || r === void 0 ? void 0 : r.scrollX) || 0, c = ((i = window) === null || i === void 0 ? void 0 : i.scrollY) || 0, d = o + l + u, h = s + this.offset.top + a / 2 + c;
        this.mouseHandlerCallback({
          pageX: d,
          pageY: h
        });
      }
    }
  }]);
}();
function Iie(e, t, r) {
  if (r === "number" && t === !0 && Array.isArray(e)) {
    var i = e == null ? void 0 : e[0], n = e == null ? void 0 : e[1];
    if (i && n && ue(i) && ue(n))
      return !0;
  }
  return !1;
}
function Oie(e, t, r, i) {
  var n = i / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: e === "horizontal" ? t.x - n : r.left + 0.5,
    y: e === "horizontal" ? r.top + 0.5 : t.y - n,
    width: e === "horizontal" ? i : r.width - 1,
    height: e === "horizontal" ? r.height - 1 : i
  };
}
function vF(e) {
  var t = e.cx, r = e.cy, i = e.radius, n = e.startAngle, o = e.endAngle, s = At(t, r, i, n), a = At(t, r, i, o);
  return {
    points: [s, a],
    cx: t,
    cy: r,
    radius: i,
    startAngle: n,
    endAngle: o
  };
}
function Mie(e, t, r) {
  var i, n, o, s;
  if (e === "horizontal")
    i = t.x, o = i, n = r.top, s = r.top + r.height;
  else if (e === "vertical")
    n = t.y, s = n, i = r.left, o = r.left + r.width;
  else if (t.cx != null && t.cy != null)
    if (e === "centric") {
      var a = t.cx, l = t.cy, u = t.innerRadius, c = t.outerRadius, d = t.angle, h = At(a, l, u, d), p = At(a, l, c, d);
      i = h.x, n = h.y, o = p.x, s = p.y;
    } else
      return vF(t);
  return [{
    x: i,
    y: n
  }, {
    x: o,
    y: s
  }];
}
function Ad(e) {
  "@babel/helpers - typeof";
  return Ad = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ad(e);
}
function DT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function up(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DT(Object(r), !0).forEach(function(i) {
      Fie(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : DT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Fie(e, t, r) {
  return t = _ie(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function _ie(e) {
  var t = Nie(e, "string");
  return Ad(t) == "symbol" ? t : t + "";
}
function Nie(e, t) {
  if (Ad(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ad(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Lie(e) {
  var t, r, i = e.element, n = e.tooltipEventType, o = e.isActive, s = e.activeCoordinate, a = e.activePayload, l = e.offset, u = e.activeTooltipIndex, c = e.tooltipAxisBandSize, d = e.layout, h = e.chartName, p = (t = i.props.cursor) !== null && t !== void 0 ? t : (r = i.type.defaultProps) === null || r === void 0 ? void 0 : r.cursor;
  if (!i || !p || !o || !s || h !== "ScatterChart" && n !== "axis")
    return null;
  var g, m = Pf;
  if (h === "ScatterChart")
    g = s, m = eQ;
  else if (h === "BarChart")
    g = Oie(d, s, l, c), m = wS;
  else if (d === "radial") {
    var f = vF(s), C = f.cx, w = f.cy, E = f.radius, b = f.startAngle, y = f.endAngle;
    g = {
      cx: C,
      cy: w,
      startAngle: b,
      endAngle: y,
      innerRadius: E,
      outerRadius: E
    }, m = fM;
  } else
    g = {
      points: Mie(d, s, l)
    }, m = Pf;
  var S = up(up(up(up({
    stroke: "#ccc",
    pointerEvents: "none"
  }, l), g), Ie(p, !1)), {}, {
    payload: a,
    payloadIndex: u,
    className: xe("recharts-tooltip-cursor", p.className)
  });
  return /* @__PURE__ */ cn(p) ? /* @__PURE__ */ Gt(p, S) : /* @__PURE__ */ zc(m, S);
}
var Gie = ["item"], kie = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function Ul(e) {
  "@babel/helpers - typeof";
  return Ul = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ul(e);
}
function cl() {
  return cl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, cl.apply(this, arguments);
}
function TT(e, t) {
  return Bie(e) || Hie(e, t) || yF(e, t) || Vie();
}
function Vie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Hie(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function Bie(e) {
  if (Array.isArray(e)) return e;
}
function RT(e, t) {
  if (e == null) return {};
  var r = Wie(e, t), i, n;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++)
      i = o[n], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);
  }
  return r;
}
function Wie(e, t) {
  if (e == null) return {};
  var r = {};
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) >= 0) continue;
      r[i] = e[i];
    }
  return r;
}
function $ie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jie(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, bF(i.key), i);
  }
}
function zie(e, t, r) {
  return t && jie(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function Uie(e, t, r) {
  return t = eg(t), Yie(e, CF() ? Reflect.construct(t, r || [], eg(e).constructor) : t.apply(e, r));
}
function Yie(e, t) {
  if (t && (Ul(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Xie(e);
}
function Xie(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function CF() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (CF = function() {
    return !!e;
  })();
}
function eg(e) {
  return eg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, eg(e);
}
function Kie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Ab(e, t);
}
function Ab(e, t) {
  return Ab = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Ab(e, t);
}
function Yl(e) {
  return Jie(e) || Zie(e) || yF(e) || qie();
}
function qie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yF(e, t) {
  if (e) {
    if (typeof e == "string") return Db(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Db(e, t);
  }
}
function Zie(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Jie(e) {
  if (Array.isArray(e)) return Db(e);
}
function Db(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function PT(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function K(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PT(Object(r), !0).forEach(function(i) {
      Me(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : PT(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Me(e, t, r) {
  return t = bF(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function bF(e) {
  var t = Qie(e, "string");
  return Ul(t) == "symbol" ? t : t + "";
}
function Qie(e, t) {
  if (Ul(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ul(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var ene = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
}, tne = {
  width: "100%",
  height: "100%"
}, wF = {
  x: 0,
  y: 0
};
function cp(e) {
  return e;
}
var rne = function(t, r) {
  return r === "horizontal" ? t.x : r === "vertical" ? t.y : r === "centric" ? t.angle : t.radius;
}, ine = function(t, r, i, n) {
  var o = r.find(function(c) {
    return c && c.index === i;
  });
  if (o) {
    if (t === "horizontal")
      return {
        x: o.coordinate,
        y: n.y
      };
    if (t === "vertical")
      return {
        x: n.x,
        y: o.coordinate
      };
    if (t === "centric") {
      var s = o.coordinate, a = n.radius;
      return K(K(K({}, n), At(n.cx, n.cy, a, s)), {}, {
        angle: s,
        radius: a
      });
    }
    var l = o.coordinate, u = n.angle;
    return K(K(K({}, n), At(n.cx, n.cy, l, u)), {}, {
      angle: u,
      radius: l
    });
  }
  return wF;
}, Tm = function(t, r) {
  var i = r.graphicalItems, n = r.dataStartIndex, o = r.dataEndIndex, s = (i ?? []).reduce(function(a, l) {
    var u = l.props.data;
    return u && u.length ? [].concat(Yl(a), Yl(u)) : a;
  }, []);
  return s.length > 0 ? s : t && t.length && ue(n) && ue(o) ? t.slice(n, o + 1) : [];
};
function SF(e) {
  return e === "number" ? [0, "auto"] : void 0;
}
var Tb = function(t, r, i, n) {
  var o = t.graphicalItems, s = t.tooltipAxis, a = Tm(r, t);
  return i < 0 || !o || !o.length || i >= a.length ? null : o.reduce(function(l, u) {
    var c, d = (c = u.props.data) !== null && c !== void 0 ? c : r;
    d && t.dataStartIndex + t.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717
    // The data is sliced only when the active index is within the start/end index range.
    t.dataEndIndex - t.dataStartIndex >= i && (d = d.slice(t.dataStartIndex, t.dataEndIndex + 1));
    var h;
    if (s.dataKey && !s.allowDuplicatedCategory) {
      var p = d === void 0 ? a : d;
      h = Zp(p, s.dataKey, n);
    } else
      h = d && d[i] || a[i];
    return h ? [].concat(Yl(l), [lM(u, h)]) : l;
  }, []);
}, IT = function(t, r, i, n) {
  var o = n || {
    x: t.chartX,
    y: t.chartY
  }, s = rne(o, i), a = t.orderedTooltipTicks, l = t.tooltipAxis, u = t.tooltipTicks, c = vZ(s, a, u, l);
  if (c >= 0 && u) {
    var d = u[c] && u[c].value, h = Tb(t, r, c, d), p = ine(i, a, c, o);
    return {
      activeTooltipIndex: c,
      activeLabel: d,
      activePayload: h,
      activeCoordinate: p
    };
  }
  return null;
}, nne = function(t, r) {
  var i = r.axes, n = r.graphicalItems, o = r.axisType, s = r.axisIdKey, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, c = t.layout, d = t.children, h = t.stackOffset, p = rM(c, o);
  return i.reduce(function(g, m) {
    var f, C = m.type.defaultProps !== void 0 ? K(K({}, m.type.defaultProps), m.props) : m.props, w = C.type, E = C.dataKey, b = C.allowDataOverflow, y = C.allowDuplicatedCategory, S = C.scale, x = C.ticks, R = C.includeHidden, P = C[s];
    if (g[P])
      return g;
    var O = Tm(t.data, {
      graphicalItems: n.filter(function(j) {
        var U, oe = s in j.props ? j.props[s] : (U = j.type.defaultProps) === null || U === void 0 ? void 0 : U[s];
        return oe === P;
      }),
      dataStartIndex: l,
      dataEndIndex: u
    }), I = O.length, M, _, G;
    Iie(C.domain, b, w) && (M = ky(C.domain, null, b), p && (w === "number" || S !== "auto") && (G = Nc(O, E, "category")));
    var F = SF(w);
    if (!M || M.length === 0) {
      var N, V = (N = C.domain) !== null && N !== void 0 ? N : F;
      if (E) {
        if (M = Nc(O, E, w), w === "category" && p) {
          var B = oB(M);
          y && B ? (_ = M, M = Hf(0, I)) : y || (M = jA(V, M, m).reduce(function(j, U) {
            return j.indexOf(U) >= 0 ? j : [].concat(Yl(j), [U]);
          }, []));
        } else if (w === "category")
          y ? M = M.filter(function(j) {
            return j !== "" && !ke(j);
          }) : M = jA(V, M, m).reduce(function(j, U) {
            return j.indexOf(U) >= 0 || U === "" || ke(U) ? j : [].concat(Yl(j), [U]);
          }, []);
        else if (w === "number") {
          var $ = SZ(O, n.filter(function(j) {
            var U, oe, ie = s in j.props ? j.props[s] : (U = j.type.defaultProps) === null || U === void 0 ? void 0 : U[s], le = "hide" in j.props ? j.props.hide : (oe = j.type.defaultProps) === null || oe === void 0 ? void 0 : oe.hide;
            return ie === P && (R || !le);
          }), E, o, c);
          $ && (M = $);
        }
        p && (w === "number" || S !== "auto") && (G = Nc(O, E, "category"));
      } else p ? M = Hf(0, I) : a && a[P] && a[P].hasStack && w === "number" ? M = h === "expand" ? [0, 1] : aM(a[P].stackGroups, l, u) : M = tM(O, n.filter(function(j) {
        var U = s in j.props ? j.props[s] : j.type.defaultProps[s], oe = "hide" in j.props ? j.props.hide : j.type.defaultProps.hide;
        return U === P && (R || !oe);
      }), w, c, !0);
      if (w === "number")
        M = xb(d, M, P, o, x), V && (M = ky(V, M, b));
      else if (w === "category" && V) {
        var L = V, z = M.every(function(j) {
          return L.indexOf(j) >= 0;
        });
        z && (M = L);
      }
    }
    return K(K({}, g), {}, Me({}, P, K(K({}, C), {}, {
      axisType: o,
      domain: M,
      categoricalDomain: G,
      duplicateDomain: _,
      originalDomain: (f = C.domain) !== null && f !== void 0 ? f : F,
      isCategorical: p,
      layout: c
    })));
  }, {});
}, one = function(t, r) {
  var i = r.graphicalItems, n = r.Axis, o = r.axisType, s = r.axisIdKey, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, c = t.layout, d = t.children, h = Tm(t.data, {
    graphicalItems: i,
    dataStartIndex: l,
    dataEndIndex: u
  }), p = h.length, g = rM(c, o), m = -1;
  return i.reduce(function(f, C) {
    var w = C.type.defaultProps !== void 0 ? K(K({}, C.type.defaultProps), C.props) : C.props, E = w[s], b = SF("number");
    if (!f[E]) {
      m++;
      var y;
      return g ? y = Hf(0, p) : a && a[E] && a[E].hasStack ? (y = aM(a[E].stackGroups, l, u), y = xb(d, y, E, o)) : (y = ky(b, tM(h, i.filter(function(S) {
        var x, R, P = s in S.props ? S.props[s] : (x = S.type.defaultProps) === null || x === void 0 ? void 0 : x[s], O = "hide" in S.props ? S.props.hide : (R = S.type.defaultProps) === null || R === void 0 ? void 0 : R.hide;
        return P === E && !O;
      }), "number", c), n.defaultProps.allowDataOverflow), y = xb(d, y, E, o)), K(K({}, f), {}, Me({}, E, K(K({
        axisType: o
      }, n.defaultProps), {}, {
        hide: !0,
        orientation: vi(ene, "".concat(o, ".").concat(m % 2), null),
        domain: y,
        originalDomain: b,
        isCategorical: g,
        layout: c
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return f;
  }, {});
}, sne = function(t, r) {
  var i = r.axisType, n = i === void 0 ? "xAxis" : i, o = r.AxisComp, s = r.graphicalItems, a = r.stackGroups, l = r.dataStartIndex, u = r.dataEndIndex, c = t.children, d = "".concat(n, "Id"), h = Ci(c, o), p = {};
  return h && h.length ? p = nne(t, {
    axes: h,
    graphicalItems: s,
    axisType: n,
    axisIdKey: d,
    stackGroups: a,
    dataStartIndex: l,
    dataEndIndex: u
  }) : s && s.length && (p = one(t, {
    Axis: o,
    graphicalItems: s,
    axisType: n,
    axisIdKey: d,
    stackGroups: a,
    dataStartIndex: l,
    dataEndIndex: u
  })), p;
}, ane = function(t) {
  var r = Bo(t), i = ao(r, !1, !0);
  return {
    tooltipTicks: i,
    orderedTooltipTicks: zw(i, function(n) {
      return n.coordinate;
    }),
    tooltipAxis: r,
    tooltipAxisBandSize: Df(r, i)
  };
}, OT = function(t) {
  var r = t.children, i = t.defaultShowTooltip, n = hi(r, Ll), o = 0, s = 0;
  return t.data && t.data.length !== 0 && (s = t.data.length - 1), n && n.props && (n.props.startIndex >= 0 && (o = n.props.startIndex), n.props.endIndex >= 0 && (s = n.props.endIndex)), {
    chartX: 0,
    chartY: 0,
    dataStartIndex: o,
    dataEndIndex: s,
    activeTooltipIndex: -1,
    isTooltipActive: !!i
  };
}, lne = function(t) {
  return !t || !t.length ? !1 : t.some(function(r) {
    var i = lo(r && r.type);
    return i && i.indexOf("Bar") >= 0;
  });
}, MT = function(t) {
  return t === "horizontal" ? {
    numericAxisName: "yAxis",
    cateAxisName: "xAxis"
  } : t === "vertical" ? {
    numericAxisName: "xAxis",
    cateAxisName: "yAxis"
  } : t === "centric" ? {
    numericAxisName: "radiusAxis",
    cateAxisName: "angleAxis"
  } : {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
}, une = function(t, r) {
  var i = t.props, n = t.graphicalItems, o = t.xAxisMap, s = o === void 0 ? {} : o, a = t.yAxisMap, l = a === void 0 ? {} : a, u = i.width, c = i.height, d = i.children, h = i.margin || {}, p = hi(d, Ll), g = hi(d, uo), m = Object.keys(l).reduce(function(y, S) {
    var x = l[S], R = x.orientation;
    return !x.mirror && !x.hide ? K(K({}, y), {}, Me({}, R, y[R] + x.width)) : y;
  }, {
    left: h.left || 0,
    right: h.right || 0
  }), f = Object.keys(s).reduce(function(y, S) {
    var x = s[S], R = x.orientation;
    return !x.mirror && !x.hide ? K(K({}, y), {}, Me({}, R, vi(y, "".concat(R)) + x.height)) : y;
  }, {
    top: h.top || 0,
    bottom: h.bottom || 0
  }), C = K(K({}, f), m), w = C.bottom;
  p && (C.bottom += p.props.height || Ll.defaultProps.height), g && r && (C = bZ(C, n, i, r));
  var E = u - C.left - C.right, b = c - C.top - C.bottom;
  return K(K({
    brushBottom: w
  }, C), {}, {
    // never return negative values for height and width
    width: Math.max(E, 0),
    height: Math.max(b, 0)
  });
}, cne = function(t, r) {
  if (r === "xAxis")
    return t[r].width;
  if (r === "yAxis")
    return t[r].height;
}, MS = function(t) {
  var r = t.chartName, i = t.GraphicalChild, n = t.defaultTooltipEventType, o = n === void 0 ? "axis" : n, s = t.validateTooltipEventTypes, a = s === void 0 ? ["axis"] : s, l = t.axisComponents, u = t.legendContent, c = t.formatAxisMap, d = t.defaultProps, h = function(C, w) {
    var E = w.graphicalItems, b = w.stackGroups, y = w.offset, S = w.updateId, x = w.dataStartIndex, R = w.dataEndIndex, P = C.barSize, O = C.layout, I = C.barGap, M = C.barCategoryGap, _ = C.maxBarSize, G = MT(O), F = G.numericAxisName, N = G.cateAxisName, V = lne(E), B = [];
    return E.forEach(function($, L) {
      var z = Tm(C.data, {
        graphicalItems: [$],
        dataStartIndex: x,
        dataEndIndex: R
      }), j = $.type.defaultProps !== void 0 ? K(K({}, $.type.defaultProps), $.props) : $.props, U = j.dataKey, oe = j.maxBarSize, ie = j["".concat(F, "Id")], le = j["".concat(N, "Id")], ce = {}, he = l.reduce(function(Lt, zt) {
        var er, ui, Qi = w["".concat(zt.axisType, "Map")], wt = j["".concat(zt.axisType, "Id")];
        Qi && Qi[wt] || zt.axisType === "zAxis" || (process.env.NODE_ENV !== "production" ? qr(!1, "Specifying a(n) ".concat(zt.axisType, "Id requires a corresponding ").concat(
          zt.axisType,
          "Id on the targeted graphical component "
        ).concat((er = $ == null || (ui = $.type) === null || ui === void 0 ? void 0 : ui.displayName) !== null && er !== void 0 ? er : "")) : qr());
        var pr = Qi[wt];
        return K(K({}, Lt), {}, Me(Me({}, zt.axisType, pr), "".concat(zt.axisType, "Ticks"), ao(pr)));
      }, ce), Z = he[N], se = he["".concat(N, "Ticks")], ae = b && b[ie] && b[ie].hasStack && OZ($, b[ie].stackGroups), W = lo($.type).indexOf("Bar") >= 0, be = Df(Z, se), X = [], Te = V && CZ({
        barSize: P,
        stackGroups: b,
        totalSize: cne(he, N)
      });
      if (W) {
        var He, je, jt = ke(oe) ? _ : oe, Mr = (He = (je = Df(Z, se, !0)) !== null && je !== void 0 ? je : jt) !== null && He !== void 0 ? He : 0;
        X = yZ({
          barGap: I,
          barCategoryGap: M,
          bandSize: Mr !== be ? Mr : be,
          sizeList: Te[le],
          maxBarSize: jt
        }), Mr !== be && (X = X.map(function(Lt) {
          return K(K({}, Lt), {}, {
            position: K(K({}, Lt.position), {}, {
              offset: Lt.position.offset - Mr / 2
            })
          });
        }));
      }
      var Qt = $ && $.type && $.type.getComposedData;
      Qt && B.push({
        props: K(K({}, Qt(K(K({}, he), {}, {
          displayedData: z,
          props: C,
          dataKey: U,
          item: $,
          bandSize: be,
          barPosition: X,
          offset: y,
          stackedData: ae,
          layout: O,
          dataStartIndex: x,
          dataEndIndex: R
        }))), {}, Me(Me(Me({
          key: $.key || "item-".concat(L)
        }, F, he[F]), N, he[N]), "animationId", S)),
        childIndex: CB($, C.children),
        item: $
      });
    }), B;
  }, p = function(C, w) {
    var E = C.props, b = C.dataStartIndex, y = C.dataEndIndex, S = C.updateId;
    if (!Gx({
      props: E
    }))
      return null;
    var x = E.children, R = E.layout, P = E.stackOffset, O = E.data, I = E.reverseStackOrder, M = MT(R), _ = M.numericAxisName, G = M.cateAxisName, F = Ci(x, i), N = PZ(O, F, "".concat(_, "Id"), "".concat(G, "Id"), P, I), V = l.reduce(function(j, U) {
      var oe = "".concat(U.axisType, "Map");
      return K(K({}, j), {}, Me({}, oe, sne(E, K(K({}, U), {}, {
        graphicalItems: F,
        stackGroups: U.axisType === _ && N,
        dataStartIndex: b,
        dataEndIndex: y
      }))));
    }, {}), B = une(K(K({}, V), {}, {
      props: E,
      graphicalItems: F
    }), w == null ? void 0 : w.legendBBox);
    Object.keys(V).forEach(function(j) {
      V[j] = c(E, V[j], B, j.replace("Map", ""), r);
    });
    var $ = V["".concat(G, "Map")], L = ane($), z = h(E, K(K({}, V), {}, {
      dataStartIndex: b,
      dataEndIndex: y,
      updateId: S,
      graphicalItems: F,
      stackGroups: N,
      offset: B
    }));
    return K(K({
      formattedGraphicalItems: z,
      graphicalItems: F,
      offset: B,
      stackGroups: N
    }, L), V);
  }, g = /* @__PURE__ */ function(f) {
    function C(w) {
      var E, b, y;
      return $ie(this, C), y = Uie(this, C, [w]), Me(y, "eventEmitterSymbol", Symbol("rechartsEventEmitter")), Me(y, "accessibilityManager", new Pie()), Me(y, "handleLegendBBoxUpdate", function(S) {
        if (S) {
          var x = y.state, R = x.dataStartIndex, P = x.dataEndIndex, O = x.updateId;
          y.setState(K({
            legendBBox: S
          }, p({
            props: y.props,
            dataStartIndex: R,
            dataEndIndex: P,
            updateId: O
          }, K(K({}, y.state), {}, {
            legendBBox: S
          }))));
        }
      }), Me(y, "handleReceiveSyncEvent", function(S, x, R) {
        if (y.props.syncId === S) {
          if (R === y.eventEmitterSymbol && typeof y.props.syncMethod != "function")
            return;
          y.applySyncEvent(x);
        }
      }), Me(y, "handleBrushChange", function(S) {
        var x = S.startIndex, R = S.endIndex;
        if (x !== y.state.dataStartIndex || R !== y.state.dataEndIndex) {
          var P = y.state.updateId;
          y.setState(function() {
            return K({
              dataStartIndex: x,
              dataEndIndex: R
            }, p({
              props: y.props,
              dataStartIndex: x,
              dataEndIndex: R,
              updateId: P
            }, y.state));
          }), y.triggerSyncEvent({
            dataStartIndex: x,
            dataEndIndex: R
          });
        }
      }), Me(y, "handleMouseEnter", function(S) {
        var x = y.getMouseInfo(S);
        if (x) {
          var R = K(K({}, x), {}, {
            isTooltipActive: !0
          });
          y.setState(R), y.triggerSyncEvent(R);
          var P = y.props.onMouseEnter;
          Le(P) && P(R, S);
        }
      }), Me(y, "triggeredAfterMouseMove", function(S) {
        var x = y.getMouseInfo(S), R = x ? K(K({}, x), {}, {
          isTooltipActive: !0
        }) : {
          isTooltipActive: !1
        };
        y.setState(R), y.triggerSyncEvent(R);
        var P = y.props.onMouseMove;
        Le(P) && P(R, S);
      }), Me(y, "handleItemMouseEnter", function(S) {
        y.setState(function() {
          return {
            isTooltipActive: !0,
            activeItem: S,
            activePayload: S.tooltipPayload,
            activeCoordinate: S.tooltipPosition || {
              x: S.cx,
              y: S.cy
            }
          };
        });
      }), Me(y, "handleItemMouseLeave", function() {
        y.setState(function() {
          return {
            isTooltipActive: !1
          };
        });
      }), Me(y, "handleMouseMove", function(S) {
        S.persist(), y.throttleTriggeredAfterMouseMove(S);
      }), Me(y, "handleMouseLeave", function(S) {
        y.throttleTriggeredAfterMouseMove.cancel();
        var x = {
          isTooltipActive: !1
        };
        y.setState(x), y.triggerSyncEvent(x);
        var R = y.props.onMouseLeave;
        Le(R) && R(x, S);
      }), Me(y, "handleOuterEvent", function(S) {
        var x = vB(S), R = vi(y.props, "".concat(x));
        if (x && Le(R)) {
          var P, O;
          /.*touch.*/i.test(x) ? O = y.getMouseInfo(S.changedTouches[0]) : O = y.getMouseInfo(S), R((P = O) !== null && P !== void 0 ? P : {}, S);
        }
      }), Me(y, "handleClick", function(S) {
        var x = y.getMouseInfo(S);
        if (x) {
          var R = K(K({}, x), {}, {
            isTooltipActive: !0
          });
          y.setState(R), y.triggerSyncEvent(R);
          var P = y.props.onClick;
          Le(P) && P(R, S);
        }
      }), Me(y, "handleMouseDown", function(S) {
        var x = y.props.onMouseDown;
        if (Le(x)) {
          var R = y.getMouseInfo(S);
          x(R, S);
        }
      }), Me(y, "handleMouseUp", function(S) {
        var x = y.props.onMouseUp;
        if (Le(x)) {
          var R = y.getMouseInfo(S);
          x(R, S);
        }
      }), Me(y, "handleTouchMove", function(S) {
        S.changedTouches != null && S.changedTouches.length > 0 && y.throttleTriggeredAfterMouseMove(S.changedTouches[0]);
      }), Me(y, "handleTouchStart", function(S) {
        S.changedTouches != null && S.changedTouches.length > 0 && y.handleMouseDown(S.changedTouches[0]);
      }), Me(y, "handleTouchEnd", function(S) {
        S.changedTouches != null && S.changedTouches.length > 0 && y.handleMouseUp(S.changedTouches[0]);
      }), Me(y, "handleDoubleClick", function(S) {
        var x = y.props.onDoubleClick;
        if (Le(x)) {
          var R = y.getMouseInfo(S);
          x(R, S);
        }
      }), Me(y, "handleContextMenu", function(S) {
        var x = y.props.onContextMenu;
        if (Le(x)) {
          var R = y.getMouseInfo(S);
          x(R, S);
        }
      }), Me(y, "triggerSyncEvent", function(S) {
        y.props.syncId !== void 0 && nC.emit(oC, y.props.syncId, S, y.eventEmitterSymbol);
      }), Me(y, "applySyncEvent", function(S) {
        var x = y.props, R = x.layout, P = x.syncMethod, O = y.state.updateId, I = S.dataStartIndex, M = S.dataEndIndex;
        if (S.dataStartIndex !== void 0 || S.dataEndIndex !== void 0)
          y.setState(K({
            dataStartIndex: I,
            dataEndIndex: M
          }, p({
            props: y.props,
            dataStartIndex: I,
            dataEndIndex: M,
            updateId: O
          }, y.state)));
        else if (S.activeTooltipIndex !== void 0) {
          var _ = S.chartX, G = S.chartY, F = S.activeTooltipIndex, N = y.state, V = N.offset, B = N.tooltipTicks;
          if (!V)
            return;
          if (typeof P == "function")
            F = P(B, S);
          else if (P === "value") {
            F = -1;
            for (var $ = 0; $ < B.length; $++)
              if (B[$].value === S.activeLabel) {
                F = $;
                break;
              }
          }
          var L = K(K({}, V), {}, {
            x: V.left,
            y: V.top
          }), z = Math.min(_, L.x + L.width), j = Math.min(G, L.y + L.height), U = B[F] && B[F].value, oe = Tb(y.state, y.props.data, F), ie = B[F] ? {
            x: R === "horizontal" ? B[F].coordinate : z,
            y: R === "horizontal" ? j : B[F].coordinate
          } : wF;
          y.setState(K(K({}, S), {}, {
            activeLabel: U,
            activeCoordinate: ie,
            activePayload: oe,
            activeTooltipIndex: F
          }));
        } else
          y.setState(S);
      }), Me(y, "renderCursor", function(S) {
        var x, R = y.state, P = R.isTooltipActive, O = R.activeCoordinate, I = R.activePayload, M = R.offset, _ = R.activeTooltipIndex, G = R.tooltipAxisBandSize, F = y.getTooltipEventType(), N = (x = S.props.active) !== null && x !== void 0 ? x : P, V = y.props.layout, B = S.key || "_recharts-cursor";
        return /* @__PURE__ */ D.createElement(Lie, {
          key: B,
          activeCoordinate: O,
          activePayload: I,
          activeTooltipIndex: _,
          chartName: r,
          element: S,
          isActive: N,
          layout: V,
          offset: M,
          tooltipAxisBandSize: G,
          tooltipEventType: F
        });
      }), Me(y, "renderPolarAxis", function(S, x, R) {
        var P = vi(S, "type.axisType"), O = vi(y.state, "".concat(P, "Map")), I = S.type.defaultProps, M = I !== void 0 ? K(K({}, I), S.props) : S.props, _ = O && O[M["".concat(P, "Id")]];
        return /* @__PURE__ */ Gt(S, K(K({}, _), {}, {
          className: xe(P, _.className),
          key: S.key || "".concat(x, "-").concat(R),
          ticks: ao(_, !0)
        }));
      }), Me(y, "renderPolarGrid", function(S) {
        var x = S.props, R = x.radialLines, P = x.polarAngles, O = x.polarRadius, I = y.state, M = I.radiusAxisMap, _ = I.angleAxisMap, G = Bo(M), F = Bo(_), N = F.cx, V = F.cy, B = F.innerRadius, $ = F.outerRadius;
        return /* @__PURE__ */ Gt(S, {
          polarAngles: Array.isArray(P) ? P : ao(F, !0).map(function(L) {
            return L.coordinate;
          }),
          polarRadius: Array.isArray(O) ? O : ao(G, !0).map(function(L) {
            return L.coordinate;
          }),
          cx: N,
          cy: V,
          innerRadius: B,
          outerRadius: $,
          key: S.key || "polar-grid",
          radialLines: R
        });
      }), Me(y, "renderLegend", function() {
        var S = y.state.formattedGraphicalItems, x = y.props, R = x.children, P = x.width, O = x.height, I = y.props.margin || {}, M = P - (I.left || 0) - (I.right || 0), _ = QO({
          children: R,
          formattedGraphicalItems: S,
          legendWidth: M,
          legendContent: u
        });
        if (!_)
          return null;
        var G = _.item, F = RT(_, Gie);
        return /* @__PURE__ */ Gt(G, K(K({}, F), {}, {
          chartWidth: P,
          chartHeight: O,
          margin: I,
          onBBoxUpdate: y.handleLegendBBoxUpdate
        }));
      }), Me(y, "renderTooltip", function() {
        var S, x = y.props, R = x.children, P = x.accessibilityLayer, O = hi(R, Mi);
        if (!O)
          return null;
        var I = y.state, M = I.isTooltipActive, _ = I.activeCoordinate, G = I.activePayload, F = I.activeLabel, N = I.offset, V = (S = O.props.active) !== null && S !== void 0 ? S : M;
        return /* @__PURE__ */ Gt(O, {
          viewBox: K(K({}, N), {}, {
            x: N.left,
            y: N.top
          }),
          active: V,
          label: F,
          payload: V ? G : [],
          coordinate: _,
          accessibilityLayer: P
        });
      }), Me(y, "renderBrush", function(S) {
        var x = y.props, R = x.margin, P = x.data, O = y.state, I = O.offset, M = O.dataStartIndex, _ = O.dataEndIndex, G = O.updateId;
        return /* @__PURE__ */ Gt(S, {
          key: S.key || "_recharts-brush",
          onChange: op(y.handleBrushChange, S.props.onChange),
          data: P,
          x: ue(S.props.x) ? S.props.x : I.left,
          y: ue(S.props.y) ? S.props.y : I.top + I.height + I.brushBottom - (R.bottom || 0),
          width: ue(S.props.width) ? S.props.width : I.width,
          startIndex: M,
          endIndex: _,
          updateId: "brush-".concat(G)
        });
      }), Me(y, "renderReferenceElement", function(S, x, R) {
        if (!S)
          return null;
        var P = y, O = P.clipPathId, I = y.state, M = I.xAxisMap, _ = I.yAxisMap, G = I.offset, F = S.type.defaultProps || {}, N = S.props, V = N.xAxisId, B = V === void 0 ? F.xAxisId : V, $ = N.yAxisId, L = $ === void 0 ? F.yAxisId : $;
        return /* @__PURE__ */ Gt(S, {
          key: S.key || "".concat(x, "-").concat(R),
          xAxis: M[B],
          yAxis: _[L],
          viewBox: {
            x: G.left,
            y: G.top,
            width: G.width,
            height: G.height
          },
          clipPathId: O
        });
      }), Me(y, "renderActivePoints", function(S) {
        var x = S.item, R = S.activePoint, P = S.basePoint, O = S.childIndex, I = S.isRange, M = [], _ = x.props.key, G = x.item.type.defaultProps !== void 0 ? K(K({}, x.item.type.defaultProps), x.item.props) : x.item.props, F = G.activeDot, N = G.dataKey, V = K(K({
          index: O,
          dataKey: N,
          cx: R.x,
          cy: R.y,
          r: 4,
          fill: CS(x.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: R.payload,
          value: R.value
        }, Ie(F, !1)), Jp(F));
        return M.push(C.renderActiveDot(F, V, "".concat(_, "-activePoint-").concat(O))), P ? M.push(C.renderActiveDot(F, K(K({}, V), {}, {
          cx: P.x,
          cy: P.y
        }), "".concat(_, "-basePoint-").concat(O))) : I && M.push(null), M;
      }), Me(y, "renderGraphicChild", function(S, x, R) {
        var P = y.filterFormatItem(S, x, R);
        if (!P)
          return null;
        var O = y.getTooltipEventType(), I = y.state, M = I.isTooltipActive, _ = I.tooltipAxis, G = I.activeTooltipIndex, F = I.activeLabel, N = y.props.children, V = hi(N, Mi), B = P.props, $ = B.points, L = B.isRange, z = B.baseLine, j = P.item.type.defaultProps !== void 0 ? K(K({}, P.item.type.defaultProps), P.item.props) : P.item.props, U = j.activeDot, oe = j.hide, ie = j.activeBar, le = j.activeShape, ce = !!(!oe && M && V && (U || ie || le)), he = {};
        O !== "axis" && V && V.props.trigger === "click" ? he = {
          onClick: op(y.handleItemMouseEnter, S.props.onClick)
        } : O !== "axis" && (he = {
          onMouseLeave: op(y.handleItemMouseLeave, S.props.onMouseLeave),
          onMouseEnter: op(y.handleItemMouseEnter, S.props.onMouseEnter)
        });
        var Z = /* @__PURE__ */ Gt(S, K(K({}, P.props), he));
        function se(zt) {
          return typeof _.dataKey == "function" ? _.dataKey(zt.payload) : null;
        }
        if (ce)
          if (G >= 0) {
            var ae, W;
            if (_.dataKey && !_.allowDuplicatedCategory) {
              var be = typeof _.dataKey == "function" ? se : "payload.".concat(_.dataKey.toString());
              ae = Zp($, be, F), W = L && z && Zp(z, be, F);
            } else
              ae = $ == null ? void 0 : $[G], W = L && z && z[G];
            if (le || ie) {
              var X = S.props.activeIndex !== void 0 ? S.props.activeIndex : G;
              return [/* @__PURE__ */ Gt(S, K(K(K({}, P.props), he), {}, {
                activeIndex: X
              })), null, null];
            }
            if (!ke(ae))
              return [Z].concat(Yl(y.renderActivePoints({
                item: P,
                activePoint: ae,
                basePoint: W,
                childIndex: G,
                isRange: L
              })));
          } else {
            var Te, He = (Te = y.getItemByXY(y.state.activeCoordinate)) !== null && Te !== void 0 ? Te : {
              graphicalItem: Z
            }, je = He.graphicalItem, jt = je.item, Mr = jt === void 0 ? S : jt, Qt = je.childIndex, Lt = K(K(K({}, P.props), he), {}, {
              activeIndex: Qt
            });
            return [/* @__PURE__ */ Gt(Mr, Lt), null, null];
          }
        return L ? [Z, null, null] : [Z, null];
      }), Me(y, "renderCustomized", function(S, x, R) {
        return /* @__PURE__ */ Gt(S, K(K({
          key: "recharts-customized-".concat(R)
        }, y.props), y.state));
      }), Me(y, "renderMap", {
        CartesianGrid: {
          handler: cp,
          once: !0
        },
        ReferenceArea: {
          handler: y.renderReferenceElement
        },
        ReferenceLine: {
          handler: cp
        },
        ReferenceDot: {
          handler: y.renderReferenceElement
        },
        XAxis: {
          handler: cp
        },
        YAxis: {
          handler: cp
        },
        Brush: {
          handler: y.renderBrush,
          once: !0
        },
        Bar: {
          handler: y.renderGraphicChild
        },
        Line: {
          handler: y.renderGraphicChild
        },
        Area: {
          handler: y.renderGraphicChild
        },
        Radar: {
          handler: y.renderGraphicChild
        },
        RadialBar: {
          handler: y.renderGraphicChild
        },
        Scatter: {
          handler: y.renderGraphicChild
        },
        Pie: {
          handler: y.renderGraphicChild
        },
        Funnel: {
          handler: y.renderGraphicChild
        },
        Tooltip: {
          handler: y.renderCursor,
          once: !0
        },
        PolarGrid: {
          handler: y.renderPolarGrid,
          once: !0
        },
        PolarAngleAxis: {
          handler: y.renderPolarAxis
        },
        PolarRadiusAxis: {
          handler: y.renderPolarAxis
        },
        Customized: {
          handler: y.renderCustomized
        }
      }), y.clipPathId = "".concat((E = w.id) !== null && E !== void 0 ? E : Ru("recharts"), "-clip"), y.throttleTriggeredAfterMouseMove = JI(y.triggeredAfterMouseMove, (b = w.throttleDelay) !== null && b !== void 0 ? b : 1e3 / 60), y.state = {}, y;
    }
    return Kie(C, f), zie(C, [{
      key: "componentDidMount",
      value: function() {
        var E, b;
        this.addListener(), this.accessibilityManager.setDetails({
          container: this.container,
          offset: {
            left: (E = this.props.margin.left) !== null && E !== void 0 ? E : 0,
            top: (b = this.props.margin.top) !== null && b !== void 0 ? b : 0
          },
          coordinateList: this.state.tooltipTicks,
          mouseHandlerCallback: this.triggeredAfterMouseMove,
          layout: this.props.layout
        }), this.displayDefaultTooltip();
      }
    }, {
      key: "displayDefaultTooltip",
      value: function() {
        var E = this.props, b = E.children, y = E.data, S = E.height, x = E.layout, R = hi(b, Mi);
        if (R) {
          var P = R.props.defaultIndex;
          if (!(typeof P != "number" || P < 0 || P > this.state.tooltipTicks.length - 1)) {
            var O = this.state.tooltipTicks[P] && this.state.tooltipTicks[P].value, I = Tb(this.state, y, P, O), M = this.state.tooltipTicks[P].coordinate, _ = (this.state.offset.top + S) / 2, G = x === "horizontal", F = G ? {
              x: M,
              y: _
            } : {
              y: M,
              x: _
            }, N = this.state.formattedGraphicalItems.find(function(B) {
              var $ = B.item;
              return $.type.name === "Scatter";
            });
            N && (F = K(K({}, F), N.props.points[P].tooltipPosition), I = N.props.points[P].tooltipPayload);
            var V = {
              activeTooltipIndex: P,
              isTooltipActive: !0,
              activeLabel: O,
              activePayload: I,
              activeCoordinate: F
            };
            this.setState(V), this.renderCursor(R), this.accessibilityManager.setIndex(P);
          }
        }
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function(E, b) {
        if (!this.props.accessibilityLayer)
          return null;
        if (this.state.tooltipTicks !== b.tooltipTicks && this.accessibilityManager.setDetails({
          coordinateList: this.state.tooltipTicks
        }), this.props.layout !== E.layout && this.accessibilityManager.setDetails({
          layout: this.props.layout
        }), this.props.margin !== E.margin) {
          var y, S;
          this.accessibilityManager.setDetails({
            offset: {
              left: (y = this.props.margin.left) !== null && y !== void 0 ? y : 0,
              top: (S = this.props.margin.top) !== null && S !== void 0 ? S : 0
            }
          });
        }
        return null;
      }
    }, {
      key: "componentDidUpdate",
      value: function(E) {
        QC([hi(E.children, Mi)], [hi(this.props.children, Mi)]) || this.displayDefaultTooltip();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel();
      }
    }, {
      key: "getTooltipEventType",
      value: function() {
        var E = hi(this.props.children, Mi);
        if (E && typeof E.props.shared == "boolean") {
          var b = E.props.shared ? "axis" : "item";
          return a.indexOf(b) >= 0 ? b : o;
        }
        return o;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {MousePointer} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function(E) {
        if (!this.container)
          return null;
        var b = this.container, y = b.getBoundingClientRect(), S = z5(y), x = {
          chartX: Math.round(E.pageX - S.left),
          chartY: Math.round(E.pageY - S.top)
        }, R = y.width / b.offsetWidth || 1, P = this.inRange(x.chartX, x.chartY, R);
        if (!P)
          return null;
        var O = this.state, I = O.xAxisMap, M = O.yAxisMap, _ = this.getTooltipEventType(), G = IT(this.state, this.props.data, this.props.layout, P);
        if (_ !== "axis" && I && M) {
          var F = Bo(I).scale, N = Bo(M).scale, V = F && F.invert ? F.invert(x.chartX) : null, B = N && N.invert ? N.invert(x.chartY) : null;
          return K(K({}, x), {}, {
            xValue: V,
            yValue: B
          }, G);
        }
        return G ? K(K({}, x), G) : null;
      }
    }, {
      key: "inRange",
      value: function(E, b) {
        var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, S = this.props.layout, x = E / y, R = b / y;
        if (S === "horizontal" || S === "vertical") {
          var P = this.state.offset, O = x >= P.left && x <= P.left + P.width && R >= P.top && R <= P.top + P.height;
          return O ? {
            x,
            y: R
          } : null;
        }
        var I = this.state, M = I.angleAxisMap, _ = I.radiusAxisMap;
        if (M && _) {
          var G = Bo(M);
          return YA({
            x,
            y: R
          }, G);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function() {
        var E = this.props.children, b = this.getTooltipEventType(), y = hi(E, Mi), S = {};
        y && b === "axis" && (y.props.trigger === "click" ? S = {
          onClick: this.handleClick
        } : S = {
          onMouseEnter: this.handleMouseEnter,
          onDoubleClick: this.handleDoubleClick,
          onMouseMove: this.handleMouseMove,
          onMouseLeave: this.handleMouseLeave,
          onTouchMove: this.handleTouchMove,
          onTouchStart: this.handleTouchStart,
          onTouchEnd: this.handleTouchEnd,
          onContextMenu: this.handleContextMenu
        });
        var x = Jp(this.props, this.handleOuterEvent);
        return K(K({}, x), S);
      }
    }, {
      key: "addListener",
      value: function() {
        nC.on(oC, this.handleReceiveSyncEvent);
      }
    }, {
      key: "removeListener",
      value: function() {
        nC.removeListener(oC, this.handleReceiveSyncEvent);
      }
    }, {
      key: "filterFormatItem",
      value: function(E, b, y) {
        for (var S = this.state.formattedGraphicalItems, x = 0, R = S.length; x < R; x++) {
          var P = S[x];
          if (P.item === E || P.props.key === E.key || b === lo(P.item.type) && y === P.childIndex)
            return P;
        }
        return null;
      }
    }, {
      key: "renderClipPath",
      value: function() {
        var E = this.clipPathId, b = this.state.offset, y = b.left, S = b.top, x = b.height, R = b.width;
        return /* @__PURE__ */ D.createElement("defs", null, /* @__PURE__ */ D.createElement("clipPath", {
          id: E
        }, /* @__PURE__ */ D.createElement("rect", {
          x: y,
          y: S,
          height: x,
          width: R
        })));
      }
    }, {
      key: "getXScales",
      value: function() {
        var E = this.state.xAxisMap;
        return E ? Object.entries(E).reduce(function(b, y) {
          var S = TT(y, 2), x = S[0], R = S[1];
          return K(K({}, b), {}, Me({}, x, R.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function() {
        var E = this.state.yAxisMap;
        return E ? Object.entries(E).reduce(function(b, y) {
          var S = TT(y, 2), x = S[0], R = S[1];
          return K(K({}, b), {}, Me({}, x, R.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function(E) {
        var b;
        return (b = this.state.xAxisMap) === null || b === void 0 || (b = b[E]) === null || b === void 0 ? void 0 : b.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function(E) {
        var b;
        return (b = this.state.yAxisMap) === null || b === void 0 || (b = b[E]) === null || b === void 0 ? void 0 : b.scale;
      }
    }, {
      key: "getItemByXY",
      value: function(E) {
        var b = this.state, y = b.formattedGraphicalItems, S = b.activeItem;
        if (y && y.length)
          for (var x = 0, R = y.length; x < R; x++) {
            var P = y[x], O = P.props, I = P.item, M = I.type.defaultProps !== void 0 ? K(K({}, I.type.defaultProps), I.props) : I.props, _ = lo(I.type);
            if (_ === "Bar") {
              var G = (O.data || []).find(function(B) {
                return _8(E, B);
              });
              if (G)
                return {
                  graphicalItem: P,
                  payload: G
                };
            } else if (_ === "RadialBar") {
              var F = (O.data || []).find(function(B) {
                return YA(E, B);
              });
              if (F)
                return {
                  graphicalItem: P,
                  payload: F
                };
            } else if (bm(P, S) || wm(P, S) || bd(P, S)) {
              var N = S7({
                graphicalItem: P,
                activeTooltipItem: S,
                itemData: M.data
              }), V = M.activeIndex === void 0 ? N : M.activeIndex;
              return {
                graphicalItem: K(K({}, P), {}, {
                  childIndex: V
                }),
                payload: bd(P, S) ? M.data[N] : P.props.data[N]
              };
            }
          }
        return null;
      }
    }, {
      key: "render",
      value: function() {
        var E = this;
        if (!Gx(this))
          return null;
        var b = this.props, y = b.children, S = b.className, x = b.width, R = b.height, P = b.style, O = b.compact, I = b.title, M = b.desc, _ = RT(b, kie), G = Ie(_, !1);
        if (O)
          return /* @__PURE__ */ D.createElement(uT, {
            state: this.state,
            width: this.props.width,
            height: this.props.height,
            clipPathId: this.clipPathId
          }, /* @__PURE__ */ D.createElement(ty, cl({}, G, {
            width: x,
            height: R,
            title: I,
            desc: M
          }), this.renderClipPath(), Vx(y, this.renderMap)));
        if (this.props.accessibilityLayer) {
          var F, N;
          G.tabIndex = (F = this.props.tabIndex) !== null && F !== void 0 ? F : 0, G.role = (N = this.props.role) !== null && N !== void 0 ? N : "application", G.onKeyDown = function(B) {
            E.accessibilityManager.keyboardEvent(B);
          }, G.onFocus = function() {
            E.accessibilityManager.focus();
          };
        }
        var V = this.parseEventsOfWrapper();
        return /* @__PURE__ */ D.createElement(uT, {
          state: this.state,
          width: this.props.width,
          height: this.props.height,
          clipPathId: this.clipPathId
        }, /* @__PURE__ */ D.createElement("div", cl({
          className: xe("recharts-wrapper", S),
          style: K({
            position: "relative",
            cursor: "default",
            width: x,
            height: R
          }, P)
        }, V, {
          ref: function($) {
            E.container = $;
          }
        }), /* @__PURE__ */ D.createElement(ty, cl({}, G, {
          width: x,
          height: R,
          title: I,
          desc: M,
          style: tne
        }), this.renderClipPath(), Vx(y, this.renderMap)), this.renderLegend(), this.renderTooltip()));
      }
    }]);
  }($t);
  Me(g, "displayName", r), Me(g, "defaultProps", K({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: !1,
    syncMethod: "index"
  }, d)), Me(g, "getDerivedStateFromProps", function(f, C) {
    var w = f.dataKey, E = f.data, b = f.children, y = f.width, S = f.height, x = f.layout, R = f.stackOffset, P = f.margin, O = C.dataStartIndex, I = C.dataEndIndex;
    if (C.updateId === void 0) {
      var M = OT(f);
      return K(K(K({}, M), {}, {
        updateId: 0
      }, p(K(K({
        props: f
      }, M), {}, {
        updateId: 0
      }), C)), {}, {
        prevDataKey: w,
        prevData: E,
        prevWidth: y,
        prevHeight: S,
        prevLayout: x,
        prevStackOffset: R,
        prevMargin: P,
        prevChildren: b
      });
    }
    if (w !== C.prevDataKey || E !== C.prevData || y !== C.prevWidth || S !== C.prevHeight || x !== C.prevLayout || R !== C.prevStackOffset || !pl(P, C.prevMargin)) {
      var _ = OT(f), G = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: C.chartX,
        chartY: C.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: C.isTooltipActive
      }, F = K(K({}, IT(C, E, x)), {}, {
        updateId: C.updateId + 1
      }), N = K(K(K({}, _), G), F);
      return K(K(K({}, N), p(K({
        props: f
      }, N), C)), {}, {
        prevDataKey: w,
        prevData: E,
        prevWidth: y,
        prevHeight: S,
        prevLayout: x,
        prevStackOffset: R,
        prevMargin: P,
        prevChildren: b
      });
    }
    if (!QC(b, C.prevChildren)) {
      var V, B, $, L, z = hi(b, Ll), j = z && (V = (B = z.props) === null || B === void 0 ? void 0 : B.startIndex) !== null && V !== void 0 ? V : O, U = z && ($ = (L = z.props) === null || L === void 0 ? void 0 : L.endIndex) !== null && $ !== void 0 ? $ : I, oe = j !== O || U !== I, ie = !ke(E), le = ie && !oe ? C.updateId : C.updateId + 1;
      return K(K({
        updateId: le
      }, p(K(K({
        props: f
      }, C), {}, {
        updateId: le,
        dataStartIndex: j,
        dataEndIndex: U
      }), C)), {}, {
        prevChildren: b,
        dataStartIndex: j,
        dataEndIndex: U
      });
    }
    return null;
  }), Me(g, "renderActiveDot", function(f, C, w) {
    var E;
    return /* @__PURE__ */ cn(f) ? E = /* @__PURE__ */ Gt(f, C) : Le(f) ? E = f(C) : E = /* @__PURE__ */ D.createElement(gm, C), /* @__PURE__ */ D.createElement(Ze, {
      className: "recharts-active-dot",
      key: w
    }, E);
  });
  var m = /* @__PURE__ */ ns(function(C, w) {
    return /* @__PURE__ */ D.createElement(g, cl({}, C, {
      ref: w
    }));
  });
  return m.displayName = g.displayName, m;
}, dne = MS({
  chartName: "LineChart",
  GraphicalChild: vh,
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: Lu
  }, {
    axisType: "yAxis",
    AxisComp: Gu
  }],
  formatAxisMap: HM
}), hne = MS({
  chartName: "BarChart",
  GraphicalChild: Ia,
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: ["axis", "item"],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: Lu
  }, {
    axisType: "yAxis",
    AxisComp: Gu
  }],
  formatAxisMap: HM
}), pne = MS({
  chartName: "PieChart",
  GraphicalChild: Po,
  validateTooltipEventTypes: ["item"],
  defaultTooltipEventType: "item",
  legendContent: "children",
  axisComponents: [{
    axisType: "angleAxis",
    AxisComp: ym
  }, {
    axisType: "radiusAxis",
    AxisComp: vm
  }],
  formatAxisMap: BZ,
  defaultProps: {
    layout: "centric",
    startAngle: 0,
    endAngle: 360,
    cx: "50%",
    cy: "50%",
    innerRadius: 0,
    outerRadius: "80%"
  }
});
const fc = ["light", "dark", "corporate", "midnight", "blueprint"], EF = Cn(void 0), ebe = ({ children: e }) => {
  const [t, r] = ee(() => {
    if (typeof window < "u") {
      const n = localStorage.getItem("theme");
      if (n && fc.includes(n))
        return n;
      if (window.matchMedia("(prefers-color-scheme: dark)").matches && fc.includes("dark"))
        return "dark";
    }
    return "light";
  }), i = fe((n) => {
    if (!fc.includes(n)) {
      console.warn(`Attempted to set an unsupported theme: ${n}`);
      return;
    }
    r(n), localStorage.setItem("theme", n);
  }, []);
  return gt(() => {
    const n = document.documentElement;
    fc.forEach((o) => n.classList.remove(o)), n.classList.add(t);
  }, [t]), /* @__PURE__ */ H(EF.Provider, { value: { theme: t, availableThemes: fc, setTheme: i }, children: e });
}, ku = () => {
  const e = bt(EF);
  if (e === void 0)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, tbe = ({ data: e, dataKeyX: t, barKeys: r, title: i }) => {
  const { theme: n } = ku(), o = n === "light" ? "#314155" : "#D1D5DB", s = n === "light" ? "#E5E7EB" : "#4B5563", a = n === "light" ? "#FFFFFF" : "#1F2937", l = n === "light" ? "#314155" : "#D1D5DB";
  return (
    // Self-contained "chart card" styling from your original
    /* @__PURE__ */ ve("div", { className: "w-full h-96 bg-card border border-border rounded-lg shadow-md p-4 flex flex-col", children: [
      i && /* @__PURE__ */ H("h3", { className: "text-xl font-semibold mb-4 text-text", children: i }),
      /* @__PURE__ */ H(Yw, { width: "100%", height: "100%", children: /* @__PURE__ */ ve(
        hne,
        {
          data: e,
          margin: { top: 5, right: 30, left: 20, bottom: 5 },
          children: [
            /* @__PURE__ */ H(OS, { strokeDasharray: "3 3", stroke: s }),
            /* @__PURE__ */ H(Lu, { dataKey: t, stroke: o, tick: { fill: o } }),
            /* @__PURE__ */ H(Gu, { stroke: o, tick: { fill: o } }),
            /* @__PURE__ */ H(
              Mi,
              {
                contentStyle: { backgroundColor: a, borderColor: s },
                itemStyle: { color: l },
                labelStyle: { color: l }
              }
            ),
            /* @__PURE__ */ H(uo, {}),
            r.map((u, c) => /* @__PURE__ */ H(Ia, { dataKey: u.key, fill: u.color }, c))
          ]
        }
      ) })
    ] })
  );
}, Oa = ({
  children: e,
  className: t,
  background: r,
  border: i,
  padding: n,
  shadow: o,
  ...s
}) => {
  const c = [
    "rounded-lg",
    r !== void 0 ? r : "bg-card",
    i !== void 0 ? i : "border border-border",
    n,
    // Only added if the prop is provided
    o,
    // Only added if the prop is provided
    t
    // Allows for further customization and overrides
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ H("div", { className: c, ...s, children: e });
};
/**
 * @license lucide-react v0.537.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fne = {
  "a-arrow-down": () => import("./a-arrow-down-o3jEYjRh.mjs"),
  "a-arrow-up": () => import("./a-arrow-up-D8GHcZyy.mjs"),
  "a-large-small": () => import("./a-large-small-D3r2E2Qm.mjs"),
  accessibility: () => import("./accessibility-DqUzmKhE.mjs"),
  activity: () => import("./activity-DFuNhXWZ.mjs"),
  "air-vent": () => import("./air-vent-B3daUSxV.mjs"),
  airplay: () => import("./airplay-jU-YI-Uz.mjs"),
  "alarm-clock-check": () => import("./alarm-clock-check-BEb27RTC.mjs"),
  "alarm-check": () => import("./alarm-clock-check-BEb27RTC.mjs"),
  "alarm-clock-minus": () => import("./alarm-clock-minus-Ch43J0bH.mjs"),
  "alarm-minus": () => import("./alarm-clock-minus-Ch43J0bH.mjs"),
  "alarm-clock-off": () => import("./alarm-clock-off-B0GZLYUE.mjs"),
  "alarm-clock-plus": () => import("./alarm-clock-plus-VvtPcTyt.mjs"),
  "alarm-plus": () => import("./alarm-clock-plus-VvtPcTyt.mjs"),
  "alarm-clock": () => import("./alarm-clock-DizxYDRy.mjs"),
  "alarm-smoke": () => import("./alarm-smoke-B_rT28Pt.mjs"),
  album: () => import("./album-D_43Wuxv.mjs"),
  "align-center-horizontal": () => import("./align-center-horizontal-Cu-sCrrW.mjs"),
  "align-center-vertical": () => import("./align-center-vertical-BXE1ULBM.mjs"),
  "align-center": () => import("./align-center-CMIo3d3q.mjs"),
  "align-end-horizontal": () => import("./align-end-horizontal-DZX31ChX.mjs"),
  "align-end-vertical": () => import("./align-end-vertical-CKfdRUXD.mjs"),
  "align-horizontal-distribute-center": () => import("./align-horizontal-distribute-center-CVKkTSAQ.mjs"),
  "align-horizontal-distribute-end": () => import("./align-horizontal-distribute-end-DjD5ANfN.mjs"),
  "align-horizontal-distribute-start": () => import("./align-horizontal-distribute-start-C5ABzn7V.mjs"),
  "align-horizontal-justify-center": () => import("./align-horizontal-justify-center-DT0EqaI3.mjs"),
  "align-horizontal-justify-end": () => import("./align-horizontal-justify-end-qradvwRW.mjs"),
  "align-horizontal-justify-start": () => import("./align-horizontal-justify-start-DHdDh5lB.mjs"),
  "align-horizontal-space-around": () => import("./align-horizontal-space-around-D3yH7F-4.mjs"),
  "align-horizontal-space-between": () => import("./align-horizontal-space-between-D-zq6A5-.mjs"),
  "align-justify": () => import("./align-justify-C1cM9e6l.mjs"),
  "align-left": () => import("./align-left-DiaiL5l2.mjs"),
  "align-right": () => import("./align-right-CzhwFGLU.mjs"),
  "align-start-horizontal": () => import("./align-start-horizontal-v5v4xtwn.mjs"),
  "align-start-vertical": () => import("./align-start-vertical-CI4fF3S3.mjs"),
  "align-vertical-distribute-center": () => import("./align-vertical-distribute-center--kMaf7jj.mjs"),
  "align-vertical-distribute-end": () => import("./align-vertical-distribute-end-D-jF1Imz.mjs"),
  "align-vertical-distribute-start": () => import("./align-vertical-distribute-start-CYzPdEal.mjs"),
  "align-vertical-justify-center": () => import("./align-vertical-justify-center-xdVhLuhp.mjs"),
  "align-vertical-justify-end": () => import("./align-vertical-justify-end-spj8UqX5.mjs"),
  "align-vertical-justify-start": () => import("./align-vertical-justify-start-H5BwYGW1.mjs"),
  "align-vertical-space-around": () => import("./align-vertical-space-around-t9k7sKdm.mjs"),
  "align-vertical-space-between": () => import("./align-vertical-space-between-RgOE9DAE.mjs"),
  ambulance: () => import("./ambulance-vxGMCBni.mjs"),
  ampersand: () => import("./ampersand-C5A9in0J.mjs"),
  ampersands: () => import("./ampersands-lvMxkVmJ.mjs"),
  amphora: () => import("./amphora-IGd6SOOR.mjs"),
  anchor: () => import("./anchor-DREaq3Jt.mjs"),
  angry: () => import("./angry-BnPrCAws.mjs"),
  annoyed: () => import("./annoyed-Co9y90u9.mjs"),
  antenna: () => import("./antenna-6FNpf8Zl.mjs"),
  anvil: () => import("./anvil-BzrfkMop.mjs"),
  aperture: () => import("./aperture-BwMir_Dg.mjs"),
  "app-window-mac": () => import("./app-window-mac-D8_vI2PA.mjs"),
  "app-window": () => import("./app-window-DDPxjptQ.mjs"),
  apple: () => import("./apple-CRwViHZj.mjs"),
  "archive-restore": () => import("./archive-restore-Ilf6_WV7.mjs"),
  "archive-x": () => import("./archive-x-LB_AyV_h.mjs"),
  archive: () => import("./archive-CXO8jpry.mjs"),
  armchair: () => import("./armchair-XBX34fvE.mjs"),
  "arrow-big-down-dash": () => import("./arrow-big-down-dash-DS_TYjw3.mjs"),
  "arrow-big-down": () => import("./arrow-big-down-GXxTq8Vi.mjs"),
  "arrow-big-left-dash": () => import("./arrow-big-left-dash-DqZUQoG2.mjs"),
  "arrow-big-left": () => import("./arrow-big-left-Dh7HiBDi.mjs"),
  "arrow-big-right-dash": () => import("./arrow-big-right-dash-B1-qwpoT.mjs"),
  "arrow-big-right": () => import("./arrow-big-right-CpVyicxc.mjs"),
  "arrow-big-up-dash": () => import("./arrow-big-up-dash-BiYFkJOo.mjs"),
  "arrow-big-up": () => import("./arrow-big-up-C2RLVpMl.mjs"),
  "arrow-down-0-1": () => import("./arrow-down-0-1-BM6MvjB1.mjs"),
  "arrow-down-01": () => import("./arrow-down-0-1-BM6MvjB1.mjs"),
  "arrow-down-1-0": () => import("./arrow-down-1-0-DUtVQouA.mjs"),
  "arrow-down-10": () => import("./arrow-down-1-0-DUtVQouA.mjs"),
  "arrow-down-a-z": () => import("./arrow-down-a-z-BM8XLc4U.mjs"),
  "arrow-down-az": () => import("./arrow-down-a-z-BM8XLc4U.mjs"),
  "arrow-down-from-line": () => import("./arrow-down-from-line-CfsxYnHB.mjs"),
  "arrow-down-left": () => import("./arrow-down-left-DNew4qTB.mjs"),
  "arrow-down-narrow-wide": () => import("./arrow-down-narrow-wide-Fw_4sdav.mjs"),
  "arrow-down-right": () => import("./arrow-down-right-WjO0xRNj.mjs"),
  "arrow-down-to-dot": () => import("./arrow-down-to-dot-DL6g5Wf1.mjs"),
  "arrow-down-to-line": () => import("./arrow-down-to-line-BYuexvZ7.mjs"),
  "arrow-down-up": () => import("./arrow-down-up-CnIe68AC.mjs"),
  "arrow-down-wide-narrow": () => import("./arrow-down-wide-narrow-BHova5nl.mjs"),
  "sort-desc": () => import("./arrow-down-wide-narrow-BHova5nl.mjs"),
  "arrow-down-z-a": () => import("./arrow-down-z-a-C9-1kJ1b.mjs"),
  "arrow-down-za": () => import("./arrow-down-z-a-C9-1kJ1b.mjs"),
  "arrow-down": () => import("./arrow-down-CSefx_oS.mjs"),
  "arrow-left-from-line": () => import("./arrow-left-from-line-CE7ffQbs.mjs"),
  "arrow-left-right": () => import("./arrow-left-right-C7M6nNLG.mjs"),
  "arrow-left-to-line": () => import("./arrow-left-to-line-D96pWrfC.mjs"),
  "arrow-left": () => import("./arrow-left-XvpjsNmO.mjs"),
  "arrow-right-from-line": () => import("./arrow-right-from-line-BRGGP8KW.mjs"),
  "arrow-right-left": () => import("./arrow-right-left-B0ey0dep.mjs"),
  "arrow-right-to-line": () => import("./arrow-right-to-line-k5sKl-5Y.mjs"),
  "arrow-right": () => import("./arrow-right-COjDpDWb.mjs"),
  "arrow-up-0-1": () => import("./arrow-up-0-1-bB9DQUyj.mjs"),
  "arrow-up-01": () => import("./arrow-up-0-1-bB9DQUyj.mjs"),
  "arrow-up-1-0": () => import("./arrow-up-1-0-C0dHBUWd.mjs"),
  "arrow-up-10": () => import("./arrow-up-1-0-C0dHBUWd.mjs"),
  "arrow-up-a-z": () => import("./arrow-up-a-z-CxJv9pRs.mjs"),
  "arrow-up-az": () => import("./arrow-up-a-z-CxJv9pRs.mjs"),
  "arrow-up-down": () => import("./arrow-up-down-Ds01AB9z.mjs"),
  "arrow-up-from-dot": () => import("./arrow-up-from-dot-Cfs_U10m.mjs"),
  "arrow-up-from-line": () => import("./arrow-up-from-line-BhSGjx14.mjs"),
  "arrow-up-left": () => import("./arrow-up-left-p8FkDQQR.mjs"),
  "arrow-up-narrow-wide": () => import("./arrow-up-narrow-wide-DnjFze-C.mjs"),
  "sort-asc": () => import("./arrow-up-narrow-wide-DnjFze-C.mjs"),
  "arrow-up-right": () => import("./arrow-up-right-DyKaEfKO.mjs"),
  "arrow-up-to-line": () => import("./arrow-up-to-line-C2pAuhQq.mjs"),
  "arrow-up-wide-narrow": () => import("./arrow-up-wide-narrow-D_FIi7n5.mjs"),
  "arrow-up-z-a": () => import("./arrow-up-z-a-DrfLBRhW.mjs"),
  "arrow-up-za": () => import("./arrow-up-z-a-DrfLBRhW.mjs"),
  "arrow-up": () => import("./arrow-up-CaqPJBl1.mjs"),
  "arrows-up-from-line": () => import("./arrows-up-from-line-QqFgppth.mjs"),
  asterisk: () => import("./asterisk-CpJP2WG8.mjs"),
  "at-sign": () => import("./at-sign-C_GDnbig.mjs"),
  atom: () => import("./atom-D6tYHC1H.mjs"),
  "audio-lines": () => import("./audio-lines-BBkrbUJi.mjs"),
  "audio-waveform": () => import("./audio-waveform-BQimAefx.mjs"),
  award: () => import("./award-DGPhBSwu.mjs"),
  axe: () => import("./axe-B0V4219j.mjs"),
  "axis-3d": () => import("./axis-3d-CULQM9TG.mjs"),
  "axis-3-d": () => import("./axis-3d-CULQM9TG.mjs"),
  baby: () => import("./baby-CJsBglV6.mjs"),
  backpack: () => import("./backpack-CCq4GbwI.mjs"),
  "badge-alert": () => import("./badge-alert-TK-kHCgU.mjs"),
  "badge-cent": () => import("./badge-cent-BQYZgrsB.mjs"),
  "badge-check": () => import("./badge-check-D-iwuIh3.mjs"),
  verified: () => import("./badge-check-D-iwuIh3.mjs"),
  "badge-dollar-sign": () => import("./badge-dollar-sign-CWpVexKo.mjs"),
  "badge-euro": () => import("./badge-euro-Bsp7XI_6.mjs"),
  "badge-indian-rupee": () => import("./badge-indian-rupee-CLmZP5Di.mjs"),
  "badge-info": () => import("./badge-info-OksICQ2p.mjs"),
  "badge-japanese-yen": () => import("./badge-japanese-yen-Dl_9sukN.mjs"),
  "badge-minus": () => import("./badge-minus-DoYOe1zL.mjs"),
  "badge-percent": () => import("./badge-percent-B03zRl1S.mjs"),
  "badge-plus": () => import("./badge-plus-DHbI0JdK.mjs"),
  "badge-pound-sterling": () => import("./badge-pound-sterling-CcBR5yUS.mjs"),
  "badge-question-mark": () => import("./badge-question-mark-C-9O_fq6.mjs"),
  "badge-help": () => import("./badge-question-mark-C-9O_fq6.mjs"),
  "badge-russian-ruble": () => import("./badge-russian-ruble-D1jSRpy6.mjs"),
  "badge-swiss-franc": () => import("./badge-swiss-franc-Alc5Dmyd.mjs"),
  "badge-turkish-lira": () => import("./badge-turkish-lira-C8B_O2LN.mjs"),
  "badge-x": () => import("./badge-x-CQ8PQPlA.mjs"),
  badge: () => import("./badge-DlhyIvpP.mjs"),
  "baggage-claim": () => import("./baggage-claim-BYI5nU2k.mjs"),
  ban: () => import("./ban-dO9mNZai.mjs"),
  banana: () => import("./banana-DqO-TRtE.mjs"),
  bandage: () => import("./bandage-CXrONk8d.mjs"),
  "banknote-arrow-down": () => import("./banknote-arrow-down-m0-5E2fU.mjs"),
  "banknote-arrow-up": () => import("./banknote-arrow-up-CxyROUHT.mjs"),
  "banknote-x": () => import("./banknote-x-CRsbmBEF.mjs"),
  banknote: () => import("./banknote-CT2xE2bQ.mjs"),
  barcode: () => import("./barcode-B9pB2Ida.mjs"),
  barrel: () => import("./barrel-CogaTmuy.mjs"),
  baseline: () => import("./baseline-BDQkALZ7.mjs"),
  bath: () => import("./bath-Cm2A8QbO.mjs"),
  "battery-charging": () => import("./battery-charging-DX6BFDky.mjs"),
  "battery-full": () => import("./battery-full-9-DAG98H.mjs"),
  "battery-low": () => import("./battery-low-Bup14z4O.mjs"),
  "battery-medium": () => import("./battery-medium-BZ6MluBy.mjs"),
  "battery-plus": () => import("./battery-plus-Dzzu9Fyo.mjs"),
  "battery-warning": () => import("./battery-warning-Cg4i-Tnv.mjs"),
  battery: () => import("./battery-DG856hYZ.mjs"),
  beaker: () => import("./beaker-kVk88twc.mjs"),
  "bean-off": () => import("./bean-off-Dtouv8fM.mjs"),
  bean: () => import("./bean-D49pje2j.mjs"),
  "bed-double": () => import("./bed-double-BlOjZ1ak.mjs"),
  "bed-single": () => import("./bed-single-CU9Y3fo3.mjs"),
  bed: () => import("./bed-RvytKHBN.mjs"),
  beef: () => import("./beef-DReZBF2T.mjs"),
  "beer-off": () => import("./beer-off-P7wpCjZo.mjs"),
  beer: () => import("./beer-CxwfUFUj.mjs"),
  "bell-dot": () => import("./bell-dot-Bzi_rjWI.mjs"),
  "bell-electric": () => import("./bell-electric-Dz52Poir.mjs"),
  "bell-minus": () => import("./bell-minus-BMU6M2Ke.mjs"),
  "bell-off": () => import("./bell-off-DfLwKMsf.mjs"),
  "bell-plus": () => import("./bell-plus-DWuWEx_n.mjs"),
  "bell-ring": () => import("./bell-ring-CHNq4CEW.mjs"),
  bell: () => import("./bell-Blz1Tz9l.mjs"),
  "between-horizontal-end": () => import("./between-horizontal-end-BkbhHy5h.mjs"),
  "between-horizonal-end": () => import("./between-horizontal-end-BkbhHy5h.mjs"),
  "between-horizontal-start": () => import("./between-horizontal-start-CtnwhASw.mjs"),
  "between-horizonal-start": () => import("./between-horizontal-start-CtnwhASw.mjs"),
  "between-vertical-end": () => import("./between-vertical-end-Da1l5MJA.mjs"),
  "between-vertical-start": () => import("./between-vertical-start-iSru8NCy.mjs"),
  "biceps-flexed": () => import("./biceps-flexed-BDOLpJtD.mjs"),
  bike: () => import("./bike-C_b07-cO.mjs"),
  binary: () => import("./binary-BKKX4pBC.mjs"),
  binoculars: () => import("./binoculars-BLM6basP.mjs"),
  biohazard: () => import("./biohazard-BUNrL0Fi.mjs"),
  bird: () => import("./bird-B7_7dwMc.mjs"),
  bitcoin: () => import("./bitcoin-fhPR_Bes.mjs"),
  blend: () => import("./blend-CoM9CtT7.mjs"),
  blinds: () => import("./blinds-LSNybrPj.mjs"),
  blocks: () => import("./blocks-CNDBRF5K.mjs"),
  "bluetooth-connected": () => import("./bluetooth-connected-DcC4Pk1W.mjs"),
  "bluetooth-off": () => import("./bluetooth-off-DbKWQqJO.mjs"),
  "bluetooth-searching": () => import("./bluetooth-searching-RhCJ5xDE.mjs"),
  bluetooth: () => import("./bluetooth-DVjdzafS.mjs"),
  bold: () => import("./bold-q0RvDEDa.mjs"),
  bolt: () => import("./bolt-BEnY18ej.mjs"),
  bomb: () => import("./bomb-CWM7FnUF.mjs"),
  bone: () => import("./bone-DcZlcsEG.mjs"),
  "book-a": () => import("./book-a-CKCsY5GF.mjs"),
  "book-alert": () => import("./book-alert-CTt_BjDd.mjs"),
  "book-audio": () => import("./book-audio-3YqgtHsm.mjs"),
  "book-check": () => import("./book-check-CuKFy4Ff.mjs"),
  "book-copy": () => import("./book-copy-Yb4SOAJW.mjs"),
  "book-dashed": () => import("./book-dashed-BHZvn9mG.mjs"),
  "book-template": () => import("./book-dashed-BHZvn9mG.mjs"),
  "book-down": () => import("./book-down-BnIQnOoA.mjs"),
  "book-headphones": () => import("./book-headphones-QD9ma0pa.mjs"),
  "book-heart": () => import("./book-heart-D1ZFFgTW.mjs"),
  "book-image": () => import("./book-image-CH246X0O.mjs"),
  "book-key": () => import("./book-key-DrWYOzpz.mjs"),
  "book-lock": () => import("./book-lock-Dp3LCtJL.mjs"),
  "book-marked": () => import("./book-marked-CQkIQxxy.mjs"),
  "book-minus": () => import("./book-minus-BJ7Wc9c1.mjs"),
  "book-open-check": () => import("./book-open-check-BBwbtPAS.mjs"),
  "book-open-text": () => import("./book-open-text-xYxL1EG6.mjs"),
  "book-open": () => import("./book-open-CoNL1dqf.mjs"),
  "book-plus": () => import("./book-plus-BY0A-Mnb.mjs"),
  "book-text": () => import("./book-text-aNUhzH9B.mjs"),
  "book-type": () => import("./book-type-ClYowUx1.mjs"),
  "book-up-2": () => import("./book-up-2-Bkk3UGxM.mjs"),
  "book-up": () => import("./book-up-3pJMbgf3.mjs"),
  "book-user": () => import("./book-user-B-60DIH4.mjs"),
  "book-x": () => import("./book-x-7gGun6FX.mjs"),
  book: () => import("./book-DOXOuPWS.mjs"),
  "bookmark-check": () => import("./bookmark-check-CWL2UV2F.mjs"),
  "bookmark-minus": () => import("./bookmark-minus-BlSwVcY8.mjs"),
  "bookmark-plus": () => import("./bookmark-plus-Cfn7czXQ.mjs"),
  "bookmark-x": () => import("./bookmark-x-Dv93g2X3.mjs"),
  bookmark: () => import("./bookmark-Ck_uSzp9.mjs"),
  "boom-box": () => import("./boom-box-CkDEVm9B.mjs"),
  "bot-message-square": () => import("./bot-message-square-DutgdkBY.mjs"),
  "bot-off": () => import("./bot-off-DUxCO0DA.mjs"),
  bot: () => import("./bot-B5EQtl11.mjs"),
  "bottle-wine": () => import("./bottle-wine-Jq48q9wj.mjs"),
  "bow-arrow": () => import("./bow-arrow--intlmjK.mjs"),
  box: () => import("./box-IJfKdoKa.mjs"),
  boxes: () => import("./boxes-9NKD6sF9.mjs"),
  braces: () => import("./braces-qwE1ZfVt.mjs"),
  "curly-braces": () => import("./braces-qwE1ZfVt.mjs"),
  brackets: () => import("./brackets-BerGxLFO.mjs"),
  "brain-circuit": () => import("./brain-circuit-C4s8IPNg.mjs"),
  "brain-cog": () => import("./brain-cog-BK9zkVOY.mjs"),
  brain: () => import("./brain-B4PXsasS.mjs"),
  "brick-wall-fire": () => import("./brick-wall-fire-C86xvfse.mjs"),
  "brick-wall": () => import("./brick-wall-D3AVJ5Jw.mjs"),
  "briefcase-business": () => import("./briefcase-business-DgORn3Cb.mjs"),
  "briefcase-conveyor-belt": () => import("./briefcase-conveyor-belt-BKGow-q3.mjs"),
  "briefcase-medical": () => import("./briefcase-medical-DnL4iisV.mjs"),
  briefcase: () => import("./briefcase-mKD2dRrr.mjs"),
  "bring-to-front": () => import("./bring-to-front-C_q7D7GV.mjs"),
  "brush-cleaning": () => import("./brush-cleaning-5nNcSmVC.mjs"),
  brush: () => import("./brush-tnsgUyks.mjs"),
  bubbles: () => import("./bubbles-CouJdo70.mjs"),
  "bug-off": () => import("./bug-off-BNVGhFb3.mjs"),
  "bug-play": () => import("./bug-play-GlNvG_Ro.mjs"),
  bug: () => import("./bug-9a-xjnxH.mjs"),
  "building-2": () => import("./building-2-C28llmgE.mjs"),
  building: () => import("./building-DO9rjgxP.mjs"),
  "bus-front": () => import("./bus-front-Cx5tz3ER.mjs"),
  bus: () => import("./bus-CPPLPJPP.mjs"),
  "cable-car": () => import("./cable-car-DT-j_viy.mjs"),
  cable: () => import("./cable-DvRepAY8.mjs"),
  "cake-slice": () => import("./cake-slice-CIUDd7et.mjs"),
  cake: () => import("./cake-DCAJyv9t.mjs"),
  calculator: () => import("./calculator-BC-bk54a.mjs"),
  "calendar-1": () => import("./calendar-1-BVo1op-x.mjs"),
  "calendar-arrow-down": () => import("./calendar-arrow-down-DNom1xOa.mjs"),
  "calendar-arrow-up": () => import("./calendar-arrow-up-CfLuX9Rd.mjs"),
  "calendar-check-2": () => import("./calendar-check-2-BstiRWMn.mjs"),
  "calendar-check": () => import("./calendar-check-KFWAya13.mjs"),
  "calendar-clock": () => import("./calendar-clock-d1hn4qKZ.mjs"),
  "calendar-cog": () => import("./calendar-cog-BYm7fGwX.mjs"),
  "calendar-days": () => import("./calendar-days-BB744uMX.mjs"),
  "calendar-fold": () => import("./calendar-fold-BdAItbaI.mjs"),
  "calendar-heart": () => import("./calendar-heart-BEr8Vo-l.mjs"),
  "calendar-minus-2": () => import("./calendar-minus-2-CINuFIGW.mjs"),
  "calendar-minus": () => import("./calendar-minus-BfThM4Vq.mjs"),
  "calendar-off": () => import("./calendar-off-dVaI9elg.mjs"),
  "calendar-plus-2": () => import("./calendar-plus-2-Lb7aXCgz.mjs"),
  "calendar-plus": () => import("./calendar-plus-CL9n7NPd.mjs"),
  "calendar-range": () => import("./calendar-range-DSNFyb1b.mjs"),
  "calendar-search": () => import("./calendar-search-JqIsdpxA.mjs"),
  "calendar-sync": () => import("./calendar-sync-DjlNuRah.mjs"),
  "calendar-x-2": () => import("./calendar-x-2-BLi-1vqk.mjs"),
  "calendar-x": () => import("./calendar-x-CLKDSQtY.mjs"),
  calendar: () => import("./calendar-CWzEfF6q.mjs"),
  "camera-off": () => import("./camera-off-h-kYycrj.mjs"),
  camera: () => import("./camera-TwLw1yhW.mjs"),
  "candy-cane": () => import("./candy-cane-Xtk5ncJY.mjs"),
  "candy-off": () => import("./candy-off-CFlrYyZW.mjs"),
  candy: () => import("./candy-Bv4WTlCl.mjs"),
  cannabis: () => import("./cannabis-DIxL1Jd6.mjs"),
  "captions-off": () => import("./captions-off-CZADxKeI.mjs"),
  captions: () => import("./captions-BpDwM2AB.mjs"),
  subtitles: () => import("./captions-BpDwM2AB.mjs"),
  "car-front": () => import("./car-front-rgaVQ5df.mjs"),
  "car-taxi-front": () => import("./car-taxi-front-CPBWdwuD.mjs"),
  car: () => import("./car-Di2Gsfa6.mjs"),
  caravan: () => import("./caravan-C_sOyl2w.mjs"),
  "card-sim": () => import("./card-sim-B1CSXzK_.mjs"),
  carrot: () => import("./carrot-Bjz7Je2a.mjs"),
  "case-lower": () => import("./case-lower-CTBBPM5M.mjs"),
  "case-sensitive": () => import("./case-sensitive-CJaSCRgk.mjs"),
  "case-upper": () => import("./case-upper-_WM3LLFO.mjs"),
  "cassette-tape": () => import("./cassette-tape-BNTquSmH.mjs"),
  cast: () => import("./cast-BxNfzFzn.mjs"),
  castle: () => import("./castle-BJ8-23kZ.mjs"),
  cat: () => import("./cat-jfPlc4nB.mjs"),
  cctv: () => import("./cctv-C8UOjXyz.mjs"),
  "chart-area": () => import("./chart-area-DcmnkmwG.mjs"),
  "area-chart": () => import("./chart-area-DcmnkmwG.mjs"),
  "chart-bar-big": () => import("./chart-bar-big-Bdd7AzvS.mjs"),
  "bar-chart-horizontal-big": () => import("./chart-bar-big-Bdd7AzvS.mjs"),
  "chart-bar-decreasing": () => import("./chart-bar-decreasing-DBCUe7pV.mjs"),
  "chart-bar-increasing": () => import("./chart-bar-increasing-vVfpohDw.mjs"),
  "chart-bar-stacked": () => import("./chart-bar-stacked-Drg6JunY.mjs"),
  "chart-bar": () => import("./chart-bar-eCUq-fcd.mjs"),
  "bar-chart-horizontal": () => import("./chart-bar-eCUq-fcd.mjs"),
  "chart-candlestick": () => import("./chart-candlestick-Ca1-zgj-.mjs"),
  "candlestick-chart": () => import("./chart-candlestick-Ca1-zgj-.mjs"),
  "chart-column-big": () => import("./chart-column-big-CEeT_ycq.mjs"),
  "bar-chart-big": () => import("./chart-column-big-CEeT_ycq.mjs"),
  "chart-column-decreasing": () => import("./chart-column-decreasing-DQW_u6Tx.mjs"),
  "chart-column-increasing": () => import("./chart-column-increasing-BOqGn-O5.mjs"),
  "bar-chart-4": () => import("./chart-column-increasing-BOqGn-O5.mjs"),
  "chart-column-stacked": () => import("./chart-column-stacked-CgKpRCPK.mjs"),
  "chart-column": () => import("./chart-column-Cd65Wp9q.mjs"),
  "bar-chart-3": () => import("./chart-column-Cd65Wp9q.mjs"),
  "chart-gantt": () => import("./chart-gantt-0OMh8NzU.mjs"),
  "chart-line": () => import("./chart-line-3gUUStW1.mjs"),
  "line-chart": () => import("./chart-line-3gUUStW1.mjs"),
  "chart-network": () => import("./chart-network-CqWJVEL0.mjs"),
  "chart-no-axes-column-decreasing": () => import("./chart-no-axes-column-decreasing-DTXtYYjE.mjs"),
  "chart-no-axes-column-increasing": () => import("./chart-no-axes-column-increasing-C97LUV1x.mjs"),
  "bar-chart": () => import("./chart-no-axes-column-increasing-C97LUV1x.mjs"),
  "chart-no-axes-column": () => import("./chart-no-axes-column-j79G0IVI.mjs"),
  "bar-chart-2": () => import("./chart-no-axes-column-j79G0IVI.mjs"),
  "chart-no-axes-combined": () => import("./chart-no-axes-combined-BypmXgem.mjs"),
  "chart-no-axes-gantt": () => import("./chart-no-axes-gantt-VTGbqbqs.mjs"),
  "gantt-chart": () => import("./chart-no-axes-gantt-VTGbqbqs.mjs"),
  "chart-pie": () => import("./chart-pie-D3Djr80Y.mjs"),
  "pie-chart": () => import("./chart-pie-D3Djr80Y.mjs"),
  "chart-scatter": () => import("./chart-scatter-CcEuTswf.mjs"),
  "scatter-chart": () => import("./chart-scatter-CcEuTswf.mjs"),
  "chart-spline": () => import("./chart-spline-CUsJ638F.mjs"),
  "check-check": () => import("./check-check-p2tdQH8q.mjs"),
  "check-line": () => import("./check-line-CWBwOp3n.mjs"),
  check: () => import("./check-aXe_GvRt.mjs"),
  "chef-hat": () => import("./chef-hat-CpORJWl9.mjs"),
  cherry: () => import("./cherry-BuUBUk8C.mjs"),
  "chevron-down": () => import("./chevron-down-Dsz6irI-.mjs"),
  "chevron-first": () => import("./chevron-first-BUawVnq_.mjs"),
  "chevron-last": () => import("./chevron-last-DYbBUQjS.mjs"),
  "chevron-left": () => import("./chevron-left-BsBweQNf.mjs"),
  "chevron-right": () => import("./chevron-right-BoShNcfj.mjs"),
  "chevron-up": () => import("./chevron-up-B0e_qdTj.mjs"),
  "chevrons-down-up": () => import("./chevrons-down-up-BYTk2IDS.mjs"),
  "chevrons-down": () => import("./chevrons-down-Dcky9GxW.mjs"),
  "chevrons-left-right-ellipsis": () => import("./chevrons-left-right-ellipsis-CRAcoge0.mjs"),
  "chevrons-left-right": () => import("./chevrons-left-right-DJRsYasA.mjs"),
  "chevrons-left": () => import("./chevrons-left-CeXUzghi.mjs"),
  "chevrons-right-left": () => import("./chevrons-right-left-BgDCkPcE.mjs"),
  "chevrons-right": () => import("./chevrons-right-DFnojtHs.mjs"),
  "chevrons-up-down": () => import("./chevrons-up-down-uNG0ZUZt.mjs"),
  "chevrons-up": () => import("./chevrons-up-CbTepNcu.mjs"),
  chrome: () => import("./chrome-DOTojbWD.mjs"),
  church: () => import("./church-BVFzSUwQ.mjs"),
  "cigarette-off": () => import("./cigarette-off-DB1s8x8c.mjs"),
  cigarette: () => import("./cigarette-lAodc4zS.mjs"),
  "circle-alert": () => import("./circle-alert-CtGcRr4Y.mjs"),
  "alert-circle": () => import("./circle-alert-CtGcRr4Y.mjs"),
  "circle-arrow-down": () => import("./circle-arrow-down-jhbkDO11.mjs"),
  "arrow-down-circle": () => import("./circle-arrow-down-jhbkDO11.mjs"),
  "circle-arrow-left": () => import("./circle-arrow-left-MlApxvOV.mjs"),
  "arrow-left-circle": () => import("./circle-arrow-left-MlApxvOV.mjs"),
  "circle-arrow-out-down-left": () => import("./circle-arrow-out-down-left-B0VXBHuc.mjs"),
  "arrow-down-left-from-circle": () => import("./circle-arrow-out-down-left-B0VXBHuc.mjs"),
  "circle-arrow-out-down-right": () => import("./circle-arrow-out-down-right-K_t7oDE_.mjs"),
  "arrow-down-right-from-circle": () => import("./circle-arrow-out-down-right-K_t7oDE_.mjs"),
  "circle-arrow-out-up-left": () => import("./circle-arrow-out-up-left-CYDg7Un4.mjs"),
  "arrow-up-left-from-circle": () => import("./circle-arrow-out-up-left-CYDg7Un4.mjs"),
  "circle-arrow-out-up-right": () => import("./circle-arrow-out-up-right-mGcHNUan.mjs"),
  "arrow-up-right-from-circle": () => import("./circle-arrow-out-up-right-mGcHNUan.mjs"),
  "circle-arrow-right": () => import("./circle-arrow-right-BzAHz-j0.mjs"),
  "arrow-right-circle": () => import("./circle-arrow-right-BzAHz-j0.mjs"),
  "circle-arrow-up": () => import("./circle-arrow-up-CLYIgI8a.mjs"),
  "arrow-up-circle": () => import("./circle-arrow-up-CLYIgI8a.mjs"),
  "circle-check-big": () => import("./circle-check-big-C7ijgMsS.mjs"),
  "check-circle": () => import("./circle-check-big-C7ijgMsS.mjs"),
  "circle-check": () => import("./circle-check-BtzxNgqE.mjs"),
  "check-circle-2": () => import("./circle-check-BtzxNgqE.mjs"),
  "circle-chevron-down": () => import("./circle-chevron-down-CdsqlFZ_.mjs"),
  "chevron-down-circle": () => import("./circle-chevron-down-CdsqlFZ_.mjs"),
  "circle-chevron-left": () => import("./circle-chevron-left-BPiIZrGy.mjs"),
  "chevron-left-circle": () => import("./circle-chevron-left-BPiIZrGy.mjs"),
  "circle-chevron-right": () => import("./circle-chevron-right-CIJrC8HJ.mjs"),
  "chevron-right-circle": () => import("./circle-chevron-right-CIJrC8HJ.mjs"),
  "circle-chevron-up": () => import("./circle-chevron-up-B_uc7bgU.mjs"),
  "chevron-up-circle": () => import("./circle-chevron-up-B_uc7bgU.mjs"),
  "circle-dashed": () => import("./circle-dashed-r_oNcc7_.mjs"),
  "circle-divide": () => import("./circle-divide-CZ_uGQd-.mjs"),
  "divide-circle": () => import("./circle-divide-CZ_uGQd-.mjs"),
  "circle-dollar-sign": () => import("./circle-dollar-sign-BGFZ18gI.mjs"),
  "circle-dot-dashed": () => import("./circle-dot-dashed-mGs6UhmB.mjs"),
  "circle-dot": () => import("./circle-dot-DTj5ugRx.mjs"),
  "circle-ellipsis": () => import("./circle-ellipsis-BdBZPVAQ.mjs"),
  "circle-equal": () => import("./circle-equal-5jfwmOg1.mjs"),
  "circle-fading-arrow-up": () => import("./circle-fading-arrow-up-SyRNERxM.mjs"),
  "circle-fading-plus": () => import("./circle-fading-plus-CRiGDSce.mjs"),
  "circle-gauge": () => import("./circle-gauge-DNxakOgR.mjs"),
  "gauge-circle": () => import("./circle-gauge-DNxakOgR.mjs"),
  "circle-minus": () => import("./circle-minus-CBb7G3lc.mjs"),
  "minus-circle": () => import("./circle-minus-CBb7G3lc.mjs"),
  "circle-off": () => import("./circle-off-DinoQ8vl.mjs"),
  "circle-parking-off": () => import("./circle-parking-off-CiZSnZyt.mjs"),
  "parking-circle-off": () => import("./circle-parking-off-CiZSnZyt.mjs"),
  "circle-parking": () => import("./circle-parking-BjODS6nk.mjs"),
  "parking-circle": () => import("./circle-parking-BjODS6nk.mjs"),
  "circle-pause": () => import("./circle-pause-ClYEfB9B.mjs"),
  "pause-circle": () => import("./circle-pause-ClYEfB9B.mjs"),
  "circle-percent": () => import("./circle-percent-DXvJd7zx.mjs"),
  "percent-circle": () => import("./circle-percent-DXvJd7zx.mjs"),
  "circle-play": () => import("./circle-play-Cd2WK9ID.mjs"),
  "play-circle": () => import("./circle-play-Cd2WK9ID.mjs"),
  "circle-plus": () => import("./circle-plus-qP54Ir07.mjs"),
  "plus-circle": () => import("./circle-plus-qP54Ir07.mjs"),
  "circle-pound-sterling": () => import("./circle-pound-sterling-h0FZSHfv.mjs"),
  "circle-power": () => import("./circle-power-Bkf4G0Kz.mjs"),
  "power-circle": () => import("./circle-power-Bkf4G0Kz.mjs"),
  "circle-question-mark": () => import("./circle-question-mark-DHeYrQZ_.mjs"),
  "help-circle": () => import("./circle-question-mark-DHeYrQZ_.mjs"),
  "circle-help": () => import("./circle-question-mark-DHeYrQZ_.mjs"),
  "circle-slash-2": () => import("./circle-slash-2-DyIlwL5r.mjs"),
  "circle-slashed": () => import("./circle-slash-2-DyIlwL5r.mjs"),
  "circle-slash": () => import("./circle-slash-DSEShV-7.mjs"),
  "circle-small": () => import("./circle-small-TP21b1_0.mjs"),
  "circle-star": () => import("./circle-star-xxO5DQOc.mjs"),
  "circle-stop": () => import("./circle-stop-7ev7i7Xu.mjs"),
  "stop-circle": () => import("./circle-stop-7ev7i7Xu.mjs"),
  "circle-user-round": () => import("./circle-user-round-C_rIAZZA.mjs"),
  "user-circle-2": () => import("./circle-user-round-C_rIAZZA.mjs"),
  "circle-user": () => import("./circle-user-CfQ5TQan.mjs"),
  "user-circle": () => import("./circle-user-CfQ5TQan.mjs"),
  "circle-x": () => import("./circle-x-Ck8m4DTv.mjs"),
  "x-circle": () => import("./circle-x-Ck8m4DTv.mjs"),
  circle: () => import("./circle-DrxK-cyd.mjs"),
  "circuit-board": () => import("./circuit-board-q9DweT1T.mjs"),
  citrus: () => import("./citrus-CBv_TJI9.mjs"),
  clapperboard: () => import("./clapperboard-Cp_tjI32.mjs"),
  "clipboard-check": () => import("./clipboard-check-CTbO2G1t.mjs"),
  "clipboard-clock": () => import("./clipboard-clock-BpuEcjWH.mjs"),
  "clipboard-copy": () => import("./clipboard-copy-DQ1U8nwg.mjs"),
  "clipboard-list": () => import("./clipboard-list-DhrUjmis.mjs"),
  "clipboard-minus": () => import("./clipboard-minus-DRVKLGFj.mjs"),
  "clipboard-paste": () => import("./clipboard-paste-8u0aJHUY.mjs"),
  "clipboard-pen-line": () => import("./clipboard-pen-line-CxsdaVrV.mjs"),
  "clipboard-signature": () => import("./clipboard-pen-line-CxsdaVrV.mjs"),
  "clipboard-pen": () => import("./clipboard-pen-DkF1vkdX.mjs"),
  "clipboard-edit": () => import("./clipboard-pen-DkF1vkdX.mjs"),
  "clipboard-plus": () => import("./clipboard-plus-D-JyIAOl.mjs"),
  "clipboard-type": () => import("./clipboard-type-Bf-Bn7eA.mjs"),
  "clipboard-x": () => import("./clipboard-x-uU9hgQHh.mjs"),
  clipboard: () => import("./clipboard-DR65l60E.mjs"),
  "clock-1": () => import("./clock-1-D4wuWMFt.mjs"),
  "clock-10": () => import("./clock-10-DTpHPzgP.mjs"),
  "clock-11": () => import("./clock-11-CjRid3-c.mjs"),
  "clock-12": () => import("./clock-12-BWX7hrHa.mjs"),
  "clock-2": () => import("./clock-2-DI3FAmAD.mjs"),
  "clock-3": () => import("./clock-3-PWVtLcCT.mjs"),
  "clock-4": () => import("./clock-4-CihyGTy0.mjs"),
  "clock-5": () => import("./clock-5-D0LN6xIq.mjs"),
  "clock-6": () => import("./clock-6-CLMW5II1.mjs"),
  "clock-7": () => import("./clock-7-ZdLc9T8L.mjs"),
  "clock-8": () => import("./clock-8-tBaqLlmV.mjs"),
  "clock-9": () => import("./clock-9-Cc2Q72rL.mjs"),
  "clock-alert": () => import("./clock-alert-C7eBOQQ-.mjs"),
  "clock-arrow-down": () => import("./clock-arrow-down-CLlMbjoh.mjs"),
  "clock-arrow-up": () => import("./clock-arrow-up-B4YlZeAU.mjs"),
  "clock-fading": () => import("./clock-fading-Du7AJzaS.mjs"),
  "clock-plus": () => import("./clock-plus-CxskBKEZ.mjs"),
  clock: () => import("./clock-B6yXxply.mjs"),
  "closed-caption": () => import("./closed-caption-DLiT78iA.mjs"),
  "cloud-alert": () => import("./cloud-alert-DbjKTpuG.mjs"),
  "cloud-check": () => import("./cloud-check-n-NJ9wSC.mjs"),
  "cloud-cog": () => import("./cloud-cog-B8mYVtVY.mjs"),
  "cloud-download": () => import("./cloud-download-Y4cY5eZ2.mjs"),
  "download-cloud": () => import("./cloud-download-Y4cY5eZ2.mjs"),
  "cloud-drizzle": () => import("./cloud-drizzle-IVDxobvA.mjs"),
  "cloud-fog": () => import("./cloud-fog-CEA50Mrk.mjs"),
  "cloud-hail": () => import("./cloud-hail-sLKWiEsh.mjs"),
  "cloud-lightning": () => import("./cloud-lightning-BeDwb-2R.mjs"),
  "cloud-moon-rain": () => import("./cloud-moon-rain-D-prfVuy.mjs"),
  "cloud-moon": () => import("./cloud-moon-DUvOtBcT.mjs"),
  "cloud-off": () => import("./cloud-off-Dq9kNGsu.mjs"),
  "cloud-rain-wind": () => import("./cloud-rain-wind-vIPuMhlW.mjs"),
  "cloud-rain": () => import("./cloud-rain-Cp01bEKb.mjs"),
  "cloud-snow": () => import("./cloud-snow-jtnoNiPS.mjs"),
  "cloud-sun-rain": () => import("./cloud-sun-rain-CmNSuxz5.mjs"),
  "cloud-sun": () => import("./cloud-sun-DiIQT9ov.mjs"),
  "cloud-upload": () => import("./cloud-upload-CmKJvc_C.mjs"),
  "upload-cloud": () => import("./cloud-upload-CmKJvc_C.mjs"),
  cloud: () => import("./cloud-yleTW_A8.mjs"),
  cloudy: () => import("./cloudy-BeAHhDHR.mjs"),
  clover: () => import("./clover-CGO_Jwx8.mjs"),
  club: () => import("./club-A09ox_mQ.mjs"),
  "code-xml": () => import("./code-xml-E4U0_QK0.mjs"),
  "code-2": () => import("./code-xml-E4U0_QK0.mjs"),
  code: () => import("./code-2h3WYVRL.mjs"),
  codepen: () => import("./codepen-BGWaJvbo.mjs"),
  codesandbox: () => import("./codesandbox-BZ061tgT.mjs"),
  coffee: () => import("./coffee-wMcPcRdw.mjs"),
  cog: () => import("./cog-DcK-tQb-.mjs"),
  coins: () => import("./coins-dh2C-dlK.mjs"),
  "columns-2": () => import("./columns-2-gyCD6a3X.mjs"),
  columns: () => import("./columns-2-gyCD6a3X.mjs"),
  "columns-3-cog": () => import("./columns-3-cog-BjpKt-Bm.mjs"),
  "columns-settings": () => import("./columns-3-cog-BjpKt-Bm.mjs"),
  "table-config": () => import("./columns-3-cog-BjpKt-Bm.mjs"),
  "columns-3": () => import("./columns-3-DrEZt7zD.mjs"),
  "panels-left-right": () => import("./columns-3-DrEZt7zD.mjs"),
  "columns-4": () => import("./columns-4-Zz5nI9bX.mjs"),
  combine: () => import("./combine-BJQw2NeV.mjs"),
  command: () => import("./command-wU3vn21x.mjs"),
  compass: () => import("./compass-B_97gci5.mjs"),
  component: () => import("./component-DBOdY1sP.mjs"),
  computer: () => import("./computer-CHZGxz66.mjs"),
  "concierge-bell": () => import("./concierge-bell-COU89A1X.mjs"),
  cone: () => import("./cone-COhSNV3Z.mjs"),
  construction: () => import("./construction-CwBS_P1c.mjs"),
  "contact-round": () => import("./contact-round-BDmcrMDD.mjs"),
  "contact-2": () => import("./contact-round-BDmcrMDD.mjs"),
  contact: () => import("./contact-h26zgCQt.mjs"),
  container: () => import("./container-Sco8y7tt.mjs"),
  contrast: () => import("./contrast-BiDakHJY.mjs"),
  cookie: () => import("./cookie-DSZz5mRu.mjs"),
  "cooking-pot": () => import("./cooking-pot-BBb_ZhLd.mjs"),
  "copy-check": () => import("./copy-check-BMobuZ0s.mjs"),
  "copy-minus": () => import("./copy-minus-CnlWjK-Z.mjs"),
  "copy-plus": () => import("./copy-plus-u_4nRdY3.mjs"),
  "copy-slash": () => import("./copy-slash-IzUR3za8.mjs"),
  "copy-x": () => import("./copy-x-BhA6WBRm.mjs"),
  copy: () => import("./copy-DwjwPDrb.mjs"),
  copyleft: () => import("./copyleft-c_djkIBQ.mjs"),
  copyright: () => import("./copyright-CpkhQi9N.mjs"),
  "corner-down-left": () => import("./corner-down-left-WyFj7E12.mjs"),
  "corner-down-right": () => import("./corner-down-right-DquaeArJ.mjs"),
  "corner-left-down": () => import("./corner-left-down-DHswOZf2.mjs"),
  "corner-left-up": () => import("./corner-left-up-B38OBTAi.mjs"),
  "corner-right-down": () => import("./corner-right-down-CPlw7SUV.mjs"),
  "corner-right-up": () => import("./corner-right-up-BWDP67bp.mjs"),
  "corner-up-left": () => import("./corner-up-left-DX29x6Dw.mjs"),
  "corner-up-right": () => import("./corner-up-right-DjWFSIRM.mjs"),
  cpu: () => import("./cpu-CZyacpKn.mjs"),
  "creative-commons": () => import("./creative-commons-D-mwGaFd.mjs"),
  "credit-card": () => import("./credit-card-C5XjVGZt.mjs"),
  croissant: () => import("./croissant-DuaQGnKU.mjs"),
  crop: () => import("./crop-C6vVvv4P.mjs"),
  cross: () => import("./cross-B94TWsTA.mjs"),
  crosshair: () => import("./crosshair-DZioDZu0.mjs"),
  crown: () => import("./crown-B0AHP5Jw.mjs"),
  cuboid: () => import("./cuboid-Bn-nUcgt.mjs"),
  "cup-soda": () => import("./cup-soda-BWMzJYvE.mjs"),
  currency: () => import("./currency-C9dX3nnl.mjs"),
  cylinder: () => import("./cylinder-BIdc6TG4.mjs"),
  dam: () => import("./dam-CpAj6Vi8.mjs"),
  "database-backup": () => import("./database-backup-Bg4_r3GH.mjs"),
  "database-zap": () => import("./database-zap-DrdnmIyI.mjs"),
  database: () => import("./database-V6hWrLvc.mjs"),
  "decimals-arrow-left": () => import("./decimals-arrow-left-Y8lfgZll.mjs"),
  "decimals-arrow-right": () => import("./decimals-arrow-right-Cru4iR_t.mjs"),
  delete: () => import("./delete-CTTLf9UA.mjs"),
  dessert: () => import("./dessert-DQOHkijN.mjs"),
  diameter: () => import("./diameter-CBFXtXEq.mjs"),
  "diamond-minus": () => import("./diamond-minus-D5WSQxaw.mjs"),
  "diamond-percent": () => import("./diamond-percent-B79xjy_J.mjs"),
  "percent-diamond": () => import("./diamond-percent-B79xjy_J.mjs"),
  "diamond-plus": () => import("./diamond-plus-JKDc_-OC.mjs"),
  diamond: () => import("./diamond-CSIKpX1I.mjs"),
  "dice-1": () => import("./dice-1-b-CNrtsm.mjs"),
  "dice-2": () => import("./dice-2-CIMXK2hs.mjs"),
  "dice-3": () => import("./dice-3-BD9Nr-K9.mjs"),
  "dice-4": () => import("./dice-4-jl8SMa3d.mjs"),
  "dice-5": () => import("./dice-5-DmGGsB3P.mjs"),
  "dice-6": () => import("./dice-6-CKF5qhQl.mjs"),
  dices: () => import("./dices-B7xVdxq-.mjs"),
  diff: () => import("./diff-PcjS2iWS.mjs"),
  "disc-2": () => import("./disc-2-CLe4qHpt.mjs"),
  "disc-3": () => import("./disc-3-Bvv8IVAR.mjs"),
  "disc-album": () => import("./disc-album-BpptlsCU.mjs"),
  disc: () => import("./disc-CpRKGxKq.mjs"),
  divide: () => import("./divide-BGDdMyPW.mjs"),
  "dna-off": () => import("./dna-off-B6aAi32u.mjs"),
  dna: () => import("./dna-BobBILIK.mjs"),
  dock: () => import("./dock-CGhHxLZR.mjs"),
  dog: () => import("./dog-CN0ydU9O.mjs"),
  "dollar-sign": () => import("./dollar-sign-YpQfixLu.mjs"),
  donut: () => import("./donut-C4vzYxHQ.mjs"),
  "door-closed-locked": () => import("./door-closed-locked-IFpHC2Em.mjs"),
  "door-closed": () => import("./door-closed-Bm7ope8n.mjs"),
  "door-open": () => import("./door-open-DCK2OxmS.mjs"),
  dot: () => import("./dot-32HxD_6r.mjs"),
  download: () => import("./download-Cl1HSU3m.mjs"),
  "drafting-compass": () => import("./drafting-compass-DgA2Yz1X.mjs"),
  drama: () => import("./drama-XRhaC-rR.mjs"),
  dribbble: () => import("./dribbble-xhJmrx0o.mjs"),
  drill: () => import("./drill-BDPpmrDg.mjs"),
  drone: () => import("./drone-Doky4VZA.mjs"),
  "droplet-off": () => import("./droplet-off-BDurFJ8N.mjs"),
  droplet: () => import("./droplet-DKVec6re.mjs"),
  droplets: () => import("./droplets-V1A5X315.mjs"),
  drum: () => import("./drum-DReEWP_w.mjs"),
  drumstick: () => import("./drumstick-0wsmrfYF.mjs"),
  dumbbell: () => import("./dumbbell-BoWTnTlU.mjs"),
  "ear-off": () => import("./ear-off-BNJZ-VM4.mjs"),
  ear: () => import("./ear-CSWeI2gM.mjs"),
  "earth-lock": () => import("./earth-lock-WX13fF5k.mjs"),
  earth: () => import("./earth-D2FBpHWv.mjs"),
  "globe-2": () => import("./earth-D2FBpHWv.mjs"),
  eclipse: () => import("./eclipse-UJnl-19s.mjs"),
  "egg-fried": () => import("./egg-fried-C5S_q2fF.mjs"),
  "egg-off": () => import("./egg-off-CN_GtCXv.mjs"),
  egg: () => import("./egg-BC69Vk-V.mjs"),
  "ellipsis-vertical": () => import("./ellipsis-vertical-B-ekw1ar.mjs"),
  "more-vertical": () => import("./ellipsis-vertical-B-ekw1ar.mjs"),
  ellipsis: () => import("./ellipsis-bHs8i_To.mjs"),
  "more-horizontal": () => import("./ellipsis-bHs8i_To.mjs"),
  "equal-approximately": () => import("./equal-approximately-C3vAXJIR.mjs"),
  "equal-not": () => import("./equal-not-Cm698Co6.mjs"),
  equal: () => import("./equal-DmpCSXzo.mjs"),
  eraser: () => import("./eraser-zxaRx7RT.mjs"),
  "ethernet-port": () => import("./ethernet-port-Bd4RaLJB.mjs"),
  euro: () => import("./euro-C5Xci-P2.mjs"),
  expand: () => import("./expand-BMtzJdB8.mjs"),
  "external-link": () => import("./external-link-DWnTxsCm.mjs"),
  "eye-closed": () => import("./eye-closed-BBQA0gbK.mjs"),
  "eye-off": () => import("./eye-off-C-GIsefo.mjs"),
  eye: () => import("./eye-CNrSimWC.mjs"),
  facebook: () => import("./facebook-CWwGkanQ.mjs"),
  factory: () => import("./factory-BVuDbyv3.mjs"),
  fan: () => import("./fan-BUR21y60.mjs"),
  "fast-forward": () => import("./fast-forward-BL963zon.mjs"),
  feather: () => import("./feather-CVvFM-kt.mjs"),
  fence: () => import("./fence-m_TWkE8o.mjs"),
  "ferris-wheel": () => import("./ferris-wheel-COtibg8I.mjs"),
  figma: () => import("./figma-CrmGntMt.mjs"),
  "file-archive": () => import("./file-archive-CdZj7Hc1.mjs"),
  "file-audio-2": () => import("./file-audio-2-DlAVwtgU.mjs"),
  "file-audio": () => import("./file-audio-D7-qZB53.mjs"),
  "file-axis-3d": () => import("./file-axis-3d-BDysWJy_.mjs"),
  "file-axis-3-d": () => import("./file-axis-3d-BDysWJy_.mjs"),
  "file-badge-2": () => import("./file-badge-2-CkfzFkwb.mjs"),
  "file-badge": () => import("./file-badge-DMCuCuGc.mjs"),
  "file-box": () => import("./file-box-CrQb5vjq.mjs"),
  "file-chart-column-increasing": () => import("./file-chart-column-increasing-BBHY6n1J.mjs"),
  "file-bar-chart": () => import("./file-chart-column-increasing-BBHY6n1J.mjs"),
  "file-chart-column": () => import("./file-chart-column-CltjxDC_.mjs"),
  "file-bar-chart-2": () => import("./file-chart-column-CltjxDC_.mjs"),
  "file-chart-line": () => import("./file-chart-line-CtVXoEUY.mjs"),
  "file-line-chart": () => import("./file-chart-line-CtVXoEUY.mjs"),
  "file-chart-pie": () => import("./file-chart-pie-CBY_VFTm.mjs"),
  "file-pie-chart": () => import("./file-chart-pie-CBY_VFTm.mjs"),
  "file-check-2": () => import("./file-check-2-SKrscGHU.mjs"),
  "file-check": () => import("./file-check-7HiMqNuv.mjs"),
  "file-clock": () => import("./file-clock-DMJbTxEQ.mjs"),
  "file-code-2": () => import("./file-code-2-C8i3Jwcw.mjs"),
  "file-code": () => import("./file-code-3QWTe3jF.mjs"),
  "file-cog": () => import("./file-cog-BNUMxQSj.mjs"),
  "file-cog-2": () => import("./file-cog-BNUMxQSj.mjs"),
  "file-diff": () => import("./file-diff-CV5NnkiF.mjs"),
  "file-digit": () => import("./file-digit-1QPsxHV0.mjs"),
  "file-down": () => import("./file-down-DIRhwGN4.mjs"),
  "file-heart": () => import("./file-heart-vP3a59wq.mjs"),
  "file-image": () => import("./file-image-BcNxjrnd.mjs"),
  "file-input": () => import("./file-input-BjPfmPwz.mjs"),
  "file-json-2": () => import("./file-json-2-D1XWg3vG.mjs"),
  "file-json": () => import("./file-json-C1fndzk0.mjs"),
  "file-key-2": () => import("./file-key-2-CfuQ_fSS.mjs"),
  "file-key": () => import("./file-key-B3XVZrxa.mjs"),
  "file-lock-2": () => import("./file-lock-2-bl-4k3F6.mjs"),
  "file-lock": () => import("./file-lock-CHa1Bi3L.mjs"),
  "file-minus-2": () => import("./file-minus-2-DSDDlSC8.mjs"),
  "file-minus": () => import("./file-minus-D084Fm2j.mjs"),
  "file-music": () => import("./file-music-RJFn9_uK.mjs"),
  "file-output": () => import("./file-output-DXxTh_oi.mjs"),
  "file-pen-line": () => import("./file-pen-line-ocUxbbUr.mjs"),
  "file-signature": () => import("./file-pen-line-ocUxbbUr.mjs"),
  "file-pen": () => import("./file-pen-BgGSsssB.mjs"),
  "file-edit": () => import("./file-pen-BgGSsssB.mjs"),
  "file-play": () => import("./file-play-twrgZ74C.mjs"),
  "file-video": () => import("./file-play-twrgZ74C.mjs"),
  "file-plus-2": () => import("./file-plus-2-BmA4r-E4.mjs"),
  "file-plus": () => import("./file-plus-CrBtCxno.mjs"),
  "file-question-mark": () => import("./file-question-mark-uHPqArM_.mjs"),
  "file-question": () => import("./file-question-mark-uHPqArM_.mjs"),
  "file-scan": () => import("./file-scan-BfYVsxeZ.mjs"),
  "file-search-2": () => import("./file-search-2-D2JrQ-xL.mjs"),
  "file-search": () => import("./file-search-Iw_J_ycD.mjs"),
  "file-sliders": () => import("./file-sliders-13W_zy3d.mjs"),
  "file-spreadsheet": () => import("./file-spreadsheet-BDm8gvqG.mjs"),
  "file-stack": () => import("./file-stack-BdaVw67e.mjs"),
  "file-symlink": () => import("./file-symlink-Bq___dey.mjs"),
  "file-terminal": () => import("./file-terminal-No20Ow9o.mjs"),
  "file-text": () => import("./file-text-Bgp1NLhs.mjs"),
  "file-type-2": () => import("./file-type-2-BcltOll5.mjs"),
  "file-type": () => import("./file-type-Bs3cOD7I.mjs"),
  "file-up": () => import("./file-up-DBdN2-_f.mjs"),
  "file-user": () => import("./file-user-CrV2fu-C.mjs"),
  "file-video-camera": () => import("./file-video-camera-DkBUpds6.mjs"),
  "file-video-2": () => import("./file-video-camera-DkBUpds6.mjs"),
  "file-volume-2": () => import("./file-volume-2-D4ffjAMO.mjs"),
  "file-volume": () => import("./file-volume-BEafUTjx.mjs"),
  "file-warning": () => import("./file-warning-D8EjKgkk.mjs"),
  "file-x-2": () => import("./file-x-2-CPERny-E.mjs"),
  "file-x": () => import("./file-x-Dm1320Df.mjs"),
  file: () => import("./file-BFVqc5Sj.mjs"),
  files: () => import("./files-4J4mmou9.mjs"),
  film: () => import("./film-QGbbaUA-.mjs"),
  fingerprint: () => import("./fingerprint-C-aQGvHb.mjs"),
  "fire-extinguisher": () => import("./fire-extinguisher-D-sqA3VU.mjs"),
  "fish-off": () => import("./fish-off-CxvrZ7Rh.mjs"),
  "fish-symbol": () => import("./fish-symbol-DMj9kwgV.mjs"),
  fish: () => import("./fish-PuLlrgzD.mjs"),
  "flag-off": () => import("./flag-off-Cl6lWJQG.mjs"),
  "flag-triangle-left": () => import("./flag-triangle-left-BGD97WfX.mjs"),
  "flag-triangle-right": () => import("./flag-triangle-right-Dcn_Qjq4.mjs"),
  flag: () => import("./flag-DfzcWuf0.mjs"),
  "flame-kindling": () => import("./flame-kindling-D9o0rHbb.mjs"),
  flame: () => import("./flame-BSLT_tqe.mjs"),
  "flashlight-off": () => import("./flashlight-off-CXW4167Y.mjs"),
  flashlight: () => import("./flashlight-C4TyfzJT.mjs"),
  "flask-conical-off": () => import("./flask-conical-off-Cf_3-QX9.mjs"),
  "flask-conical": () => import("./flask-conical-DpW-82kR.mjs"),
  "flask-round": () => import("./flask-round-B1RElUTN.mjs"),
  "flip-horizontal-2": () => import("./flip-horizontal-2-VGQeE4vo.mjs"),
  "flip-horizontal": () => import("./flip-horizontal-CSdfk7My.mjs"),
  "flip-vertical-2": () => import("./flip-vertical-2-i2z0osBU.mjs"),
  "flip-vertical": () => import("./flip-vertical-DDcfm3Pi.mjs"),
  "flower-2": () => import("./flower-2-DPWmZuLZ.mjs"),
  flower: () => import("./flower-fWyv5OR6.mjs"),
  focus: () => import("./focus-CbVrFNBL.mjs"),
  "fold-horizontal": () => import("./fold-horizontal-CfwgiZNk.mjs"),
  "fold-vertical": () => import("./fold-vertical-D6auzRcD.mjs"),
  "folder-archive": () => import("./folder-archive-B02GI6es.mjs"),
  "folder-check": () => import("./folder-check-CBXlGk28.mjs"),
  "folder-clock": () => import("./folder-clock-D-vDRPxY.mjs"),
  "folder-closed": () => import("./folder-closed-CemAxaft.mjs"),
  "folder-code": () => import("./folder-code-BoL5DBEW.mjs"),
  "folder-cog": () => import("./folder-cog-DLLDBIn1.mjs"),
  "folder-cog-2": () => import("./folder-cog-DLLDBIn1.mjs"),
  "folder-dot": () => import("./folder-dot-BtjvMeAf.mjs"),
  "folder-down": () => import("./folder-down-mhgiPODG.mjs"),
  "folder-git-2": () => import("./folder-git-2-DuoWtT79.mjs"),
  "folder-git": () => import("./folder-git-QhxBYLCS.mjs"),
  "folder-heart": () => import("./folder-heart-EkfPW21j.mjs"),
  "folder-input": () => import("./folder-input-CPdfUDhq.mjs"),
  "folder-kanban": () => import("./folder-kanban-D1JFyYmx.mjs"),
  "folder-key": () => import("./folder-key-CmxrRU2s.mjs"),
  "folder-lock": () => import("./folder-lock-C8Xk5Ef3.mjs"),
  "folder-minus": () => import("./folder-minus-DrvUrz9m.mjs"),
  "folder-open-dot": () => import("./folder-open-dot-Cqt_g2OO.mjs"),
  "folder-open": () => import("./folder-open-DtNxUKri.mjs"),
  "folder-output": () => import("./folder-output-BNZ1-8hT.mjs"),
  "folder-pen": () => import("./folder-pen-B_sQg0Wy.mjs"),
  "folder-edit": () => import("./folder-pen-B_sQg0Wy.mjs"),
  "folder-plus": () => import("./folder-plus-Bd-NBcHm.mjs"),
  "folder-root": () => import("./folder-root-BgrvvC6x.mjs"),
  "folder-search-2": () => import("./folder-search-2-C_4QgYYH.mjs"),
  "folder-search": () => import("./folder-search-BXao41j8.mjs"),
  "folder-symlink": () => import("./folder-symlink-8vMJ5y9-.mjs"),
  "folder-sync": () => import("./folder-sync-eyzpQxcn.mjs"),
  "folder-tree": () => import("./folder-tree-xwCnWkuJ.mjs"),
  "folder-up": () => import("./folder-up-DyprZVbN.mjs"),
  "folder-x": () => import("./folder-x-sqb6_2tH.mjs"),
  folder: () => import("./folder-8JyrU4G9.mjs"),
  folders: () => import("./folders-CKs5C-RV.mjs"),
  footprints: () => import("./footprints-CXB82CP3.mjs"),
  forklift: () => import("./forklift-D3ZKjxCq.mjs"),
  forward: () => import("./forward-Bo5CnVG1.mjs"),
  frame: () => import("./frame-pKeobJxP.mjs"),
  framer: () => import("./framer-9wSGnxB7.mjs"),
  frown: () => import("./frown-CRGNM55U.mjs"),
  fuel: () => import("./fuel-ueox2haA.mjs"),
  fullscreen: () => import("./fullscreen-AGB2ruJq.mjs"),
  "funnel-plus": () => import("./funnel-plus-BlyNGaiB.mjs"),
  "funnel-x": () => import("./funnel-x-DgbRAThm.mjs"),
  "filter-x": () => import("./funnel-x-DgbRAThm.mjs"),
  funnel: () => import("./funnel-BxPLuvO-.mjs"),
  filter: () => import("./funnel-BxPLuvO-.mjs"),
  "gallery-horizontal-end": () => import("./gallery-horizontal-end-DUd-Wbbd.mjs"),
  "gallery-horizontal": () => import("./gallery-horizontal-DdNuVpPw.mjs"),
  "gallery-thumbnails": () => import("./gallery-thumbnails-BPFmezqQ.mjs"),
  "gallery-vertical-end": () => import("./gallery-vertical-end-7AAg8Gbh.mjs"),
  "gallery-vertical": () => import("./gallery-vertical-lWV1OyJw.mjs"),
  "gamepad-2": () => import("./gamepad-2-DRZNmNyt.mjs"),
  gamepad: () => import("./gamepad-DuGHiptk.mjs"),
  gauge: () => import("./gauge-RRZIfR3M.mjs"),
  gavel: () => import("./gavel-tTSCNgJv.mjs"),
  gem: () => import("./gem-BUVSBhmp.mjs"),
  "georgian-lari": () => import("./georgian-lari-C_lTOAPl.mjs"),
  ghost: () => import("./ghost-WbvA3l-S.mjs"),
  gift: () => import("./gift-3UZskpGA.mjs"),
  "git-branch-plus": () => import("./git-branch-plus-Bt4utZKU.mjs"),
  "git-branch": () => import("./git-branch-BOydBxtE.mjs"),
  "git-commit-horizontal": () => import("./git-commit-horizontal-D8wLDXyB.mjs"),
  "git-commit": () => import("./git-commit-horizontal-D8wLDXyB.mjs"),
  "git-commit-vertical": () => import("./git-commit-vertical--ZaJYWTr.mjs"),
  "git-compare-arrows": () => import("./git-compare-arrows-BkSXLQdE.mjs"),
  "git-compare": () => import("./git-compare-b22Q2i55.mjs"),
  "git-fork": () => import("./git-fork-DDuGVZkk.mjs"),
  "git-graph": () => import("./git-graph-D1LJxM4N.mjs"),
  "git-merge": () => import("./git-merge-Ca9aG8lp.mjs"),
  "git-pull-request-arrow": () => import("./git-pull-request-arrow-CDuucuUM.mjs"),
  "git-pull-request-closed": () => import("./git-pull-request-closed-Bft7NkM6.mjs"),
  "git-pull-request-create-arrow": () => import("./git-pull-request-create-arrow-BFyi2Vr3.mjs"),
  "git-pull-request-create": () => import("./git-pull-request-create-DSyOyiiB.mjs"),
  "git-pull-request-draft": () => import("./git-pull-request-draft-CYACwMD2.mjs"),
  "git-pull-request": () => import("./git-pull-request-C9UQ-ame.mjs"),
  github: () => import("./github-BUt5UkIh.mjs"),
  gitlab: () => import("./gitlab-DzwtOtIX.mjs"),
  "glass-water": () => import("./glass-water-F6RTwYg_.mjs"),
  glasses: () => import("./glasses-C4nlBlyG.mjs"),
  "globe-lock": () => import("./globe-lock-Dn8NehO_.mjs"),
  globe: () => import("./globe-BUb2mWSD.mjs"),
  goal: () => import("./goal-CSnCT9X4.mjs"),
  gpu: () => import("./gpu-C32wJxWG.mjs"),
  "graduation-cap": () => import("./graduation-cap-CM2V51ni.mjs"),
  grape: () => import("./grape-yICYO3SX.mjs"),
  "grid-2x2-check": () => import("./grid-2x2-check-BzbCToIQ.mjs"),
  "grid-2-x-2-check": () => import("./grid-2x2-check-BzbCToIQ.mjs"),
  "grid-2x2-plus": () => import("./grid-2x2-plus-bop8C-dc.mjs"),
  "grid-2-x-2-plus": () => import("./grid-2x2-plus-bop8C-dc.mjs"),
  "grid-2x2-x": () => import("./grid-2x2-x-4KwkY-s7.mjs"),
  "grid-2-x-2-x": () => import("./grid-2x2-x-4KwkY-s7.mjs"),
  "grid-2x2": () => import("./grid-2x2-DvqQJQSF.mjs"),
  "grid-2-x-2": () => import("./grid-2x2-DvqQJQSF.mjs"),
  "grid-3x2": () => import("./grid-3x2-B-PifFvt.mjs"),
  "grid-3x3": () => import("./grid-3x3-BjFIjwNY.mjs"),
  grid: () => import("./grid-3x3-BjFIjwNY.mjs"),
  "grid-3-x-3": () => import("./grid-3x3-BjFIjwNY.mjs"),
  "grip-horizontal": () => import("./grip-horizontal-dtK1vrrc.mjs"),
  "grip-vertical": () => import("./grip-vertical-CfATzycP.mjs"),
  grip: () => import("./grip-1TtjGYYq.mjs"),
  group: () => import("./group-a4IZGixj.mjs"),
  guitar: () => import("./guitar-CwEBfNKF.mjs"),
  ham: () => import("./ham-CWA3QlFy.mjs"),
  hamburger: () => import("./hamburger-CW88khUu.mjs"),
  hammer: () => import("./hammer-DGSWMu_O.mjs"),
  "hand-coins": () => import("./hand-coins-DZIrT8kk.mjs"),
  "hand-fist": () => import("./hand-fist-CBZzbCMm.mjs"),
  "hand-grab": () => import("./hand-grab-Atpw8P_2.mjs"),
  grab: () => import("./hand-grab-Atpw8P_2.mjs"),
  "hand-heart": () => import("./hand-heart-DCjd8ory.mjs"),
  "hand-helping": () => import("./hand-helping-CJzcxRz8.mjs"),
  "helping-hand": () => import("./hand-helping-CJzcxRz8.mjs"),
  "hand-metal": () => import("./hand-metal-CMHy2dMN.mjs"),
  "hand-platter": () => import("./hand-platter-Dj1ScLRD.mjs"),
  hand: () => import("./hand-Bn3sQYIn.mjs"),
  handbag: () => import("./handbag-HtLe1jfj.mjs"),
  handshake: () => import("./handshake-BXTjzEW3.mjs"),
  "hard-drive-download": () => import("./hard-drive-download-C4MFPsfF.mjs"),
  "hard-drive-upload": () => import("./hard-drive-upload-Bo9XhEAv.mjs"),
  "hard-drive": () => import("./hard-drive-CtLtmXNg.mjs"),
  "hard-hat": () => import("./hard-hat-DG_f01hy.mjs"),
  hash: () => import("./hash-B2TeII1v.mjs"),
  "hat-glasses": () => import("./hat-glasses-ihtd90SF.mjs"),
  haze: () => import("./haze-FTVuE-IJ.mjs"),
  "hdmi-port": () => import("./hdmi-port-CPbb1xyM.mjs"),
  "heading-1": () => import("./heading-1-DGOzrAsL.mjs"),
  "heading-2": () => import("./heading-2-VmxS63V5.mjs"),
  "heading-3": () => import("./heading-3-ZCiC3wmJ.mjs"),
  "heading-4": () => import("./heading-4-DinPgDf5.mjs"),
  "heading-5": () => import("./heading-5-Dvs2VRAv.mjs"),
  "heading-6": () => import("./heading-6-jpy2dABf.mjs"),
  heading: () => import("./heading-DUCoTr_d.mjs"),
  "headphone-off": () => import("./headphone-off-CHZhhq8d.mjs"),
  headphones: () => import("./headphones-Kn7DcCGT.mjs"),
  headset: () => import("./headset-0jwH5Kx8.mjs"),
  "heart-crack": () => import("./heart-crack-BlcsMRZJ.mjs"),
  "heart-handshake": () => import("./heart-handshake-MwJsYRxC.mjs"),
  "heart-minus": () => import("./heart-minus-CmMbzn1U.mjs"),
  "heart-off": () => import("./heart-off-BobaXfNr.mjs"),
  "heart-plus": () => import("./heart-plus-DbfN3WVF.mjs"),
  "heart-pulse": () => import("./heart-pulse-4qsjBxg3.mjs"),
  heart: () => import("./heart-C0Hb3MYN.mjs"),
  heater: () => import("./heater-DXlW84Fv.mjs"),
  hexagon: () => import("./hexagon-BYClVGLF.mjs"),
  highlighter: () => import("./highlighter-BnizqnVf.mjs"),
  history: () => import("./history-B2vhp_mm.mjs"),
  "hop-off": () => import("./hop-off-BVRKVFur.mjs"),
  hop: () => import("./hop-CbnKEv0D.mjs"),
  hospital: () => import("./hospital-CGHwXTFZ.mjs"),
  hotel: () => import("./hotel-BBGJpRwI.mjs"),
  hourglass: () => import("./hourglass-DMsWWhCn.mjs"),
  "house-plug": () => import("./house-plug-Z2xjORzm.mjs"),
  "house-plus": () => import("./house-plus-DH3GHiiV.mjs"),
  "house-wifi": () => import("./house-wifi-BhkLh6iP.mjs"),
  house: () => import("./house-ClX8rI8H.mjs"),
  home: () => import("./house-ClX8rI8H.mjs"),
  "ice-cream-bowl": () => import("./ice-cream-bowl-bpM-xB6i.mjs"),
  "ice-cream-2": () => import("./ice-cream-bowl-bpM-xB6i.mjs"),
  "ice-cream-cone": () => import("./ice-cream-cone-B5dEbNay.mjs"),
  "ice-cream": () => import("./ice-cream-cone-B5dEbNay.mjs"),
  "id-card-lanyard": () => import("./id-card-lanyard-Bk6AXd5E.mjs"),
  "id-card": () => import("./id-card-ClQcWDQi.mjs"),
  "image-down": () => import("./image-down-DhhmtO-y.mjs"),
  "image-minus": () => import("./image-minus-DU2LSYA6.mjs"),
  "image-off": () => import("./image-off-CbaU533q.mjs"),
  "image-play": () => import("./image-play-Cox3URfx.mjs"),
  "image-plus": () => import("./image-plus-MxogW8TQ.mjs"),
  "image-up": () => import("./image-up-hUhMjOjp.mjs"),
  "image-upscale": () => import("./image-upscale-BnNCf0_v.mjs"),
  image: () => import("./image-BKM8Dpdf.mjs"),
  images: () => import("./images-wGGZgTpU.mjs"),
  import: () => import("./import-CxBmmQmt.mjs"),
  inbox: () => import("./inbox-wTy_5J3j.mjs"),
  "indent-decrease": () => import("./indent-decrease-Bp_p9VYa.mjs"),
  outdent: () => import("./indent-decrease-Bp_p9VYa.mjs"),
  "indent-increase": () => import("./indent-increase-DXfPYzfY.mjs"),
  indent: () => import("./indent-increase-DXfPYzfY.mjs"),
  "indian-rupee": () => import("./indian-rupee-vYIEact8.mjs"),
  infinity: () => import("./infinity-faOjj13r.mjs"),
  info: () => import("./info-j6uc9Rmy.mjs"),
  "inspection-panel": () => import("./inspection-panel-qAxDPAHH.mjs"),
  instagram: () => import("./instagram-Df7fyIQB.mjs"),
  italic: () => import("./italic-BTup1-fu.mjs"),
  "iteration-ccw": () => import("./iteration-ccw-Pu-Hdxbx.mjs"),
  "iteration-cw": () => import("./iteration-cw-DV_gOsCV.mjs"),
  "japanese-yen": () => import("./japanese-yen-B58YDtQT.mjs"),
  joystick: () => import("./joystick-DprJTh5J.mjs"),
  kanban: () => import("./kanban-C4-s3L8g.mjs"),
  "key-round": () => import("./key-round-CFagNRXd.mjs"),
  "key-square": () => import("./key-square-sUMB6X_k.mjs"),
  key: () => import("./key-dCAUdBKt.mjs"),
  "keyboard-music": () => import("./keyboard-music-Dpv2nng_.mjs"),
  "keyboard-off": () => import("./keyboard-off-B-Dol4Px.mjs"),
  keyboard: () => import("./keyboard-DPcUCgFH.mjs"),
  "lamp-ceiling": () => import("./lamp-ceiling-CF4pxUbr.mjs"),
  "lamp-desk": () => import("./lamp-desk-DYlwFgJd.mjs"),
  "lamp-floor": () => import("./lamp-floor-BEA5MvMO.mjs"),
  "lamp-wall-down": () => import("./lamp-wall-down-RCj4UGqJ.mjs"),
  "lamp-wall-up": () => import("./lamp-wall-up-BTb96nr6.mjs"),
  lamp: () => import("./lamp-BIE3yUaS.mjs"),
  "land-plot": () => import("./land-plot-CBmUNK-q.mjs"),
  landmark: () => import("./landmark-DP4mU6Dy.mjs"),
  languages: () => import("./languages-CChGlzyP.mjs"),
  "laptop-minimal-check": () => import("./laptop-minimal-check-Iwks6H4H.mjs"),
  "laptop-minimal": () => import("./laptop-minimal-C9KZZ7H2.mjs"),
  "laptop-2": () => import("./laptop-minimal-C9KZZ7H2.mjs"),
  laptop: () => import("./laptop-BNfo48aB.mjs"),
  "lasso-select": () => import("./lasso-select-CVH1Ytpq.mjs"),
  lasso: () => import("./lasso-1shv3OH9.mjs"),
  laugh: () => import("./laugh-CK0yawVZ.mjs"),
  "layers-2": () => import("./layers-2-199_y0ta.mjs"),
  layers: () => import("./layers-CEv5wafx.mjs"),
  "layers-3": () => import("./layers-CEv5wafx.mjs"),
  "layout-dashboard": () => import("./layout-dashboard-CRWM6OVl.mjs"),
  "layout-grid": () => import("./layout-grid-EXX4jJwo.mjs"),
  "layout-list": () => import("./layout-list-CAuMc-8G.mjs"),
  "layout-panel-left": () => import("./layout-panel-left-CYIHXNLH.mjs"),
  "layout-panel-top": () => import("./layout-panel-top-CfclABYn.mjs"),
  "layout-template": () => import("./layout-template-B2Q2cohY.mjs"),
  leaf: () => import("./leaf-BFzqmv_X.mjs"),
  "leafy-green": () => import("./leafy-green-CJajK5Ax.mjs"),
  lectern: () => import("./lectern-B3At4FjI.mjs"),
  "letter-text": () => import("./letter-text-CgD9KA3W.mjs"),
  "library-big": () => import("./library-big-BCAMZyNY.mjs"),
  library: () => import("./library-BmPx1cvs.mjs"),
  "life-buoy": () => import("./life-buoy-4QoJ0rXX.mjs"),
  ligature: () => import("./ligature-DV33czmE.mjs"),
  "lightbulb-off": () => import("./lightbulb-off-DetgfjOK.mjs"),
  lightbulb: () => import("./lightbulb-DeTr57tF.mjs"),
  "line-squiggle": () => import("./line-squiggle-BDPKxgqV.mjs"),
  "link-2-off": () => import("./link-2-off-CWyUz8o0.mjs"),
  "link-2": () => import("./link-2-D2vVJKyo.mjs"),
  link: () => import("./link-BN-xF5-L.mjs"),
  linkedin: () => import("./linkedin-DJGrJa0I.mjs"),
  "list-check": () => import("./list-check-D1aU2Xz0.mjs"),
  "list-checks": () => import("./list-checks-CiN_e4i2.mjs"),
  "list-collapse": () => import("./list-collapse-Dug7cVou.mjs"),
  "list-end": () => import("./list-end-Dd3dsdd7.mjs"),
  "list-filter-plus": () => import("./list-filter-plus-D7LsTa_7.mjs"),
  "list-filter": () => import("./list-filter-BR1q_FJz.mjs"),
  "list-minus": () => import("./list-minus-DBbz1nJc.mjs"),
  "list-music": () => import("./list-music-CKtQ4YA0.mjs"),
  "list-ordered": () => import("./list-ordered-ByBKgyTJ.mjs"),
  "list-plus": () => import("./list-plus-BrvDawxZ.mjs"),
  "list-restart": () => import("./list-restart-BNne89AD.mjs"),
  "list-start": () => import("./list-start-CTlT1Q21.mjs"),
  "list-todo": () => import("./list-todo-IyZ2lXIU.mjs"),
  "list-tree": () => import("./list-tree-D9ztIwct.mjs"),
  "list-video": () => import("./list-video-C-u34i55.mjs"),
  "list-x": () => import("./list-x-BXXu9snh.mjs"),
  list: () => import("./list-_c5xF0Um.mjs"),
  "loader-circle": () => import("./loader-circle-CdGGTa05.mjs"),
  "loader-2": () => import("./loader-circle-CdGGTa05.mjs"),
  "loader-pinwheel": () => import("./loader-pinwheel-9-f2crJw.mjs"),
  loader: () => import("./loader-BRwUzSUp.mjs"),
  "locate-fixed": () => import("./locate-fixed-CtYKRBmD.mjs"),
  "locate-off": () => import("./locate-off-DjGYqc6Z.mjs"),
  locate: () => import("./locate-CWWh3-lU.mjs"),
  "lock-keyhole-open": () => import("./lock-keyhole-open-CF2waC65.mjs"),
  "unlock-keyhole": () => import("./lock-keyhole-open-CF2waC65.mjs"),
  "lock-keyhole": () => import("./lock-keyhole-CFI0Y2xK.mjs"),
  "lock-open": () => import("./lock-open-_8aBfapL.mjs"),
  unlock: () => import("./lock-open-_8aBfapL.mjs"),
  lock: () => import("./lock-CNGKcJor.mjs"),
  "log-in": () => import("./log-in-0eukRgeB.mjs"),
  "log-out": () => import("./log-out-03LbbPMH.mjs"),
  logs: () => import("./logs-CuzwINnB.mjs"),
  lollipop: () => import("./lollipop-CEKSqgeB.mjs"),
  luggage: () => import("./luggage-viQWfOnD.mjs"),
  magnet: () => import("./magnet-D2d3b3Wp.mjs"),
  "mail-check": () => import("./mail-check-BMqyeTi2.mjs"),
  "mail-minus": () => import("./mail-minus-DuLGuGnM.mjs"),
  "mail-open": () => import("./mail-open-BlLidR4U.mjs"),
  "mail-plus": () => import("./mail-plus-BuJxaksX.mjs"),
  "mail-question-mark": () => import("./mail-question-mark-YAmChQgj.mjs"),
  "mail-question": () => import("./mail-question-mark-YAmChQgj.mjs"),
  "mail-search": () => import("./mail-search-D6vO7LWi.mjs"),
  "mail-warning": () => import("./mail-warning-8jwGU041.mjs"),
  "mail-x": () => import("./mail-x-DhqylZGR.mjs"),
  mail: () => import("./mail-Dziiu0Op.mjs"),
  mailbox: () => import("./mailbox-BRswU_Iu.mjs"),
  mails: () => import("./mails-CvHdNWQs.mjs"),
  "map-minus": () => import("./map-minus-0tvs4EbG.mjs"),
  "map-pin-check-inside": () => import("./map-pin-check-inside-BI5LTCz7.mjs"),
  "map-pin-check": () => import("./map-pin-check-CSfCn5MC.mjs"),
  "map-pin-house": () => import("./map-pin-house-DtVt67d8.mjs"),
  "map-pin-minus-inside": () => import("./map-pin-minus-inside-C1gx1eWs.mjs"),
  "map-pin-minus": () => import("./map-pin-minus-ChsnRrjB.mjs"),
  "map-pin-off": () => import("./map-pin-off-D0P4RWX3.mjs"),
  "map-pin-pen": () => import("./map-pin-pen-Bam1gBP6.mjs"),
  "location-edit": () => import("./map-pin-pen-Bam1gBP6.mjs"),
  "map-pin-plus-inside": () => import("./map-pin-plus-inside-BEinLLp2.mjs"),
  "map-pin-plus": () => import("./map-pin-plus-CJwhjj3x.mjs"),
  "map-pin-x-inside": () => import("./map-pin-x-inside-wIV4cj1G.mjs"),
  "map-pin-x": () => import("./map-pin-x-ucSSoZaO.mjs"),
  "map-pin": () => import("./map-pin-BirLnl08.mjs"),
  "map-pinned": () => import("./map-pinned-BhT7mlMh.mjs"),
  "map-plus": () => import("./map-plus-pxx0sSYb.mjs"),
  map: () => import("./map-B_rkuRHe.mjs"),
  "mars-stroke": () => import("./mars-stroke-CDlecUCx.mjs"),
  mars: () => import("./mars-BZ2rE5SA.mjs"),
  martini: () => import("./martini-CIxevUMk.mjs"),
  "maximize-2": () => import("./maximize-2-CsWjRbzr.mjs"),
  maximize: () => import("./maximize-l_mb9bKc.mjs"),
  medal: () => import("./medal-CmBbpHED.mjs"),
  "megaphone-off": () => import("./megaphone-off-DTWYC52S.mjs"),
  megaphone: () => import("./megaphone-1pqPYGdx.mjs"),
  meh: () => import("./meh-CcUQHjTf.mjs"),
  "memory-stick": () => import("./memory-stick-Dy5WsfoN.mjs"),
  menu: () => import("./menu-CLspAX_Y.mjs"),
  merge: () => import("./merge-C1IJI2on.mjs"),
  "message-circle-code": () => import("./message-circle-code-Brg7MOc3.mjs"),
  "message-circle-dashed": () => import("./message-circle-dashed-Co4Ew_aH.mjs"),
  "message-circle-heart": () => import("./message-circle-heart-hHxIWSPA.mjs"),
  "message-circle-more": () => import("./message-circle-more-BaIhW-nd.mjs"),
  "message-circle-off": () => import("./message-circle-off-CPthmI-n.mjs"),
  "message-circle-plus": () => import("./message-circle-plus-CRdeWldB.mjs"),
  "message-circle-question-mark": () => import("./message-circle-question-mark-9GW0dJ_x.mjs"),
  "message-circle-question": () => import("./message-circle-question-mark-9GW0dJ_x.mjs"),
  "message-circle-reply": () => import("./message-circle-reply-DRFpVZ-n.mjs"),
  "message-circle-warning": () => import("./message-circle-warning-DV4zQJpH.mjs"),
  "message-circle-x": () => import("./message-circle-x-DLh7eLcA.mjs"),
  "message-circle": () => import("./message-circle-D-W64oMf.mjs"),
  "message-square-code": () => import("./message-square-code-BYlEXUGn.mjs"),
  "message-square-dashed": () => import("./message-square-dashed-D3G0OGj5.mjs"),
  "message-square-diff": () => import("./message-square-diff-Daec8RvW.mjs"),
  "message-square-dot": () => import("./message-square-dot-Cl28h4Bx.mjs"),
  "message-square-heart": () => import("./message-square-heart-lJL3vSqB.mjs"),
  "message-square-lock": () => import("./message-square-lock-CDOQNEZj.mjs"),
  "message-square-more": () => import("./message-square-more-C9WCFc8x.mjs"),
  "message-square-off": () => import("./message-square-off-DhTS3n5s.mjs"),
  "message-square-plus": () => import("./message-square-plus-Hubd2CrC.mjs"),
  "message-square-quote": () => import("./message-square-quote-DC4Qjxfn.mjs"),
  "message-square-reply": () => import("./message-square-reply-BVQRUKL6.mjs"),
  "message-square-share": () => import("./message-square-share-Opb_C2M-.mjs"),
  "message-square-text": () => import("./message-square-text-CS2M46MZ.mjs"),
  "message-square-warning": () => import("./message-square-warning-D8uXK1dK.mjs"),
  "message-square-x": () => import("./message-square-x-DP4k6Nw7.mjs"),
  "message-square": () => import("./message-square-B6hmhxGM.mjs"),
  "messages-square": () => import("./messages-square-BoV2zEKe.mjs"),
  "mic-off": () => import("./mic-off-BY87t-r6.mjs"),
  "mic-vocal": () => import("./mic-vocal-CBU7M2Ib.mjs"),
  "mic-2": () => import("./mic-vocal-CBU7M2Ib.mjs"),
  mic: () => import("./mic-BnrQvtJ2.mjs"),
  microchip: () => import("./microchip-RJaMHZFr.mjs"),
  microscope: () => import("./microscope-C5glJJuZ.mjs"),
  microwave: () => import("./microwave-C7tzS8S0.mjs"),
  milestone: () => import("./milestone-CjFjH2gM.mjs"),
  "milk-off": () => import("./milk-off-BCMC7dGd.mjs"),
  milk: () => import("./milk-Chopw-v0.mjs"),
  "minimize-2": () => import("./minimize-2-DlDIkZY9.mjs"),
  minimize: () => import("./minimize-eCbKhT1K.mjs"),
  minus: () => import("./minus-B8-UBIU3.mjs"),
  "monitor-check": () => import("./monitor-check-Cj_aOaA-.mjs"),
  "monitor-cog": () => import("./monitor-cog-ByMae0F7.mjs"),
  "monitor-dot": () => import("./monitor-dot-C4Ctesm_.mjs"),
  "monitor-down": () => import("./monitor-down-Boe-XXQh.mjs"),
  "monitor-off": () => import("./monitor-off-bSZEJGb3.mjs"),
  "monitor-pause": () => import("./monitor-pause-BP09zN2h.mjs"),
  "monitor-play": () => import("./monitor-play-C16DhFB8.mjs"),
  "monitor-smartphone": () => import("./monitor-smartphone-DfIJEscP.mjs"),
  "monitor-speaker": () => import("./monitor-speaker-CbgvVhw-.mjs"),
  "monitor-stop": () => import("./monitor-stop-B-tO3nwx.mjs"),
  "monitor-up": () => import("./monitor-up-Cd8bCXT2.mjs"),
  "monitor-x": () => import("./monitor-x-K5gTZiCh.mjs"),
  monitor: () => import("./monitor-Da1xIrIu.mjs"),
  "moon-star": () => import("./moon-star-s0x4hQ-M.mjs"),
  moon: () => import("./moon-CmfAM3o8.mjs"),
  "mountain-snow": () => import("./mountain-snow-DEaK8RZK.mjs"),
  mountain: () => import("./mountain-B6FfUVrY.mjs"),
  "mouse-off": () => import("./mouse-off-CU1JfRIS.mjs"),
  "mouse-pointer-2": () => import("./mouse-pointer-2-Cyb6dMBc.mjs"),
  "mouse-pointer-ban": () => import("./mouse-pointer-ban-DbHJ0VFZ.mjs"),
  "mouse-pointer-click": () => import("./mouse-pointer-click-CETYfjcz.mjs"),
  "mouse-pointer": () => import("./mouse-pointer-BiGdsc1M.mjs"),
  mouse: () => import("./mouse-Cpv-MSYy.mjs"),
  "move-3d": () => import("./move-3d-CjDUAsUA.mjs"),
  "move-3-d": () => import("./move-3d-CjDUAsUA.mjs"),
  "move-diagonal-2": () => import("./move-diagonal-2-nH7eXRRC.mjs"),
  "move-diagonal": () => import("./move-diagonal-DVVzbOaz.mjs"),
  "move-down-left": () => import("./move-down-left-TYDcz3_k.mjs"),
  "move-down-right": () => import("./move-down-right-BjTcTOgR.mjs"),
  "move-down": () => import("./move-down-CI9rU1dj.mjs"),
  "move-horizontal": () => import("./move-horizontal-BNcXWkzu.mjs"),
  "move-left": () => import("./move-left-BWdMHEgl.mjs"),
  "move-right": () => import("./move-right-DKQl03sN.mjs"),
  "move-up-left": () => import("./move-up-left-DyviutF5.mjs"),
  "move-up-right": () => import("./move-up-right-ZR2KjP9C.mjs"),
  "move-up": () => import("./move-up-cxhsjzg-.mjs"),
  "move-vertical": () => import("./move-vertical-CJ8Z8PRN.mjs"),
  move: () => import("./move-UwKjgDn_.mjs"),
  "music-2": () => import("./music-2-BgiTOKZG.mjs"),
  "music-3": () => import("./music-3-B_RdnZHw.mjs"),
  "music-4": () => import("./music-4-BqXb9yaU.mjs"),
  music: () => import("./music-BDmfp36z.mjs"),
  "navigation-2-off": () => import("./navigation-2-off-C5fjxJn_.mjs"),
  "navigation-2": () => import("./navigation-2-keYK-6bJ.mjs"),
  "navigation-off": () => import("./navigation-off-CTvfydep.mjs"),
  navigation: () => import("./navigation-5PAbOtW3.mjs"),
  network: () => import("./network-CbqGssLI.mjs"),
  newspaper: () => import("./newspaper-CpPQhLlF.mjs"),
  nfc: () => import("./nfc-CxC4mVmp.mjs"),
  "non-binary": () => import("./non-binary-Bo9xdTM8.mjs"),
  "notebook-pen": () => import("./notebook-pen-DCMpZ-sL.mjs"),
  "notebook-tabs": () => import("./notebook-tabs-DhDZY9uY.mjs"),
  "notebook-text": () => import("./notebook-text-CBfR9lEm.mjs"),
  notebook: () => import("./notebook-B8dVNUyF.mjs"),
  "notepad-text-dashed": () => import("./notepad-text-dashed-BE3OhF3t.mjs"),
  "notepad-text": () => import("./notepad-text-4H4XRF10.mjs"),
  "nut-off": () => import("./nut-off-COiQS6Uc.mjs"),
  nut: () => import("./nut-CWwnphn-.mjs"),
  "octagon-alert": () => import("./octagon-alert-SAtv-Dlh.mjs"),
  "alert-octagon": () => import("./octagon-alert-SAtv-Dlh.mjs"),
  "octagon-minus": () => import("./octagon-minus-IBG43Hg8.mjs"),
  "octagon-pause": () => import("./octagon-pause-GmrxL2SC.mjs"),
  "pause-octagon": () => import("./octagon-pause-GmrxL2SC.mjs"),
  "octagon-x": () => import("./octagon-x-DOfGmK0h.mjs"),
  "x-octagon": () => import("./octagon-x-DOfGmK0h.mjs"),
  octagon: () => import("./octagon-DDLSNVpa.mjs"),
  omega: () => import("./omega-CLaTDV_h.mjs"),
  option: () => import("./option-Cn_ImUjW.mjs"),
  orbit: () => import("./orbit-n2XfTNlO.mjs"),
  origami: () => import("./origami-CXWNpbtR.mjs"),
  "package-2": () => import("./package-2-BfgsC5iJ.mjs"),
  "package-check": () => import("./package-check-C36FKJ-W.mjs"),
  "package-minus": () => import("./package-minus-o77MIDs2.mjs"),
  "package-open": () => import("./package-open-BJgphnot.mjs"),
  "package-plus": () => import("./package-plus-DLwjLPQA.mjs"),
  "package-search": () => import("./package-search-D2yWq2OW.mjs"),
  "package-x": () => import("./package-x-DDdEI30T.mjs"),
  package: () => import("./package-BMHSjEYP.mjs"),
  "paint-bucket": () => import("./paint-bucket-DeykyKnx.mjs"),
  "paint-roller": () => import("./paint-roller-BA6PJN7y.mjs"),
  "paintbrush-vertical": () => import("./paintbrush-vertical-BI5zeyMP.mjs"),
  "paintbrush-2": () => import("./paintbrush-vertical-BI5zeyMP.mjs"),
  paintbrush: () => import("./paintbrush-Du27nvRF.mjs"),
  palette: () => import("./palette-CKUawSco.mjs"),
  panda: () => import("./panda-CFwqHlCw.mjs"),
  "panel-bottom-close": () => import("./panel-bottom-close-hDp_Uxam.mjs"),
  "panel-bottom-dashed": () => import("./panel-bottom-dashed-D7GKd-hz.mjs"),
  "panel-bottom-inactive": () => import("./panel-bottom-dashed-D7GKd-hz.mjs"),
  "panel-bottom-open": () => import("./panel-bottom-open-D0L4g7UQ.mjs"),
  "panel-bottom": () => import("./panel-bottom-DALrAGk4.mjs"),
  "panel-left-close": () => import("./panel-left-close-BHGHpVd1.mjs"),
  "sidebar-close": () => import("./panel-left-close-BHGHpVd1.mjs"),
  "panel-left-dashed": () => import("./panel-left-dashed-lTMaQXMb.mjs"),
  "panel-left-inactive": () => import("./panel-left-dashed-lTMaQXMb.mjs"),
  "panel-left-open": () => import("./panel-left-open-bFLY7mNg.mjs"),
  "sidebar-open": () => import("./panel-left-open-bFLY7mNg.mjs"),
  "panel-left": () => import("./panel-left-Cw7CxNs_.mjs"),
  sidebar: () => import("./panel-left-Cw7CxNs_.mjs"),
  "panel-right-close": () => import("./panel-right-close-6Mt3JAqP.mjs"),
  "panel-right-dashed": () => import("./panel-right-dashed-1dO-rcJH.mjs"),
  "panel-right-inactive": () => import("./panel-right-dashed-1dO-rcJH.mjs"),
  "panel-right-open": () => import("./panel-right-open-hLYEcB1O.mjs"),
  "panel-right": () => import("./panel-right-D0S_e4Za.mjs"),
  "panel-top-close": () => import("./panel-top-close-BX1eOCV3.mjs"),
  "panel-top-dashed": () => import("./panel-top-dashed-Cvx6TRBN.mjs"),
  "panel-top-inactive": () => import("./panel-top-dashed-Cvx6TRBN.mjs"),
  "panel-top-open": () => import("./panel-top-open-nd7CyNgj.mjs"),
  "panel-top": () => import("./panel-top-B8ej1ILr.mjs"),
  "panels-left-bottom": () => import("./panels-left-bottom-BejG-hd_.mjs"),
  "panels-right-bottom": () => import("./panels-right-bottom-Cc856LOM.mjs"),
  "panels-top-left": () => import("./panels-top-left-YWR0d_fh.mjs"),
  layout: () => import("./panels-top-left-YWR0d_fh.mjs"),
  paperclip: () => import("./paperclip-CYK3vRo_.mjs"),
  parentheses: () => import("./parentheses-DJsoYwmX.mjs"),
  "parking-meter": () => import("./parking-meter-BcPtYOTp.mjs"),
  "party-popper": () => import("./party-popper-MlSdtfji.mjs"),
  pause: () => import("./pause-BWxIjhxA.mjs"),
  "paw-print": () => import("./paw-print-IM9U219z.mjs"),
  "pc-case": () => import("./pc-case-eDjrGddj.mjs"),
  "pen-line": () => import("./pen-line-De8m-h1Q.mjs"),
  "edit-3": () => import("./pen-line-De8m-h1Q.mjs"),
  "pen-off": () => import("./pen-off-CEQ4zfQQ.mjs"),
  "pen-tool": () => import("./pen-tool-C9oogRcU.mjs"),
  pen: () => import("./pen-DHyUfdgT.mjs"),
  "edit-2": () => import("./pen-DHyUfdgT.mjs"),
  "pencil-line": () => import("./pencil-line-BI7Xtgp8.mjs"),
  "pencil-off": () => import("./pencil-off-CssL7DQf.mjs"),
  "pencil-ruler": () => import("./pencil-ruler-Dy0qRVwh.mjs"),
  pencil: () => import("./pencil-C_pcN6R8.mjs"),
  pentagon: () => import("./pentagon-DVQtT4kA.mjs"),
  percent: () => import("./percent-Dm5uHro3.mjs"),
  "person-standing": () => import("./person-standing-KiegDqLs.mjs"),
  "philippine-peso": () => import("./philippine-peso-CrX6Ydbp.mjs"),
  "phone-call": () => import("./phone-call-MJ55XHEk.mjs"),
  "phone-forwarded": () => import("./phone-forwarded-CJEv2gFX.mjs"),
  "phone-incoming": () => import("./phone-incoming-CQxaSp2H.mjs"),
  "phone-missed": () => import("./phone-missed-uKjCaJsV.mjs"),
  "phone-off": () => import("./phone-off-MLhGUOcb.mjs"),
  "phone-outgoing": () => import("./phone-outgoing-BtoNm9si.mjs"),
  phone: () => import("./phone-D8gjGiPF.mjs"),
  pi: () => import("./pi-D8Mfqfg6.mjs"),
  piano: () => import("./piano-TOOc3zDY.mjs"),
  pickaxe: () => import("./pickaxe-apReeTVK.mjs"),
  "picture-in-picture-2": () => import("./picture-in-picture-2-D3YJn5Nb.mjs"),
  "picture-in-picture": () => import("./picture-in-picture-BaSB89mL.mjs"),
  "piggy-bank": () => import("./piggy-bank-BzX-Svt5.mjs"),
  "pilcrow-left": () => import("./pilcrow-left-Wx4JGl0b.mjs"),
  "pilcrow-right": () => import("./pilcrow-right-CTGBNkSg.mjs"),
  pilcrow: () => import("./pilcrow-B235lxs-.mjs"),
  "pill-bottle": () => import("./pill-bottle-Cu890JcE.mjs"),
  pill: () => import("./pill-BCalhybr.mjs"),
  "pin-off": () => import("./pin-off-DbWPePBa.mjs"),
  pin: () => import("./pin-DMKL4XYs.mjs"),
  pipette: () => import("./pipette-BRfdBgMk.mjs"),
  pizza: () => import("./pizza-B7rEz4zb.mjs"),
  "plane-landing": () => import("./plane-landing-CmMkteEv.mjs"),
  "plane-takeoff": () => import("./plane-takeoff-C7f0kpBf.mjs"),
  plane: () => import("./plane-C-bTH3PX.mjs"),
  play: () => import("./play-DDNvkaIA.mjs"),
  "plug-2": () => import("./plug-2-XaGPOB6U.mjs"),
  "plug-zap": () => import("./plug-zap-CVcQqQTm.mjs"),
  "plug-zap-2": () => import("./plug-zap-CVcQqQTm.mjs"),
  plug: () => import("./plug-Bz_etCuj.mjs"),
  plus: () => import("./plus-D0t-kl7Z.mjs"),
  "pocket-knife": () => import("./pocket-knife-DscBz__U.mjs"),
  pocket: () => import("./pocket-BvVGDX3L.mjs"),
  podcast: () => import("./podcast-B2bBYNr-.mjs"),
  "pointer-off": () => import("./pointer-off-BZstBQpq.mjs"),
  pointer: () => import("./pointer-D4GkWcdK.mjs"),
  popcorn: () => import("./popcorn-DfIW-YYN.mjs"),
  popsicle: () => import("./popsicle-o1JJyJvg.mjs"),
  "pound-sterling": () => import("./pound-sterling-BOSBXRp5.mjs"),
  "power-off": () => import("./power-off-CQpje3ER.mjs"),
  power: () => import("./power-BcXxmqH9.mjs"),
  presentation: () => import("./presentation-DA3Q6i7R.mjs"),
  "printer-check": () => import("./printer-check-CFPnp1FR.mjs"),
  printer: () => import("./printer-B7wM0UzN.mjs"),
  projector: () => import("./projector-PjRB9BZv.mjs"),
  proportions: () => import("./proportions-hdOsmAgG.mjs"),
  puzzle: () => import("./puzzle-BTvMSiIv.mjs"),
  pyramid: () => import("./pyramid-Bgo4vig4.mjs"),
  "qr-code": () => import("./qr-code-BmziznsN.mjs"),
  quote: () => import("./quote-RMoWsYKV.mjs"),
  rabbit: () => import("./rabbit-8I75IQiZ.mjs"),
  radar: () => import("./radar-CtPNewTw.mjs"),
  radiation: () => import("./radiation-CJJ1OQ7m.mjs"),
  radical: () => import("./radical-aRc9HNK9.mjs"),
  "radio-receiver": () => import("./radio-receiver-DcnrZM7N.mjs"),
  "radio-tower": () => import("./radio-tower-CnZn6YKg.mjs"),
  radio: () => import("./radio-BYzcyESA.mjs"),
  radius: () => import("./radius-BRe_2HAg.mjs"),
  "rail-symbol": () => import("./rail-symbol-B58OwRtM.mjs"),
  rainbow: () => import("./rainbow-DtuCJNWk.mjs"),
  rat: () => import("./rat-B9447NB0.mjs"),
  ratio: () => import("./ratio-DrYAz1oE.mjs"),
  "receipt-cent": () => import("./receipt-cent-Ct-b3WHf.mjs"),
  "receipt-euro": () => import("./receipt-euro-DYTxNr5a.mjs"),
  "receipt-indian-rupee": () => import("./receipt-indian-rupee-BFdfg_tk.mjs"),
  "receipt-japanese-yen": () => import("./receipt-japanese-yen--5T2wReP.mjs"),
  "receipt-pound-sterling": () => import("./receipt-pound-sterling-DX_WDQdb.mjs"),
  "receipt-russian-ruble": () => import("./receipt-russian-ruble-DDivxMkq.mjs"),
  "receipt-swiss-franc": () => import("./receipt-swiss-franc-BCkZyuMq.mjs"),
  "receipt-text": () => import("./receipt-text-D1-2HFww.mjs"),
  "receipt-turkish-lira": () => import("./receipt-turkish-lira-BAZwVx7d.mjs"),
  receipt: () => import("./receipt-CzPjHvAg.mjs"),
  "rectangle-circle": () => import("./rectangle-circle-Cb7k-NXy.mjs"),
  "rectangle-ellipsis": () => import("./rectangle-ellipsis-BERnjkFN.mjs"),
  "form-input": () => import("./rectangle-ellipsis-BERnjkFN.mjs"),
  "rectangle-goggles": () => import("./rectangle-goggles-Bybpgvyn.mjs"),
  "rectangle-horizontal": () => import("./rectangle-horizontal-CL6DPFJf.mjs"),
  "rectangle-vertical": () => import("./rectangle-vertical-DWPyxxzx.mjs"),
  recycle: () => import("./recycle-DOZFFl81.mjs"),
  "redo-2": () => import("./redo-2-BZl-l2qF.mjs"),
  "redo-dot": () => import("./redo-dot-CnqMXXeS.mjs"),
  redo: () => import("./redo-Ce-mf5Ro.mjs"),
  "refresh-ccw-dot": () => import("./refresh-ccw-dot-B-TzZBz5.mjs"),
  "refresh-ccw": () => import("./refresh-ccw-BXNefHoZ.mjs"),
  "refresh-cw-off": () => import("./refresh-cw-off-DFfTdQh2.mjs"),
  "refresh-cw": () => import("./refresh-cw--J9u10u1.mjs"),
  refrigerator: () => import("./refrigerator-bxGbRW5q.mjs"),
  regex: () => import("./regex-BieS9k8n.mjs"),
  "remove-formatting": () => import("./remove-formatting-BkkAjdkK.mjs"),
  "repeat-1": () => import("./repeat-1-DaODSkyf.mjs"),
  "repeat-2": () => import("./repeat-2-CT7afG9s.mjs"),
  repeat: () => import("./repeat-D2rrIti_.mjs"),
  "replace-all": () => import("./replace-all-DihQI0hR.mjs"),
  replace: () => import("./replace-BJRHn2Pz.mjs"),
  "reply-all": () => import("./reply-all-DOKB_8q2.mjs"),
  reply: () => import("./reply-CSDCW8kR.mjs"),
  rewind: () => import("./rewind-B1yNTf6i.mjs"),
  ribbon: () => import("./ribbon-DIoyAFFv.mjs"),
  rocket: () => import("./rocket-DvdzN7l1.mjs"),
  "rocking-chair": () => import("./rocking-chair-CD3SHEGH.mjs"),
  "roller-coaster": () => import("./roller-coaster-BgeJ05JJ.mjs"),
  "rotate-3d": () => import("./rotate-3d-DUi4ACMe.mjs"),
  "rotate-3-d": () => import("./rotate-3d-DUi4ACMe.mjs"),
  "rotate-ccw-key": () => import("./rotate-ccw-key-CvN4Eff8.mjs"),
  "rotate-ccw-square": () => import("./rotate-ccw-square-DRNNU3hC.mjs"),
  "rotate-ccw": () => import("./rotate-ccw-CxpxMTsa.mjs"),
  "rotate-cw-square": () => import("./rotate-cw-square-8KNyY6nT.mjs"),
  "rotate-cw": () => import("./rotate-cw-CxDAUJxp.mjs"),
  "route-off": () => import("./route-off-BGP-pDc0.mjs"),
  route: () => import("./route-DMNgtu9J.mjs"),
  router: () => import("./router-Cm94OnEX.mjs"),
  "rows-2": () => import("./rows-2-_f_TuqbQ.mjs"),
  rows: () => import("./rows-2-_f_TuqbQ.mjs"),
  "rows-3": () => import("./rows-3-DOyDGWm6.mjs"),
  "panels-top-bottom": () => import("./rows-3-DOyDGWm6.mjs"),
  "rows-4": () => import("./rows-4-I2Im0eZF.mjs"),
  rss: () => import("./rss-C0CCfJbj.mjs"),
  "ruler-dimension-line": () => import("./ruler-dimension-line-RXOoA071.mjs"),
  ruler: () => import("./ruler-CiMaQu14.mjs"),
  "russian-ruble": () => import("./russian-ruble-BHHPbn3i.mjs"),
  sailboat: () => import("./sailboat-uH03se4t.mjs"),
  salad: () => import("./salad-BGTRYMi8.mjs"),
  sandwich: () => import("./sandwich-l0Sg6hDy.mjs"),
  "satellite-dish": () => import("./satellite-dish-BmuKizF8.mjs"),
  satellite: () => import("./satellite-irA_YBB5.mjs"),
  "saudi-riyal": () => import("./saudi-riyal-C7A5AIZD.mjs"),
  "save-all": () => import("./save-all-D_MEmjT3.mjs"),
  "save-off": () => import("./save-off-BqAa2Zfs.mjs"),
  save: () => import("./save-CH1m43Dt.mjs"),
  "scale-3d": () => import("./scale-3d-B5JXMW41.mjs"),
  "scale-3-d": () => import("./scale-3d-B5JXMW41.mjs"),
  scale: () => import("./scale-CAnAQbdQ.mjs"),
  scaling: () => import("./scaling-BPpCmx38.mjs"),
  "scan-barcode": () => import("./scan-barcode-afTISJ7g.mjs"),
  "scan-eye": () => import("./scan-eye-BLmijAp3.mjs"),
  "scan-face": () => import("./scan-face-DMiJWZHM.mjs"),
  "scan-heart": () => import("./scan-heart-De2DqxmS.mjs"),
  "scan-line": () => import("./scan-line-5scLRPZU.mjs"),
  "scan-qr-code": () => import("./scan-qr-code-CLcylsqI.mjs"),
  "scan-search": () => import("./scan-search-BB3-esvY.mjs"),
  "scan-text": () => import("./scan-text-Cg_Ds-MT.mjs"),
  scan: () => import("./scan-BLQzV1Ay.mjs"),
  school: () => import("./school-C3JjMOit.mjs"),
  "scissors-line-dashed": () => import("./scissors-line-dashed-D3etwAn7.mjs"),
  scissors: () => import("./scissors-BLKXAT7b.mjs"),
  "screen-share-off": () => import("./screen-share-off-WwerqqS_.mjs"),
  "screen-share": () => import("./screen-share-DVRGBheB.mjs"),
  "scroll-text": () => import("./scroll-text-BfzQHiSx.mjs"),
  scroll: () => import("./scroll-C4Ofh4jf.mjs"),
  "search-check": () => import("./search-check-CEQGcZPJ.mjs"),
  "search-code": () => import("./search-code-Dh26xWPA.mjs"),
  "search-slash": () => import("./search-slash-CxLuC8XO.mjs"),
  "search-x": () => import("./search-x-DodFIvq1.mjs"),
  search: () => import("./search-Bim8iF6D.mjs"),
  section: () => import("./section-BWUatAYI.mjs"),
  "send-horizontal": () => import("./send-horizontal-32izG077.mjs"),
  "send-horizonal": () => import("./send-horizontal-32izG077.mjs"),
  "send-to-back": () => import("./send-to-back-r_UWFShx.mjs"),
  send: () => import("./send-DfmU-i7E.mjs"),
  "separator-horizontal": () => import("./separator-horizontal-C0_nX0x9.mjs"),
  "separator-vertical": () => import("./separator-vertical-BnJGe7Eb.mjs"),
  "server-cog": () => import("./server-cog-CUTZELwE.mjs"),
  "server-crash": () => import("./server-crash-AMpt8uZ9.mjs"),
  "server-off": () => import("./server-off-B6NaLpNB.mjs"),
  server: () => import("./server-CZCwg58p.mjs"),
  "settings-2": () => import("./settings-2-Aj-JGptG.mjs"),
  settings: () => import("./settings-BabOjZjY.mjs"),
  shapes: () => import("./shapes-DG4W5Ke8.mjs"),
  "share-2": () => import("./share-2-BVeMekpQ.mjs"),
  share: () => import("./share-DRsLSfJs.mjs"),
  sheet: () => import("./sheet-CNJUW3GF.mjs"),
  shell: () => import("./shell-hqCXjCZ_.mjs"),
  "shield-alert": () => import("./shield-alert-DfuXd046.mjs"),
  "shield-ban": () => import("./shield-ban-CyU4LHuH.mjs"),
  "shield-check": () => import("./shield-check-DcSe2tTF.mjs"),
  "shield-ellipsis": () => import("./shield-ellipsis-Tx5uXf6s.mjs"),
  "shield-half": () => import("./shield-half-N4RB-dVD.mjs"),
  "shield-minus": () => import("./shield-minus-CZkiTc36.mjs"),
  "shield-off": () => import("./shield-off-gBnh_UNT.mjs"),
  "shield-plus": () => import("./shield-plus-DqNwm7LH.mjs"),
  "shield-question-mark": () => import("./shield-question-mark-DxoYoCRF.mjs"),
  "shield-question": () => import("./shield-question-mark-DxoYoCRF.mjs"),
  "shield-user": () => import("./shield-user-D5aFsvvC.mjs"),
  "shield-x": () => import("./shield-x-xSu3YKxx.mjs"),
  "shield-close": () => import("./shield-x-xSu3YKxx.mjs"),
  shield: () => import("./shield-Cks8hr_T.mjs"),
  "ship-wheel": () => import("./ship-wheel-C_UpJcjv.mjs"),
  ship: () => import("./ship-D1jerIRT.mjs"),
  shirt: () => import("./shirt-BOycO67q.mjs"),
  "shopping-bag": () => import("./shopping-bag-C5I3EDaM.mjs"),
  "shopping-basket": () => import("./shopping-basket-CbicZ1qn.mjs"),
  "shopping-cart": () => import("./shopping-cart-B_S2tBke.mjs"),
  shovel: () => import("./shovel-CQKPLn7b.mjs"),
  "shower-head": () => import("./shower-head-BieFPXXN.mjs"),
  shredder: () => import("./shredder-CdBjAeHk.mjs"),
  shrimp: () => import("./shrimp-BQHwT8SL.mjs"),
  shrink: () => import("./shrink-na-8XA2Z.mjs"),
  shrub: () => import("./shrub-B10XsOe6.mjs"),
  shuffle: () => import("./shuffle-CRpcVPM5.mjs"),
  sigma: () => import("./sigma-DcpPRa44.mjs"),
  "signal-high": () => import("./signal-high-CMvPRXNZ.mjs"),
  "signal-low": () => import("./signal-low-DD2rvueb.mjs"),
  "signal-medium": () => import("./signal-medium-BuwIOP3-.mjs"),
  "signal-zero": () => import("./signal-zero-DW5VKHZk.mjs"),
  signal: () => import("./signal-CBIWMex8.mjs"),
  signature: () => import("./signature-BhNCSx0W.mjs"),
  "signpost-big": () => import("./signpost-big-BYxAGWnp.mjs"),
  signpost: () => import("./signpost-Cq3KNEo2.mjs"),
  siren: () => import("./siren-CFZvNj0_.mjs"),
  "skip-back": () => import("./skip-back-DsKbEiQm.mjs"),
  "skip-forward": () => import("./skip-forward-CqmfO2rG.mjs"),
  skull: () => import("./skull-00JtMf9M.mjs"),
  slack: () => import("./slack-Dxde1UYw.mjs"),
  slash: () => import("./slash-C75dTN0m.mjs"),
  slice: () => import("./slice-BA4lGUvB.mjs"),
  "sliders-horizontal": () => import("./sliders-horizontal-BLjsrjzD.mjs"),
  "sliders-vertical": () => import("./sliders-vertical-BvKag2mO.mjs"),
  sliders: () => import("./sliders-vertical-BvKag2mO.mjs"),
  "smartphone-charging": () => import("./smartphone-charging-Dg5q9KnQ.mjs"),
  "smartphone-nfc": () => import("./smartphone-nfc-BC6R9iMz.mjs"),
  smartphone: () => import("./smartphone-B_gwTB16.mjs"),
  "smile-plus": () => import("./smile-plus-wD7NQGon.mjs"),
  smile: () => import("./smile-CMPZYoQ0.mjs"),
  snail: () => import("./snail-xaKSm_Iw.mjs"),
  snowflake: () => import("./snowflake-ziCaqfFs.mjs"),
  "soap-dispenser-droplet": () => import("./soap-dispenser-droplet-Dn0FFhjB.mjs"),
  sofa: () => import("./sofa-Dp2twIgj.mjs"),
  soup: () => import("./soup-BEsDSsII.mjs"),
  space: () => import("./space-DHyCHutS.mjs"),
  spade: () => import("./spade-C78I1DqZ.mjs"),
  sparkle: () => import("./sparkle-Cxqht8CE.mjs"),
  sparkles: () => import("./sparkles-DnOFm_Da.mjs"),
  stars: () => import("./sparkles-DnOFm_Da.mjs"),
  speaker: () => import("./speaker-B8oTItxn.mjs"),
  speech: () => import("./speech-CHDfM6Yp.mjs"),
  "spell-check-2": () => import("./spell-check-2-9759Kd3W.mjs"),
  "spell-check": () => import("./spell-check-nqQzXmna.mjs"),
  "spline-pointer": () => import("./spline-pointer-Dj-DlIp-.mjs"),
  spline: () => import("./spline-D9UtAG0w.mjs"),
  split: () => import("./split-DndvSy3d.mjs"),
  spool: () => import("./spool-awj2XXzb.mjs"),
  spotlight: () => import("./spotlight-COii2naV.mjs"),
  "spray-can": () => import("./spray-can-DP7sTbVM.mjs"),
  sprout: () => import("./sprout-StbeItSc.mjs"),
  "square-activity": () => import("./square-activity-CoE2Cuwu.mjs"),
  "activity-square": () => import("./square-activity-CoE2Cuwu.mjs"),
  "square-arrow-down-left": () => import("./square-arrow-down-left-DRu8LgNM.mjs"),
  "arrow-down-left-square": () => import("./square-arrow-down-left-DRu8LgNM.mjs"),
  "square-arrow-down-right": () => import("./square-arrow-down-right-fbzlt5QQ.mjs"),
  "arrow-down-right-square": () => import("./square-arrow-down-right-fbzlt5QQ.mjs"),
  "square-arrow-down": () => import("./square-arrow-down-kolrDqwF.mjs"),
  "arrow-down-square": () => import("./square-arrow-down-kolrDqwF.mjs"),
  "square-arrow-left": () => import("./square-arrow-left-BFIO6jqf.mjs"),
  "arrow-left-square": () => import("./square-arrow-left-BFIO6jqf.mjs"),
  "square-arrow-out-down-left": () => import("./square-arrow-out-down-left-6jkCmGur.mjs"),
  "arrow-down-left-from-square": () => import("./square-arrow-out-down-left-6jkCmGur.mjs"),
  "square-arrow-out-down-right": () => import("./square-arrow-out-down-right-BktpOr7r.mjs"),
  "arrow-down-right-from-square": () => import("./square-arrow-out-down-right-BktpOr7r.mjs"),
  "square-arrow-out-up-left": () => import("./square-arrow-out-up-left-C9S6ntMg.mjs"),
  "arrow-up-left-from-square": () => import("./square-arrow-out-up-left-C9S6ntMg.mjs"),
  "square-arrow-out-up-right": () => import("./square-arrow-out-up-right-DCQwigFo.mjs"),
  "arrow-up-right-from-square": () => import("./square-arrow-out-up-right-DCQwigFo.mjs"),
  "square-arrow-right": () => import("./square-arrow-right-CyLfwtuy.mjs"),
  "arrow-right-square": () => import("./square-arrow-right-CyLfwtuy.mjs"),
  "square-arrow-up-left": () => import("./square-arrow-up-left-CkdV0y4j.mjs"),
  "arrow-up-left-square": () => import("./square-arrow-up-left-CkdV0y4j.mjs"),
  "square-arrow-up-right": () => import("./square-arrow-up-right-BSipAbNo.mjs"),
  "arrow-up-right-square": () => import("./square-arrow-up-right-BSipAbNo.mjs"),
  "square-arrow-up": () => import("./square-arrow-up-D55to-V-.mjs"),
  "arrow-up-square": () => import("./square-arrow-up-D55to-V-.mjs"),
  "square-asterisk": () => import("./square-asterisk-Ccj7lAbF.mjs"),
  "asterisk-square": () => import("./square-asterisk-Ccj7lAbF.mjs"),
  "square-bottom-dashed-scissors": () => import("./square-bottom-dashed-scissors-9B2bZuga.mjs"),
  "scissors-square-dashed-bottom": () => import("./square-bottom-dashed-scissors-9B2bZuga.mjs"),
  "square-chart-gantt": () => import("./square-chart-gantt-BFbag8T2.mjs"),
  "gantt-chart-square": () => import("./square-chart-gantt-BFbag8T2.mjs"),
  "square-gantt-chart": () => import("./square-chart-gantt-BFbag8T2.mjs"),
  "square-check-big": () => import("./square-check-big-Dr3c5g1V.mjs"),
  "check-square": () => import("./square-check-big-Dr3c5g1V.mjs"),
  "square-check": () => import("./square-check-BU3y2Bro.mjs"),
  "check-square-2": () => import("./square-check-BU3y2Bro.mjs"),
  "square-chevron-down": () => import("./square-chevron-down-Dl0y9p0c.mjs"),
  "chevron-down-square": () => import("./square-chevron-down-Dl0y9p0c.mjs"),
  "square-chevron-left": () => import("./square-chevron-left-KAzej18k.mjs"),
  "chevron-left-square": () => import("./square-chevron-left-KAzej18k.mjs"),
  "square-chevron-right": () => import("./square-chevron-right-_J-c8jXY.mjs"),
  "chevron-right-square": () => import("./square-chevron-right-_J-c8jXY.mjs"),
  "square-chevron-up": () => import("./square-chevron-up-BHrVjY-y.mjs"),
  "chevron-up-square": () => import("./square-chevron-up-BHrVjY-y.mjs"),
  "square-code": () => import("./square-code-Bh91coqB.mjs"),
  "code-square": () => import("./square-code-Bh91coqB.mjs"),
  "square-dashed-bottom-code": () => import("./square-dashed-bottom-code--ktnbNCD.mjs"),
  "square-dashed-bottom": () => import("./square-dashed-bottom-DSnk6v1V.mjs"),
  "square-dashed-kanban": () => import("./square-dashed-kanban-CCrgqqJd.mjs"),
  "kanban-square-dashed": () => import("./square-dashed-kanban-CCrgqqJd.mjs"),
  "square-dashed-mouse-pointer": () => import("./square-dashed-mouse-pointer-tfC3kZc1.mjs"),
  "mouse-pointer-square-dashed": () => import("./square-dashed-mouse-pointer-tfC3kZc1.mjs"),
  "square-dashed-top-solid": () => import("./square-dashed-top-solid-DPwkrSq-.mjs"),
  "square-dashed": () => import("./square-dashed-MzOeBXab.mjs"),
  "box-select": () => import("./square-dashed-MzOeBXab.mjs"),
  "square-divide": () => import("./square-divide-CuEW73BA.mjs"),
  "divide-square": () => import("./square-divide-CuEW73BA.mjs"),
  "square-dot": () => import("./square-dot-4x36b95B.mjs"),
  "dot-square": () => import("./square-dot-4x36b95B.mjs"),
  "square-equal": () => import("./square-equal-DFESvDjx.mjs"),
  "equal-square": () => import("./square-equal-DFESvDjx.mjs"),
  "square-function": () => import("./square-function-BbAsjjt8.mjs"),
  "function-square": () => import("./square-function-BbAsjjt8.mjs"),
  "square-kanban": () => import("./square-kanban-NLWtCjw1.mjs"),
  "kanban-square": () => import("./square-kanban-NLWtCjw1.mjs"),
  "square-library": () => import("./square-library-CrHlhn7_.mjs"),
  "library-square": () => import("./square-library-CrHlhn7_.mjs"),
  "square-m": () => import("./square-m-CI4JQ26T.mjs"),
  "m-square": () => import("./square-m-CI4JQ26T.mjs"),
  "square-menu": () => import("./square-menu-9XojzwDi.mjs"),
  "menu-square": () => import("./square-menu-9XojzwDi.mjs"),
  "square-minus": () => import("./square-minus-DS6DsyL2.mjs"),
  "minus-square": () => import("./square-minus-DS6DsyL2.mjs"),
  "square-mouse-pointer": () => import("./square-mouse-pointer-CuRT3pzn.mjs"),
  inspect: () => import("./square-mouse-pointer-CuRT3pzn.mjs"),
  "square-parking-off": () => import("./square-parking-off-CishaR6-.mjs"),
  "parking-square-off": () => import("./square-parking-off-CishaR6-.mjs"),
  "square-parking": () => import("./square-parking-D3_J8qlv.mjs"),
  "parking-square": () => import("./square-parking-D3_J8qlv.mjs"),
  "square-pause": () => import("./square-pause-BqhLbbuX.mjs"),
  "square-pen": () => import("./square-pen-Cdzjnat5.mjs"),
  "pen-box": () => import("./square-pen-Cdzjnat5.mjs"),
  edit: () => import("./square-pen-Cdzjnat5.mjs"),
  "pen-square": () => import("./square-pen-Cdzjnat5.mjs"),
  "square-percent": () => import("./square-percent-BgexIaaK.mjs"),
  "percent-square": () => import("./square-percent-BgexIaaK.mjs"),
  "square-pi": () => import("./square-pi-C61sIzOu.mjs"),
  "pi-square": () => import("./square-pi-C61sIzOu.mjs"),
  "square-pilcrow": () => import("./square-pilcrow-JhN2nJeA.mjs"),
  "pilcrow-square": () => import("./square-pilcrow-JhN2nJeA.mjs"),
  "square-play": () => import("./square-play-BDz4J67d.mjs"),
  "play-square": () => import("./square-play-BDz4J67d.mjs"),
  "square-plus": () => import("./square-plus-DgNbOX4N.mjs"),
  "plus-square": () => import("./square-plus-DgNbOX4N.mjs"),
  "square-power": () => import("./square-power-JKGjuaxi.mjs"),
  "power-square": () => import("./square-power-JKGjuaxi.mjs"),
  "square-radical": () => import("./square-radical-BHfJkeIj.mjs"),
  "square-round-corner": () => import("./square-round-corner-Dpg2hcLZ.mjs"),
  "square-scissors": () => import("./square-scissors-DAH-UvRl.mjs"),
  "scissors-square": () => import("./square-scissors-DAH-UvRl.mjs"),
  "square-sigma": () => import("./square-sigma-DGC3LYpV.mjs"),
  "sigma-square": () => import("./square-sigma-DGC3LYpV.mjs"),
  "square-slash": () => import("./square-slash-CIzO1Mxu.mjs"),
  "slash-square": () => import("./square-slash-CIzO1Mxu.mjs"),
  "square-split-horizontal": () => import("./square-split-horizontal-DGlwjeO3.mjs"),
  "split-square-horizontal": () => import("./square-split-horizontal-DGlwjeO3.mjs"),
  "square-split-vertical": () => import("./square-split-vertical-D4bw8w9H.mjs"),
  "split-square-vertical": () => import("./square-split-vertical-D4bw8w9H.mjs"),
  "square-square": () => import("./square-square-CwVrRkpl.mjs"),
  "square-stack": () => import("./square-stack-OYKgLDQL.mjs"),
  "square-star": () => import("./square-star-a2qPAmAJ.mjs"),
  "square-stop": () => import("./square-stop-DoJ-2iC-.mjs"),
  "square-terminal": () => import("./square-terminal-CBe5PbLt.mjs"),
  "terminal-square": () => import("./square-terminal-CBe5PbLt.mjs"),
  "square-user-round": () => import("./square-user-round-Bja_2QR9.mjs"),
  "user-square-2": () => import("./square-user-round-Bja_2QR9.mjs"),
  "square-user": () => import("./square-user-BsWucLM8.mjs"),
  "user-square": () => import("./square-user-BsWucLM8.mjs"),
  "square-x": () => import("./square-x-DT4QYMQ1.mjs"),
  "x-square": () => import("./square-x-DT4QYMQ1.mjs"),
  square: () => import("./square-CduLDwzy.mjs"),
  "squares-exclude": () => import("./squares-exclude-DwZ_nJcO.mjs"),
  "squares-intersect": () => import("./squares-intersect-Cd_hM8tu.mjs"),
  "squares-subtract": () => import("./squares-subtract-BHOccyhq.mjs"),
  "squares-unite": () => import("./squares-unite-Bpp50SNV.mjs"),
  "squircle-dashed": () => import("./squircle-dashed-BzjFDMoo.mjs"),
  squircle: () => import("./squircle-BuHI34FT.mjs"),
  squirrel: () => import("./squirrel-DTQ8iQeM.mjs"),
  stamp: () => import("./stamp-DSyuXdMo.mjs"),
  "star-half": () => import("./star-half-CfFv6Tgz.mjs"),
  "star-off": () => import("./star-off-CexpCq32.mjs"),
  star: () => import("./star-w6Fi69kM.mjs"),
  "step-back": () => import("./step-back-EP1Lqjnw.mjs"),
  "step-forward": () => import("./step-forward-DKEZfLLr.mjs"),
  stethoscope: () => import("./stethoscope-BrWGrfrm.mjs"),
  sticker: () => import("./sticker-Chd4JtWZ.mjs"),
  "sticky-note": () => import("./sticky-note-CiKdpBT3.mjs"),
  store: () => import("./store-DRsAhY6k.mjs"),
  "stretch-horizontal": () => import("./stretch-horizontal-DCKT-_tU.mjs"),
  "stretch-vertical": () => import("./stretch-vertical-BuAI1gEb.mjs"),
  strikethrough: () => import("./strikethrough-CXnuMThQ.mjs"),
  subscript: () => import("./subscript-DOAsPObx.mjs"),
  "sun-dim": () => import("./sun-dim-Bpl5puED.mjs"),
  "sun-medium": () => import("./sun-medium-OZibHS5F.mjs"),
  "sun-moon": () => import("./sun-moon-dbsJkNWr.mjs"),
  "sun-snow": () => import("./sun-snow-DdDsBN-h.mjs"),
  sun: () => import("./sun-BBpkgMvp.mjs"),
  sunrise: () => import("./sunrise-B1T05wYi.mjs"),
  sunset: () => import("./sunset-Cf2RHIh9.mjs"),
  superscript: () => import("./superscript-CKswjNb3.mjs"),
  "swatch-book": () => import("./swatch-book-CLZt0YLl.mjs"),
  "swiss-franc": () => import("./swiss-franc-BYAhP9zu.mjs"),
  "switch-camera": () => import("./switch-camera-CLCDKCWI.mjs"),
  sword: () => import("./sword-C0VJTZFa.mjs"),
  swords: () => import("./swords-B-QMtX1b.mjs"),
  syringe: () => import("./syringe-CCTuluGj.mjs"),
  "table-2": () => import("./table-2-pH__EKX1.mjs"),
  "table-cells-merge": () => import("./table-cells-merge-BSX4c_IP.mjs"),
  "table-cells-split": () => import("./table-cells-split-fZJdGduL.mjs"),
  "table-columns-split": () => import("./table-columns-split-B8q2hOlg.mjs"),
  "table-of-contents": () => import("./table-of-contents-DJn9AYZI.mjs"),
  "table-properties": () => import("./table-properties-BNDn-1DE.mjs"),
  "table-rows-split": () => import("./table-rows-split-qob6-hPX.mjs"),
  table: () => import("./table-9HyMqZfF.mjs"),
  "tablet-smartphone": () => import("./tablet-smartphone-pXrYlqbQ.mjs"),
  tablet: () => import("./tablet-BAsgF9gN.mjs"),
  tablets: () => import("./tablets-DhOyn49o.mjs"),
  tag: () => import("./tag-DKFxfsb7.mjs"),
  tags: () => import("./tags-C9TOQZBT.mjs"),
  "tally-1": () => import("./tally-1-CW4Pw5S2.mjs"),
  "tally-2": () => import("./tally-2-BCMwAqcS.mjs"),
  "tally-3": () => import("./tally-3-CbKvge4k.mjs"),
  "tally-4": () => import("./tally-4-B-B4Mugy.mjs"),
  "tally-5": () => import("./tally-5-LRS8yP0E.mjs"),
  tangent: () => import("./tangent-0rs1dbJt.mjs"),
  target: () => import("./target-DtBCeCX2.mjs"),
  telescope: () => import("./telescope-Do5d1opi.mjs"),
  "tent-tree": () => import("./tent-tree-D55Rs1Zj.mjs"),
  tent: () => import("./tent-C-Ct2rmY.mjs"),
  terminal: () => import("./terminal-BanOQaMF.mjs"),
  "test-tube-diagonal": () => import("./test-tube-diagonal-OvGpQBS9.mjs"),
  "test-tube-2": () => import("./test-tube-diagonal-OvGpQBS9.mjs"),
  "test-tube": () => import("./test-tube-CxbycOPk.mjs"),
  "test-tubes": () => import("./test-tubes-DGXvRF0i.mjs"),
  "text-cursor-input": () => import("./text-cursor-input-31t3PPN6.mjs"),
  "text-cursor": () => import("./text-cursor-BgmGtFoT.mjs"),
  "text-quote": () => import("./text-quote-DPylYPq5.mjs"),
  "text-search": () => import("./text-search-DfL45zSI.mjs"),
  "text-select": () => import("./text-select-DCS67SGn.mjs"),
  "text-selection": () => import("./text-select-DCS67SGn.mjs"),
  text: () => import("./text-D1SjF-rf.mjs"),
  theater: () => import("./theater-DoBDeEGj.mjs"),
  "thermometer-snowflake": () => import("./thermometer-snowflake-BGt0Sz1S.mjs"),
  "thermometer-sun": () => import("./thermometer-sun-D64fkojs.mjs"),
  thermometer: () => import("./thermometer-Bm7xn08Q.mjs"),
  "thumbs-down": () => import("./thumbs-down-CYMuCbHN.mjs"),
  "thumbs-up": () => import("./thumbs-up-20kU6HS9.mjs"),
  "ticket-check": () => import("./ticket-check-Dnqed6eu.mjs"),
  "ticket-minus": () => import("./ticket-minus-CbwMt6ne.mjs"),
  "ticket-percent": () => import("./ticket-percent-DW2Vnehg.mjs"),
  "ticket-plus": () => import("./ticket-plus-CEb1SoK0.mjs"),
  "ticket-slash": () => import("./ticket-slash-Mr_lrxXN.mjs"),
  "ticket-x": () => import("./ticket-x-C513UCFR.mjs"),
  ticket: () => import("./ticket-C0a5YYmx.mjs"),
  "tickets-plane": () => import("./tickets-plane-BHHkejfX.mjs"),
  tickets: () => import("./tickets-D8kzwhxu.mjs"),
  "timer-off": () => import("./timer-off-DBTsEHjc.mjs"),
  "timer-reset": () => import("./timer-reset-DPTgorRQ.mjs"),
  timer: () => import("./timer-CUsBopeM.mjs"),
  "toggle-left": () => import("./toggle-left-s3WhS-T3.mjs"),
  "toggle-right": () => import("./toggle-right-zbvkGSYH.mjs"),
  toilet: () => import("./toilet-DjAJuzzs.mjs"),
  "tool-case": () => import("./tool-case-DmV0wP4s.mjs"),
  tornado: () => import("./tornado-C6MY7lqd.mjs"),
  torus: () => import("./torus-Dy9HugWw.mjs"),
  "touchpad-off": () => import("./touchpad-off-BCpg8F7q.mjs"),
  touchpad: () => import("./touchpad-CRWJQW9f.mjs"),
  "tower-control": () => import("./tower-control-CmP2gJgw.mjs"),
  "toy-brick": () => import("./toy-brick-1c6aivIv.mjs"),
  tractor: () => import("./tractor-Cxl9oqVY.mjs"),
  "traffic-cone": () => import("./traffic-cone-mKY2huRs.mjs"),
  "train-front-tunnel": () => import("./train-front-tunnel-BQzEF_DG.mjs"),
  "train-front": () => import("./train-front-C3Zok5eR.mjs"),
  "train-track": () => import("./train-track-90FSVGSu.mjs"),
  "tram-front": () => import("./tram-front-DMYTk4Av.mjs"),
  train: () => import("./tram-front-DMYTk4Av.mjs"),
  transgender: () => import("./transgender-7Hwxv1ag.mjs"),
  "trash-2": () => import("./trash-2-H5PJUk0Q.mjs"),
  trash: () => import("./trash-CX54-5wS.mjs"),
  "tree-deciduous": () => import("./tree-deciduous-D8ALbyj6.mjs"),
  "tree-palm": () => import("./tree-palm-CjQCO1MF.mjs"),
  palmtree: () => import("./tree-palm-CjQCO1MF.mjs"),
  "tree-pine": () => import("./tree-pine-CvXzs3KJ.mjs"),
  trees: () => import("./trees-Cm6oWAcC.mjs"),
  trello: () => import("./trello-Bq8Wwswz.mjs"),
  "trending-down": () => import("./trending-down-6_AQugY0.mjs"),
  "trending-up-down": () => import("./trending-up-down-DHBtJXsN.mjs"),
  "trending-up": () => import("./trending-up-DZVHc0mw.mjs"),
  "triangle-alert": () => import("./triangle-alert-BvpjHZVe.mjs"),
  "alert-triangle": () => import("./triangle-alert-BvpjHZVe.mjs"),
  "triangle-dashed": () => import("./triangle-dashed-DfuG1YkS.mjs"),
  "triangle-right": () => import("./triangle-right-DOxXRnUn.mjs"),
  triangle: () => import("./triangle-DJifZwya.mjs"),
  trophy: () => import("./trophy-J9hQguV3.mjs"),
  "truck-electric": () => import("./truck-electric-CX0jq86_.mjs"),
  truck: () => import("./truck-CHSf-ZoB.mjs"),
  "turkish-lira": () => import("./turkish-lira-B5VyFuP5.mjs"),
  turntable: () => import("./turntable-Dka6z2Qo.mjs"),
  turtle: () => import("./turtle-StTn8bgp.mjs"),
  "tv-minimal-play": () => import("./tv-minimal-play-D-UGLlV4.mjs"),
  "tv-minimal": () => import("./tv-minimal-CuIqrx8J.mjs"),
  "tv-2": () => import("./tv-minimal-CuIqrx8J.mjs"),
  tv: () => import("./tv-DWTzMi8v.mjs"),
  twitch: () => import("./twitch-BkF8Qhpd.mjs"),
  twitter: () => import("./twitter-C3XP6C3f.mjs"),
  "type-outline": () => import("./type-outline-2nDl9neG.mjs"),
  type: () => import("./type-C4_otPnl.mjs"),
  "umbrella-off": () => import("./umbrella-off-DaK1E61F.mjs"),
  umbrella: () => import("./umbrella-BtLjTMqS.mjs"),
  underline: () => import("./underline-C9TYiGby.mjs"),
  "undo-2": () => import("./undo-2-CfAzYEHJ.mjs"),
  "undo-dot": () => import("./undo-dot-DdMX13o4.mjs"),
  undo: () => import("./undo-DUIXnuA2.mjs"),
  "unfold-horizontal": () => import("./unfold-horizontal-CoZpHwUL.mjs"),
  "unfold-vertical": () => import("./unfold-vertical-_Z9pPCIz.mjs"),
  ungroup: () => import("./ungroup-CIUWJUWA.mjs"),
  university: () => import("./university-CG2qxq7S.mjs"),
  "school-2": () => import("./university-CG2qxq7S.mjs"),
  "unlink-2": () => import("./unlink-2-BzVi_Upe.mjs"),
  unlink: () => import("./unlink-6xARHMup.mjs"),
  unplug: () => import("./unplug-BTtoU4F4.mjs"),
  upload: () => import("./upload-Bou35iw4.mjs"),
  usb: () => import("./usb-mQgGSqIU.mjs"),
  "user-check": () => import("./user-check-BMOJdfeO.mjs"),
  "user-cog": () => import("./user-cog-PwutmEKA.mjs"),
  "user-lock": () => import("./user-lock-CVCxQjgA.mjs"),
  "user-minus": () => import("./user-minus-B6S8eImN.mjs"),
  "user-pen": () => import("./user-pen-DJ4LNuTi.mjs"),
  "user-plus": () => import("./user-plus-BZTrOGW8.mjs"),
  "user-round-check": () => import("./user-round-check-DCU_h3gX.mjs"),
  "user-check-2": () => import("./user-round-check-DCU_h3gX.mjs"),
  "user-round-cog": () => import("./user-round-cog-xBq_6sPI.mjs"),
  "user-cog-2": () => import("./user-round-cog-xBq_6sPI.mjs"),
  "user-round-minus": () => import("./user-round-minus-B0VkJPtX.mjs"),
  "user-minus-2": () => import("./user-round-minus-B0VkJPtX.mjs"),
  "user-round-pen": () => import("./user-round-pen-DUAFJxTJ.mjs"),
  "user-round-plus": () => import("./user-round-plus-DfJSbFTm.mjs"),
  "user-plus-2": () => import("./user-round-plus-DfJSbFTm.mjs"),
  "user-round-search": () => import("./user-round-search-Cl8lD8RL.mjs"),
  "user-round-x": () => import("./user-round-x-y95gOX9r.mjs"),
  "user-x-2": () => import("./user-round-x-y95gOX9r.mjs"),
  "user-round": () => import("./user-round-DDTIXpu0.mjs"),
  "user-2": () => import("./user-round-DDTIXpu0.mjs"),
  "user-search": () => import("./user-search-DEdU2O7F.mjs"),
  "user-star": () => import("./user-star-CcQm5Kip.mjs"),
  "user-x": () => import("./user-x-ChphOhfA.mjs"),
  user: () => import("./user-DIZAV7q1.mjs"),
  "users-round": () => import("./users-round-x4Fyw5VR.mjs"),
  "users-2": () => import("./users-round-x4Fyw5VR.mjs"),
  users: () => import("./users--6YC516f.mjs"),
  "utensils-crossed": () => import("./utensils-crossed-BF4jPl9q.mjs"),
  "fork-knife-crossed": () => import("./utensils-crossed-BF4jPl9q.mjs"),
  utensils: () => import("./utensils-BVX7kv2E.mjs"),
  "fork-knife": () => import("./utensils-BVX7kv2E.mjs"),
  "utility-pole": () => import("./utility-pole-CFDPAguP.mjs"),
  variable: () => import("./variable-Vxt9Ga10.mjs"),
  vault: () => import("./vault-DnU0tVYW.mjs"),
  "vector-square": () => import("./vector-square-sHQ5bRPC.mjs"),
  vegan: () => import("./vegan-Ca2hjpPZ.mjs"),
  "venetian-mask": () => import("./venetian-mask-B_NDK0dr.mjs"),
  "venus-and-mars": () => import("./venus-and-mars-CPPFpDYo.mjs"),
  venus: () => import("./venus-c8pbIAqV.mjs"),
  "vibrate-off": () => import("./vibrate-off-BQiIEShj.mjs"),
  vibrate: () => import("./vibrate-D1BEFIcb.mjs"),
  "video-off": () => import("./video-off-BAHUERAr.mjs"),
  video: () => import("./video-SllyrfJG.mjs"),
  videotape: () => import("./videotape-BM9O9INu.mjs"),
  view: () => import("./view-CkMXv1HC.mjs"),
  voicemail: () => import("./voicemail-JLbSdNET.mjs"),
  volleyball: () => import("./volleyball-CaZr-RBu.mjs"),
  "volume-1": () => import("./volume-1-BwkM_Ci2.mjs"),
  "volume-2": () => import("./volume-2-UrtiwGl5.mjs"),
  "volume-off": () => import("./volume-off-Bu8Qqd2j.mjs"),
  "volume-x": () => import("./volume-x-ZZXAfBIo.mjs"),
  volume: () => import("./volume-DvFIBdxR.mjs"),
  vote: () => import("./vote-BYOq9e5R.mjs"),
  "wallet-cards": () => import("./wallet-cards-AwkEVNjY.mjs"),
  "wallet-minimal": () => import("./wallet-minimal-6hqqU_ug.mjs"),
  "wallet-2": () => import("./wallet-minimal-6hqqU_ug.mjs"),
  wallet: () => import("./wallet-C1p3R3GA.mjs"),
  wallpaper: () => import("./wallpaper-D12ogoqG.mjs"),
  "wand-sparkles": () => import("./wand-sparkles-5Klh7RL8.mjs"),
  "wand-2": () => import("./wand-sparkles-5Klh7RL8.mjs"),
  wand: () => import("./wand-D_gbOg7g.mjs"),
  warehouse: () => import("./warehouse-BjrkfmjM.mjs"),
  "washing-machine": () => import("./washing-machine-nyUaxA_J.mjs"),
  watch: () => import("./watch-BTiTU5J-.mjs"),
  "waves-ladder": () => import("./waves-ladder-CeJsA4He.mjs"),
  waves: () => import("./waves-CK2vTYmk.mjs"),
  waypoints: () => import("./waypoints-yElC0lUS.mjs"),
  webcam: () => import("./webcam-Cm-dAcNS.mjs"),
  "webhook-off": () => import("./webhook-off-BK7UeKDi.mjs"),
  webhook: () => import("./webhook-C1EVFfUd.mjs"),
  weight: () => import("./weight-BmBCL7Hl.mjs"),
  "wheat-off": () => import("./wheat-off-C44FqHYQ.mjs"),
  wheat: () => import("./wheat-CQsH5rGd.mjs"),
  "whole-word": () => import("./whole-word-Bzh_0lU5.mjs"),
  "wifi-cog": () => import("./wifi-cog-BG5Ri6H4.mjs"),
  "wifi-high": () => import("./wifi-high-BtG6StGR.mjs"),
  "wifi-low": () => import("./wifi-low-gUKu39tz.mjs"),
  "wifi-off": () => import("./wifi-off-DE5fgWor.mjs"),
  "wifi-pen": () => import("./wifi-pen-CYYBvmmw.mjs"),
  "wifi-sync": () => import("./wifi-sync-CvaRcATt.mjs"),
  "wifi-zero": () => import("./wifi-zero-CklGGJR4.mjs"),
  wifi: () => import("./wifi-BnAVaDUo.mjs"),
  "wind-arrow-down": () => import("./wind-arrow-down-CY_wtLSe.mjs"),
  wind: () => import("./wind-CXNua6RH.mjs"),
  "wine-off": () => import("./wine-off-CtrkKV3G.mjs"),
  wine: () => import("./wine-D4K9Kxuz.mjs"),
  workflow: () => import("./workflow-RspGKcwb.mjs"),
  worm: () => import("./worm-CLQVhvyJ.mjs"),
  "wrap-text": () => import("./wrap-text-D9CbMKSl.mjs"),
  wrench: () => import("./wrench-BDpwoFHC.mjs"),
  x: () => import("./x-Dl7n6FXU.mjs"),
  youtube: () => import("./youtube-DKohYjSK.mjs"),
  "zap-off": () => import("./zap-off-e1KvSItP.mjs"),
  zap: () => import("./zap-CWSmVwLe.mjs"),
  "zoom-in": () => import("./zoom-in-Df8_C4sp.mjs"),
  "zoom-out": () => import("./zoom-out-BHr2bGRr.mjs")
}, gne = ({ name: e, className: t, ...r }) => {
  const [i, n] = ee(null);
  return gt(() => {
    let o = !0;
    return (async () => {
      const a = await fne[e]();
      o && n(() => a.default);
    })(), () => {
      o = !1;
    };
  }, [e]), i ? /* @__PURE__ */ H(i, { className: t, ...r }) : /* @__PURE__ */ H("span", { style: { height: r.size || 24, width: r.size || 24 } });
}, Hi = $r(gne), mne = ({
  isOpen: e,
  onClose: t,
  children: r,
  position: i = "right",
  size: n = "320px",
  title: o,
  className: s,
  overlayDismiss: a = !0
}) => {
  const [l, u] = ee(!1), [c, d] = ee(!1), h = re(null), p = fe(() => {
    switch (i) {
      case "left":
        return { from: "-translate-x-full", to: "translate-x-0", positionClass: "left-0 top-0 h-full" };
      case "right":
        return { from: "translate-x-full", to: "translate-x-0", positionClass: "right-0 top-0 h-full" };
      case "top":
        return { from: "-translate-y-full", to: "translate-y-0", positionClass: "left-0 top-0 w-full" };
      case "bottom":
        return { from: "translate-y-full", to: "translate-y-0", positionClass: "left-0 bottom-0 w-full" };
      default:
        return { from: "translate-x-full", to: "translate-x-0", positionClass: "right-0 top-0 h-full" };
    }
  }, [i]), g = fe(() => {
    const y = {};
    return i === "left" || i === "right" ? (y.width = n, y.maxWidth = "100vw") : (y.height = n, y.maxHeight = "100vh"), y;
  }, [i, n]), { from: m, to: f, positionClass: C } = p(), w = g();
  gt(() => {
    let y, S;
    return e ? (u(!0), y = requestAnimationFrame(() => {
      S = window.setTimeout(() => {
        d(!0);
      }, 10);
    })) : (d(!1), S = window.setTimeout(() => u(!1), 500)), () => {
      cancelAnimationFrame(y), clearTimeout(S);
    };
  }, [e]);
  const E = fe((y) => {
    a && h.current && !h.current.contains(y.target) && t();
  }, [t, a]), b = fe((y) => {
    y.key === "Escape" && e && t();
  }, [e, t]);
  return gt(() => (l ? document.addEventListener("keydown", b) : document.removeEventListener("keydown", b), () => {
    document.removeEventListener("keydown", b);
  }), [l, b]), l ? xa(
    /* @__PURE__ */ H(
      "div",
      {
        className: `fixed inset-0 z-50 flex
        ${c ? "opacity-100" : "opacity-0"}
        transition-opacity duration-500 ease-in-out`,
        onClick: E,
        style: { backgroundColor: "rgba(0,0,0,0.5)" },
        children: /* @__PURE__ */ ve(
          "div",
          {
            ref: h,
            style: w,
            className: `fixed bg-card border border-border text-text shadow-xl flex flex-col
          ${C}
          transform transition-transform duration-500 ease-out
          ${c ? f : m}
          ${s || ""}`,
            children: [
              /* @__PURE__ */ ve("div", { className: "flex justify-between items-center p-4 border-b border-border flex-shrink-0", children: [
                o && /* @__PURE__ */ H("h3", { className: "text-xl font-semibold", children: o }),
                /* @__PURE__ */ H(
                  "button",
                  {
                    onClick: t,
                    className: "text-text-light hover:text-text transition-colors",
                    "aria-label": "Close drawer",
                    children: /* @__PURE__ */ H(Hi, { name: "x", size: 24 })
                  }
                )
              ] }),
              /* @__PURE__ */ H("div", { className: "flex-grow p-4 overflow-y-auto", children: r })
            ]
          }
        )
      }
    ),
    document.body
  ) : null;
}, vne = {
  primary: "bg-primary text-primary-foreground hover:brightness-110 active:brightness-105 focus:ring-primary disabled:hover:brightness-100",
  secondary: "bg-secondary text-secondary-foreground hover:brightness-110 active:brightness-105 focus:ring-secondary disabled:hover:brightness-100",
  danger: "bg-danger text-danger-foreground hover:brightness-110 active:brightness-95 focus:ring-danger disabled:hover:brightness-100",
  outline: "border border-border text-text hover:bg-primary/10 hover:text-primary focus:ring-primary disabled:hover:bg-transparent disabled:hover:text-text",
  accent: "bg-accent text-accent-foreground hover:brightness-110 active:brightness-105 focus:ring-accent disabled:hover:brightness-100",
  ghost: "bg-transparent text-text hover:bg-border focus:ring-primary disabled:hover:bg-transparent",
  link: "bg-transparent text-primary hover:underline focus:ring-primary underline-offset-4 shadow-none disabled:hover:no-underline"
}, Cne = ({ className: e }) => /* @__PURE__ */ ve(
  "svg",
  {
    className: `animate-spin -ml-1 mr-3 h-5 w-5 text-current ${e}`,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [
      /* @__PURE__ */ H("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
      /* @__PURE__ */ H("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
    ]
  }
), Uo = D.forwardRef(
  (e, t) => {
    const {
      children: r,
      variant: i = "primary",
      size: n = "md",
      iconBefore: o,
      iconAfter: s,
      loading: a = !1,
      fullWidth: l = !1,
      className: u,
      isIconOnly: c,
      ...d
    } = e, { href: h } = d, p = c || !r && (o || s), g = {
      sm: `text-sm ${p ? "p-1.5" : "py-1 px-2"}`,
      md: `text-base ${p ? "p-2" : "py-2 px-4"}`,
      lg: `text-lg ${p ? "p-3" : "py-3 px-6"}`
    }, m = "appearance-none inline-flex items-center justify-center font-semibold rounded-md shadow-sm transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap", f = l ? "w-full" : "", C = e.disabled || a, w = /* @__PURE__ */ ve(kP, { children: [
      a && /* @__PURE__ */ H(Cne, {}),
      !a && o && /* @__PURE__ */ H("span", { className: r ? "mr-2" : "", children: o }),
      !a && r,
      !a && s && /* @__PURE__ */ H("span", { className: r ? "ml-2" : "", children: s })
    ] }), E = `${m} ${vne[i]} ${g[n]} ${f} ${u || ""}`;
    if (h) {
      const { form: y, formAction: S, formEncType: x, formMethod: R, formNoValidate: P, formTarget: O, name: I, ...M } = d;
      return /* @__PURE__ */ H(
        "a",
        {
          ref: t,
          href: h,
          className: E,
          "aria-disabled": C,
          ...M,
          children: w
        }
      );
    }
    return /* @__PURE__ */ H(
      "button",
      {
        ref: t,
        className: E,
        disabled: C,
        "aria-busy": a,
        ...d,
        children: w
      }
    );
  }
);
Uo.displayName = "Button";
const rbe = () => /* @__PURE__ */ H("div", { className: "my-1 h-px bg-border", role: "separator" }), FT = ({ children: e, onClick: t, disabled: r, icon: i }) => /* @__PURE__ */ ve(
  "button",
  {
    onClick: t,
    disabled: r,
    className: `flex items-center w-full text-left px-4 py-2 text-sm cursor-pointer transition-colors duration-150 ease-in-out whitespace-nowrap hover:bg-bg-hover text-text ${r ? "opacity-50 cursor-not-allowed" : ""}`,
    role: "menuitem",
    children: [
      i && /* @__PURE__ */ H("span", { className: "mr-3 h-4 w-4 text-muted-foreground", children: i }),
      e
    ]
  }
), yne = ({ trigger: e, children: t, position: r = "bottom-right" }) => {
  const [i, n] = ee(!1), o = re(null), s = re(null), a = () => {
    s.current && clearTimeout(s.current), n(!0);
  }, l = () => {
    s.current = window.setTimeout(() => {
      n(!1);
    }, 150);
  }, u = fe(() => n((h) => !h), []), c = fe((h) => {
    o.current && !o.current.contains(h.target) && n(!1);
  }, []);
  return gt(() => (i ? document.addEventListener("mousedown", c) : document.removeEventListener("mousedown", c), () => {
    document.removeEventListener("mousedown", c);
  }), [i, c]), /* @__PURE__ */ ve(
    "div",
    {
      className: "relative inline-block text-left",
      ref: o,
      onMouseEnter: a,
      onMouseLeave: l,
      children: [
        /* @__PURE__ */ H("div", { onClick: u, className: "cursor-pointer", children: e }),
        i && /* @__PURE__ */ H(
          "div",
          {
            onMouseEnter: a,
            className: `origin-top-right absolute z-50 rounded-md shadow-lg bg-card border border-border ring-1 ring-black ring-opacity-5 focus:outline-none min-w-[12rem] w-max ${(() => {
              switch (r) {
                case "bottom-left":
                  return "top-full left-0 mt-1";
                case "bottom-right":
                  return "top-full right-0 mt-1";
                case "top-left":
                  return "bottom-full left-0 mb-1";
                case "top-right":
                  return "bottom-full right-0 mb-1";
                default:
                  return "top-full right-0 mt-2";
              }
            })()}`,
            role: "menu",
            "aria-orientation": "vertical",
            "aria-labelledby": "menu-button",
            children: /* @__PURE__ */ H("div", { className: "py-4", role: "none", children: t })
          }
        )
      ]
    }
  );
}, bne = ({ icon: e, title: t, description: r, actionButton: i, className: n }) => /* @__PURE__ */ ve(Oa, { className: `p-8 text-center flex flex-col items-center justify-center space-y-4 ${n || ""}`, children: [
  e && /* @__PURE__ */ H("div", { className: "text-text-light/50 mb-4", children: /* @__PURE__ */ H(Hi, { name: e, size: 64, strokeWidth: 1.5 }) }),
  /* @__PURE__ */ H("h3", { className: "text-2xl font-semibold text-text", children: t }),
  r && /* @__PURE__ */ H("p", { className: "text-text-light max-w-md", children: r }),
  i && /* @__PURE__ */ H("div", { className: "mt-4", children: i })
] }), wne = ({ headers: e, data: t, caption: r, className: i }) => /* @__PURE__ */ H("div", { className: `overflow-x-auto rounded-lg border border-border ${i || ""}`, children: /* @__PURE__ */ ve("table", { className: "w-full text-left", children: [
  r && /* @__PURE__ */ H("caption", { className: "p-4 text-lg font-semibold text-text bg-card-alt", children: r }),
  /* @__PURE__ */ H("thead", { className: "bg-card-alt", children: /* @__PURE__ */ H("tr", { children: e.map((n) => /* @__PURE__ */ H("th", { scope: "col", className: "p-4 text-sm font-semibold text-text whitespace-nowrap", children: n.label }, n.key)) }) }),
  /* @__PURE__ */ H("tbody", { className: "divide-y divide-border", children: t.length > 0 ? t.map((n, o) => /* @__PURE__ */ H("tr", { className: "hover:bg-primary/5 transition-colors", children: e.map((s) => {
    const a = n[s.key];
    return /* @__PURE__ */ H("td", { className: "p-4 text-sm text-text-light whitespace-nowrap", children: s.render ? s.render(a, n) : String(a) }, s.key);
  }) }, o)) : /* @__PURE__ */ H("tr", { children: /* @__PURE__ */ H("td", { colSpan: e.length, children: /* @__PURE__ */ H("div", { className: "p-8 flex justify-center items-center", children: /* @__PURE__ */ H(
    bne,
    {
      title: "No Data Available",
      description: "There is no data to display in this table.",
      icon: "table"
    }
  ) }) }) }) })
] }) }), ibe = ({ title: e, children: t, data: r, tableHeaders: i }) => {
  const [n, o] = ee(!1);
  return /* @__PURE__ */ ve(Oa, { padding: "p-6", children: [
    /* @__PURE__ */ ve("div", { className: "flex justify-between items-center mb-4", children: [
      /* @__PURE__ */ H("h3", { className: "text-2xl font-semibold text-text", children: e }),
      /* @__PURE__ */ ve(
        yne,
        {
          trigger: /* @__PURE__ */ H(Uo, { variant: "ghost", size: "sm", children: /* @__PURE__ */ H(Hi, { name: "more-horizontal" }) }),
          position: "bottom-right",
          children: [
            /* @__PURE__ */ ve(FT, { onClick: () => o(!0), children: [
              /* @__PURE__ */ H(Hi, { name: "table", size: 16, className: "mr-2" }),
              "View as table"
            ] }),
            /* @__PURE__ */ ve(FT, { children: [
              /* @__PURE__ */ H(Hi, { name: "download", size: 16, className: "mr-2" }),
              "Download as CSV"
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ H("div", { className: "h-96", children: t }),
    /* @__PURE__ */ H(
      mne,
      {
        isOpen: n,
        onClose: () => o(!1),
        position: "right",
        size: "50%",
        title: `Data for: ${e}`,
        children: /* @__PURE__ */ H("div", { className: "p-4", children: /* @__PURE__ */ H(wne, { headers: i, data: r }) })
      }
    )
  ] });
}, nbe = ({ data: e, dataKeyX: t, lineKeys: r, title: i }) => {
  const { theme: n } = ku(), o = n === "light" ? "#314155" : "#D1D5DB", s = n === "light" ? "#E5E7EB" : "#4B5563", a = n === "light" ? "#FFFFFF" : "#1F2937", l = n === "light" ? "#314155" : "#D1D5DB";
  return /* @__PURE__ */ ve("div", { className: "w-full h-96 bg-card border border-border rounded-lg shadow-md p-4 flex flex-col", children: [
    i && /* @__PURE__ */ H("h3", { className: "text-xl font-semibold mb-4 text-text", children: i }),
    /* @__PURE__ */ H(Yw, { width: "100%", height: "100%", children: /* @__PURE__ */ ve(
      dne,
      {
        data: e,
        margin: { top: 5, right: 30, left: 20, bottom: 5 },
        children: [
          /* @__PURE__ */ H(OS, { strokeDasharray: "3 3", stroke: s }),
          /* @__PURE__ */ H(Lu, { dataKey: t, stroke: o, tick: { fill: o } }),
          /* @__PURE__ */ H(Gu, { stroke: o, tick: { fill: o } }),
          /* @__PURE__ */ H(
            Mi,
            {
              contentStyle: { backgroundColor: a, borderColor: s },
              itemStyle: { color: l },
              labelStyle: { color: l }
            }
          ),
          /* @__PURE__ */ H(uo, {}),
          r.map((u, c) => /* @__PURE__ */ H(
            vh,
            {
              type: "monotone",
              dataKey: u.key,
              stroke: u.color,
              strokeWidth: 2,
              activeDot: { r: 8 }
            },
            c
          ))
        ]
      }
    ) })
  ] });
}, obe = ({ data: e, dataKey: t, nameKey: r, title: i }) => {
  const { theme: n } = ku(), o = n === "light" ? "#314155" : "#D1D5DB", s = n === "light" ? "#FFFFFF" : "#1F2937", a = n === "light" ? "#E5E7EB" : "#4B5563", l = n === "light" ? "#314155" : "#D1D5DB", u = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#AF19FF", "#FF4560"], c = ({ active: d, payload: h }) => d && h && h.length ? /* @__PURE__ */ H("div", { style: {
    backgroundColor: s,
    border: `1px solid ${a}`,
    borderRadius: "0.375rem",
    padding: "0.5rem",
    boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)"
  }, children: /* @__PURE__ */ H("p", { style: { color: l }, children: `${h[0].name} : ${h[0].value}` }) }) : null;
  return /* @__PURE__ */ ve("div", { className: "w-full h-96 bg-card border border-border rounded-lg shadow-md p-4 flex flex-col", children: [
    i && /* @__PURE__ */ H("h3", { className: "text-xl font-semibold mb-4 text-text", children: i }),
    /* @__PURE__ */ H(Yw, { width: "100%", height: "100%", children: /* @__PURE__ */ ve(pne, { children: [
      /* @__PURE__ */ H(
        Po,
        {
          data: e,
          cx: "50%",
          cy: "50%",
          labelLine: !1,
          outerRadius: 100,
          fill: "#8884d8",
          dataKey: t,
          nameKey: r,
          children: e.map((d, h) => /* @__PURE__ */ H(im, { fill: u[h % u.length] }, `cell-${h}`))
        }
      ),
      /* @__PURE__ */ H(Mi, { content: /* @__PURE__ */ H(c, {}) }),
      /* @__PURE__ */ H(
        uo,
        {
          formatter: (d) => /* @__PURE__ */ H("span", { style: { color: o }, children: d })
        }
      )
    ] }) })
  ] });
};
var FS = Object.defineProperty, Sne = Object.defineProperties, Ene = Object.getOwnPropertyDescriptor, xne = Object.getOwnPropertyDescriptors, tg = Object.getOwnPropertySymbols, xF = Object.prototype.hasOwnProperty, AF = Object.prototype.propertyIsEnumerable, _T = (e, t, r) => t in e ? FS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ce = (e, t) => {
  for (var r in t || (t = {}))
    xF.call(t, r) && _T(e, r, t[r]);
  if (tg)
    for (var r of tg(t))
      AF.call(t, r) && _T(e, r, t[r]);
  return e;
}, Dt = (e, t) => Sne(e, xne(t)), Ane = (e, t) => {
  var r = {};
  for (var i in e)
    xF.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
  if (e != null && tg)
    for (var i of tg(e))
      t.indexOf(i) < 0 && AF.call(e, i) && (r[i] = e[i]);
  return r;
}, yr = (e, t) => {
  for (var r in t)
    FS(e, r, { get: t[r], enumerable: !0 });
}, v = (e, t, r, i) => {
  for (var n = i > 1 ? void 0 : i ? Ene(t, r) : t, o = e.length - 1, s; o >= 0; o--)
    (s = e[o]) && (n = (i ? s(t, r, n) : s(n)) || n);
  return i && n && FS(t, r, n), n;
}, an = (e, t) => (r, i) => t(r, i, e), DF = {};
yr(DF, {
  attrToBoolean: () => rg,
  attrToNumber: () => Yo,
  attrToString: () => Dne,
  defaultComparator: () => Tne,
  exists: () => q,
  jsonEquals: () => Rb,
  makeNull: () => Nn,
  missing: () => Re,
  missingOrEmpty: () => Ni,
  toStringOrNull: () => Dd,
  values: () => zs
});
function Nn(e) {
  return e == null || e === "" ? null : e;
}
function q(e, t = !1) {
  return e != null && (e !== "" || t);
}
function Re(e) {
  return !q(e);
}
function Ni(e) {
  return e == null || e.length === 0;
}
function Dd(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function Yo(e) {
  if (e === void 0)
    return;
  if (e === null || e === "")
    return null;
  if (typeof e == "number")
    return isNaN(e) ? void 0 : e;
  const t = parseInt(e, 10);
  return isNaN(t) ? void 0 : t;
}
function rg(e) {
  if (e !== void 0)
    return e === null || e === "" ? !1 : typeof e == "boolean" ? e : /true/i.test(e);
}
function Dne(e) {
  if (!(e == null || e === ""))
    return e;
}
function Rb(e, t) {
  const r = e ? JSON.stringify(e) : null, i = t ? JSON.stringify(t) : null;
  return r === i;
}
function Tne(e, t, r = !1) {
  const i = e == null, n = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), i && n)
    return 0;
  if (i)
    return -1;
  if (n)
    return 1;
  function o(s, a) {
    return s > a ? 1 : s < a ? -1 : 0;
  }
  if (typeof e != "string" || !r)
    return o(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return o(e, t);
  }
}
function zs(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = [];
    return e.forEach((r) => t.push(r)), t;
  }
  return Object.values(e);
}
var Rne = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = Dd(e);
    let r = 0;
    for (; ; ) {
      let i;
      if (e ? (i = e, r !== 0 && (i += "_" + r)) : t ? (i = t, r !== 0 && (i += "_" + r)) : i = r, !this.existingKeys[i])
        return this.existingKeys[i] = !0, String(i);
      r++;
    }
  }
}, TF = {};
yr(TF, {
  SKIP_JS_BUILTINS: () => Rm,
  cloneObject: () => _S,
  deepCloneDefinition: () => ig,
  getAllValuesInObject: () => qo,
  getValueUsingField: () => ml,
  isNonNullObject: () => ng,
  iterateObject: () => Tr,
  mergeDeep: () => Zr,
  removeAllReferences: () => RF
});
var Rm = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function Tr(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r++)
        t(r.toString(), e[r]);
      return;
    }
    for (const [r, i] of Object.entries(e))
      t(r, i);
  }
}
function _S(e) {
  const t = {}, r = Object.keys(e);
  for (let i = 0; i < r.length; i++) {
    if (Rm.has(r[i]))
      continue;
    const n = r[i], o = e[n];
    t[n] = o;
  }
  return t;
}
function ig(e, t) {
  if (!e)
    return;
  const r = e, i = {};
  return Object.keys(r).forEach((n) => {
    if (t && t.indexOf(n) >= 0 || Rm.has(n))
      return;
    const o = r[n];
    ng(o) && o.constructor === Object ? i[n] = ig(o) : i[n] = o;
  }), i;
}
function qo(e) {
  if (!e)
    return [];
  const t = Object;
  if (typeof t.values == "function")
    return t.values(e);
  const r = [];
  for (const i in e)
    e.hasOwnProperty(i) && e.propertyIsEnumerable(i) && r.push(e[i]);
  return r;
}
function Zr(e, t, r = !0, i = !1) {
  q(t) && Tr(t, (n, o) => {
    if (Rm.has(n))
      return;
    let s = e[n];
    s !== o && (i && s == null && o != null && typeof o == "object" && o.constructor === Object && (s = {}, e[n] = s), ng(o) && ng(s) && !Array.isArray(s) ? Zr(s, o, r, i) : (r || o !== void 0) && (e[n] = o));
  });
}
function ml(e, t, r) {
  if (!t || !e)
    return;
  if (!r)
    return e[t];
  const i = t.split(".");
  let n = e;
  for (let o = 0; o < i.length; o++) {
    if (n == null)
      return;
    n = n[i[o]];
  }
  return n;
}
function RF(e, t = [], r) {
  Object.keys(e).forEach((s) => {
    typeof e[s] == "object" && !t.includes(s) && (e[s] = void 0);
  });
  const i = Object.getPrototypeOf(e), n = {}, o = (s) => `AG Grid: Grid API function ${s}() cannot be called as the grid has been destroyed.
    It is recommended to remove local references to the grid api. Alternatively, check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
    To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${r}`;
  Object.getOwnPropertyNames(i).forEach((s) => {
    if (typeof i[s] == "function" && !t.includes(s)) {
      const l = () => {
        console.warn(o(s));
      };
      n[s] = { value: l, writable: !0 };
    }
  }), Object.defineProperties(e, n);
}
function ng(e) {
  return typeof e == "object" && e !== null;
}
var PF = {};
yr(PF, {
  compose: () => Pne,
  debounce: () => kr,
  doOnce: () => Xl,
  errorOnce: () => ks,
  executeAfter: () => OF,
  executeInAWhile: () => IF,
  executeNextVMTurn: () => Pb,
  getFunctionName: () => Pm,
  isFunction: () => Im,
  noop: () => Ine,
  throttle: () => Ib,
  waitUntil: () => NS,
  warnOnce: () => we
});
var NT = {};
function Xl(e, t) {
  NT[t] || (e(), NT[t] = !0);
}
function we(e) {
  Xl(() => console.warn("AG Grid: " + e), e);
}
function ks(e) {
  Xl(() => console.error("AG Grid: " + e), e);
}
function Pm(e) {
  if (e.name)
    return e.name;
  const t = /function\s+([^\(]+)/.exec(e.toString());
  return t && t.length === 2 ? t[1].trim() : null;
}
function Im(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function IF(e) {
  OF(e, 400);
}
var aC = [], lC = !1;
function Pb(e) {
  aC.push(e), !lC && (lC = !0, window.setTimeout(() => {
    const t = aC.slice();
    aC.length = 0, lC = !1, t.forEach((r) => r());
  }, 0));
}
function OF(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((r) => r()), t);
}
function kr(e, t) {
  let r;
  return function(...i) {
    const n = this;
    window.clearTimeout(r), r = window.setTimeout(function() {
      e.apply(n, i);
    }, t);
  };
}
function Ib(e, t) {
  let r = 0;
  return function(...i) {
    const n = this, o = (/* @__PURE__ */ new Date()).getTime();
    o - r < t || (r = o, e.apply(n, i));
  };
}
function NS(e, t, r = 100, i) {
  const n = (/* @__PURE__ */ new Date()).getTime();
  let o = null, s = !1;
  const a = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - n > r;
    (e() || l) && (t(), s = !0, o != null && (window.clearInterval(o), o = null), l && i && console.warn(i));
  };
  a(), s || (o = window.setInterval(a, 10));
}
function Pne(...e) {
  return (t) => e.reduce((r, i) => i(r), t);
}
var Ine = () => {
}, MF = /* @__PURE__ */ ((e) => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(MF || {}), Om = class et {
  /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */
  static register(t) {
    et.__register(t, !0, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(t) {
    et.__registerModules(t, !0, void 0);
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __register(t, r, i) {
    et.runVersionChecks(t), i !== void 0 ? (et.areGridScopedModules = !0, et.gridModulesMap[i] === void 0 && (et.gridModulesMap[i] = {}), et.gridModulesMap[i][t.moduleName] = t) : et.globalModulesMap[t.moduleName] = t, et.setModuleBased(r);
  }
  /** AG GRID INTERNAL - Unregister grid scoped module. */
  static __unRegisterGridModules(t) {
    delete et.gridModulesMap[t];
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __registerModules(t, r, i) {
    et.setModuleBased(r), t && t.forEach((n) => et.__register(n, r, i));
  }
  static isValidModuleVersion(t) {
    const [r, i] = t.version.split(".") || [], [n, o] = et.currentModuleVersion.split(".") || [];
    return r === n && i === o;
  }
  static runVersionChecks(t) {
    if (et.currentModuleVersion || (et.currentModuleVersion = t.version), t.version ? et.isValidModuleVersion(t) || console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${t.moduleName}' is version ${t.version} but the other modules are version ${this.currentModuleVersion}. Please update all modules to the same version.`) : console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${t.moduleName}' is incompatible. Please update all modules to the same version.`), t.validate) {
      const r = t.validate();
      r.isValid || console.error(`AG Grid: ${r.message}`);
    }
  }
  static setModuleBased(t) {
    et.moduleBased === void 0 ? et.moduleBased = t : et.moduleBased !== t && Xl(
      () => {
        console.warn("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), console.warn("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information.");
      },
      "ModulePackageCheck"
    );
  }
  /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */
  static __setIsBundled() {
    et.isBundled = !0;
  }
  /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
  static __assertRegistered(t, r, i) {
    var n;
    if (this.__isRegistered(t, i))
      return !0;
    const o = r + t;
    let s;
    if (et.isBundled)
      s = `AG Grid: unable to use ${r} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (et.moduleBased || et.moduleBased === void 0) {
      let a = (n = Object.entries(MF).find(([l, u]) => u === t)) == null ? void 0 : n[0];
      s = `AG Grid: unable to use ${r} as the ${a} is not registered${et.areGridScopedModules ? ` for gridId: ${i}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${a} } from '${t}';
    
    ModuleRegistry.registerModules([ ${a} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else
      s = `AG Grid: unable to use ${r} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
    return Xl(() => {
      console.warn(s);
    }, o), !1;
  }
  /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
  static __isRegistered(t, r) {
    var i;
    return !!et.globalModulesMap[t] || !!((i = et.gridModulesMap[r]) != null && i[t]);
  }
  /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
  static __getRegisteredModules(t) {
    return [...zs(et.globalModulesMap), ...zs(et.gridModulesMap[t] || {})];
  }
  /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
  static __getGridRegisteredModules(t) {
    var r;
    return zs((r = et.gridModulesMap[t]) != null ? r : {}) || [];
  }
  /** INTERNAL */
  static __isPackageBased() {
    return !et.moduleBased;
  }
};
Om.globalModulesMap = {};
Om.gridModulesMap = {};
Om.areGridScopedModules = !1;
var Xe = Om, One = class {
  constructor(e, t) {
    if (this.beanWrappers = {}, this.destroyed = !1, !e || !e.beanClasses)
      return;
    this.contextParams = e, this.logger = t, this.logger.log(">> creating ag-Application Context"), this.createBeans();
    const r = this.getBeanInstances();
    this.wireBeans(r), this.logger.log(">> ag-Application Context ready - component is alive");
  }
  getBeanInstances() {
    return zs(this.beanWrappers).map((e) => e.beanInstance);
  }
  createBean(e, t) {
    if (!e)
      throw Error("Can't wire to bean since it is null");
    return this.wireBeans([e], t), e;
  }
  wireBeans(e, t) {
    this.autoWireBeans(e), this.methodWireBeans(e), this.callLifeCycleMethods(e, "preConstructMethods"), q(t) && e.forEach(t), this.callLifeCycleMethods(e, "postConstructMethods");
  }
  createBeans() {
    this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this)), Tr(this.beanWrappers, (t, r) => {
      let i;
      r.bean.__agBeanMetaData && r.bean.__agBeanMetaData.autowireMethods && r.bean.__agBeanMetaData.autowireMethods.agConstructor && (i = r.bean.__agBeanMetaData.autowireMethods.agConstructor);
      const n = this.getBeansForParameters(i, r.bean.name), o = new (r.bean.bind.apply(r.bean, [null, ...n]))();
      r.beanInstance = o;
    });
    const e = Object.keys(this.beanWrappers).join(", ");
    this.logger.log(`created beans: ${e}`);
  }
  // tslint:disable-next-line
  createBeanWrapper(e) {
    const t = e.__agBeanMetaData;
    if (!t) {
      let i;
      e.prototype.constructor ? i = Pm(e.prototype.constructor) : i = "" + e, console.error(`Context item ${i} is not a bean`);
      return;
    }
    const r = {
      bean: e,
      beanInstance: null,
      beanName: t.beanName
    };
    this.beanWrappers[t.beanName] = r;
  }
  autoWireBeans(e) {
    e.forEach((t) => {
      this.forEachMetaDataInHierarchy(t, (r, i) => {
        const n = r.agClassAttributes;
        n && n.forEach((o) => {
          const s = this.lookupBeanInstance(i, o.beanName, o.optional);
          t[o.attributeName] = s;
        });
      });
    });
  }
  methodWireBeans(e) {
    e.forEach((t) => {
      this.forEachMetaDataInHierarchy(t, (r, i) => {
        Tr(r.autowireMethods, (n, o) => {
          if (n === "agConstructor")
            return;
          const s = this.getBeansForParameters(o, i);
          t[n].apply(t, s);
        });
      });
    });
  }
  forEachMetaDataInHierarchy(e, t) {
    let r = Object.getPrototypeOf(e);
    for (; r != null; ) {
      const i = r.constructor;
      if (i.hasOwnProperty("__agBeanMetaData")) {
        const n = i.__agBeanMetaData, o = this.getBeanName(i);
        t(n, o);
      }
      r = Object.getPrototypeOf(r);
    }
  }
  getBeanName(e) {
    if (e.__agBeanMetaData && e.__agBeanMetaData.beanName)
      return e.__agBeanMetaData.beanName;
    const t = e.toString();
    return t.substring(9, t.indexOf("("));
  }
  getBeansForParameters(e, t) {
    const r = [];
    return e && Tr(e, (i, n) => {
      const o = this.lookupBeanInstance(t, n);
      r[Number(i)] = o;
    }), r;
  }
  lookupBeanInstance(e, t, r = !1) {
    if (this.destroyed)
      return this.logger.log(`AG Grid: bean reference ${t} is used after the grid is destroyed!`), null;
    if (t === "context")
      return this;
    if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(t))
      return this.contextParams.providedBeanInstances[t];
    const i = this.beanWrappers[t];
    return i ? i.beanInstance : (r || console.error(`AG Grid: unable to find bean reference ${t} while initialising ${e}`), null);
  }
  callLifeCycleMethods(e, t) {
    e.forEach((r) => this.callLifeCycleMethodsOnBean(r, t));
  }
  callLifeCycleMethodsOnBean(e, t, r) {
    const i = {};
    this.forEachMetaDataInHierarchy(e, (o) => {
      const s = o[t];
      s && s.forEach((a) => {
        a != r && (i[a] = !0);
      });
    }), Object.keys(i).forEach((o) => e[o]());
  }
  getBean(e) {
    return this.lookupBeanInstance("getBean", e, !0);
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0, this.logger.log(">> Shutting down ag-Application Context");
    const e = this.getBeanInstances();
    this.destroyBeans(e), this.contextParams.providedBeanInstances = null, Xe.__unRegisterGridModules(this.contextParams.gridId), this.logger.log(">> ag-Application Context shut down - component is dead");
  }
  destroyBean(e) {
    e && this.destroyBeans([e]);
  }
  destroyBeans(e) {
    return e ? (e.forEach((t) => {
      this.callLifeCycleMethodsOnBean(t, "preDestroyMethods", "destroy");
      const r = t;
      typeof r.destroy == "function" && r.destroy();
    }), []) : [];
  }
  isDestroyed() {
    return this.destroyed;
  }
  getGridId() {
    return this.contextParams.gridId;
  }
};
function FF(e, t, r) {
  const i = la(e.constructor);
  i.preConstructMethods || (i.preConstructMethods = []), i.preConstructMethods.push(t);
}
function te(e, t, r) {
  const i = la(e.constructor);
  i.postConstructMethods || (i.postConstructMethods = []), i.postConstructMethods.push(t);
}
function jr(e, t, r) {
  const i = la(e.constructor);
  i.preDestroyMethods || (i.preDestroyMethods = []), i.preDestroyMethods.push(t);
}
function de(e) {
  return (t) => {
    const r = la(t);
    r.beanName = e;
  };
}
function T(e) {
  return (t, r, i) => {
    _F(t, e, !1, t, r);
  };
}
function Qe(e) {
  return (t, r, i) => {
    _F(t, e, !0, t, r);
  };
}
function _F(e, t, r, i, n, o) {
  if (t === null) {
    console.error("AG Grid: Autowired name should not be null");
    return;
  }
  const s = la(e.constructor);
  s.agClassAttributes || (s.agClassAttributes = []), s.agClassAttributes.push({
    attributeName: n,
    beanName: t,
    optional: r
  });
}
function Gi(e) {
  return (t, r, i) => {
    const n = typeof t == "function" ? t : t.constructor;
    let o;
    if (typeof i == "number") {
      let s;
      r ? (o = la(n), s = r) : (o = la(n), s = "agConstructor"), o.autowireMethods || (o.autowireMethods = {}), o.autowireMethods[s] || (o.autowireMethods[s] = {}), o.autowireMethods[s][i] = e;
    }
  };
}
function la(e) {
  return e.hasOwnProperty("__agBeanMetaData") || (e.__agBeanMetaData = {}), e.__agBeanMetaData;
}
var fn = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  // because this class is used both inside the context and outside the context, we do not
  // use autowired attributes, as that would be confusing, as sometimes the attributes
  // would be wired, and sometimes not.
  //
  // the global event servers used by AG Grid is autowired by the context once, and this
  // setBeans method gets called once.
  //
  // the times when this class is used outside of the context (eg RowNode has an instance of this
  // class) then it is not a bean, and this setBeans method is not called.
  setBeans(e, t, r = null, i = null) {
    if (this.frameworkOverrides = t, this.gos = e, r) {
      const n = e.useAsyncEvents();
      this.addGlobalListener(r, n);
    }
    i && this.addGlobalListener(i, !1);
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, r) {
    const i = t ? this.allAsyncListeners : this.allSyncListeners;
    let n = i.get(e);
    return !n && r && (n = /* @__PURE__ */ new Set(), i.set(e, n)), n;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, r = !1) {
    this.getListeners(e, r, !0).add(t);
  }
  removeEventListener(e, t, r = !1) {
    const i = this.getListeners(e, r, !1);
    i && (i.delete(t), i.size === 0 && (r ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    let t = e;
    this.gos && this.gos.addGridCommonParams(t), this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    var r;
    const i = e.type;
    if (t && "event" in e) {
      const l = e.event;
      l instanceof Event && (e.eventPath = l.composedPath());
    }
    const n = (l, u) => l.forEach((c) => {
      if (!u.has(c))
        return;
      const d = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => c(e)) : () => c(e);
      t ? this.dispatchAsync(d) : d();
    }), o = (r = this.getListeners(i, t, !1)) != null ? r : /* @__PURE__ */ new Set(), s = new Set(o);
    s.size > 0 && n(s, o), new Set(t ? this.globalAsyncListeners : this.globalSyncListeners).forEach((l) => {
      const u = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => l(i, e)) : () => l(i, e);
      t ? this.dispatchAsync(u) : u();
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    this.asyncFunctionsQueue.push(e), this.scheduled || (this.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(this.flushAsyncQueue.bind(this), 0);
    }), this.scheduled = !0);
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
v([
  an(0, Gi("gridOptionsService")),
  an(1, Gi("frameworkOverrides")),
  an(2, Gi("globalEventListener")),
  an(3, Gi("globalSyncEventListener"))
], fn.prototype, "setBeans", 1);
fn = v([
  de("eventService")
], fn);
var LS = class {
  constructor(e) {
    this.frameworkOverrides = e, this.wrappedListeners = /* @__PURE__ */ new Map(), this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
  }
  wrap(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r));
    }, this.wrappedListeners.set(e, t)), t;
  }
  wrapGlobal(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r, i) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r, i));
    }, this.wrappedGlobalListeners.set(e, t)), t;
  }
  unwrap(e) {
    var t;
    return (t = this.wrappedListeners.get(e)) != null ? t : e;
  }
  unwrapGlobal(e) {
    var t;
    return (t = this.wrappedGlobalListeners.get(e)) != null ? t : e;
  }
}, Mne = {
  resizable: !0,
  sortable: !0
}, Fne = 0;
function NF() {
  return Fne++;
}
var Jt = class LF {
  constructor(t, r, i, n) {
    this.instanceId = NF(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.eventService = new fn(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = t, this.userProvidedColDef = r, this.colId = i, this.primary = n, this.setState(t);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(t) {
    t.sort !== void 0 ? (t.sort === "asc" || t.sort === "desc") && (this.sort = t.sort) : (t.initialSort === "asc" || t.initialSort === "desc") && (this.sort = t.initialSort);
    const r = t.sortIndex, i = t.initialSortIndex;
    r !== void 0 ? r !== null && (this.sortIndex = r) : i !== null && (this.sortIndex = i);
    const n = t.hide, o = t.initialHide;
    n !== void 0 ? this.visible = !n : this.visible = !o, t.pinned !== void 0 ? this.setPinned(t.pinned) : this.setPinned(t.initialPinned);
    const s = t.flex, a = t.initialFlex;
    s !== void 0 ? this.flex = s : a !== void 0 && (this.flex = a);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(t, r, i) {
    this.colDef = t, this.userProvidedColDef = r, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.eventService.dispatchEvent(this.createColumnEvent("colDefChanged", i));
  }
  /**
   * Returns the column definition provided by the application.
   * This may not be correct, as items can be superseded by default column options.
   * However it's useful for comparison, eg to know which application column definition matches that column.
   */
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(t) {
    this.parent = t;
  }
  /** Returns the parent column group, if column grouping is active. */
  getParent() {
    return this.parent;
  }
  setOriginalParent(t) {
    this.originalParent = t;
  }
  /**
   * Used for marryChildren, helps with comparing when duplicate groups have been created to manage split groups.
   * 
   * Parent may contain a duplicate but not identical group when the group is split.
   */
  getOriginalParent() {
    return this.originalParent;
  }
  initialise() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const t = this.gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = q(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !t, this.tooltipFieldContainsDots = q(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !t;
  }
  initMinAndMaxWidths() {
    var t, r;
    const i = this.colDef;
    this.minWidth = (t = i.minWidth) != null ? t : this.environment.getMinColWidth(), this.maxWidth = (r = i.maxWidth) != null ? r : Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.tooltipEnabled = q(this.colDef.tooltipField) || q(this.colDef.tooltipValueGetter) || q(this.colDef.tooltipComponent);
  }
  resetActualWidth(t) {
    const r = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(r, t, !0);
  }
  calculateColInitialWidth(t) {
    var r, i;
    const n = (r = t.minWidth) != null ? r : this.environment.getMinColWidth(), o = (i = t.maxWidth) != null ? i : Number.MAX_SAFE_INTEGER;
    let s;
    const a = Yo(t.width), l = Yo(t.initialWidth);
    return a != null ? s = a : l != null ? s = l : s = 200, Math.max(Math.min(s, o), n);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(t) {
    if (Re(this.colDef) || Re(this.colDef.showRowGroup))
      return !1;
    const r = this.colDef.showRowGroup === !0, i = this.colDef.showRowGroup === t;
    return r || i;
  }
  /** Returns `true` if column is a primary column, `false` if secondary. Secondary columns are used for pivoting. */
  isPrimary() {
    return this.primary;
  }
  /** Returns `true` if column filtering is allowed. */
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  /** Add an event listener to the column. */
  addEventListener(t, r) {
    var i, n;
    this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.eventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new LS(this.frameworkOverrides));
    const o = (n = (i = this.frameworkEventListenerService) == null ? void 0 : i.wrap(r)) != null ? n : r;
    this.eventService.addEventListener(t, o);
  }
  /** Remove event listener from the column. */
  removeEventListener(t, r) {
    var i, n;
    const o = (n = (i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(r)) != null ? n : r;
    this.eventService.removeEventListener(t, o);
  }
  createColumnFunctionCallbackParams(t) {
    return this.gos.addGridCommonParams({
      node: t,
      data: t.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(t) {
    if (typeof this.colDef.suppressNavigable == "boolean")
      return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const r = this.createColumnFunctionCallbackParams(t), i = this.colDef.suppressNavigable;
      return i(r);
    }
    return !1;
  }
  /**
   * Returns `true` if the cell for this column is editable for the given `rowNode`, otherwise `false`.
   */
  isCellEditable(t) {
    return t.group && !this.gos.get("enableGroupEdit") ? !1 : this.isColumnFunc(t, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(t) {
    return this.isColumnFunc(t, this.colDef.rowDrag);
  }
  isDndSource(t) {
    return this.isColumnFunc(t, this.colDef.dndSource);
  }
  isCellCheckboxSelection(t) {
    return this.isColumnFunc(t, this.colDef.checkboxSelection);
  }
  isSuppressPaste(t) {
    return this.isColumnFunc(t, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(t) {
    var r;
    return (r = this.colDef[t]) != null ? r : Mne[t];
  }
  isColumnFunc(t, r) {
    if (typeof r == "boolean")
      return r;
    if (typeof r == "function") {
      const i = this.createColumnFunctionCallbackParams(t);
      return r(i);
    }
    return !1;
  }
  setMoving(t, r) {
    this.moving = t, this.eventService.dispatchEvent(this.createColumnEvent("movingChanged", r));
  }
  createColumnEvent(t, r) {
    return this.gos.addGridCommonParams({
      type: t,
      column: this,
      columns: [this],
      source: r
    });
  }
  isMoving() {
    return this.moving;
  }
  /** If sorting is active, returns the sort direction e.g. `'asc'` or `'desc'`. */
  getSort() {
    return this.sort;
  }
  setSort(t, r) {
    this.sort !== t && (this.sort = t, this.eventService.dispatchEvent(this.createColumnEvent("sortChanged", r))), this.dispatchStateUpdatedEvent("sort");
  }
  setMenuVisible(t, r) {
    this.menuVisible !== t && (this.menuVisible = t, this.eventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", r)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  isSortAscending() {
    return this.sort === "asc";
  }
  isSortDescending() {
    return this.sort === "desc";
  }
  isSortNone() {
    return Re(this.sort);
  }
  isSorting() {
    return q(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(t) {
    this.sortIndex = t, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setAggFunc(t) {
    this.aggFunc = t, this.dispatchStateUpdatedEvent("aggFunc");
  }
  /** If aggregation is set for the column, returns the aggregation function. */
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(t, r) {
    this.oldLeft = this.left, this.left !== t && (this.left = t, this.eventService.dispatchEvent(this.createColumnEvent("leftChanged", r)));
  }
  /** Returns `true` if filter is active on the column. */
  isFilterActive() {
    return this.filterActive;
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setFilterActive(t, r, i) {
    this.filterActive !== t && (this.filterActive = t, this.eventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", r)));
    const n = this.createColumnEvent("filterChanged", r);
    i && Zr(n, i), this.eventService.dispatchEvent(n);
  }
  /** Returns `true` when this `Column` is hovered, otherwise `false` */
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(t) {
    t === !0 || t === "left" ? this.pinned = "left" : t === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(t, r) {
    this.firstRightPinned !== t && (this.firstRightPinned = t, this.eventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", r)));
  }
  setLastLeftPinned(t, r) {
    this.lastLeftPinned !== t && (this.lastLeftPinned = t, this.eventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", r)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(t, r) {
    const i = t === !0;
    this.visible !== i && (this.visible = i, this.eventService.dispatchEvent(this.createColumnEvent("visibleChanged", r))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const t = this.getColDef();
    return !t.suppressSpanHeaderHeight && !t.autoHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let t = this.getParent();
    if (!t || !t.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const r = t.getPaddingLevel() + 1;
    let i = !0;
    for (; t; ) {
      if (!t.isPadding()) {
        i = !1;
        break;
      }
      t = t.getParent();
    }
    return { numberOfParents: r, isSpanningTotal: i };
  }
  /** Returns the column definition for this column.
   * The column definition will be the result of merging the application provided column definition with any provided defaults
   * (e.g. `defaultColDef` grid option, or column types.
   *
   * Equivalent: `getDefinition` */
  getColDef() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getId`, `getUniqueId` */
  getColId() {
    return this.colId;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getColId`, `getUniqueId` */
  getId() {
    return this.colId;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getColId`, `getId` */
  getUniqueId() {
    return this.colId;
  }
  getDefinition() {
    return this.colDef;
  }
  /** Returns the current width of the column. If the column is resized, the actual width is the new size. */
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(t) {
    const r = t !== this.autoHeaderHeight;
    return this.autoHeaderHeight = t, r;
  }
  createBaseColDefParams(t) {
    return this.gos.addGridCommonParams({
      node: t,
      data: t.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(t) {
    if (Re(this.colDef.colSpan))
      return 1;
    const r = this.createBaseColDefParams(t), i = this.colDef.colSpan(r);
    return Math.max(i, 1);
  }
  getRowSpan(t) {
    if (Re(this.colDef.rowSpan))
      return 1;
    const r = this.createBaseColDefParams(t), i = this.colDef.rowSpan(r);
    return Math.max(i, 1);
  }
  setActualWidth(t, r, i = !1) {
    this.minWidth != null && (t = Math.max(t, this.minWidth)), this.maxWidth != null && (t = Math.min(t, this.maxWidth)), this.actualWidth !== t && (this.actualWidth = t, this.flex && r !== "flex" && r !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(r)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(t) {
    this.eventService.dispatchEvent(this.createColumnEvent("widthChanged", t));
  }
  isGreaterThanMax(t) {
    return this.maxWidth != null ? t > this.maxWidth : !1;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  // this method should only be used by the columnModel to
  // change flex when required by the applyColumnState method.
  setFlex(t) {
    this.flex !== t && (this.flex = t), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(t) {
    q(this.minWidth) && this.setActualWidth(this.minWidth, t);
  }
  setRowGroupActive(t, r) {
    this.rowGroupActive !== t && (this.rowGroupActive = t, this.eventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", r))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  /** Returns `true` if row group is currently active for this column. */
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(t, r) {
    this.pivotActive !== t && (this.pivotActive = t, this.eventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", r))), this.dispatchStateUpdatedEvent("pivot");
  }
  /** Returns `true` if pivot is currently active for this column. */
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(t, r) {
    this.aggregationActive !== t && (this.aggregationActive = t, this.eventService.dispatchEvent(this.createColumnEvent("columnValueChanged", r)));
  }
  /** Returns `true` if value (aggregation) is currently active for this column. */
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  /**
   * @deprecated v31.1 Use `getColDef().menuTabs ?? defaultValues` instead.
   */
  getMenuTabs(t) {
    we("As of v31.1, 'getMenuTabs' is deprecated. Use 'getColDef().menuTabs ?? defaultValues' instead.");
    let r = this.getColDef().menuTabs;
    return r == null && (r = t), r;
  }
  dispatchStateUpdatedEvent(t) {
    this.eventService.dispatchEvent({
      type: LF.EVENT_STATE_UPDATED,
      key: t
    });
  }
};
Jt.EVENT_MOVING_CHANGED = "movingChanged";
Jt.EVENT_LEFT_CHANGED = "leftChanged";
Jt.EVENT_WIDTH_CHANGED = "widthChanged";
Jt.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged";
Jt.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged";
Jt.EVENT_VISIBLE_CHANGED = "visibleChanged";
Jt.EVENT_FILTER_CHANGED = "filterChanged";
Jt.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged";
Jt.EVENT_SORT_CHANGED = "sortChanged";
Jt.EVENT_COL_DEF_CHANGED = "colDefChanged";
Jt.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged";
Jt.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged";
Jt.EVENT_PIVOT_CHANGED = "columnPivotChanged";
Jt.EVENT_VALUE_CHANGED = "columnValueChanged";
Jt.EVENT_STATE_UPDATED = "columnStateUpdated";
v([
  T("gridOptionsService")
], Jt.prototype, "gos", 2);
v([
  T("environment")
], Jt.prototype, "environment", 2);
v([
  T("columnHoverService")
], Jt.prototype, "columnHoverService", 2);
v([
  T("frameworkOverrides")
], Jt.prototype, "frameworkOverrides", 2);
v([
  te
], Jt.prototype, "initialise", 1);
var ct = Jt, Mm = class xc {
  constructor(t, r, i, n) {
    this.localEventService = new fn(), this.expandable = !1, this.instanceId = NF(), this.expandableListenerRemoveCallback = null, this.colGroupDef = t, this.groupId = r, this.expanded = !!t && !!t.openByDefault, this.padding = i, this.level = n;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0);
  }
  reset(t, r) {
    this.colGroupDef = t, this.level = r, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(t) {
    this.originalParent = t;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((t) => t.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(t) {
    this.expanded = t === void 0 ? !1 : t;
    const r = {
      type: xc.EVENT_EXPANDED_CHANGED
    };
    this.localEventService.dispatchEvent(r);
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(t) {
    this.children = t;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const t = [];
    return this.addLeafColumns(t), t;
  }
  addLeafColumns(t) {
    this.children && this.children.forEach((r) => {
      r instanceof ct ? t.push(r) : r instanceof xc && r.addLeafColumns(t);
    });
  }
  getColumnGroupShow() {
    const t = this.colGroupDef;
    if (t)
      return t.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const t = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((r) => r.addEventListener("visibleChanged", t)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((r) => r.removeEventListener("visibleChanged", t)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let t = !1, r = !1, i = !1;
    const n = this.findChildrenRemovingPadding();
    for (let s = 0, a = n.length; s < a; s++) {
      const l = n[s];
      if (!l.isVisible())
        continue;
      const u = l.getColumnGroupShow();
      u === "open" ? (t = !0, i = !0) : u === "closed" ? (r = !0, i = !0) : (t = !0, r = !0);
    }
    const o = t && r && i;
    if (this.expandable !== o) {
      this.expandable = o;
      const s = {
        type: xc.EVENT_EXPANDABLE_CHANGED
      };
      this.localEventService.dispatchEvent(s);
    }
  }
  findChildrenRemovingPadding() {
    const t = [], r = (i) => {
      i.forEach((n) => {
        n instanceof xc && n.isPadding() ? r(n.children) : t.push(n);
      });
    };
    return r(this.children), t;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
  addEventListener(t, r) {
    this.localEventService.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    this.localEventService.removeEventListener(t, r);
  }
};
Mm.EVENT_EXPANDED_CHANGED = "expandedChanged";
Mm.EVENT_EXPANDABLE_CHANGED = "expandableChanged";
v([
  jr
], Mm.prototype, "destroy", 1);
var Ut = Mm, _ne = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
}, GF = {};
yr(GF, {
  addSafePassiveEventListener: () => YF,
  createEventPath: () => zF,
  getCtrlForEventTarget: () => og,
  getEventPath: () => UF,
  isElementInEventPath: () => sg,
  isEventSupported: () => kS,
  isStopPropagationForAgGrid: () => hn,
  stopPropagationForAgGrid: () => gn
});
var kF = {};
yr(kF, {
  areEqual: () => On,
  existsAndNotEmpty: () => VF,
  flatten: () => $F,
  forEachReverse: () => kne,
  includes: () => yi,
  insertArrayIntoArray: () => Ob,
  insertIntoArray: () => Td,
  last: () => ze,
  moveInArray: () => Mb,
  pushAll: () => Fb,
  removeAllFromArray: () => WF,
  removeAllFromUnorderedArray: () => BF,
  removeFromArray: () => Xr,
  removeFromUnorderedArray: () => GS,
  removeRepeatsFromArray: () => Lne,
  shallowCompare: () => Nne,
  sortNumerically: () => HF,
  toStrings: () => Gne
});
function VF(e) {
  return e != null && e.length > 0;
}
function ze(e) {
  if (!(!e || !e.length))
    return e[e.length - 1];
}
function On(e, t, r) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((i, n) => r ? r(i, t[n]) : t[n] === i);
}
function Nne(e, t) {
  return On(e, t);
}
function HF(e) {
  return e.sort((t, r) => t - r);
}
function Lne(e, t) {
  if (e)
    for (let r = e.length - 2; r >= 0; r--) {
      const i = e[r] === t, n = e[r + 1] === t;
      i && n && e.splice(r + 1, 1);
    }
}
function GS(e, t) {
  const r = e.indexOf(t);
  r >= 0 && (e[r] = e[e.length - 1], e.pop());
}
function Xr(e, t) {
  const r = e.indexOf(t);
  r >= 0 && e.splice(r, 1);
}
function BF(e, t) {
  for (let r = 0; r < t.length; r++)
    GS(e, t[r]);
}
function WF(e, t) {
  for (let r = 0; r < t.length; r++)
    Xr(e, t[r]);
}
function Td(e, t, r) {
  e.splice(r, 0, t);
}
function Ob(e, t, r) {
  if (!(e == null || t == null))
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      Td(e, n, r);
    }
}
function Mb(e, t, r) {
  WF(e, t), t.slice().reverse().forEach((i) => Td(e, i, r));
}
function yi(e, t) {
  return e.indexOf(t) > -1;
}
function $F(e) {
  return [].concat.apply([], e);
}
function Fb(e, t) {
  t == null || e == null || t.forEach((r) => e.push(r));
}
function Gne(e) {
  return e.map(Dd);
}
function kne(e, t) {
  if (e != null)
    for (let r = e.length - 1; r >= 0; r--)
      t(e[r], r);
}
var jF = "__ag_Grid_Stop_Propagation", Vne = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], uC = {};
function gn(e) {
  e[jF] = !0;
}
function hn(e) {
  return e[jF] === !0;
}
var kS = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (r) => {
    if (typeof uC[r] == "boolean")
      return uC[r];
    const i = document.createElement(e[r] || "div");
    return r = "on" + r, uC[r] = r in i;
  };
})();
function og(e, t, r) {
  let i = t;
  for (; i; ) {
    const n = e.getDomData(i, r);
    if (n)
      return n;
    i = i.parentElement;
  }
  return null;
}
function sg(e, t) {
  return !t || !e ? !1 : UF(t).indexOf(e) >= 0;
}
function zF(e) {
  const t = [];
  let r = e.target;
  for (; r; )
    t.push(r), r = r.parentElement;
  return t;
}
function UF(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : zF(t);
}
function YF(e, t, r, i) {
  const o = yi(Vne, r) ? { passive: !0 } : void 0;
  e && e.addEventListener && e.addEventListener(t, r, i, o);
}
var Io = class XF {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.lastChangeSetIdLookup = {}, this.propertyListenerId = 0, this.isAlive = () => !this.destroyed;
  }
  // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  getContext() {
    return this.context;
  }
  destroy() {
    for (let t = 0; t < this.destroyFunctions.length; t++)
      this.destroyFunctions[t]();
    this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchEvent({ type: XF.EVENT_DESTROYED });
  }
  addEventListener(t, r) {
    this.localEventService || (this.localEventService = new fn()), this.localEventService.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    this.localEventService && this.localEventService.removeEventListener(t, r);
  }
  dispatchEvent(t) {
    this.localEventService && this.localEventService.dispatchEvent(t);
  }
  addManagedListener(t, r, i) {
    if (this.destroyed)
      return;
    t instanceof HTMLElement ? YF(this.getFrameworkOverrides(), t, r, i) : t.addEventListener(r, i);
    const n = () => (t.removeEventListener(r, i), null);
    return this.destroyFunctions.push(n), () => (n(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== n), null);
  }
  setupGridOptionListener(t, r) {
    this.gos.addEventListener(t, r);
    const i = () => (this.gos.removeEventListener(t, r), null);
    return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((n) => n !== i), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(t, r) {
    return this.destroyed ? () => null : this.setupGridOptionListener(t, r);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(t, r) {
    if (this.destroyed)
      return;
    const i = t.join("-") + this.propertyListenerId++, n = (o) => {
      if (o.changeSet) {
        if (o.changeSet && o.changeSet.id === this.lastChangeSetIdLookup[i])
          return;
        this.lastChangeSetIdLookup[i] = o.changeSet.id;
      }
      const s = {
        type: "gridPropertyChanged",
        changeSet: o.changeSet,
        source: o.source
      };
      r(s);
    };
    t.forEach((o) => this.setupGridOptionListener(o, n));
  }
  addDestroyFunc(t) {
    this.isAlive() ? this.destroyFunctions.push(t) : t();
  }
  createManagedBean(t, r) {
    const i = this.createBean(t, r);
    return this.addDestroyFunc(this.destroyBean.bind(this, t, r)), i;
  }
  createBean(t, r, i) {
    return (r || this.getContext()).createBean(t, i);
  }
  destroyBean(t, r) {
    return (r || this.getContext()).destroyBean(t);
  }
  destroyBeans(t, r) {
    if (t)
      for (let i = 0; i < t.length; i++)
        this.destroyBean(t[i], r);
    return [];
  }
};
Io.EVENT_DESTROYED = "destroyed";
v([
  T("frameworkOverrides")
], Io.prototype, "frameworkOverrides", 2);
v([
  T("context")
], Io.prototype, "context", 2);
v([
  T("eventService")
], Io.prototype, "eventService", 2);
v([
  T("gridOptionsService")
], Io.prototype, "gos", 2);
v([
  T("localeService")
], Io.prototype, "localeService", 2);
v([
  T("environment")
], Io.prototype, "environment", 2);
v([
  jr
], Io.prototype, "destroy", 1);
var Q = Io, Rd = class extends Q {
  setBeans(e) {
    this.logger = e.create("ColumnFactory");
  }
  createColumnTree(e, t, r, i) {
    const n = new Rne(), { existingCols: o, existingGroups: s, existingColKeys: a } = this.extractExistingTreeData(r);
    n.addExistingKeys(a);
    const l = this.recursivelyCreateColumns(
      e,
      0,
      t,
      o,
      n,
      s,
      i
    ), u = this.findMaxDept(l, 0);
    this.logger.log("Number of levels for grouped columns is " + u);
    const c = this.balanceColumnTree(l, 0, u, n);
    return io(null, c, (h, p) => {
      h instanceof Ut && h.setupExpandable(), h.setOriginalParent(p);
    }), {
      columnTree: c,
      treeDept: u
    };
  }
  extractExistingTreeData(e) {
    const t = [], r = [], i = [];
    return e && io(null, e, (n) => {
      if (n instanceof Ut) {
        const o = n;
        r.push(o);
      } else {
        const o = n;
        i.push(o.getId()), t.push(o);
      }
    }), { existingCols: t, existingGroups: r, existingColKeys: i };
  }
  createForAutoGroups(e, t) {
    return e.map((r) => this.createAutoGroupTreeItem(t, r));
  }
  createAutoGroupTreeItem(e, t) {
    const r = this.findDepth(e);
    let i = t;
    for (let n = r - 1; n >= 0; n--) {
      const o = new Ut(
        null,
        `FAKE_PATH_${t.getId()}}_${n}`,
        !0,
        n
      );
      this.createBean(o), o.setChildren([i]), i.setOriginalParent(o), i = o;
    }
    return r === 0 && t.setOriginalParent(null), i;
  }
  findDepth(e) {
    let t = 0, r = e;
    for (; r && r[0] && r[0] instanceof Ut; )
      t++, r = r[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, r, i) {
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const s = e[o];
      if (s instanceof Ut) {
        const a = s, l = this.balanceColumnTree(
          a.getChildren(),
          t + 1,
          r,
          i
        );
        a.setChildren(l), n.push(a);
      } else {
        let a, l;
        for (let u = r - 1; u >= t; u--) {
          const c = i.getUniqueKey(null, null), d = this.createMergedColGroupDef(null), h = new Ut(d, c, !0, t);
          this.createBean(h), l && l.setChildren([h]), l = h, a || (a = l);
        }
        if (a && l)
          if (n.push(a), e.some((c) => c instanceof Ut)) {
            l.setChildren([s]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        n.push(s);
      }
    }
    return n;
  }
  findMaxDept(e, t) {
    let r = t;
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      if (n instanceof Ut) {
        const o = n, s = this.findMaxDept(o.getChildren(), t + 1);
        r < s && (r = s);
      }
    }
    return r;
  }
  recursivelyCreateColumns(e, t, r, i, n, o, s) {
    if (!e)
      return [];
    const a = new Array(e.length);
    for (let l = 0; l < a.length; l++) {
      const u = e[l];
      this.isColumnGroup(u) ? a[l] = this.createColumnGroup(
        r,
        u,
        t,
        i,
        n,
        o,
        s
      ) : a[l] = this.createColumn(r, u, i, n, s);
    }
    return a;
  }
  createColumnGroup(e, t, r, i, n, o, s) {
    const a = this.createMergedColGroupDef(t), l = n.getUniqueKey(a.groupId || null, null), u = new Ut(a, l, !1, r);
    this.createBean(u);
    const c = this.findExistingGroup(t, o);
    c && o.splice(c.idx, 1);
    let d = c == null ? void 0 : c.group;
    d && u.setExpanded(d.isExpanded());
    const h = this.recursivelyCreateColumns(
      a.children,
      r + 1,
      e,
      i,
      n,
      o,
      s
    );
    return u.setChildren(h), u;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, r, i, n) {
    const o = this.findExistingColumn(t, r);
    o && (r == null || r.splice(o.idx, 1));
    let s = o == null ? void 0 : o.column;
    if (s) {
      const a = this.addColumnDefaultAndTypes(t, s.getColId());
      s.setColDef(a, t, n), this.applyColumnState(s, a, n);
    } else {
      const a = i.getUniqueKey(t.colId, t.field), l = this.addColumnDefaultAndTypes(t, a);
      s = new ct(l, t, a, e), this.context.createBean(s);
    }
    return this.dataTypeService.addColumnListeners(s), s;
  }
  applyColumnState(e, t, r) {
    const i = Yo(t.flex);
    if (i !== void 0 && e.setFlex(i), e.getFlex() <= 0) {
      const a = Yo(t.width);
      if (a != null)
        e.setActualWidth(a, r);
      else {
        const l = e.getActualWidth();
        e.setActualWidth(l, r);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort, r) : e.setSort(void 0, r));
    const o = Yo(t.sortIndex);
    o !== void 0 && e.setSortIndex(o);
    const s = rg(t.hide);
    s !== void 0 && e.setVisible(!s, r), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    if (t)
      for (let r = 0; r < t.length; r++) {
        const i = t[r].getUserProvidedColDef();
        if (!i)
          continue;
        if (e.colId != null) {
          if (t[r].getId() === e.colId)
            return { idx: r, column: t[r] };
          continue;
        }
        if (e.field != null) {
          if (i.field === e.field)
            return { idx: r, column: t[r] };
          continue;
        }
        if (i === e)
          return { idx: r, column: t[r] };
      }
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        if (n.getColGroupDef() && n.getId() === e.groupId)
          return { idx: i, group: n };
      }
  }
  addColumnDefaultAndTypes(e, t) {
    const r = {}, i = this.gos.get("defaultColDef");
    Zr(r, i, !1, !0);
    const n = this.dataTypeService.updateColDefAndGetColumnType(r, e, t);
    n && this.assignColumnTypes(n, r), Zr(r, e, !1, !0);
    const o = this.gos.get("autoGroupColumnDef"), s = this.gos.isColumnsSortingCoupledToGroup();
    return e.rowGroup && o && s && Zr(r, { sort: o.sort, initialSort: o.initialSort }, !1, !0), this.dataTypeService.validateColDef(r), r;
  }
  assignColumnTypes(e, t) {
    if (!e.length)
      return;
    const r = Object.assign({}, _ne), i = this.gos.get("columnTypes") || {};
    Tr(i, (n, o) => {
      n in r ? console.warn(`AG Grid: the column type '${n}' is a default column type and cannot be overridden.`) : (o.type && we("Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."), r[n] = o);
    }), e.forEach((n) => {
      const o = r[n.trim()];
      o ? Zr(t, o, !1, !0) : console.warn("AG Grid: colDef.type '" + n + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  // if object has children, we assume it's a group
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
v([
  T("dataTypeService")
], Rd.prototype, "dataTypeService", 2);
v([
  an(0, Gi("loggerFactory"))
], Rd.prototype, "setBeans", 1);
Rd = v([
  de("columnFactory")
], Rd);
function io(e, t, r) {
  if (t)
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      n instanceof Ut && io(n, n.getChildren(), r), r(n, e);
    }
}
var Fm = class wn {
  constructor(t, r, i, n) {
    this.displayedChildren = [], this.localEventService = new fn(), this.groupId = r, this.partId = i, this.providedColumnGroup = t, this.pinned = n;
  }
  // this is static, a it is used outside of this class
  static createUniqueId(t, r) {
    return t + "_" + r;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(t) {
    this.parent = t;
  }
  getUniqueId() {
    return wn.createUniqueId(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const t = this.getProvidedColumnGroup().getLeafColumns();
    return !t || t.length === 0 ? !1 : t.every((r) => r.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((t) => {
      t instanceof wn && t.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const r = ze(this.displayedChildren).getLeft();
        this.setLeft(r);
      } else {
        const t = this.displayedChildren[0].getLeft();
        this.setLeft(t);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(t) {
    this.oldLeft = this.left, this.left !== t && (this.left = t, this.localEventService.dispatchEvent(this.createAgEvent(wn.EVENT_LEFT_CHANGED)));
  }
  getPinned() {
    return this.pinned;
  }
  createAgEvent(t) {
    return { type: t };
  }
  addEventListener(t, r) {
    this.localEventService.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    this.localEventService.removeEventListener(t, r);
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  isChildInThisGroupDeepSearch(t) {
    let r = !1;
    return this.children.forEach((i) => {
      t === i && (r = !0), i instanceof wn && i.isChildInThisGroupDeepSearch(t) && (r = !0);
    }), r;
  }
  getActualWidth() {
    let t = 0;
    return this.displayedChildren && this.displayedChildren.forEach((r) => {
      t += r.getActualWidth();
    }), t;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let t = !1;
    return this.displayedChildren.forEach((r) => {
      r.isResizable() && (t = !0);
    }), t;
  }
  getMinWidth() {
    let t = 0;
    return this.displayedChildren.forEach((r) => {
      t += r.getMinWidth() || 0;
    }), t;
  }
  addChild(t) {
    this.children || (this.children = []), this.children.push(t);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const t = [];
    return this.addLeafColumns(t), t;
  }
  getDisplayedLeafColumns() {
    const t = [];
    return this.addDisplayedLeafColumns(t), t;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(t) {
    this.providedColumnGroup.setExpanded(t);
  }
  addDisplayedLeafColumns(t) {
    this.displayedChildren.forEach((r) => {
      r instanceof ct ? t.push(r) : r instanceof wn && r.addDisplayedLeafColumns(t);
    });
  }
  addLeafColumns(t) {
    this.children.forEach((r) => {
      r instanceof ct ? t.push(r) : r instanceof wn && r.addLeafColumns(t);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const t = this.getParent();
    return !this.isPadding() || !t || !t.isPadding() ? 0 : 1 + t.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let t = this;
    for (; t != null && t.isPadding(); )
      t = t.getParent();
    if (!(t ? t.providedColumnGroup.isExpandable() : !1)) {
      this.displayedChildren = this.children, this.localEventService.dispatchEvent(this.createAgEvent(wn.EVENT_DISPLAYED_CHILDREN_CHANGED));
      return;
    }
    this.children.forEach((i) => {
      if (i instanceof wn && (!i.displayedChildren || !i.displayedChildren.length))
        return;
      switch (i.getColumnGroupShow()) {
        case "open":
          t.providedColumnGroup.isExpanded() && this.displayedChildren.push(i);
          break;
        case "closed":
          t.providedColumnGroup.isExpanded() || this.displayedChildren.push(i);
          break;
        default:
          this.displayedChildren.push(i);
          break;
      }
    }), this.localEventService.dispatchEvent(this.createAgEvent(wn.EVENT_DISPLAYED_CHILDREN_CHANGED));
  }
};
Fm.EVENT_LEFT_CHANGED = "leftChanged";
Fm.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged";
v([
  T("gridOptionsService")
], Fm.prototype, "gos", 2);
var ur = Fm, A = class {
  /*****************************  INTERNAL EVENTS: END ******************************************* */
};
A.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged";
A.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded";
A.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged";
A.EVENT_PIVOT_MAX_COLUMNS_EXCEEDED = "pivotMaxColumnsExceeded";
A.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
A.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll";
A.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged";
A.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged";
A.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged";
A.EVENT_COLUMN_MOVED = "columnMoved";
A.EVENT_COLUMN_VISIBLE = "columnVisible";
A.EVENT_COLUMN_PINNED = "columnPinned";
A.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened";
A.EVENT_COLUMN_RESIZED = "columnResized";
A.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged";
A.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED = "suppressMovableColumns";
A.EVENT_SUPPRESS_MENU_HIDE_CHANGED = "suppressMenuHide";
A.EVENT_SUPPRESS_FIELD_DOT_NOTATION = "suppressFieldDotNotation";
A.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged";
A.EVENT_COLUMN_HEADER_MOUSE_OVER = "columnHeaderMouseOver";
A.EVENT_COLUMN_HEADER_MOUSE_LEAVE = "columnHeaderMouseLeave";
A.EVENT_COLUMN_HEADER_CLICKED = "columnHeaderClicked";
A.EVENT_COLUMN_HEADER_CONTEXT_MENU = "columnHeaderContextMenu";
A.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed";
A.EVENT_ROW_GROUP_OPENED = "rowGroupOpened";
A.EVENT_ROW_DATA_UPDATED = "rowDataUpdated";
A.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged";
A.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged";
A.EVENT_CHART_CREATED = "chartCreated";
A.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged";
A.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged";
A.EVENT_CHART_DESTROYED = "chartDestroyed";
A.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged";
A.EVENT_TOOL_PANEL_SIZE_CHANGED = "toolPanelSizeChanged";
A.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart";
A.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd";
A.EVENT_MODEL_UPDATED = "modelUpdated";
A.EVENT_CUT_START = "cutStart";
A.EVENT_CUT_END = "cutEnd";
A.EVENT_PASTE_START = "pasteStart";
A.EVENT_PASTE_END = "pasteEnd";
A.EVENT_FILL_START = "fillStart";
A.EVENT_FILL_END = "fillEnd";
A.EVENT_RANGE_DELETE_START = "rangeDeleteStart";
A.EVENT_RANGE_DELETE_END = "rangeDeleteEnd";
A.EVENT_UNDO_STARTED = "undoStarted";
A.EVENT_UNDO_ENDED = "undoEnded";
A.EVENT_REDO_STARTED = "redoStarted";
A.EVENT_REDO_ENDED = "redoEnded";
A.EVENT_KEY_SHORTCUT_CHANGED_CELL_START = "keyShortcutChangedCellStart";
A.EVENT_KEY_SHORTCUT_CHANGED_CELL_END = "keyShortcutChangedCellEnd";
A.EVENT_CELL_CLICKED = "cellClicked";
A.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked";
A.EVENT_CELL_MOUSE_DOWN = "cellMouseDown";
A.EVENT_CELL_CONTEXT_MENU = "cellContextMenu";
A.EVENT_CELL_VALUE_CHANGED = "cellValueChanged";
A.EVENT_CELL_EDIT_REQUEST = "cellEditRequest";
A.EVENT_ROW_VALUE_CHANGED = "rowValueChanged";
A.EVENT_CELL_FOCUSED = "cellFocused";
A.EVENT_CELL_FOCUS_CLEARED = "cellFocusCleared";
A.EVENT_FULL_WIDTH_ROW_FOCUSED = "fullWidthRowFocused";
A.EVENT_ROW_SELECTED = "rowSelected";
A.EVENT_SELECTION_CHANGED = "selectionChanged";
A.EVENT_TOOLTIP_SHOW = "tooltipShow";
A.EVENT_TOOLTIP_HIDE = "tooltipHide";
A.EVENT_CELL_KEY_DOWN = "cellKeyDown";
A.EVENT_CELL_MOUSE_OVER = "cellMouseOver";
A.EVENT_CELL_MOUSE_OUT = "cellMouseOut";
A.EVENT_FILTER_CHANGED = "filterChanged";
A.EVENT_FILTER_MODIFIED = "filterModified";
A.EVENT_FILTER_OPENED = "filterOpened";
A.EVENT_ADVANCED_FILTER_BUILDER_VISIBLE_CHANGED = "advancedFilterBuilderVisibleChanged";
A.EVENT_SORT_CHANGED = "sortChanged";
A.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved";
A.EVENT_ROW_CLICKED = "rowClicked";
A.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked";
A.EVENT_GRID_READY = "gridReady";
A.EVENT_GRID_PRE_DESTROYED = "gridPreDestroyed";
A.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged";
A.EVENT_VIEWPORT_CHANGED = "viewportChanged";
A.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged";
A.EVENT_FIRST_DATA_RENDERED = "firstDataRendered";
A.EVENT_DRAG_STARTED = "dragStarted";
A.EVENT_DRAG_STOPPED = "dragStopped";
A.EVENT_CHECKBOX_CHANGED = "checkboxChanged";
A.EVENT_ROW_EDITING_STARTED = "rowEditingStarted";
A.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped";
A.EVENT_CELL_EDITING_STARTED = "cellEditingStarted";
A.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped";
A.EVENT_BODY_SCROLL = "bodyScroll";
A.EVENT_BODY_SCROLL_END = "bodyScrollEnd";
A.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged";
A.EVENT_PAGINATION_CHANGED = "paginationChanged";
A.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged";
A.EVENT_STORE_REFRESHED = "storeRefreshed";
A.EVENT_STATE_UPDATED = "stateUpdated";
A.EVENT_COLUMN_MENU_VISIBLE_CHANGED = "columnMenuVisibleChanged";
A.EVENT_CONTEXT_MENU_VISIBLE_CHANGED = "contextMenuVisibleChanged";
A.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged";
A.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED = "columnContainerWidthChanged";
A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged";
A.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged";
A.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged";
A.EVENT_FLASH_CELLS = "flashCells";
A.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged";
A.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged";
A.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged";
A.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged";
A.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged";
A.EVENT_HEADER_HEIGHT_CHANGED = "headerHeightChanged";
A.EVENT_COLUMN_HEADER_HEIGHT_CHANGED = "columnHeaderHeightChanged";
A.EVENT_ROW_DRAG_ENTER = "rowDragEnter";
A.EVENT_ROW_DRAG_MOVE = "rowDragMove";
A.EVENT_ROW_DRAG_LEAVE = "rowDragLeave";
A.EVENT_ROW_DRAG_END = "rowDragEnd";
A.EVENT_GRID_STYLES_CHANGED = "gridStylesChanged";
A.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest";
A.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest";
A.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest";
A.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest";
A.EVENT_STORE_UPDATED = "storeUpdated";
A.EVENT_FILTER_DESTROYED = "filterDestroyed";
A.EVENT_ROW_DATA_UPDATE_STARTED = "rowDataUpdateStarted";
A.EVENT_ROW_COUNT_READY = "rowCountReady";
A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED = "advancedFilterEnabledChanged";
A.EVENT_DATA_TYPES_INFERRED = "dataTypesInferred";
A.EVENT_FIELD_VALUE_CHANGED = "fieldValueChanged";
A.EVENT_FIELD_PICKER_VALUE_SELECTED = "fieldPickerValueSelected";
A.EVENT_SIDE_BAR_UPDATED = "sideBarUpdated";
var Pp = /* @__PURE__ */ new Set([A.EVENT_GRID_PRE_DESTROYED, A.EVENT_FILL_START]), KF = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let r;
    return typeof t != "number" ? r = 0 : r = t + 1, this.existingIds[e] = r, r;
  }
}, Kl = "ag-Grid-AutoColumn", Pd = class extends Q {
  createAutoGroupColumns(e) {
    const t = [], r = this.gos.get("treeData");
    let i = this.gos.isGroupMultiAutoColumn();
    return r && i && (console.warn('AG Grid: you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data'), i = !1), i ? e.forEach((n, o) => {
      t.push(this.createOneAutoGroupColumn(n, o));
    }) : t.push(this.createOneAutoGroupColumn()), t;
  }
  updateAutoGroupColumns(e, t) {
    e.forEach((r, i) => this.updateOneAutoGroupColumn(r, i, t));
  }
  // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
  createOneAutoGroupColumn(e, t) {
    let r;
    e ? r = `${Kl}-${e.getId()}` : r = Kl;
    const i = this.createAutoGroupColDef(r, e, t);
    i.colId = r;
    const n = new ct(i, null, r, !0);
    return this.context.createBean(n), n;
  }
  /**
   * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef
   */
  updateOneAutoGroupColumn(e, t, r) {
    const i = e.getColDef(), n = typeof i.showRowGroup == "string" ? i.showRowGroup : void 0, o = n != null ? this.columnModel.getPrimaryColumn(n) : void 0, s = this.createAutoGroupColDef(e.getId(), o ?? void 0, t);
    e.setColDef(s, null, r), this.columnFactory.applyColumnState(e, s, r);
  }
  createAutoGroupColDef(e, t, r) {
    let i = this.createBaseColDef(t);
    const n = this.gos.get("autoGroupColumnDef");
    Zr(i, n), i = this.columnFactory.addColumnDefaultAndTypes(i, e), this.gos.get("treeData") || Re(i.field) && Re(i.valueGetter) && Re(i.filterValueGetter) && i.filter !== "agGroupColumnFilter" && (i.filter = !1), r && r > 0 && (i.headerCheckboxSelection = !1);
    const o = this.gos.isColumnsSortingCoupledToGroup(), s = i.valueGetter || i.field != null;
    return o && !s && (i.sortIndex = void 0, i.initialSort = void 0), i;
  }
  createBaseColDef(e) {
    const t = this.gos.get("autoGroupColumnDef"), i = {
      headerName: this.localeService.getLocaleTextFunc()("group", "Group")
    };
    if (t && (t.cellRenderer || t.cellRendererSelector) || (i.cellRenderer = "agGroupCellRenderer"), e) {
      const o = e.getColDef();
      Object.assign(i, {
        // cellRendererParams.groupKey: colDefToCopy.field;
        headerName: this.columnModel.getDisplayNameForColumn(e, "header"),
        headerValueGetter: o.headerValueGetter
      }), o.cellRenderer && Object.assign(i, {
        cellRendererParams: {
          innerRenderer: o.cellRenderer,
          innerRendererParams: o.cellRendererParams
        }
      }), i.showRowGroup = e.getColId();
    } else
      i.showRowGroup = !0;
    return i;
  }
};
v([
  T("columnModel")
], Pd.prototype, "columnModel", 2);
v([
  T("columnFactory")
], Pd.prototype, "columnFactory", 2);
Pd = v([
  de("autoGroupColService")
], Pd);
var qF = {};
yr(qF, {
  camelCaseToHumanText: () => ZF,
  camelCaseToHyphenated: () => JF,
  capitalise: () => $ne,
  escapeString: () => Yt,
  utf8_encode: () => Wne
});
var Hne = /[&<>"']/g, Bne = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Wne(e) {
  const t = String.fromCharCode;
  function r(d) {
    const h = [];
    if (!d)
      return [];
    const p = d.length;
    let g = 0, m, f;
    for (; g < p; )
      m = d.charCodeAt(g++), m >= 55296 && m <= 56319 && g < p ? (f = d.charCodeAt(g++), (f & 64512) == 56320 ? h.push(((m & 1023) << 10) + (f & 1023) + 65536) : (h.push(m), g--)) : h.push(m);
    return h;
  }
  function i(d) {
    if (d >= 55296 && d <= 57343)
      throw Error(
        "Lone surrogate U+" + d.toString(16).toUpperCase() + " is not a scalar value"
      );
  }
  function n(d, h) {
    return t(d >> h & 63 | 128);
  }
  function o(d) {
    if (d >= 0 && d <= 31 && d !== 10)
      return `_x${d.toString(16).toUpperCase().padStart(4, "0")}_`;
    if (!(d & 4294967168))
      return t(d);
    let h = "";
    return d & 4294965248 ? d & 4294901760 ? d & 4292870144 || (h = t(d >> 18 & 7 | 240), h += n(d, 12), h += n(d, 6)) : (i(d), h = t(d >> 12 & 15 | 224), h += n(d, 6)) : h = t(d >> 6 & 31 | 192), h += t(d & 63 | 128), h;
  }
  const s = r(e), a = s.length;
  let l = -1, u, c = "";
  for (; ++l < a; )
    u = s[l], c += o(u);
  return c;
}
function $ne(e) {
  return e[0].toUpperCase() + e.substring(1).toLowerCase();
}
function Yt(e, t) {
  if (e == null)
    return null;
  const r = e.toString().toString();
  return t ? r : r.replace(Hne, (i) => Bne[i]);
}
function ZF(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, r = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(r, "$1 $2$3").replace(/\./g, " ").split(" ").map((n) => n.substring(0, 1).toUpperCase() + (n.length > 1 ? n.substring(1, n.length) : "")).join(" ");
}
function JF(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLocaleLowerCase()}`);
}
var QF = {};
yr(QF, {
  convertToMap: () => Wo,
  keys: () => zne,
  mapById: () => jne
});
function Wo(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => t.set(r[0], r[1])), t;
}
function jne(e, t) {
  const r = /* @__PURE__ */ new Map();
  return e.forEach((i) => r.set(t(i), i)), r;
}
function zne(e) {
  const t = [];
  return e.forEach((r, i) => t.push(i)), t;
}
var vr = class extends Q {
  constructor() {
    super(...arguments), this.primaryHeaderRowCount = 0, this.secondaryHeaderRowCount = 0, this.gridHeaderRowCount = 0, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.displayedColumnsAndGroupsMap = {}, this.viewportColumns = [], this.viewportColumnsHash = "", this.headerViewportColumns = [], this.viewportColumnsCenter = [], this.headerViewportColumnsCenter = [], this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.autoHeightActiveAtLeastOnce = !1, this.rowGroupColumns = [], this.valueColumns = [], this.pivotColumns = [], this.ready = !1, this.changeEventsDispatching = !1, this.autoGroupsNeedBuilding = !1, this.forceRecreateAutoGroups = !1, this.pivotMode = !1, this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  init() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
    const e = this.gos.get("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"], (t) => this.buildAutoGroupColumns(dl(t.source))), this.addManagedPropertyListener("autoGroupColumnDef", (t) => this.onAutoGroupColumnDefChanged(dl(t.source))), this.addManagedPropertyListeners(["defaultColDef", "columnTypes", "suppressFieldDotNotation"], (t) => this.onSharedColDefChanged(dl(t.source))), this.addManagedPropertyListener("pivotMode", (t) => this.setPivotMode(this.gos.get("pivotMode"), dl(t.source))), this.addManagedListener(this.eventService, A.EVENT_FIRST_DATA_RENDERED, () => this.onFirstDataRendered());
  }
  buildAutoGroupColumns(e) {
    this.columnDefs && (this.autoGroupsNeedBuilding = !0, this.forceRecreateAutoGroups = !0, this.updateGridColumns(), this.updateDisplayedColumns(e));
  }
  onAutoGroupColumnDefChanged(e) {
    this.groupAutoColumns && this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, e);
  }
  onSharedColDefChanged(e) {
    this.gridColumns && (this.groupAutoColumns && this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, e), this.createColumnsFromColumnDefs(!0, e));
  }
  setColumnDefs(e, t) {
    const r = !!this.columnDefs;
    this.columnDefs = e, this.createColumnsFromColumnDefs(r, t);
  }
  recreateColumnDefs(e) {
    this.onSharedColDefChanged(e);
  }
  destroyOldColumns(e, t) {
    const r = {};
    if (!e)
      return;
    io(null, e, (n) => {
      r[n.getInstanceId()] = n;
    }), t && io(null, t, (n) => {
      r[n.getInstanceId()] = null;
    });
    const i = Object.values(r).filter((n) => n != null);
    this.destroyBeans(i);
  }
  destroyColumns() {
    this.destroyOldColumns(this.primaryColumnTree), this.destroyOldColumns(this.secondaryBalancedTree), this.destroyOldColumns(this.groupAutoColsBalancedTree);
  }
  createColumnsFromColumnDefs(e, t) {
    const r = e ? this.compareColumnStatesAndDispatchEvents(t) : void 0;
    this.valueCache.expire(), this.autoGroupsNeedBuilding = !0;
    const i = this.primaryColumns, n = this.primaryColumnTree, o = this.columnFactory.createColumnTree(this.columnDefs, !0, n, t);
    this.destroyOldColumns(this.primaryColumnTree, o.columnTree), this.primaryColumnTree = o.columnTree, this.primaryHeaderRowCount = o.treeDept + 1, this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree), this.primaryColumnsMap = {}, this.primaryColumns.forEach((l) => this.primaryColumnsMap[l.getId()] = l), this.extractRowGroupColumns(t, i), this.extractPivotColumns(t, i), this.extractValueColumns(t, i), this.ready = !0;
    const s = this.gridColsArePrimary === void 0;
    (this.gridColsArePrimary || s || this.autoGroupsNeedBuilding) && (this.updateGridColumns(), e && this.gridColsArePrimary && !this.gos.get("maintainColumnOrder") && this.orderGridColumnsLikePrimary(), this.updateDisplayedColumns(t), this.checkViewportColumns()), this.dispatchEverythingChanged(t), this.changeEventsDispatching = !0, r && r(), this.changeEventsDispatching = !1, this.dispatchNewColumnsLoaded(t);
  }
  shouldRowModelIgnoreRefresh() {
    return this.changeEventsDispatching;
  }
  dispatchNewColumnsLoaded(e) {
    const t = {
      type: A.EVENT_NEW_COLUMNS_LOADED,
      source: e
    };
    this.eventService.dispatchEvent(t), e === "gridInitializing" && this.onColumnsReady();
  }
  // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded
  dispatchEverythingChanged(e) {
    const t = {
      type: A.EVENT_COLUMN_EVERYTHING_CHANGED,
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  orderGridColumnsLikePrimary() {
    const e = this.primaryColumns;
    if (!e)
      return;
    const t = e.filter((i) => this.gridColumns.indexOf(i) >= 0), r = this.gridColumns.filter((i) => t.indexOf(i) < 0);
    this.gridColumns = [...r, ...t], this.gridColumns = this.placeLockedColumns(this.gridColumns);
  }
  getAllDisplayedAutoHeightCols() {
    return this.displayedAutoHeightCols;
  }
  setViewport() {
    this.gos.get("enableRtl") ? (this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth, this.viewportRight = this.bodyWidth - this.scrollPosition) : (this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    if (this.displayedColumnsCenter == null || !this.extractViewport())
      return;
    const r = {
      type: A.EVENT_VIRTUAL_COLUMNS_CHANGED,
      afterScroll: e
    };
    this.eventService.dispatchEvent(r);
  }
  setViewportPosition(e, t, r = !1) {
    (e !== this.scrollWidth || t !== this.scrollPosition || this.bodyWidthDirty) && (this.scrollWidth = e, this.scrollPosition = t, this.bodyWidthDirty = !0, this.setViewport(), this.ready && this.checkViewportColumns(r));
  }
  isPivotMode() {
    return this.pivotMode;
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get("treeData") ? (we("Pivot mode not available with treeData."), !1) : !0;
  }
  setPivotMode(e, t) {
    if (e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode) || (this.pivotMode = e, !this.gridColumns))
      return;
    this.autoGroupsNeedBuilding = !0, this.updateGridColumns(), this.updateDisplayedColumns(t);
    const r = {
      type: A.EVENT_COLUMN_PIVOT_MODE_CHANGED
    };
    this.eventService.dispatchEvent(r);
  }
  getSecondaryPivotColumn(e, t) {
    if (Re(this.secondaryColumns))
      return null;
    const r = this.getPrimaryColumn(t);
    let i = null;
    return this.secondaryColumns.forEach((n) => {
      const o = n.getColDef().pivotKeys, s = n.getColDef().pivotValueColumn;
      On(o, e) && s === r && (i = n);
    }), i;
  }
  setBeans(e) {
    this.logger = e.create("columnModel");
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, r;
    this.gos.get("enableRtl") ? (t = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null, r = this.displayedColumnsRight ? ze(this.displayedColumnsRight) : null) : (t = this.displayedColumnsLeft ? ze(this.displayedColumnsLeft) : null, r = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null), this.gridColumns.forEach((i) => {
      i.setLastLeftPinned(i === t, e), i.setFirstRightPinned(i === r, e);
    });
  }
  autoSizeColumns(e) {
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.autoSizeColumns(e));
      return;
    }
    const { columns: t, skipHeader: r, skipHeaderGroups: i, stopAtGroup: n, source: o = "api" } = e;
    this.animationFrameService.flushAllFrames();
    const s = [];
    let a = -1;
    const l = r ?? this.gos.get("skipHeaderOnAutoSize"), u = i ?? l;
    for (; a !== 0; )
      a = 0, this.actionOnGridColumns(t, (c) => {
        if (s.indexOf(c) >= 0)
          return !1;
        const d = this.autoWidthCalculator.getPreferredWidthForColumn(c, l);
        if (d > 0) {
          const h = this.normaliseColumnWidth(c, d);
          c.setActualWidth(h, o), s.push(c), a++;
        }
        return !0;
      }, o);
    u || this.autoSizeColumnGroupsByColumns(t, o, n), this.dispatchColumnResizedEvent(s, !0, "autosizeColumns");
  }
  dispatchColumnResizedEvent(e, t, r, i = null) {
    if (e && e.length) {
      const n = {
        type: A.EVENT_COLUMN_RESIZED,
        columns: e,
        column: e.length === 1 ? e[0] : null,
        flexColumns: i,
        finished: t,
        source: r
      };
      this.eventService.dispatchEvent(n);
    }
  }
  dispatchColumnChangedEvent(e, t, r) {
    const i = {
      type: e,
      columns: t,
      column: t && t.length == 1 ? t[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(i);
  }
  dispatchColumnMovedEvent(e) {
    const { movedColumns: t, source: r, toIndex: i, finished: n } = e, o = {
      type: A.EVENT_COLUMN_MOVED,
      columns: t,
      column: t && t.length === 1 ? t[0] : null,
      toIndex: i,
      finished: n,
      source: r
    };
    this.eventService.dispatchEvent(o);
  }
  dispatchColumnPinnedEvent(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, i = this.getCommonValue(e, (o) => o.getPinned()), n = {
      type: A.EVENT_COLUMN_PINNED,
      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
      pinned: i ?? null,
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(n);
  }
  dispatchColumnVisibleEvent(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, i = this.getCommonValue(e, (o) => o.isVisible()), n = {
      type: A.EVENT_COLUMN_VISIBLE,
      visible: i,
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(n);
  }
  autoSizeColumn(e, t, r) {
    e && this.autoSizeColumns({ columns: [e], skipHeader: r, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, r) {
    const i = /* @__PURE__ */ new Set();
    this.getGridColumns(e).forEach((a) => {
      let l = a.getParent();
      for (; l && l != r; )
        l.isPadding() || i.add(l), l = l.getParent();
    });
    let o;
    const s = [];
    for (const a of i) {
      for (const l of this.ctrlsService.getHeaderRowContainerCtrls())
        if (o = l.getHeaderCtrlForColumn(a), o)
          break;
      o && o.resizeLeafColumnsToFit(t);
    }
    return s;
  }
  autoSizeAllColumns(e, t) {
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const r = this.getAllDisplayedColumns();
    this.autoSizeColumns({ columns: r, skipHeader: t, source: e });
  }
  // Possible candidate for reuse (alot of recursive traversal duplication)
  getColumnsFromTree(e) {
    const t = [], r = (i) => {
      for (let n = 0; n < i.length; n++) {
        const o = i[n];
        o instanceof ct ? t.push(o) : o instanceof Ut && r(o.getChildren());
      }
    };
    return r(e), t;
  }
  getAllDisplayedTrees() {
    return this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre ? this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight) : null;
  }
  // + columnSelectPanel
  getPrimaryColumnTree() {
    return this.primaryColumnTree;
  }
  // + gridPanel -> for resizing the body and setting top margin
  getHeaderRowCount() {
    return this.gridHeaderRowCount;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeLeft() {
    return this.displayedTreeLeft;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeRight() {
    return this.displayedTreeRight;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeCentre() {
    return this.displayedTreeCentre;
  }
  // gridPanel -> ensureColumnVisible
  isColumnDisplayed(e) {
    return this.getAllDisplayedColumns().indexOf(e) >= 0;
  }
  // + csvCreator
  getAllDisplayedColumns() {
    return this.displayedColumns;
  }
  getViewportColumns() {
    return this.viewportColumns;
  }
  getDisplayedLeftColumnsForRow(e) {
    return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsLeft) : this.displayedColumnsLeft;
  }
  getDisplayedRightColumnsForRow(e) {
    return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsRight) : this.displayedColumnsRight;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  getDisplayedColumnsForRow(e, t, r, i) {
    const n = [];
    let o = null;
    for (let s = 0; s < t.length; s++) {
      const a = t[s], l = t.length - s, u = Math.min(a.getColSpan(e), l), c = [a];
      if (u > 1) {
        const h = u - 1;
        for (let p = 1; p <= h; p++)
          c.push(t[s + p]);
        s += h;
      }
      let d;
      r ? (d = !1, c.forEach((h) => {
        r(h) && (d = !0);
      })) : d = !0, d && (n.length === 0 && o && (i && i(a)) && n.push(o), n.push(a)), o = a;
    }
    return n;
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getViewportCenterColumnsForRow(e) {
    if (!this.colSpanActive)
      return this.viewportColumnsCenter;
    const t = (i) => {
      const n = i.getLeft();
      return q(n) && n > this.viewportLeft;
    }, r = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this);
    return this.getDisplayedColumnsForRow(
      e,
      this.displayedColumnsCenter,
      r,
      t
    );
  }
  isColumnAtEdge(e, t) {
    const r = this.getAllDisplayedColumns();
    if (!r.length)
      return !1;
    const i = t === "first";
    let n;
    if (e instanceof ur) {
      const o = e.getDisplayedLeafColumns();
      if (!o.length)
        return !1;
      n = i ? o[0] : ze(o);
    } else
      n = e;
    return (i ? r[0] : ze(r)) === n;
  }
  getAriaColumnIndex(e) {
    let t;
    return e instanceof ur ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, r = t + e.getActualWidth(), i = this.viewportLeft - 200, n = this.viewportRight + 200, o = t < i && r < i, s = t > n && r > n;
    return !o && !s;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getDisplayedColumnsLeftWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsLeft);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsRight);
  }
  updatePrimaryColumnList(e, t, r, i, n, o) {
    if (!e || Ni(e))
      return;
    let s = !1;
    if (e.forEach((l) => {
      if (!l)
        return;
      const u = this.getPrimaryColumn(l);
      if (u) {
        if (r) {
          if (t.indexOf(u) >= 0)
            return;
          t.push(u);
        } else {
          if (t.indexOf(u) < 0)
            return;
          Xr(t, u);
        }
        i(u), s = !0;
      }
    }), !s)
      return;
    this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(o);
    const a = {
      type: n,
      columns: t,
      column: t.length === 1 ? t[0] : null,
      source: o
    };
    this.eventService.dispatchEvent(a);
  }
  setRowGroupColumns(e, t) {
    this.autoGroupsNeedBuilding = !0, this.setPrimaryColumnList(
      e,
      this.rowGroupColumns,
      A.EVENT_COLUMN_ROW_GROUP_CHANGED,
      !0,
      this.setRowGroupActive.bind(this),
      t
    );
  }
  setRowGroupActive(e, t, r) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, r), e && !this.gos.get("suppressRowGroupHidesColumns") && this.setColumnsVisible([t], !1, r), !e && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup") && this.setColumnsVisible([t], !0, r));
  }
  addRowGroupColumns(e, t) {
    this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(
      e,
      this.rowGroupColumns,
      !0,
      this.setRowGroupActive.bind(this, !0),
      A.EVENT_COLUMN_ROW_GROUP_CHANGED,
      t
    );
  }
  removeRowGroupColumns(e, t) {
    this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(
      e,
      this.rowGroupColumns,
      !1,
      this.setRowGroupActive.bind(this, !1),
      A.EVENT_COLUMN_ROW_GROUP_CHANGED,
      t
    );
  }
  addPivotColumns(e, t) {
    this.updatePrimaryColumnList(
      e,
      this.pivotColumns,
      !0,
      (r) => r.setPivotActive(!0, t),
      A.EVENT_COLUMN_PIVOT_CHANGED,
      t
    );
  }
  setPivotColumns(e, t) {
    this.setPrimaryColumnList(
      e,
      this.pivotColumns,
      A.EVENT_COLUMN_PIVOT_CHANGED,
      !0,
      (r, i) => {
        i.setPivotActive(r, t);
      },
      t
    );
  }
  removePivotColumns(e, t) {
    this.updatePrimaryColumnList(
      e,
      this.pivotColumns,
      !1,
      (r) => r.setPivotActive(!1, t),
      A.EVENT_COLUMN_PIVOT_CHANGED,
      t
    );
  }
  setPrimaryColumnList(e, t, r, i, n, o) {
    if (!this.gridColumns)
      return;
    const s = /* @__PURE__ */ new Map();
    t.forEach((a, l) => s.set(a, l)), t.length = 0, q(e) && e.forEach((a) => {
      const l = this.getPrimaryColumn(a);
      l && t.push(l);
    }), t.forEach((a, l) => {
      const u = s.get(a);
      if (u === void 0) {
        s.set(a, 0);
        return;
      }
      i && u !== l || s.delete(a);
    }), (this.primaryColumns || []).forEach((a) => {
      const l = t.indexOf(a) >= 0;
      n(l, a);
    }), this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(o), this.dispatchColumnChangedEvent(r, [...s.keys()], o);
  }
  setValueColumns(e, t) {
    this.setPrimaryColumnList(
      e,
      this.valueColumns,
      A.EVENT_COLUMN_VALUE_CHANGED,
      !1,
      this.setValueActive.bind(this),
      t
    );
  }
  setValueActive(e, t, r) {
    if (e !== t.isValueActive() && (t.setValueActive(e, r), e && !t.getAggFunc() && this.aggFuncService)) {
      const i = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(i);
    }
  }
  addValueColumns(e, t) {
    this.updatePrimaryColumnList(
      e,
      this.valueColumns,
      !0,
      this.setValueActive.bind(this, !0),
      A.EVENT_COLUMN_VALUE_CHANGED,
      t
    );
  }
  removeValueColumns(e, t) {
    this.updatePrimaryColumnList(
      e,
      this.valueColumns,
      !1,
      this.setValueActive.bind(this, !1),
      A.EVENT_COLUMN_VALUE_CHANGED,
      t
    );
  }
  // returns the width we can set to this col, taking into consideration min and max widths
  normaliseColumnWidth(e, t) {
    const r = e.getMinWidth();
    q(r) && t < r && (t = r);
    const i = e.getMaxWidth();
    return q(i) && e.isGreaterThanMax(t) && (t = i), t;
  }
  getPrimaryOrGridColumn(e) {
    return this.getPrimaryColumn(e) || this.getGridColumn(e);
  }
  setColumnWidths(e, t, r, i) {
    const n = [];
    e.forEach((o) => {
      const s = this.getPrimaryOrGridColumn(o.key);
      if (!s)
        return;
      if (n.push({
        width: o.newWidth,
        ratios: [1],
        columns: [s]
      }), this.gos.get("colResizeDefault") === "shift" && (t = !t), t) {
        const l = this.getDisplayedColAfter(s);
        if (!l)
          return;
        const u = s.getActualWidth() - o.newWidth, c = l.getActualWidth() + u;
        n.push({
          width: c,
          ratios: [1],
          columns: [l]
        });
      }
    }), n.length !== 0 && this.resizeColumnSets({
      resizeSets: n,
      finished: r,
      source: i
    });
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: r } = e;
    let i = 0, n = 0, o = !0;
    t.forEach((l) => {
      const u = l.getMinWidth();
      i += u || 0;
      const c = l.getMaxWidth();
      q(c) && c > 0 ? n += c : o = !1;
    });
    const s = r >= i, a = !o || r <= n;
    return s && a;
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: r, source: i } = e;
    if (!(!t || t.every((c) => this.checkMinAndMaxWidthsForSet(c)))) {
      if (r) {
        const c = t && t.length > 0 ? t[0].columns : null;
        this.dispatchColumnResizedEvent(c, r, i);
      }
      return;
    }
    const o = [], s = [];
    t.forEach((c) => {
      const { width: d, columns: h, ratios: p } = c, g = {}, m = {};
      h.forEach((w) => s.push(w));
      let f = !0, C = 0;
      for (; f; ) {
        if (C++, C > 1e3) {
          console.error("AG Grid: infinite loop in resizeColumnSets");
          break;
        }
        f = !1;
        const w = [];
        let E = 0, b = d;
        h.forEach((S, x) => {
          if (m[S.getId()])
            b -= g[S.getId()];
          else {
            w.push(S);
            const P = p[x];
            E += P;
          }
        });
        const y = 1 / E;
        w.forEach((S, x) => {
          const R = x === w.length - 1;
          let P;
          R ? P = b : (P = Math.round(p[x] * d * y), b -= P);
          const O = S.getMinWidth(), I = S.getMaxWidth();
          q(O) && P < O ? (P = O, m[S.getId()] = !0, f = !0) : q(I) && I > 0 && P > I && (P = I, m[S.getId()] = !0, f = !0), g[S.getId()] = P;
        });
      }
      h.forEach((w) => {
        const E = g[w.getId()];
        w.getActualWidth() !== E && (w.setActualWidth(E, i), o.push(w));
      });
    });
    const a = o.length > 0;
    let l = [];
    a && (l = this.refreshFlexedColumns({ resizingCols: s, skipSetLeft: !0 }), this.setLeftValues(i), this.updateBodyWidths(), this.checkViewportColumns());
    const u = s.concat(l);
    (a || r) && this.dispatchColumnResizedEvent(u, r, i, l);
  }
  setColumnAggFunc(e, t, r) {
    if (!e)
      return;
    const i = this.getPrimaryColumn(e);
    i && (i.setAggFunc(t), this.dispatchColumnChangedEvent(A.EVENT_COLUMN_VALUE_CHANGED, [i], r));
  }
  moveRowGroupColumn(e, t, r) {
    if (this.isRowGroupEmpty())
      return;
    const i = this.rowGroupColumns[e], n = this.rowGroupColumns.slice(e, t);
    this.rowGroupColumns.splice(e, 1), this.rowGroupColumns.splice(t, 0, i);
    const o = {
      type: A.EVENT_COLUMN_ROW_GROUP_CHANGED,
      columns: n,
      column: n.length === 1 ? n[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(o);
  }
  moveColumns(e, t, r, i = !0) {
    if (!this.gridColumns)
      return;
    if (this.columnAnimationService.start(), t > this.gridColumns.length - e.length) {
      console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + t), console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
      return;
    }
    const n = this.getGridColumns(e);
    this.doesMovePassRules(n, t) && (Mb(this.gridColumns, n, t), this.updateDisplayedColumns(r), this.dispatchColumnMovedEvent({ movedColumns: n, source: r, toIndex: t, finished: i }), this.columnAnimationService.finish());
  }
  doesMovePassRules(e, t) {
    const r = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(r);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const r = this.gridColumns.slice();
    return Mb(r, e, t), r;
  }
  // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns
  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
  sortColumnsLikeGridColumns(e) {
    !e || e.length <= 1 || e.filter((r) => this.gridColumns.indexOf(r) < 0).length > 0 || e.sort((r, i) => {
      const n = this.gridColumns.indexOf(r), o = this.gridColumns.indexOf(i);
      return n - o;
    });
  }
  doesMovePassLockedPositions(e) {
    let t = 0, r = !0;
    const i = (n) => n ? n === !0 || n === "left" ? 0 : 2 : 1;
    return e.forEach((n) => {
      const o = i(n.getColDef().lockPosition);
      o < t && (r = !1), t = o;
    }), r;
  }
  doesMovePassMarryChildren(e) {
    let t = !0;
    return io(null, this.gridBalancedTree, (r) => {
      if (!(r instanceof Ut))
        return;
      const i = r, n = i.getColGroupDef();
      if (!(n && n.marryChildren))
        return;
      const s = [];
      i.getLeafColumns().forEach((d) => {
        const h = e.indexOf(d);
        s.push(h);
      });
      const a = Math.max.apply(Math, s), l = Math.min.apply(Math, s), u = a - l, c = i.getLeafColumns().length - 1;
      u > c && (t = !1);
    }), t;
  }
  moveColumnByIndex(e, t, r) {
    if (!this.gridColumns)
      return;
    const i = this.gridColumns[e];
    this.moveColumns([i], t, r);
  }
  getColumnDefs() {
    if (!this.primaryColumns)
      return;
    const e = this.primaryColumns.slice();
    return this.gridColsArePrimary ? e.sort((t, r) => this.gridColumns.indexOf(t) - this.gridColumns.indexOf(r)) : this.lastPrimaryOrder && e.sort((t, r) => this.lastPrimaryOrder.indexOf(t) - this.lastPrimaryOrder.indexOf(r)), this.columnDefFactory.buildColumnDefs(e, this.rowGroupColumns, this.pivotColumns);
  }
  // used by:
  // + angularGrid -> for setting body width
  // + rowController -> setting main row widths (when inserting and resizing)
  // need to cache this
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  // after setColumnWidth or updateGroupsAndDisplayedColumns
  updateBodyWidths() {
    const e = this.getWidthOfColsInList(this.displayedColumnsCenter), t = this.getWidthOfColsInList(this.displayedColumnsLeft), r = this.getWidthOfColsInList(this.displayedColumnsRight);
    if (this.bodyWidthDirty = this.bodyWidth !== e, this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== r) {
      this.bodyWidth = e, this.leftWidth = t, this.rightWidth = r;
      const n = {
        type: A.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED
      };
      this.eventService.dispatchEvent(n);
      const o = {
        type: A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED
      };
      this.eventService.dispatchEvent(o);
    }
  }
  // + rowController
  getValueColumns() {
    return this.valueColumns ? this.valueColumns : [];
  }
  // + rowController
  getPivotColumns() {
    return this.pivotColumns ? this.pivotColumns : [];
  }
  // + clientSideRowModel
  isPivotActive() {
    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
  }
  // + toolPanel
  getRowGroupColumns() {
    return this.rowGroupColumns ? this.rowGroupColumns : [];
  }
  // + rowController -> while inserting rows
  getDisplayedCenterColumns() {
    return this.displayedColumnsCenter;
  }
  // + rowController -> while inserting rows
  getDisplayedLeftColumns() {
    return this.displayedColumnsLeft;
  }
  getDisplayedRightColumns() {
    return this.displayedColumnsRight;
  }
  // used by:
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getAllPrimaryColumns() {
    return this.primaryColumns ? this.primaryColumns : null;
  }
  getSecondaryColumns() {
    return this.secondaryColumns ? this.secondaryColumns : null;
  }
  getAllColumnsForQuickFilter() {
    return this.columnsForQuickFilter;
  }
  // + moveColumnController
  getAllGridColumns() {
    var e;
    return (e = this.gridColumns) != null ? e : [];
  }
  isRowGroupEmpty() {
    return Ni(this.rowGroupColumns);
  }
  setColumnsVisible(e, t = !1, r) {
    this.applyColumnState({
      state: e.map(
        (i) => ({
          colId: typeof i == "string" ? i : i.getColId(),
          hide: !t
        })
      )
    }, r);
  }
  setColumnsPinned(e, t, r) {
    if (!this.gridColumns)
      return;
    if (this.gos.isDomLayout("print")) {
      console.warn("AG Grid: Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let i;
    t === !0 || t === "left" ? i = "left" : t === "right" ? i = "right" : i = null, this.actionOnGridColumns(e, (n) => n.getPinned() !== i ? (n.setPinned(i), !0) : !1, r, () => ({
      type: A.EVENT_COLUMN_PINNED,
      pinned: i,
      column: null,
      columns: null,
      source: r
    })), this.columnAnimationService.finish();
  }
  // does an action on a set of columns. provides common functionality for looking up the
  // columns based on key, getting a list of effected columns, and then updated the event
  // with either one column (if it was just one col) or a list of columns
  // used by: autoResize, setVisible, setPinned
  actionOnGridColumns(e, t, r, i) {
    if (Ni(e))
      return;
    const n = [];
    if (e.forEach((o) => {
      if (!o)
        return;
      const s = this.getGridColumn(o);
      if (!s)
        return;
      t(s) !== !1 && n.push(s);
    }), !!n.length && (this.updateDisplayedColumns(r), q(i) && i)) {
      const o = i();
      o.columns = n, o.column = n.length === 1 ? n[0] : null, this.eventService.dispatchEvent(o);
    }
  }
  getDisplayedColBefore(e) {
    const t = this.getAllDisplayedColumns(), r = t.indexOf(e);
    return r > 0 ? t[r - 1] : null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getDisplayedColAfter(e) {
    const t = this.getAllDisplayedColumns(), r = t.indexOf(e);
    return r < t.length - 1 ? t[r + 1] : null;
  }
  getDisplayedGroupAtDirection(e, t) {
    const r = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), i = e.getDisplayedLeafColumns(), n = t === "After" ? ze(i) : i[0], o = `getDisplayedCol${t}`;
    for (; ; ) {
      const s = this[o](n);
      if (!s)
        return null;
      const a = this.getColumnGroupAtLevel(s, r);
      if (a !== e)
        return a;
    }
  }
  getColumnGroupAtLevel(e, t) {
    let r = e.getParent(), i, n;
    for (; i = r.getProvidedColumnGroup().getLevel(), n = r.getPaddingLevel(), !(i + n <= t); )
      r = r.getParent();
    return r;
  }
  isPinningLeft() {
    return this.displayedColumnsLeft.length > 0;
  }
  isPinningRight() {
    return this.displayedColumnsRight.length > 0;
  }
  getPrimaryAndSecondaryAndAutoColumns() {
    return [].concat(this.primaryColumns || [], this.groupAutoColumns || [], this.secondaryColumns || []);
  }
  createStateItemFromColumn(e) {
    const t = e.isRowGroupActive() ? this.rowGroupColumns.indexOf(e) : null, r = e.isPivotActive() ? this.pivotColumns.indexOf(e) : null, i = e.isValueActive() ? e.getAggFunc() : null, n = e.getSort() != null ? e.getSort() : null, o = e.getSortIndex() != null ? e.getSortIndex() : null, s = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return {
      colId: e.getColId(),
      width: e.getActualWidth(),
      hide: !e.isVisible(),
      pinned: e.getPinned(),
      sort: n,
      sortIndex: o,
      aggFunc: i,
      rowGroup: e.isRowGroupActive(),
      rowGroupIndex: t,
      pivot: e.isPivotActive(),
      pivotIndex: r,
      flex: s
    };
  }
  getColumnState() {
    if (Re(this.primaryColumns) || !this.isAlive())
      return [];
    const t = this.getPrimaryAndSecondaryAndAutoColumns().map(this.createStateItemFromColumn.bind(this));
    return this.orderColumnStateList(t), t;
  }
  orderColumnStateList(e) {
    const t = Wo(this.gridColumns.map((r, i) => [r.getColId(), i]));
    e.sort((r, i) => {
      const n = t.has(r.colId) ? t.get(r.colId) : -1, o = t.has(i.colId) ? t.get(i.colId) : -1;
      return n - o;
    });
  }
  resetColumnState(e) {
    if (Ni(this.primaryColumns))
      return;
    const t = this.getColumnsFromTree(this.primaryColumnTree), r = [];
    let i = 1e3, n = 1e3, o = [];
    this.groupAutoColumns && (o = o.concat(this.groupAutoColumns)), t && (o = o.concat(t)), o.forEach((s) => {
      const a = this.getColumnStateFromColDef(s);
      Re(a.rowGroupIndex) && a.rowGroup && (a.rowGroupIndex = i++), Re(a.pivotIndex) && a.pivot && (a.pivotIndex = n++), r.push(a);
    }), this.applyColumnState({ state: r, applyOrder: !0 }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (g, m) => g ?? m ?? null, r = e.getColDef(), i = t(r.sort, r.initialSort), n = t(r.sortIndex, r.initialSortIndex), o = t(r.hide, r.initialHide), s = t(r.pinned, r.initialPinned), a = t(r.width, r.initialWidth), l = t(r.flex, r.initialFlex);
    let u = t(r.rowGroupIndex, r.initialRowGroupIndex), c = t(r.rowGroup, r.initialRowGroup);
    u == null && (c == null || c == !1) && (u = null, c = null);
    let d = t(r.pivotIndex, r.initialPivotIndex), h = t(r.pivot, r.initialPivot);
    d == null && (h == null || h == !1) && (d = null, h = null);
    const p = t(r.aggFunc, r.initialAggFunc);
    return {
      colId: e.getColId(),
      sort: i,
      sortIndex: n,
      hide: o,
      pinned: s,
      width: a,
      flex: l,
      rowGroup: c,
      rowGroupIndex: u,
      pivot: h,
      pivotIndex: d,
      aggFunc: p
    };
  }
  applyColumnState(e, t) {
    if (Ni(this.primaryColumns))
      return !1;
    if (e && e.state && !e.state.forEach)
      return console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), !1;
    const r = (o, s, a) => {
      const l = this.compareColumnStatesAndDispatchEvents(t);
      this.autoGroupsNeedBuilding = !0;
      const u = s.slice(), c = {}, d = {}, h = [], p = [];
      let g = 0;
      const m = this.rowGroupColumns.slice(), f = this.pivotColumns.slice();
      o.forEach((b) => {
        const y = b.colId || "";
        if (y.startsWith(Kl)) {
          h.push(b), p.push(b);
          return;
        }
        const x = a(y);
        x ? (this.syncColumnWithStateItem(
          x,
          b,
          e.defaultState,
          c,
          d,
          !1,
          t
        ), Xr(u, x)) : (p.push(b), g += 1);
      });
      const C = (b) => this.syncColumnWithStateItem(
        b,
        null,
        e.defaultState,
        c,
        d,
        !1,
        t
      );
      u.forEach(C);
      const w = (b, y, S, x) => {
        const R = b[S.getId()], P = b[x.getId()], O = R != null, I = P != null;
        if (O && I)
          return R - P;
        if (O)
          return -1;
        if (I)
          return 1;
        const M = y.indexOf(S), _ = y.indexOf(x), G = M >= 0, F = _ >= 0;
        return G && F ? M - _ : G ? -1 : 1;
      };
      this.rowGroupColumns.sort(w.bind(this, c, m)), this.pivotColumns.sort(w.bind(this, d, f)), this.updateGridColumns();
      const E = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
      return h.forEach((b) => {
        const y = this.getAutoColumn(b.colId);
        Xr(E, y), this.syncColumnWithStateItem(y, b, e.defaultState, null, null, !0, t);
      }), E.forEach(C), this.applyOrderAfterApplyState(e), this.updateDisplayedColumns(t), this.dispatchEverythingChanged(t), l(), { unmatchedAndAutoStates: p, unmatchedCount: g };
    };
    this.columnAnimationService.start();
    let {
      unmatchedAndAutoStates: i,
      unmatchedCount: n
    } = r(e.state || [], this.primaryColumns || [], (o) => this.getPrimaryColumn(o));
    return (i.length > 0 || q(e.defaultState)) && (n = r(
      i,
      this.secondaryColumns || [],
      (o) => this.getSecondaryColumn(o)
    ).unmatchedCount), this.columnAnimationService.finish(), n === 0;
  }
  applyOrderAfterApplyState(e) {
    if (!e.applyOrder || !e.state)
      return;
    let t = [];
    const r = {};
    e.state.forEach((n) => {
      if (!n.colId || r[n.colId])
        return;
      const o = this.gridColumnsMap[n.colId];
      o && (t.push(o), r[n.colId] = !0);
    });
    let i = 0;
    if (this.gridColumns.forEach((n) => {
      const o = n.getColId();
      if (r[o] != null)
        return;
      o.startsWith(Kl) ? Td(t, n, i++) : t.push(n);
    }), t = this.placeLockedColumns(t), !this.doesMovePassMarryChildren(t)) {
      console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
      return;
    }
    this.gridColumns = t;
  }
  compareColumnStatesAndDispatchEvents(e) {
    const t = {
      rowGroupColumns: this.rowGroupColumns.slice(),
      pivotColumns: this.pivotColumns.slice(),
      valueColumns: this.valueColumns.slice()
    }, r = this.getColumnState(), i = {};
    return r.forEach((n) => {
      i[n.colId] = n;
    }), () => {
      const n = this.getPrimaryAndSecondaryAndAutoColumns(), o = (m, f, C, w) => {
        const E = f.map(w), b = C.map(w);
        if (On(E, b))
          return;
        const S = new Set(f);
        C.forEach((P) => {
          S.delete(P) || S.add(P);
        });
        const x = [...S], R = {
          type: m,
          columns: x,
          column: x.length === 1 ? x[0] : null,
          source: e
        };
        this.eventService.dispatchEvent(R);
      }, s = (m) => {
        const f = [];
        return n.forEach((C) => {
          const w = i[C.getColId()];
          w && m(w, C) && f.push(C);
        }), f;
      }, a = (m) => m.getColId();
      o(
        A.EVENT_COLUMN_ROW_GROUP_CHANGED,
        t.rowGroupColumns,
        this.rowGroupColumns,
        a
      ), o(
        A.EVENT_COLUMN_PIVOT_CHANGED,
        t.pivotColumns,
        this.pivotColumns,
        a
      );
      const u = s((m, f) => {
        const C = m.aggFunc != null, w = C != f.isValueActive(), E = C && m.aggFunc != f.getAggFunc();
        return w || E;
      });
      u.length > 0 && this.dispatchColumnChangedEvent(A.EVENT_COLUMN_VALUE_CHANGED, u, e);
      const c = (m, f) => m.width != f.getActualWidth();
      this.dispatchColumnResizedEvent(s(c), !0, e);
      const d = (m, f) => m.pinned != f.getPinned();
      this.dispatchColumnPinnedEvent(s(d), e);
      const h = (m, f) => m.hide == f.isVisible();
      this.dispatchColumnVisibleEvent(s(h), e);
      const g = s((m, f) => m.sort != f.getSort() || m.sortIndex != f.getSortIndex());
      g.length > 0 && this.sortController.dispatchSortChangedEvents(e, g), this.normaliseColumnMovedEventForColumnState(r, e);
    };
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0)
      return;
    const r = t(e[0]);
    for (let i = 1; i < e.length; i++)
      if (r !== t(e[i]))
        return;
    return r;
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const r = this.getColumnState(), i = {};
    r.forEach((l) => i[l.colId] = l);
    const n = {};
    e.forEach((l) => {
      i[l.colId] && (n[l.colId] = !0);
    });
    const o = e.filter((l) => n[l.colId]), s = r.filter((l) => n[l.colId]), a = [];
    s.forEach((l, u) => {
      const c = o && o[u];
      if (c && c.colId !== l.colId) {
        const d = this.getGridColumn(c.colId);
        d && a.push(d);
      }
    }), a.length && this.dispatchColumnMovedEvent({ movedColumns: a, source: t, finished: !0 });
  }
  syncColumnWithStateItem(e, t, r, i, n, o, s) {
    var a;
    if (!e)
      return;
    const l = (b, y) => {
      const S = { value1: void 0, value2: void 0 };
      let x = !1;
      return t && (t[b] !== void 0 && (S.value1 = t[b], x = !0), q(y) && t[y] !== void 0 && (S.value2 = t[y], x = !0)), !x && r && (r[b] !== void 0 && (S.value1 = r[b]), q(y) && r[y] !== void 0 && (S.value2 = r[y])), S;
    }, u = l("hide").value1;
    u !== void 0 && e.setVisible(!u, s);
    const c = l("pinned").value1;
    c !== void 0 && e.setPinned(c);
    const d = (a = e.getColDef().minWidth) != null ? a : this.environment.getMinColWidth(), h = l("flex").value1;
    if (h !== void 0 && e.setFlex(h), h == null) {
      const b = l("width").value1;
      b != null && d != null && b >= d && e.setActualWidth(b, s);
    }
    const p = l("sort").value1;
    p !== void 0 && (p === "desc" || p === "asc" ? e.setSort(p, s) : e.setSort(void 0, s));
    const g = l("sortIndex").value1;
    if (g !== void 0 && e.setSortIndex(g), o || !e.isPrimary())
      return;
    const m = l("aggFunc").value1;
    m !== void 0 && (typeof m == "string" ? (e.setAggFunc(m), e.isValueActive() || (e.setValueActive(!0, s), this.valueColumns.push(e))) : (q(m) && console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), e.isValueActive() && (e.setValueActive(!1, s), Xr(this.valueColumns, e))));
    const { value1: f, value2: C } = l("rowGroup", "rowGroupIndex");
    (f !== void 0 || C !== void 0) && (typeof C == "number" || f ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, s), this.rowGroupColumns.push(e)), i && typeof C == "number" && (i[e.getId()] = C)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, s), Xr(this.rowGroupColumns, e)));
    const { value1: w, value2: E } = l("pivot", "pivotIndex");
    (w !== void 0 || E !== void 0) && (typeof E == "number" || w ? (e.isPivotActive() || (e.setPivotActive(!0, s), this.pivotColumns.push(e)), n && typeof E == "number" && (n[e.getId()] = E)) : e.isPivotActive() && (e.setPivotActive(!1, s), Xr(this.pivotColumns, e)));
  }
  getGridColumns(e) {
    return this.getColumns(e, this.getGridColumn.bind(this));
  }
  getColumns(e, t) {
    const r = [];
    return e && e.forEach((i) => {
      const n = t(i);
      n && r.push(n);
    }), r;
  }
  // used by growGroupPanel
  getColumnWithValidation(e) {
    if (e == null)
      return null;
    const t = this.getGridColumn(e);
    return t || console.warn("AG Grid: could not find column " + e), t;
  }
  getPrimaryColumn(e) {
    return this.primaryColumns ? this.getColumn(e, this.primaryColumns, this.primaryColumnsMap) : null;
  }
  getGridColumn(e) {
    return this.getColumn(e, this.gridColumns, this.gridColumnsMap);
  }
  lookupGridColumn(e) {
    return this.gridColumnsMap[e];
  }
  getSecondaryColumn(e) {
    return this.secondaryColumns ? this.getColumn(e, this.secondaryColumns, this.secondaryColumnsMap) : null;
  }
  getColumn(e, t, r) {
    if (!e || !r)
      return null;
    if (typeof e == "string" && r[e])
      return r[e];
    for (let i = 0; i < t.length; i++)
      if (this.columnsMatch(t[i], e))
        return t[i];
    return this.getAutoColumn(e);
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    if (t === !0)
      return this.rowGroupColumns.slice(0);
    const r = this.getPrimaryColumn(t);
    return r ? [r] : null;
  }
  getAutoColumn(e) {
    return !this.groupAutoColumns || !q(this.groupAutoColumns) || Re(this.groupAutoColumns) ? null : this.groupAutoColumns.find((t) => this.columnsMatch(t, e)) || null;
  }
  columnsMatch(e, t) {
    const r = e === t, i = e.getColDef() === t, n = e.getColId() == t;
    return r || i || n;
  }
  getDisplayNameForColumn(e, t, r = !1) {
    if (!e)
      return null;
    const i = this.getHeaderName(e.getColDef(), e, null, null, t);
    return r ? this.wrapHeaderNameWithAggFunc(e, i) : i;
  }
  getDisplayNameForProvidedColumnGroup(e, t, r) {
    const i = t ? t.getColGroupDef() : null;
    return i ? this.getHeaderName(i, null, e, t, r) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, r, i, n) {
    const o = e.headerValueGetter;
    if (o) {
      const s = this.gos.addGridCommonParams({
        colDef: e,
        column: t,
        columnGroup: r,
        providedColumnGroup: i,
        location: n
      });
      return typeof o == "function" ? o(s) : typeof o == "string" ? this.expressionService.evaluate(o, s) : (console.warn("AG Grid: headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return ZF(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const r = e.getColDef().pivotValueColumn, i = q(r);
    let n = null, o;
    if (i) {
      const s = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && this.valueColumns.length === 1, a = e.getColDef().pivotTotalColumnIds !== void 0;
      if (s && !a)
        return t;
      n = r ? r.getAggFunc() : null, o = !0;
    } else {
      const s = e.isValueActive(), a = this.pivotMode || !this.isRowGroupEmpty();
      s && a ? (n = e.getAggFunc(), o = !0) : o = !1;
    }
    if (o) {
      const s = typeof n == "string" ? n : "func";
      return `${this.localeService.getLocaleTextFunc()(s, s)}(${t})`;
    }
    return t;
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (e instanceof ur)
      return e;
    const r = this.getAllDisplayedTrees(), i = typeof t == "number";
    let n = null;
    return Ts(r, !1, (o) => {
      if (o instanceof ur) {
        const s = o;
        let a;
        i ? a = e === s.getGroupId() && t === s.getPartId() : a = e === s.getGroupId(), a && (n = s);
      }
    }), n;
  }
  isReady() {
    return this.ready;
  }
  extractValueColumns(e, t) {
    this.valueColumns = this.extractColumns(
      t,
      this.valueColumns,
      (r, i) => r.setValueActive(i, e),
      // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
      () => {
      },
      () => {
      },
      // aggFunc is a string, so return it's existence
      (r) => {
        const i = r.aggFunc;
        if (i === null || i === "")
          return null;
        if (i !== void 0)
          return !!i;
      },
      (r) => r.initialAggFunc != null && r.initialAggFunc != ""
    ), this.valueColumns.forEach((r) => {
      const i = r.getColDef();
      i.aggFunc != null && i.aggFunc != "" ? r.setAggFunc(i.aggFunc) : r.getAggFunc() || r.setAggFunc(i.initialAggFunc);
    });
  }
  extractRowGroupColumns(e, t) {
    this.rowGroupColumns = this.extractColumns(
      t,
      this.rowGroupColumns,
      (r, i) => r.setRowGroupActive(i, e),
      (r) => r.rowGroupIndex,
      (r) => r.initialRowGroupIndex,
      (r) => r.rowGroup,
      (r) => r.initialRowGroup
    );
  }
  extractColumns(e = [], t = [], r, i, n, o, s) {
    const a = [], l = [];
    (this.primaryColumns || []).forEach((d) => {
      const h = e.indexOf(d) < 0, p = d.getColDef(), g = rg(o(p)), m = rg(s(p)), f = Yo(i(p)), C = Yo(n(p));
      let w;
      g !== void 0 ? w = g : f !== void 0 ? f === null ? w = !1 : w = f >= 0 : h ? m !== void 0 ? w = m : C !== void 0 ? w = C != null && C >= 0 : w = !1 : w = t.indexOf(d) >= 0, w && ((h ? f != null || C != null : f != null) ? a.push(d) : l.push(d));
    });
    const u = (d) => {
      const h = i(d.getColDef()), p = n(d.getColDef());
      return h ?? p;
    };
    a.sort((d, h) => {
      const p = u(d), g = u(h);
      return p === g ? 0 : p < g ? -1 : 1;
    });
    const c = [].concat(a);
    return t.forEach((d) => {
      l.indexOf(d) >= 0 && c.push(d);
    }), l.forEach((d) => {
      c.indexOf(d) < 0 && c.push(d);
    }), t.forEach((d) => {
      c.indexOf(d) < 0 && r(d, !1);
    }), c.forEach((d) => {
      t.indexOf(d) < 0 && r(d, !0);
    }), c;
  }
  extractPivotColumns(e, t) {
    this.pivotColumns = this.extractColumns(
      t,
      this.pivotColumns,
      (r, i) => r.setPivotActive(i, e),
      (r) => r.pivotIndex,
      (r) => r.initialPivotIndex,
      (r) => r.pivot,
      (r) => r.initialPivot
    );
  }
  resetColumnGroupState(e) {
    if (!this.primaryColumnTree)
      return;
    const t = [];
    io(null, this.primaryColumnTree, (r) => {
      if (r instanceof Ut) {
        const i = r.getColGroupDef(), n = {
          groupId: r.getGroupId(),
          open: i ? i.openByDefault : void 0
        };
        t.push(n);
      }
    }), this.setColumnGroupState(t, e);
  }
  getColumnGroupState() {
    const e = [];
    return io(null, this.gridBalancedTree, (t) => {
      t instanceof Ut && e.push({
        groupId: t.getGroupId(),
        open: t.isExpanded()
      });
    }), e;
  }
  setColumnGroupState(e, t) {
    if (!this.gridBalancedTree)
      return;
    this.columnAnimationService.start();
    const r = [];
    if (e.forEach((i) => {
      const n = i.groupId, o = i.open, s = this.getProvidedColumnGroup(n);
      s && s.isExpanded() !== o && (this.logger.log("columnGroupOpened(" + s.getGroupId() + "," + o + ")"), s.setExpanded(o), r.push(s));
    }), this.updateGroupsAndDisplayedColumns(t), this.setFirstRightAndLastLeftPinned(t), r.length) {
      const i = {
        type: A.EVENT_COLUMN_GROUP_OPENED,
        columnGroup: Ut.length === 1 ? r[0] : void 0,
        columnGroups: r
      };
      this.eventService.dispatchEvent(i);
    }
    this.columnAnimationService.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, r) {
    let i;
    e instanceof Ut ? i = e.getId() : i = e || "", this.setColumnGroupState([{ groupId: i, open: t }], r);
  }
  getProvidedColumnGroup(e) {
    typeof e != "string" && console.error("AG Grid: group key must be a string");
    let t = null;
    return io(null, this.gridBalancedTree, (r) => {
      r instanceof Ut && r.getId() === e && (t = r);
    }), t;
  }
  calculateColumnsForDisplay() {
    let e;
    return this.pivotMode && Re(this.secondaryColumns) ? e = this.gridColumns.filter((t) => {
      const r = this.groupAutoColumns && yi(this.groupAutoColumns, t), i = this.valueColumns && yi(this.valueColumns, t);
      return r || i;
    }) : e = this.gridColumns.filter((t) => this.groupAutoColumns && yi(this.groupAutoColumns, t) || t.isVisible()), e;
  }
  checkColSpanActiveInCols(e) {
    let t = !1;
    return e.forEach((r) => {
      q(r.getColDef().colSpan) && (t = !0);
    }), t;
  }
  calculateColumnsForGroupDisplay() {
    this.groupDisplayColumns = [], this.groupDisplayColumnsMap = {};
    const e = (t) => {
      const r = t.getColDef(), i = r.showRowGroup;
      r && q(i) && (this.groupDisplayColumns.push(t), typeof i == "string" ? this.groupDisplayColumnsMap[i] = t : i === !0 && this.getRowGroupColumns().forEach((n) => {
        this.groupDisplayColumnsMap[n.getId()] = t;
      }));
    };
    this.gridColumns.forEach(e);
  }
  getGroupDisplayColumns() {
    return this.groupDisplayColumns;
  }
  getGroupDisplayColumnForGroup(e) {
    return this.groupDisplayColumnsMap[e];
  }
  updateDisplayedColumns(e) {
    const t = this.calculateColumnsForDisplay();
    this.buildDisplayedTrees(t), this.updateGroupsAndDisplayedColumns(e), this.setFirstRightAndLastLeftPinned(e);
  }
  isSecondaryColumnsPresent() {
    return q(this.secondaryColumns);
  }
  setSecondaryColumns(e, t) {
    if (!this.gridColumns)
      return;
    const r = e;
    if (!(!r && Re(this.secondaryColumns))) {
      if (r) {
        this.processSecondaryColumnDefinitions(e);
        const i = this.columnFactory.createColumnTree(
          e,
          !1,
          this.secondaryBalancedTree || this.previousSecondaryColumns || void 0,
          t
        );
        this.destroyOldColumns(this.secondaryBalancedTree, i.columnTree), this.secondaryBalancedTree = i.columnTree, this.secondaryHeaderRowCount = i.treeDept + 1, this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree), this.secondaryColumnsMap = {}, this.secondaryColumns.forEach((n) => this.secondaryColumnsMap[n.getId()] = n), this.previousSecondaryColumns = null;
      } else
        this.previousSecondaryColumns = this.secondaryBalancedTree, this.secondaryBalancedTree = null, this.secondaryHeaderRowCount = -1, this.secondaryColumns = null, this.secondaryColumnsMap = {};
      this.updateGridColumns(), this.updateDisplayedColumns(t);
    }
  }
  processSecondaryColumnDefinitions(e) {
    const t = this.gos.get("processPivotResultColDef"), r = this.gos.get("processPivotResultColGroupDef");
    if (!t && !r)
      return;
    const i = (n) => {
      n.forEach((o) => {
        if (q(o.children)) {
          const a = o;
          r && r(a), i(a.children);
        } else
          t && t(o);
      });
    };
    e && i(e);
  }
  // called from: applyColumnState, setColumnDefs, setSecondaryColumns
  updateGridColumns() {
    const e = this.gridBalancedTree;
    if (this.gridColsArePrimary ? this.lastPrimaryOrder = this.gridColumns : this.lastSecondaryOrder = this.gridColumns, this.createGroupAutoColumnsIfNeeded()) {
      const i = Wo(this.groupAutoColumns.map((n) => [n, !0]));
      this.lastPrimaryOrder && (this.lastPrimaryOrder = this.lastPrimaryOrder.filter((n) => !i.has(n)), this.lastPrimaryOrder = [...this.groupAutoColumns, ...this.lastPrimaryOrder]), this.lastSecondaryOrder && (this.lastSecondaryOrder = this.lastSecondaryOrder.filter((n) => !i.has(n)), this.lastSecondaryOrder = [...this.groupAutoColumns, ...this.lastSecondaryOrder]);
    }
    let r;
    if (this.secondaryColumns && this.secondaryBalancedTree) {
      const i = this.secondaryColumns.some((n) => this.gridColumnsMap[n.getColId()] !== void 0);
      this.gridBalancedTree = this.secondaryBalancedTree.slice(), this.gridHeaderRowCount = this.secondaryHeaderRowCount, this.gridColumns = this.secondaryColumns.slice(), this.gridColsArePrimary = !1, i && (r = this.lastSecondaryOrder);
    } else this.primaryColumns && (this.gridBalancedTree = this.primaryColumnTree.slice(), this.gridHeaderRowCount = this.primaryHeaderRowCount, this.gridColumns = this.primaryColumns.slice(), this.gridColsArePrimary = !0, r = this.lastPrimaryOrder);
    if (this.addAutoGroupToGridColumns(), this.orderGridColsLike(r), this.gridColumns = this.placeLockedColumns(this.gridColumns), this.calculateColumnsForGroupDisplay(), this.refreshQuickFilterColumns(), this.clearDisplayedAndViewportColumns(), this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns), this.gridColumnsMap = {}, this.gridColumns.forEach((i) => this.gridColumnsMap[i.getId()] = i), this.setAutoHeightActive(), !On(e, this.gridBalancedTree)) {
      const i = {
        type: A.EVENT_GRID_COLUMNS_CHANGED
      };
      this.eventService.dispatchEvent(i);
    }
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.gridColumns.filter((e) => e.isAutoHeight()).length > 0, this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = !0, this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide") || we("autoHeight columns only work with Client Side Row Model and Server Side Row Model."));
  }
  orderGridColsLike(e) {
    if (Re(e))
      return;
    const t = Wo(e.map((l, u) => [l, u]));
    let r = !0;
    if (this.gridColumns.forEach((l) => {
      t.has(l) && (r = !1);
    }), r)
      return;
    const i = Wo(this.gridColumns.map((l) => [l, !0])), n = e.filter((l) => i.has(l)), o = Wo(n.map((l) => [l, !0])), s = this.gridColumns.filter((l) => !o.has(l)), a = n.slice();
    s.forEach((l) => {
      let u = l.getOriginalParent();
      if (!u) {
        a.push(l);
        return;
      }
      const c = [];
      for (; !c.length && u; )
        u.getLeafColumns().forEach((g) => {
          const m = a.indexOf(g) >= 0, f = c.indexOf(g) < 0;
          m && f && c.push(g);
        }), u = u.getOriginalParent();
      if (!c.length) {
        a.push(l);
        return;
      }
      const d = c.map((p) => a.indexOf(p)), h = Math.max(...d);
      Td(a, l, h + 1);
    }), this.gridColumns = a;
  }
  isPrimaryColumnGroupsPresent() {
    return this.primaryHeaderRowCount > 1;
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshQuickFilterColumns() {
    var e;
    let t = (e = this.isPivotMode() && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? this.secondaryColumns : this.primaryColumns) != null ? e : [];
    this.groupAutoColumns && (t = t.concat(this.groupAutoColumns)), this.columnsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? t : t.filter((r) => r.isVisible() || r.isRowGroupActive());
  }
  placeLockedColumns(e) {
    const t = [], r = [], i = [];
    return e.forEach((n) => {
      const o = n.getColDef().lockPosition;
      o === "right" ? i.push(n) : o === "left" || o === !0 ? t.push(n) : r.push(n);
    }), [...t, ...r, ...i];
  }
  addAutoGroupToGridColumns() {
    if (Re(this.groupAutoColumns)) {
      this.destroyOldColumns(this.groupAutoColsBalancedTree), this.groupAutoColsBalancedTree = null;
      return;
    }
    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
    const e = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
    this.destroyOldColumns(this.groupAutoColsBalancedTree, e), this.groupAutoColsBalancedTree = e, this.gridBalancedTree = e.concat(this.gridBalancedTree);
  }
  // gets called after we copy down grid columns, to make sure any part of the gui
  // that tries to draw, eg the header, it will get empty lists of columns rather
  // than stale columns. for example, the header will received gridColumnsChanged
  // event, so will try and draw, but it will draw successfully when it acts on the
  // virtualColumnsChanged event
  clearDisplayedAndViewportColumns() {
    this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.ariaOrderColumns = [], this.viewportColumns = [], this.headerViewportColumns = [], this.viewportColumnsHash = "";
  }
  updateGroupsAndDisplayedColumns(e) {
    this.updateOpenClosedVisibilityInColumnGroups(), this.deriveDisplayedColumns(e), this.refreshFlexedColumns(), this.extractViewport(), this.updateBodyWidths();
    const t = {
      type: A.EVENT_DISPLAYED_COLUMNS_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  deriveDisplayedColumns(e) {
    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight), this.joinColumnsAriaOrder(), this.joinDisplayedColumns(), this.setLeftValues(e), this.displayedAutoHeightCols = this.displayedColumns.filter((t) => t.isAutoHeight());
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  joinColumnsAriaOrder() {
    const e = this.getAllGridColumns(), t = [], r = [], i = [];
    for (const n of e) {
      const o = n.getPinned();
      o ? o === !0 || o === "left" ? t.push(n) : i.push(n) : r.push(n);
    }
    this.ariaOrderColumns = t.concat(r).concat(i);
  }
  joinDisplayedColumns() {
    this.gos.get("enableRtl") ? this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft) : this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfColumns(e), this.setLeftValuesOfGroups();
  }
  setLeftValuesOfColumns(e) {
    if (!this.primaryColumns)
      return;
    const t = this.getPrimaryAndSecondaryAndAutoColumns().slice(0), r = this.gos.get("enableRtl");
    [
      this.displayedColumnsLeft,
      this.displayedColumnsRight,
      this.displayedColumnsCenter
    ].forEach((i) => {
      if (r) {
        let n = this.getWidthOfColsInList(i);
        i.forEach((o) => {
          n -= o.getActualWidth(), o.setLeft(n, e);
        });
      } else {
        let n = 0;
        i.forEach((o) => {
          o.setLeft(n, e), n += o.getActualWidth();
        });
      }
      BF(t, i);
    }), t.forEach((i) => {
      i.setLeft(null, e);
    });
  }
  setLeftValuesOfGroups() {
    [
      this.displayedTreeLeft,
      this.displayedTreeRight,
      this.displayedTreeCentre
    ].forEach((e) => {
      e.forEach((t) => {
        t instanceof ur && t.checkLeft();
      });
    });
  }
  derivedDisplayedColumnsFromDisplayedTree(e, t) {
    t.length = 0, Ts(e, !0, (r) => {
      r instanceof ct && t.push(r);
    });
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  extractViewportColumns() {
    this.isColumnVirtualisationSuppressed() ? (this.viewportColumnsCenter = this.displayedColumnsCenter, this.headerViewportColumnsCenter = this.displayedColumnsCenter) : (this.viewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this)), this.headerViewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this))), this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight), this.headerViewportColumns = this.headerViewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
  }
  getVirtualHeaderGroupRow(e, t) {
    let r;
    switch (e) {
      case "left":
        r = this.viewportRowLeft[t];
        break;
      case "right":
        r = this.viewportRowRight[t];
        break;
      default:
        r = this.viewportRowCenter[t];
        break;
    }
    return Re(r) && (r = []), r;
  }
  calculateHeaderRows() {
    this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {};
    const e = {};
    this.headerViewportColumns.forEach((r) => e[r.getId()] = !0);
    const t = (r, i, n) => {
      let o = !1;
      for (let s = 0; s < r.length; s++) {
        const a = r[s];
        let l = !1;
        if (a instanceof ct)
          l = e[a.getId()] === !0;
        else {
          const c = a.getDisplayedChildren();
          c && (l = t(c, i, n + 1));
        }
        l && (o = !0, i[n] || (i[n] = []), i[n].push(a));
      }
      return o;
    };
    t(this.displayedTreeLeft, this.viewportRowLeft, 0), t(this.displayedTreeRight, this.viewportRowRight, 0), t(this.displayedTreeCentre, this.viewportRowCenter, 0);
  }
  extractViewport() {
    const e = (i) => `${i.getId()}-${i.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.viewportColumns.map(e).join("#"), r = this.viewportColumnsHash !== t;
    return r && (this.viewportColumnsHash = t, this.calculateHeaderRows()), r;
  }
  refreshFlexedColumns(e = {}) {
    var t;
    const r = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth)
      return [];
    let i = -1;
    if (e.resizingCols) {
      const h = new Set(e.resizingCols);
      let p = this.displayedColumnsCenter;
      for (let g = p.length - 1; g >= 0; g--)
        if (h.has(p[g])) {
          i = g;
          break;
        }
    }
    let n = 0, o = [], s = 0, a = 0;
    for (let h = 0; h < this.displayedColumnsCenter.length; h++)
      this.displayedColumnsCenter[h].getFlex() && h > i ? (o.push(this.displayedColumnsCenter[h]), a += this.displayedColumnsCenter[h].getFlex(), s += (t = this.displayedColumnsCenter[h].getMinWidth()) != null ? t : 0) : n += this.displayedColumnsCenter[h].getActualWidth();
    if (!o.length)
      return [];
    let l = [];
    n + s > this.flexViewportWidth && (o.forEach((h) => {
      var p;
      return h.setActualWidth((p = h.getMinWidth()) != null ? p : 0, r);
    }), l = o, o = []);
    const u = [];
    let c;
    e:
      for (; ; ) {
        c = this.flexViewportWidth - n;
        const h = c / a;
        for (let p = 0; p < o.length; p++) {
          const g = o[p], m = h * g.getFlex();
          let f = 0;
          const C = g.getMinWidth(), w = g.getMaxWidth();
          if (q(C) && m < C ? f = C : q(w) && m > w && (f = w), f) {
            g.setActualWidth(f, r), GS(o, g), a -= g.getFlex(), l.push(g), n += g.getActualWidth();
            continue e;
          }
          u[p] = Math.round(m);
        }
        break;
      }
    let d = c;
    return o.forEach((h, p) => {
      h.setActualWidth(Math.min(u[p], d), r), l.push(h), d -= u[p];
    }), e.skipSetLeft || this.setLeftValues(r), e.updateBodyWidths && this.updateBodyWidths(), e.fireResizedEvent && this.dispatchColumnResizedEvent(l, !0, r, o), o;
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", r, i) {
    var n, o, s, a, l;
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.sizeColumnsToFit(e, t, r, i));
      return;
    }
    const u = {};
    i && ((n = i == null ? void 0 : i.columnLimits) == null || n.forEach((C) => {
      var w = C, { key: E } = w, b = Ane(w, ["key"]);
      u[typeof E == "string" ? E : E.getColId()] = b;
    }));
    const c = this.getAllDisplayedColumns(), d = e === this.getWidthOfColsInList(c);
    if (e <= 0 || !c.length || d)
      return;
    const h = [], p = [];
    c.forEach((C) => {
      C.getColDef().suppressSizeToFit === !0 ? p.push(C) : h.push(C);
    });
    const g = h.slice(0);
    let m = !1;
    const f = (C) => {
      Xr(h, C), p.push(C);
    };
    for (h.forEach((C) => {
      var w, E;
      C.resetActualWidth(t);
      const b = u == null ? void 0 : u[C.getId()], y = (w = b == null ? void 0 : b.minWidth) != null ? w : i == null ? void 0 : i.defaultMinWidth, S = (E = b == null ? void 0 : b.maxWidth) != null ? E : i == null ? void 0 : i.defaultMaxWidth, x = C.getActualWidth();
      typeof y == "number" && x < y ? C.setActualWidth(y, t, !0) : typeof S == "number" && x > S && C.setActualWidth(S, t, !0);
    }); !m; ) {
      m = !0;
      const C = e - this.getWidthOfColsInList(p);
      if (C <= 0)
        h.forEach((w) => {
          var E, b;
          const y = (b = (E = u == null ? void 0 : u[w.getId()]) == null ? void 0 : E.minWidth) != null ? b : i == null ? void 0 : i.defaultMinWidth;
          if (typeof y == "number") {
            w.setActualWidth(y, t, !0);
            return;
          }
          w.setMinimum(t);
        });
      else {
        const w = C / this.getWidthOfColsInList(h);
        let E = C;
        for (let b = h.length - 1; b >= 0; b--) {
          const y = h[b], S = u == null ? void 0 : u[y.getId()], x = (o = S == null ? void 0 : S.minWidth) != null ? o : i == null ? void 0 : i.defaultMinWidth, R = (s = S == null ? void 0 : S.maxWidth) != null ? s : i == null ? void 0 : i.defaultMaxWidth, P = (a = y.getMinWidth()) != null ? a : 0, O = (l = y.getMaxWidth()) != null ? l : Number.MAX_VALUE, I = typeof x == "number" && x > P ? x : y.getMinWidth(), M = typeof R == "number" && R < O ? R : y.getMaxWidth();
          let _ = Math.round(y.getActualWidth() * w);
          q(I) && _ < I ? (_ = I, f(y), m = !1) : q(M) && _ > M ? (_ = M, f(y), m = !1) : b === 0 && (_ = E), y.setActualWidth(_, t, !0), E -= _;
        }
      }
    }
    g.forEach((C) => {
      C.fireColumnWidthChangedEvent(t);
    }), this.setLeftValues(t), this.updateBodyWidths(), !r && this.dispatchColumnResizedEvent(g, !0, t);
  }
  buildDisplayedTrees(e) {
    const t = [], r = [], i = [];
    e.forEach((o) => {
      switch (o.getPinned()) {
        case "left":
          t.push(o);
          break;
        case "right":
          r.push(o);
          break;
        default:
          i.push(o);
          break;
      }
    });
    const n = new KF();
    this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(
      t,
      n,
      "left",
      this.displayedTreeLeft
    ), this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(
      r,
      n,
      "right",
      this.displayedTreeRight
    ), this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(
      i,
      n,
      null,
      this.displayedTreeCentre
    ), this.updateDisplayedMap();
  }
  updateDisplayedMap() {
    this.displayedColumnsAndGroupsMap = {};
    const e = (t) => {
      this.displayedColumnsAndGroupsMap[t.getUniqueId()] = t;
    };
    Ts(this.displayedTreeCentre, !1, e), Ts(this.displayedTreeLeft, !1, e), Ts(this.displayedTreeRight, !1, e);
  }
  isDisplayed(e) {
    return this.displayedColumnsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllDisplayedTrees();
    Ts(e, !1, (t) => {
      t instanceof ur && t.calculateDisplayedColumns();
    });
  }
  getGroupAutoColumns() {
    return this.groupAutoColumns;
  }
  /**
   * Creates new auto group columns if required
   * @returns whether auto cols have changed
   */
  createGroupAutoColumnsIfNeeded() {
    const e = this.forceRecreateAutoGroups;
    if (this.forceRecreateAutoGroups = !1, !this.autoGroupsNeedBuilding)
      return !1;
    this.autoGroupsNeedBuilding = !1;
    const t = this.gos.isGroupUseEntireRow(this.pivotMode), r = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isGroupSuppressAutoColumn();
    if ((this.rowGroupColumns.length > 0 || this.gos.get("treeData")) && !r && !t) {
      const o = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);
      if (!this.autoColsEqual(o, this.groupAutoColumns) || e)
        return this.groupAutoColumns = o, !0;
    } else
      this.groupAutoColumns = null;
    return !1;
  }
  isGroupSuppressAutoColumn() {
    return this.gos.get("groupDisplayType") === "custom" ? !0 : this.gos.get("treeDataDisplayType") === "custom";
  }
  autoColsEqual(e, t) {
    return On(e, t, (r, i) => r.getColId() === i.getColId());
  }
  getWidthOfColsInList(e) {
    return e.reduce((t, r) => t + r.getActualWidth(), 0);
  }
  getFirstDisplayedColumn() {
    const e = this.gos.get("enableRtl"), t = [
      "getDisplayedLeftColumns",
      "getDisplayedCenterColumns",
      "getDisplayedRightColumns"
    ];
    e && t.reverse();
    for (let r = 0; r < t.length; r++) {
      const i = this[t[r]]();
      if (i.length)
        return e ? ze(i) : i[0];
    }
    return null;
  }
  setColumnHeaderHeight(e, t) {
    if (e.setAutoHeaderHeight(t)) {
      const i = {
        type: A.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
        column: e,
        columns: [e],
        source: "autosizeColumnHeaderHeight"
      };
      this.eventService.dispatchEvent(i);
    }
  }
  getColumnGroupHeaderRowHeight() {
    return this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), t = this.getAllDisplayedColumns().filter((r) => r.isAutoHeaderHeight()).map((r) => r.getAutoHeaderHeight() || 0);
    return Math.max(e, ...t);
  }
  getHeaderHeight() {
    var e;
    return (e = this.gos.get("headerHeight")) != null ? e : this.environment.getFromTheme(25, "headerHeight");
  }
  getFloatingFiltersHeight() {
    var e;
    return (e = this.gos.get("floatingFiltersHeight")) != null ? e : this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    var e;
    return (e = this.gos.get("groupHeaderHeight")) != null ? e : this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    var e;
    return (e = this.gos.get("pivotHeaderHeight")) != null ? e : this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    var e;
    return (e = this.gos.get("pivotGroupHeaderHeight")) != null ? e : this.getGroupHeaderHeight();
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  resetColumnDefIntoColumn(e, t) {
    const r = e.getUserProvidedColDef();
    if (!r)
      return !1;
    const i = this.columnFactory.addColumnDefaultAndTypes(r, e.getColId());
    return e.setColDef(i, r, t), !0;
  }
  isColumnGroupingLocked(e) {
    const t = this.gos.get("groupLockGroupColumns");
    if (!e.isRowGroupActive() || t === 0)
      return !1;
    if (t === -1)
      return !0;
    const r = this.rowGroupColumns.findIndex((i) => i.getColId() === e.getColId());
    return t > r;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    let r = {};
    const i = (n, o, s, a, l, u) => {
      if (!o.length || !this.primaryColumns)
        return [];
      const c = Object.keys(n), d = new Set(c), h = new Set(c), p = new Set(o.map((y) => {
        const S = y.getColId();
        return h.delete(S), S;
      }).concat(c)), g = [], m = {};
      let f = 0;
      for (let y = 0; y < this.primaryColumns.length; y++) {
        const S = this.primaryColumns[y].getColId();
        p.has(S) && (g.push(S), m[S] = f++);
      }
      let C = 1e3, w = !1, E = 0;
      const b = (y) => {
        const S = m[y];
        for (let x = E; x < S; x++) {
          const R = g[x];
          h.has(R) && (n[R][l] = C++, h.delete(R));
        }
        E = S;
      };
      o.forEach((y) => {
        const S = y.getColId();
        if (d.has(S))
          b(S), n[S][l] = C++;
        else {
          const x = y.getColDef();
          (x[l] === null || x[l] === void 0 && x[u] == null) && (w || (x[s] || x[s] === void 0 && x[a] ? b(S) : (h.forEach((O) => {
            n[O][l] = C + m[O];
          }), C += g.length, w = !0)), r[S] || (r[S] = { colId: S }), r[S][l] = C++);
        }
      });
    };
    return i(e, this.rowGroupColumns, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex"), i(t, this.pivotColumns, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex"), Object.values(r);
  }
  onColumnsReady() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e)
      return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: r, defaultMinWidth: i, defaultMaxWidth: n } = e, o = r == null ? void 0 : r.map(({ colId: s, minWidth: a, maxWidth: l }) => ({
          key: s,
          minWidth: a,
          maxWidth: l
        }));
        this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
          defaultMinWidth: i,
          defaultMaxWidth: n,
          columnLimits: o
        });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents")
      return;
    const { colIds: t, skipHeader: r } = e;
    setTimeout(() => {
      t ? this.autoSizeColumns({
        columns: t,
        skipHeader: r,
        source: "autosizeColumns"
      }) : this.autoSizeAllColumns("autosizeColumns", r);
    });
  }
};
v([
  T("expressionService")
], vr.prototype, "expressionService", 2);
v([
  T("columnFactory")
], vr.prototype, "columnFactory", 2);
v([
  T("displayedGroupCreator")
], vr.prototype, "displayedGroupCreator", 2);
v([
  T("ctrlsService")
], vr.prototype, "ctrlsService", 2);
v([
  T("autoWidthCalculator")
], vr.prototype, "autoWidthCalculator", 2);
v([
  T("columnAnimationService")
], vr.prototype, "columnAnimationService", 2);
v([
  T("autoGroupColService")
], vr.prototype, "autoGroupColService", 2);
v([
  T("valueCache")
], vr.prototype, "valueCache", 2);
v([
  T("animationFrameService")
], vr.prototype, "animationFrameService", 2);
v([
  T("sortController")
], vr.prototype, "sortController", 2);
v([
  T("columnDefFactory")
], vr.prototype, "columnDefFactory", 2);
v([
  Qe("aggFuncService")
], vr.prototype, "aggFuncService", 2);
v([
  te
], vr.prototype, "init", 1);
v([
  jr
], vr.prototype, "destroyColumns", 1);
v([
  an(0, Gi("loggerFactory"))
], vr.prototype, "setBeans", 1);
vr = v([
  de("columnModel")
], vr);
function dl(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function Ts(e, t, r) {
  if (e)
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      if (n instanceof ur) {
        const o = t ? n.getDisplayedChildren() : n.getChildren();
        Ts(o, t, r);
      }
      r(n);
    }
}
var _b = class extends Q {
  createDisplayedGroups(e, t, r, i) {
    const n = this.mapOldGroupsById(i), o = [];
    let s = e;
    for (; s.length; ) {
      const a = s;
      s = [];
      let l = 0;
      const u = (c) => {
        const d = l;
        l = c;
        const h = a[d], g = (h instanceof ur ? h.getProvidedColumnGroup() : h).getOriginalParent();
        if (g == null) {
          for (let f = d; f < c; f++)
            o.push(a[f]);
          return;
        }
        const m = this.createColumnGroup(
          g,
          t,
          n,
          r
        );
        for (let f = d; f < c; f++)
          m.addChild(a[f]);
        s.push(m);
      };
      for (let c = 1; c < a.length; c++) {
        const d = a[c], p = (d instanceof ur ? d.getProvidedColumnGroup() : d).getOriginalParent(), g = a[l], f = (g instanceof ur ? g.getProvidedColumnGroup() : g).getOriginalParent();
        p !== f && u(c);
      }
      l < a.length && u(a.length);
    }
    return this.setupParentsIntoColumns(o, null), o;
  }
  createColumnGroup(e, t, r, i) {
    const n = e.getGroupId(), o = t.getInstanceIdForKey(n), s = ur.createUniqueId(n, o);
    let a = r[s];
    return a && a.getProvidedColumnGroup() !== e && (a = null), q(a) ? a.reset() : (a = new ur(e, n, o, i), this.context.createBean(a)), a;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, r = (i) => {
      i.forEach((n) => {
        if (n instanceof ur) {
          const o = n;
          t[n.getUniqueId()] = o, r(o.getChildren());
        }
      });
    };
    return e && r(e), t;
  }
  setupParentsIntoColumns(e, t) {
    e.forEach((r) => {
      if (r.setParent(t), r instanceof ur) {
        const i = r;
        this.setupParentsIntoColumns(i.getChildren(), i);
      }
    });
  }
};
_b = v([
  de("displayedGroupCreator")
], _b);
var Une = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  excludeHiddenColumnsFromQuickFilter: !0,
  advancedFilterModel: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  enableChartToolPanelsButton: !0,
  suppressChartToolPanelsButton: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressParentsInRowNodes: !0,
  suppressTouch: !0,
  suppressAsyncEvents: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  suppressAggFuncInHeader: !0,
  suppressAggAtRootLevel: !0,
  removePivotHeaderRowWhenSingleValueColumn: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  suppressGroupMaintainValueType: !0,
  groupLockGroupColumns: !0,
  rowGroupPanelSuppressSort: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  suppressServerSideInfiniteScroll: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  functionsPassive: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0
}, ir = class {
};
ir.STRING_PROPERTIES = [
  "rowSelection",
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
];
ir.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterModel",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy"
];
ir.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
ir.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
ir.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressParentsInRowNodes",
  "suppressColumnMoveAnimation",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressAggAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsPassive",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "excludeHiddenColumnsFromQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterMovesDown",
  "enterMovesDownAfterEdit",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "enableChartToolPanelsButton",
  "suppressChartToolPanelsButton",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideFilterAllLevels",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "maintainColumnOrder",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "suppressGroupMaintainValueType",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval"
];
ir.OTHER_PROPERTIES = [
  "suppressStickyTotalRow"
];
ir.FUNCTIONAL_PROPERTIES = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher"
];
ir.CALLBACK_PROPERTIES = [
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "groupIncludeFooter",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering",
  "chartMenuItems",
  "groupTotalRow"
];
ir.FUNCTION_PROPERTIES = [
  ...ir.FUNCTIONAL_PROPERTIES,
  ...ir.CALLBACK_PROPERTIES
];
ir.ALL_PROPERTIES = [
  ...ir.ARRAY_PROPERTIES,
  ...ir.OBJECT_PROPERTIES,
  ...ir.STRING_PROPERTIES,
  ...ir.NUMBER_PROPERTIES,
  ...ir.FUNCTION_PROPERTIES,
  ...ir.BOOLEAN_PROPERTIES,
  ...ir.OTHER_PROPERTIES
];
var Id = ir, Er = class Ip {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
  static getGridOptionKeys() {
    return this.ALL_PROPERTIES_AND_CALLBACKS;
  }
  /** Combines component props / attributes with the provided gridOptions returning a new combined gridOptions object */
  static combineAttributesAndGridOptions(t, r) {
    typeof t != "object" && (t = {});
    const i = Ce({}, t);
    return Ip.getGridOptionKeys().forEach((o) => {
      const s = r[o];
      typeof s < "u" && s !== Ip.VUE_OMITTED_PROPERTY && (i[o] = s);
    }), i;
  }
  static processOnChange(t, r, i) {
    if (!t)
      return;
    const n = {};
    let o = !1;
    if (Object.keys(t).filter((a) => Ip.ALL_PROPERTIES_AND_CALLBACKS_SET.has(a)).forEach((a) => {
      n[a] = t[a], o = !0;
    }), !o)
      return;
    r.__internalUpdateGridOptions(n, !0);
    const s = {
      type: A.EVENT_COMPONENT_STATE_CHANGED
    };
    Tr(n, (a, l) => {
      s[a] = l;
    }), r.dispatchEvent(s);
  }
};
Er.EVENTS = zs(A);
Er.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
Er.EXCLUDED_INTERNAL_EVENTS = [
  A.EVENT_SCROLLBAR_WIDTH_CHANGED,
  A.EVENT_CHECKBOX_CHANGED,
  A.EVENT_HEIGHT_SCALE_CHANGED,
  A.EVENT_BODY_HEIGHT_CHANGED,
  A.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED,
  A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
  A.EVENT_SCROLL_VISIBILITY_CHANGED,
  A.EVENT_COLUMN_HOVER_CHANGED,
  A.EVENT_FLASH_CELLS,
  A.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
  A.EVENT_DISPLAYED_ROWS_CHANGED,
  A.EVENT_LEFT_PINNED_WIDTH_CHANGED,
  A.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
  A.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
  A.EVENT_STORE_UPDATED,
  A.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
  A.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
  A.EVENT_KEY_SHORTCUT_CHANGED_CELL_START,
  A.EVENT_KEY_SHORTCUT_CHANGED_CELL_END,
  A.EVENT_FULL_WIDTH_ROW_FOCUSED,
  A.EVENT_HEADER_HEIGHT_CHANGED,
  A.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
  A.EVENT_CELL_FOCUS_CLEARED,
  A.EVENT_GRID_STYLES_CHANGED,
  A.EVENT_FILTER_DESTROYED,
  A.EVENT_ROW_DATA_UPDATE_STARTED,
  A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED,
  A.EVENT_DATA_TYPES_INFERRED,
  A.EVENT_FIELD_VALUE_CHANGED,
  A.EVENT_FIELD_PICKER_VALUE_SELECTED,
  A.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED,
  A.EVENT_SUPPRESS_MENU_HIDE_CHANGED,
  A.EVENT_SUPPRESS_FIELD_DOT_NOTATION,
  A.EVENT_ROW_COUNT_READY,
  A.EVENT_SIDE_BAR_UPDATED
];
Er.PUBLIC_EVENTS = Er.EVENTS.filter((e) => !yi(Er.EXCLUDED_INTERNAL_EVENTS, e));
Er.EVENT_CALLBACKS = Er.EVENTS.map((e) => Er.getCallbackForEvent(e));
Er.BOOLEAN_PROPERTIES = Id.BOOLEAN_PROPERTIES;
Er.ALL_PROPERTIES = Id.ALL_PROPERTIES;
Er.ALL_PROPERTIES_AND_CALLBACKS = [...Er.ALL_PROPERTIES, ...Er.EVENT_CALLBACKS];
Er.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Er.ALL_PROPERTIES_AND_CALLBACKS);
var ag = Er, Nb = class extends Q {
  constructor() {
    super(...arguments), this.componentsMappedByName = {};
  }
  setupComponents(e) {
    e && e.forEach((t) => this.addComponent(t));
  }
  addComponent(e) {
    const r = e.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase().toUpperCase();
    this.componentsMappedByName[r] = e.componentClass;
  }
  getComponentClass(e) {
    return this.componentsMappedByName[e];
  }
};
Nb = v([
  de("agStackComponentsRegistry")
], Nb);
var e_ = {};
yr(e_, {
  getAriaCheckboxStateName: () => Lm,
  getAriaLabel: () => n_,
  getAriaLevel: () => Yne,
  getAriaPosInSet: () => i_,
  getAriaSortState: () => r_,
  removeAriaExpanded: () => l_,
  removeAriaSort: () => f_,
  setAriaActiveDescendant: () => WS,
  setAriaAtomic: () => o_,
  setAriaChecked: () => Kne,
  setAriaColCount: () => d_,
  setAriaColIndex: () => jS,
  setAriaColSpan: () => h_,
  setAriaControls: () => zS,
  setAriaDescribedBy: () => Xne,
  setAriaDisabled: () => BS,
  setAriaExpanded: () => So,
  setAriaHidden: () => Ch,
  setAriaLabel: () => Si,
  setAriaLabelledBy: () => ql,
  setAriaLevel: () => a_,
  setAriaLive: () => HS,
  setAriaMultiSelectable: () => u_,
  setAriaPosInSet: () => Nm,
  setAriaRelevant: () => s_,
  setAriaRole: () => Nt,
  setAriaRowCount: () => c_,
  setAriaRowIndex: () => $S,
  setAriaSelected: () => Zl,
  setAriaSetSize: () => _m,
  setAriaSort: () => p_
});
function Zi(e, t, r) {
  r == null || typeof r == "string" && r == "" ? VS(e, t) : Ji(e, t, r);
}
function Ji(e, t, r) {
  e.setAttribute(t_(t), r.toString());
}
function VS(e, t) {
  e.removeAttribute(t_(t));
}
function t_(e) {
  return `aria-${e}`;
}
function Nt(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function r_(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function Yne(e) {
  return parseInt(e.getAttribute("aria-level"), 10);
}
function i_(e) {
  return parseInt(e.getAttribute("aria-posinset"), 10);
}
function n_(e) {
  return e.getAttribute("aria-label");
}
function Si(e, t) {
  Zi(e, "label", t);
}
function ql(e, t) {
  Zi(e, "labelledby", t);
}
function Xne(e, t) {
  Zi(e, "describedby", t);
}
function HS(e, t) {
  Zi(e, "live", t);
}
function o_(e, t) {
  Zi(e, "atomic", t);
}
function s_(e, t) {
  Zi(e, "relevant", t);
}
function a_(e, t) {
  Zi(e, "level", t);
}
function BS(e, t) {
  Zi(e, "disabled", t);
}
function Ch(e, t) {
  Zi(e, "hidden", t);
}
function WS(e, t) {
  Zi(e, "activedescendant", t);
}
function So(e, t) {
  Ji(e, "expanded", t);
}
function l_(e) {
  VS(e, "expanded");
}
function _m(e, t) {
  Ji(e, "setsize", t);
}
function Nm(e, t) {
  Ji(e, "posinset", t);
}
function u_(e, t) {
  Ji(e, "multiselectable", t);
}
function c_(e, t) {
  Ji(e, "rowcount", t);
}
function $S(e, t) {
  Ji(e, "rowindex", t);
}
function d_(e, t) {
  Ji(e, "colcount", t);
}
function jS(e, t) {
  Ji(e, "colindex", t);
}
function h_(e, t) {
  Ji(e, "colspan", t);
}
function p_(e, t) {
  Ji(e, "sort", t);
}
function f_(e) {
  VS(e, "sort");
}
function Zl(e, t) {
  Zi(e, "selected", t);
}
function Kne(e, t) {
  Ji(e, "checked", t === void 0 ? "mixed" : t);
}
function zS(e, t) {
  Zi(e, "controls", t.id), ql(t, e.id);
}
function Lm(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var g_ = {};
yr(g_, {
  browserSupportsPreventScroll: () => KS,
  getBodyHeight: () => C_,
  getBodyWidth: () => v_,
  getMaxDivHeight: () => m_,
  getSafariVersion: () => US,
  getScrollbarWidth: () => y_,
  getTabIndex: () => lg,
  isBrowserChrome: () => Gm,
  isBrowserFirefox: () => YS,
  isBrowserSafari: () => jn,
  isIOSUserAgent: () => Oo,
  isInvisibleScrollbar: () => qS,
  isMacOsUserAgent: () => XS
});
var cC, dp, dC, hC, pC, fC, Lb, Gb;
function jn() {
  return cC === void 0 && (cC = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), cC;
}
function US() {
  if (dp === void 0)
    if (jn()) {
      const e = navigator.userAgent.match(/version\/(\d+)/i);
      e && (dp = e[1] != null ? parseFloat(e[1]) : 0);
    } else
      dp = 0;
  return dp;
}
function Gm() {
  if (dC === void 0) {
    const e = window;
    dC = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return dC;
}
function YS() {
  return hC === void 0 && (hC = /(firefox)/i.test(navigator.userAgent)), hC;
}
function XS() {
  return pC === void 0 && (pC = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), pC;
}
function Oo() {
  return fC === void 0 && (fC = /iPad|iPhone|iPod/.test(navigator.platform) || // eslint-disable-next-line
  navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), fC;
}
function KS() {
  return !jn() || US() >= 15;
}
function lg(e) {
  if (!e)
    return null;
  const t = e.tabIndex, r = e.getAttribute("tabIndex");
  return t === -1 && (r === null || r === "" && !YS()) ? null : t.toString();
}
function m_() {
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, r = document.createElement("div");
  for (document.body.appendChild(r); ; ) {
    const i = e * 2;
    if (r.style.height = i + "px", i > t || r.clientHeight !== i)
      break;
    e = i;
  }
  return document.body.removeChild(r), e;
}
function v_() {
  var e, t, r;
  return (r = (e = document.body) == null ? void 0 : e.clientWidth) != null ? r : window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientWidth) || -1;
}
function C_() {
  var e, t, r;
  return (r = (e = document.body) == null ? void 0 : e.clientHeight) != null ? r : window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientHeight) || -1;
}
function y_() {
  return Gb == null && b_(), Gb;
}
function b_() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let r = t.offsetWidth - t.clientWidth;
  r === 0 && t.clientWidth === 0 && (r = null), t.parentNode && t.parentNode.removeChild(t), r != null && (Gb = r, Lb = r === 0);
}
function qS() {
  return Lb == null && b_(), Lb;
}
var w_ = {};
yr(w_, {
  dateToFormattedString: () => Cl,
  parseDateTimeFromString: () => Jr,
  serialiseDate: () => Bi
});
var S_ = {};
yr(S_, {
  cleanNumber: () => qne,
  createArrayOfNumbers: () => E_,
  decToHex: () => Zne,
  formatNumberCommas: () => ZS,
  formatNumberTwoDecimalPlacesAndCommas: () => Jne,
  padStartWidthZeros: () => vl,
  sum: () => Qne
});
function vl(e, t) {
  return e.toString().padStart(t, "0");
}
function E_(e, t) {
  const r = [];
  for (let i = e; i <= t; i++)
    r.push(i);
  return r;
}
function qne(e) {
  return typeof e == "string" && (e = parseInt(e, 10)), typeof e == "number" ? Math.floor(e) : null;
}
function Zne(e, t) {
  let r = "";
  for (let i = 0; i < t; i++)
    r += String.fromCharCode(e & 255), e >>>= 8;
  return r;
}
function Jne(e, t, r) {
  return typeof e != "number" ? "" : ZS(Math.round(e * 100) / 100, t, r);
}
function ZS(e, t, r) {
  return typeof e != "number" ? "" : e.toString().replace(".", r).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`);
}
function Qne(e) {
  return e == null ? null : e.reduce((t, r) => t + r, 0);
}
function Bi(e, t = !0, r = "-") {
  if (!e)
    return null;
  let i = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((n) => vl(n, 2)).join(r);
  return t && (i += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((n) => vl(n, 2)).join(":")), i;
}
var gC = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function Cl(e, t = "YYYY-MM-DD") {
  const r = vl(e.getFullYear(), 4), i = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], n = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ], o = {
    YYYY: () => r.slice(r.length - 4, r.length),
    YY: () => r.slice(r.length - 2, r.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => i[e.getMonth()],
    MMM: () => i[e.getMonth()].slice(0, 3),
    MM: () => vl(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${gC(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${gC(e.getDate())}`,
    DD: () => vl(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => n[e.getDay()],
    ddd: () => n[e.getDay()].slice(0, 3),
    dd: () => n[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${gC(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, s = new RegExp(Object.keys(o).join("|"), "g");
  return t.replace(s, (a) => a in o ? o[a]() : a);
}
function Jr(e) {
  if (!e)
    return null;
  const [t, r] = e.split(" ");
  if (!t)
    return null;
  const i = t.split("-").map((d) => parseInt(d, 10));
  if (i.filter((d) => !isNaN(d)).length !== 3)
    return null;
  const [n, o, s] = i, a = new Date(n, o - 1, s);
  if (a.getFullYear() !== n || a.getMonth() !== o - 1 || a.getDate() !== s)
    return null;
  if (!r || r === "00:00:00")
    return a;
  const [l, u, c] = r.split(":").map((d) => parseInt(d, 10));
  return l >= 0 && l < 24 && a.setHours(l), u >= 0 && u < 60 && a.setMinutes(u), c >= 0 && c < 60 && a.setSeconds(c), a;
}
var x_ = {};
yr(x_, {
  FOCUSABLE_EXCLUDE: () => JS,
  FOCUSABLE_SELECTOR: () => A_,
  addOrRemoveAttribute: () => Ln,
  addStylesToElement: () => oE,
  bindCellRendererToHtmlElement: () => aE,
  clearElement: () => Ht,
  copyNodeList: () => I_,
  ensureDomOrder: () => iE,
  formatSize: () => km,
  getAbsoluteHeight: () => eE,
  getAbsoluteWidth: () => Od,
  getElementRectWithOffset: () => tE,
  getElementSize: () => us,
  getInnerHeight: () => yh,
  getInnerWidth: () => Ma,
  getScrollLeft: () => Fd,
  insertWithDomOrder: () => T_,
  isElementChildOfClass: () => Us,
  isFocusableFormField: () => QS,
  isHorizontalScrollShowing: () => R_,
  isInDOM: () => rE,
  isNodeOrElement: () => bh,
  isRtlNegativeScroll: () => Md,
  isVerticalScrollShowing: () => P_,
  isVisible: () => ii,
  iterateNamedNodeMap: () => O_,
  loadTemplate: () => Qr,
  nodeListForEach: () => sE,
  radioCssClass: () => kb,
  removeFromParent: () => ln,
  setDisabled: () => Jl,
  setDisplayed: () => We,
  setDomChildOrder: () => nE,
  setElementHeight: () => eoe,
  setElementWidth: () => Nd,
  setFixedHeight: () => Ys,
  setFixedWidth: () => Wi,
  setScrollLeft: () => _d,
  setVisible: () => D_
});
var hp;
function kb(e, t, r) {
  const i = e.parentElement;
  let n = i && i.firstChild;
  for (; n; )
    t && n.classList.toggle(t, n === e), r && n.classList.toggle(r, n !== e), n = n.nextSibling;
}
var A_ = "[tabindex], input, select, button, textarea, [href]", JS = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function QS(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, i = t.call(e, "input, select, button, textarea"), n = t.call(e, JS), o = ii(e);
  return i && !n && o;
}
function We(e, t, r = {}) {
  const { skipAriaHidden: i } = r;
  e.classList.toggle("ag-hidden", !t), i || Ch(e, !t);
}
function D_(e, t, r = {}) {
  const { skipAriaHidden: i } = r;
  e.classList.toggle("ag-invisible", !t), i || Ch(e, !t);
}
function Jl(e, t) {
  const r = "disabled", i = t ? (n) => n.setAttribute(r, "") : (n) => n.removeAttribute(r);
  i(e), sE(e.querySelectorAll("input"), (n) => i(n));
}
function Us(e, t, r) {
  let i = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof r == "number") {
      if (++i > r)
        break;
    } else if (e === r)
      break;
  }
  return !1;
}
function us(e) {
  const {
    height: t,
    width: r,
    borderTopWidth: i,
    borderRightWidth: n,
    borderBottomWidth: o,
    borderLeftWidth: s,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: u,
    paddingLeft: c,
    marginTop: d,
    marginRight: h,
    marginBottom: p,
    marginLeft: g,
    boxSizing: m
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(r || "0"),
    borderTopWidth: parseFloat(i || "0"),
    borderRightWidth: parseFloat(n || "0"),
    borderBottomWidth: parseFloat(o || "0"),
    borderLeftWidth: parseFloat(s || "0"),
    paddingTop: parseFloat(a || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(u || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(d || "0"),
    marginRight: parseFloat(h || "0"),
    marginBottom: parseFloat(p || "0"),
    marginLeft: parseFloat(g || "0"),
    boxSizing: m
  };
}
function yh(e) {
  const t = us(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function Ma(e) {
  const t = us(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function eE(e) {
  const t = us(e), r = t.marginBottom + t.marginTop;
  return Math.ceil(e.offsetHeight + r);
}
function Od(e) {
  const t = us(e), r = t.marginLeft + t.marginRight;
  return Math.ceil(e.offsetWidth + r);
}
function tE(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: r, borderLeftWidth: i, borderRightWidth: n, borderBottomWidth: o } = us(e);
  return {
    top: t.top + (r || 0),
    left: t.left + (i || 0),
    right: t.right + (n || 0),
    bottom: t.bottom + (o || 0)
  };
}
function Md() {
  if (typeof hp == "boolean")
    return hp;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, hp = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), hp;
}
function Fd(e, t) {
  let r = e.scrollLeft;
  return t && (r = Math.abs(r), Gm() && !Md() && (r = e.scrollWidth - e.clientWidth - r)), r;
}
function _d(e, t, r) {
  r && (Md() ? t *= -1 : (jn() || Gm()) && (t = e.scrollWidth - e.clientWidth - t)), e.scrollLeft = t;
}
function Ht(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function ln(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function rE(e) {
  return !!e.offsetParent;
}
function ii(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!rE(e) || window.getComputedStyle(e).visibility !== "visible");
}
function Qr(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function iE(e, t, r) {
  r && r.nextSibling === t || (r ? r.nextSibling ? e.insertBefore(t, r.nextSibling) : e.appendChild(t) : e.firstChild && e.firstChild !== t && e.insertAdjacentElement("afterbegin", t));
}
function nE(e, t) {
  for (let r = 0; r < t.length; r++) {
    const i = t[r], n = e.children[r];
    n !== i && e.insertBefore(i, n);
  }
}
function T_(e, t, r) {
  r ? r.insertAdjacentElement("afterend", t) : e.firstChild ? e.insertAdjacentElement("afterbegin", t) : e.appendChild(t);
}
function oE(e, t) {
  if (t)
    for (const [r, i] of Object.entries(t)) {
      if (!r || !r.length || i == null)
        continue;
      const n = JF(r), o = i.toString(), s = o.replace(/\s*!important/g, ""), a = s.length != o.length ? "important" : void 0;
      e.style.setProperty(n, s, a);
    }
}
function R_(e) {
  return e.clientWidth < e.scrollWidth;
}
function P_(e) {
  return e.clientHeight < e.scrollHeight;
}
function Nd(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Wi(e, t);
}
function Wi(e, t) {
  t = km(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function eoe(e, t) {
  t === "flex" ? (e.style.removeProperty("height"), e.style.removeProperty("minHeight"), e.style.removeProperty("maxHeight"), e.style.flex = "1 1 auto") : Ys(e, t);
}
function Ys(e, t) {
  t = km(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function km(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function bh(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function I_(e) {
  if (e == null)
    return [];
  const t = [];
  return sE(e, (r) => t.push(r)), t;
}
function O_(e, t) {
  if (e)
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      t(i.name, i.value);
    }
}
function Ln(e, t, r) {
  r == null ? e.removeAttribute(t) : e.setAttribute(t, r.toString());
}
function sE(e, t) {
  if (e != null)
    for (let r = 0; r < e.length; r++)
      t(e[r]);
}
function aE(e, t) {
  e.then((r) => {
    const i = r.getGui();
    i != null && (typeof i == "object" ? t.appendChild(i) : t.innerHTML = i);
  });
}
var M_ = {};
yr(M_, {
  fuzzyCheckStrings: () => F_,
  fuzzySuggestions: () => wh
});
function F_(e, t, r) {
  const i = {}, n = e.filter(
    (o) => !t.some(
      (s) => s === o
    )
  );
  return n.length > 0 && n.forEach(
    (o) => i[o] = wh(o, r).values
  ), i;
}
function wh(e, t, r, i) {
  let n = t.map((a, l) => ({
    value: a,
    relevance: toe(e.toLowerCase(), a.toLocaleLowerCase()),
    idx: l
  }));
  if (n.sort((a, l) => l.relevance - a.relevance), r && (n = n.filter((a) => a.relevance !== 0)), n.length > 0 && i && i > 0) {
    const l = n[0].relevance * i;
    n = n.filter((u) => l - u.relevance < 0);
  }
  const o = [], s = [];
  for (const a of n)
    o.push(a.value), s.push(a.idx);
  return { values: o, indices: s };
}
function toe(e, t) {
  const r = e.replace(/\s/g, ""), i = t.replace(/\s/g, "");
  let n = 0, o = -1;
  for (let s = 0; s < r.length; s++) {
    const a = i.indexOf(r[s], o + 1);
    a !== -1 && (o = a, n += 100 - o * 100 / 1e4 * 100);
  }
  return n;
}
var __ = {};
yr(__, {
  createIcon: () => Ii,
  createIconNoSpan: () => It,
  iconNameClassMap: () => N_
});
var N_ = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  menuAlt: "menu-alt",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none",
  // Builder button in Advanced Filter
  advancedFilterBuilder: "group",
  // drag handle used to pick up Advanced Filter Builder rows
  advancedFilterBuilderDrag: "grip",
  // Advanced Filter Builder row validation error
  advancedFilterBuilderInvalid: "not-allowed",
  // shown on Advanced Filter Builder rows to move them up
  advancedFilterBuilderMoveUp: "up",
  // shown on Advanced Filter Builder rows to move them down
  advancedFilterBuilderMoveDown: "down",
  // shown on Advanced Filter Builder rows to add new rows
  advancedFilterBuilderAdd: "plus",
  // shown on Advanced Filter Builder rows to remove row
  advancedFilterBuilderRemove: "minus",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus"
};
function Ii(e, t, r) {
  const i = It(e, t, r);
  if (i) {
    const { className: o } = i;
    if (typeof o == "string" && o.indexOf("ag-icon") > -1 || typeof o == "object" && o["ag-icon"])
      return i;
  }
  const n = document.createElement("span");
  return n.appendChild(i), n;
}
function It(e, t, r, i) {
  let n = null;
  const o = r && r.getColDef().icons;
  if (o && (n = o[e]), t && !n) {
    const s = t.get("icons");
    s && (n = s[e]);
  }
  if (n) {
    let s;
    if (typeof n == "function")
      s = n();
    else if (typeof n == "string")
      s = n;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof s == "string")
      return Qr(s);
    if (bh(s))
      return s;
    console.warn("AG Grid: iconRenderer should return back a string or a dom object");
  } else {
    const s = document.createElement("span");
    let a = N_[e];
    return a || (i ? a = e : (console.warn(`AG Grid: Did not find icon ${e}`), a = "")), s.setAttribute("class", `ag-icon ag-icon-${a}`), s.setAttribute("unselectable", "on"), Nt(s, "presentation"), s;
  }
}
var L_ = {};
yr(L_, {
  isDeleteKey: () => V_,
  isEventFromPrintableCharacter: () => Vm,
  isUserSuppressingHeaderKeyboardEvent: () => G_,
  isUserSuppressingKeyboardEvent: () => ug,
  normaliseQwertyAzerty: () => k_
});
var k = class {
};
k.BACKSPACE = "Backspace";
k.TAB = "Tab";
k.ENTER = "Enter";
k.ESCAPE = "Escape";
k.SPACE = " ";
k.LEFT = "ArrowLeft";
k.UP = "ArrowUp";
k.RIGHT = "ArrowRight";
k.DOWN = "ArrowDown";
k.DELETE = "Delete";
k.F2 = "F2";
k.PAGE_UP = "PageUp";
k.PAGE_DOWN = "PageDown";
k.PAGE_HOME = "Home";
k.PAGE_END = "End";
k.A = "KeyA";
k.C = "KeyC";
k.D = "KeyD";
k.V = "KeyV";
k.X = "KeyX";
k.Y = "KeyY";
k.Z = "KeyZ";
var roe = 65, ioe = 67, noe = 86, ooe = 68, soe = 90, aoe = 89;
function Vm(e) {
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : e.key.length === 1;
}
function ug(e, t, r, i, n) {
  const o = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!o)
    return !1;
  const s = e.addGridCommonParams({
    event: t,
    editing: n,
    column: i,
    node: r,
    data: r.data,
    colDef: i.getColDef()
  });
  return !!(o && o(s));
}
function G_(e, t, r, i) {
  const n = i.getDefinition(), o = n && n.suppressHeaderKeyboardEvent;
  if (!q(o))
    return !1;
  const s = e.addGridCommonParams({
    colDef: n,
    column: i,
    headerRowIndex: r,
    event: t
  });
  return !!o(s);
}
function k_(e) {
  const { keyCode: t } = e;
  let r;
  switch (t) {
    case roe:
      r = k.A;
      break;
    case ioe:
      r = k.C;
      break;
    case noe:
      r = k.V;
      break;
    case ooe:
      r = k.D;
      break;
    case soe:
      r = k.Z;
      break;
    case aoe:
      r = k.Y;
      break;
    default:
      r = e.code;
  }
  return r;
}
function V_(e, t = !1) {
  return e === k.DELETE ? !0 : !t && e === k.BACKSPACE ? XS() : !1;
}
var H_ = {};
yr(H_, {
  areEventsNear: () => lE
});
function lE(e, t, r) {
  if (r === 0)
    return !1;
  const i = Math.abs(e.clientX - t.clientX), n = Math.abs(e.clientY - t.clientY);
  return Math.max(i, n) <= r;
}
var B_ = {};
yr(B_, {
  sortRowNodesByOrder: () => loe
});
function loe(e, t) {
  if (!e)
    return !1;
  const r = (s, a) => {
    const l = t[s.id], u = t[a.id], c = l !== void 0, d = u !== void 0, h = c && d, p = !c && !d;
    return h ? l - u : p ? s.__objectId - a.__objectId : c ? 1 : -1;
  };
  let i, n, o = !1;
  for (let s = 0; s < e.length - 1; s++)
    if (i = e[s], n = e[s + 1], r(i, n) > 0) {
      o = !0;
      break;
    }
  return o ? (e.sort(r), !0) : !1;
}
var W_ = {};
yr(W_, {
  convertToSet: () => uE
});
function uE(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => t.add(r)), t;
}
var uoe = Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce(Ce({}, e_), kF), g_), w_), x_), GF), PF), M_), DF), __), L_), QF), H_), S_), TF), B_), W_), qF), Ae = uoe, Ql = class {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}, qt = class Op {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t((r) => this.onDone(r), (r) => this.onReject(r));
  }
  static all(t) {
    return new Op((r) => {
      let i = t.length;
      const n = new Array(i);
      t.forEach((o, s) => {
        o.then((a) => {
          n[s] = a, i--, i === 0 && r(n);
        });
      });
    });
  }
  static resolve(t = null) {
    return new Op((r) => r(t));
  }
  then(t) {
    return new Op((r) => {
      this.status === 1 ? r(t(this.resolution)) : this.waiters.push((i) => r(t(i)));
    });
  }
  resolveNow(t, r) {
    return this.status === 1 ? r(this.resolution) : t;
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((r) => r(t));
  }
  onReject(t) {
    console.warn("TBI");
  }
}, Sh = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((i) => this.addCssClass(i));
      return;
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const i = this.getGui();
      i && i.classList.add(e), this.cssClassStates[e] = !0;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((i) => this.removeCssClass(i));
      return;
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const i = this.getGui();
      i && i.classList.remove(e), this.cssClassStates[e] = !1;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const i = (e || "").split(" ");
      if (i.length > 1) {
        i.forEach((n) => this.addOrRemoveCssClass(n, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const i = this.getGui();
      i && i.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
}, Eh = class Rs extends Q {
  constructor(t, r, i, n) {
    super(), this.parentComp = t, this.tooltipShowDelayOverride = r, this.tooltipHideDelayOverride = i, this.shouldDisplayTooltip = n, this.SHOW_QUICK_TOOLTIP_DIFF = 1e3, this.FADE_OUT_TOOLTIP_TIMEOUT = 1e3, this.INTERACTIVE_HIDE_DELAY = 100, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const t = this.parentComp.getGui();
    this.tooltipTrigger === 0 && (this.addManagedListener(t, "mouseenter", this.onMouseEnter.bind(this)), this.addManagedListener(t, "mouseleave", this.onMouseLeave.bind(this))), this.tooltipTrigger === 1 && (this.addManagedListener(t, "focusin", this.onFocusIn.bind(this)), this.addManagedListener(t, "focusout", this.onFocusOut.bind(this))), this.addManagedListener(t, "mousemove", this.onMouseMove.bind(this)), this.interactionEnabled || (this.addManagedListener(t, "mousedown", this.onMouseDown.bind(this)), this.addManagedListener(t, "keydown", this.onKeyDown.bind(this)));
  }
  getGridOptionsTooltipDelay(t) {
    const r = this.gos.get(t);
    return r < 0 && we(`${t} should not be lower than 0`), Math.max(200, r);
  }
  getTooltipDelay(t) {
    var r, i;
    return t === "show" ? (r = this.tooltipShowDelayOverride) != null ? r : this.getGridOptionsTooltipDelay("tooltipShowDelay") : (i = this.tooltipHideDelayOverride) != null ? i : this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const t = this.gos.get("tooltipTrigger");
    return !t || t === "hover" ? 0 : 1;
  }
  onMouseEnter(t) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !Oo() && (Rs.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(t);
    }, this.INTERACTIVE_HIDE_DELAY) : this.prepareToShowTooltip(t));
  }
  onMouseMove(t) {
    this.lastMouseEvent && (this.lastMouseEvent = t), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(t) {
    var r;
    const i = t.relatedTarget, n = this.parentComp.getGui(), o = (r = this.tooltipComp) == null ? void 0 : r.getGui();
    this.isInteractingWithTooltip || n.contains(i) || this.interactionEnabled && (o != null && o.contains(i)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.setToDoNothing();
  }
  prepareToShowTooltip(t) {
    if (this.state != 0 || Rs.isLocked)
      return;
    let r = 0;
    t && (r = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), r), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    const t = (/* @__PURE__ */ new Date()).getTime(), r = Rs.lastTooltipHideTime;
    return t - r < this.SHOW_QUICK_TOOLTIP_DIFF;
  }
  setToDoNothing() {
    this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    const t = Ce({}, this.parentComp.getTooltipParams());
    if (!q(t.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    this.state = 2, this.tooltipInstanceCount++;
    const r = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(t).newAgStackInstance().then(r);
  }
  hideTooltip(t) {
    if (!t && this.isInteractingWithTooltip)
      return;
    this.tooltipComp && (this.destroyTooltipComp(), Rs.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime());
    const r = {
      type: A.EVENT_TOOLTIP_HIDE,
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(r), this.state = 0;
  }
  newTooltipComponentCallback(t, r) {
    if (this.state !== 2 || this.tooltipInstanceCount !== t) {
      this.getContext().destroyBean(r);
      return;
    }
    const n = r.getGui();
    this.tooltipComp = r, n.classList.contains("ag-tooltip") || n.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && n.classList.add("ag-tooltip-animate"), this.interactionEnabled && n.classList.add("ag-tooltip-interactive");
    const o = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      eChild: n,
      ariaLabel: o("ariaLabelTooltip", "Tooltip")
    });
    s && (this.tooltipPopupDestroyFunc = s.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1 && (this.onBodyScrollEventCallback = this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL, this.setToDoNothing.bind(this)), this.onColumnMovedEventCallback = this.addManagedListener(this.eventService, A.EVENT_COLUMN_MOVED, this.setToDoNothing.bind(this))), this.interactionEnabled && (this.tooltipTrigger === 0 ? (this.tooltipMouseEnterListener = this.addManagedListener(n, "mouseenter", this.onTooltipMouseEnter.bind(this)) || null, this.tooltipMouseLeaveListener = this.addManagedListener(n, "mouseleave", this.onTooltipMouseLeave.bind(this)) || null) : (this.tooltipFocusInListener = this.addManagedListener(n, "focusin", this.onTooltipFocusIn.bind(this)) || null, this.tooltipFocusOutListener = this.addManagedListener(n, "focusout", this.onTooltipFocusOut.bind(this)) || null));
    const a = {
      type: A.EVENT_TOOLTIP_SHOW,
      tooltipGui: n,
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(a), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isInteractingWithTooltip = !1, this.lockService();
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  onTooltipFocusOut(t) {
    var r;
    const i = this.parentComp.getGui(), n = (r = this.tooltipComp) == null ? void 0 : r.getGui(), o = t.relatedTarget;
    n != null && n.contains(o) || (this.isInteractingWithTooltip = !1, i.contains(o) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    const t = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent(Dt(Ce({}, t), {
      mouseEvent: this.lastMouseEvent
    })) : this.popupService.positionPopupByComponent(Dt(Ce({}, t), {
      eventSource: this.parentComp.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    }));
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const t = this.tooltipPopupDestroyFunc, r = this.tooltipComp, i = this.tooltipTrigger === 0 ? this.FADE_OUT_TOOLTIP_TIMEOUT : 0;
    window.setTimeout(() => {
      t(), this.getContext().destroyBean(r);
    }, i), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((t) => {
      t && t();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    Rs.isLocked = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, this.INTERACTIVE_HIDE_DELAY);
  }
  unlockService() {
    Rs.isLocked = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
Eh.isLocked = !1;
v([
  T("popupService")
], Eh.prototype, "popupService", 2);
v([
  T("userComponentFactory")
], Eh.prototype, "userComponentFactory", 2);
v([
  te
], Eh.prototype, "postConstruct", 1);
var coe = Eh, Mo = class extends Q {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  postConstruct() {
    this.refreshToolTip();
  }
  setBrowserTooltip(e) {
    const t = "title", r = this.ctrl.getGui();
    r && (e != null && e != "" ? r.setAttribute(t, e) : r.removeAttribute(t));
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    var e, t, r, i;
    if (this.tooltipManager != null)
      return;
    const n = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.tooltipManager = this.createBean(new coe(
      n,
      (t = (e = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : t.call(e),
      (i = (r = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : i.call(r),
      this.ctrl.shouldDisplayTooltip
    ), this.beans.context);
  }
  refreshToolTip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  getTooltipParams() {
    const e = this.ctrl, t = e.getColumn ? e.getColumn() : void 0, r = e.getColDef ? e.getColDef() : void 0, i = e.getRowNode ? e.getRowNode() : void 0;
    return {
      location: e.getLocation(),
      //'cell',
      colDef: r,
      column: t,
      rowIndex: e.getRowIndex ? e.getRowIndex() : void 0,
      node: i,
      data: i ? i.data : void 0,
      value: this.getTooltipText(),
      valueFormatted: e.getValueFormatted ? e.getValueFormatted() : void 0,
      hideTooltipCallback: () => {
        var n;
        return (n = this.tooltipManager) == null ? void 0 : n.hideTooltip(!0);
      }
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy();
  }
};
v([
  T("beans")
], Mo.prototype, "beans", 2);
v([
  te
], Mo.prototype, "postConstruct", 1);
var doe = new Ql(), xh = class Vb extends Q {
  constructor(t) {
    super(), this.displayed = !0, this.visible = !0, this.compId = doe.next(), this.cssClassManager = new Sh(() => this.eGui), t && this.setTemplate(t);
  }
  preConstructOnComponent() {
    this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips");
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(t) {
    const { newTooltipText: r, showDelayOverride: i, hideDelayOverride: n, location: o, shouldDisplayTooltip: s } = t || {};
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== r && (this.tooltipText = r);
    const a = () => this.tooltipText;
    r != null && (this.tooltipFeature = this.createBean(new Mo({
      getTooltipValue: a,
      getGui: () => this.getGui(),
      getLocation: () => o ?? "UNKNOWN",
      getColDef: t == null ? void 0 : t.getColDef,
      getColumn: t == null ? void 0 : t.getColumn,
      getTooltipShowDelayOverride: i != null ? () => i : void 0,
      getTooltipHideDelayOverride: n != null ? () => n : void 0,
      shouldDisplayTooltip: s
    })));
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(t, r) {
    I_(t.childNodes).forEach((n) => {
      if (!(n instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(n, (s) => {
        s.getGui() && this.copyAttributesFromNode(n, s.getGui());
      }, r);
      if (o) {
        if (o.addItems && n.children.length) {
          this.createChildComponentsFromTags(n, r);
          const s = Array.prototype.slice.call(n.children);
          o.addItems(s);
        }
        this.swapComponentForNode(o, t, n);
      } else n.childNodes && this.createChildComponentsFromTags(n, r);
    });
  }
  createComponentFromElement(t, r, i) {
    const n = t.nodeName, o = i ? i[t.getAttribute("ref")] : void 0, s = this.agStackComponentsRegistry.getComponentClass(n);
    if (s) {
      Vb.elementGettingCreated = t;
      const a = new s(o);
      return a.setParentComponent(this), this.createBean(a, null, r), a;
    }
    return null;
  }
  copyAttributesFromNode(t, r) {
    O_(t.attributes, (i, n) => r.setAttribute(i, n));
  }
  swapComponentForNode(t, r, i) {
    const n = t.getGui();
    r.replaceChild(n, i), r.insertBefore(document.createComment(i.nodeName), n), this.addDestroyFunc(this.destroyBean.bind(this, t)), this.swapInComponentForQuerySelectors(t, i);
  }
  swapInComponentForQuerySelectors(t, r) {
    const i = this;
    this.iterateOverQuerySelectors((n) => {
      i[n.attributeName] === r && (i[n.attributeName] = t);
    });
  }
  iterateOverQuerySelectors(t) {
    let r = Object.getPrototypeOf(this);
    for (; r != null; ) {
      const i = r.__agComponentMetaData, n = Pm(r.constructor);
      i && i[n] && i[n].querySelectors && i[n].querySelectors.forEach((o) => t(o)), r = Object.getPrototypeOf(r);
    }
  }
  activateTabIndex(t) {
    const r = this.gos.get("tabIndex");
    t || (t = []), t.length || t.push(this.getGui()), t.forEach((i) => i.setAttribute("tabindex", r.toString()));
  }
  setTemplate(t, r) {
    const i = Qr(t);
    this.setTemplateFromElement(i, r);
  }
  setTemplateFromElement(t, r) {
    this.eGui = t, this.eGui.__agComponent = this, this.wireQuerySelectors(), this.getContext() && this.createChildComponentsFromTags(this.getGui(), r);
  }
  createChildComponentsPreConstruct() {
    this.getGui() && this.createChildComponentsFromTags(this.getGui());
  }
  wireQuerySelectors() {
    if (!this.eGui)
      return;
    const t = this;
    this.iterateOverQuerySelectors((r) => {
      const i = (o) => t[r.attributeName] = o;
      if (r.refSelector && this.getAttribute("ref") === r.refSelector)
        i(this.eGui);
      else {
        const o = this.eGui.querySelector(r.querySelector);
        o && i(o.__agComponent || o);
      }
    });
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(t) {
    this.eGui = t;
  }
  queryForHtmlElement(t) {
    return this.eGui.querySelector(t);
  }
  queryForHtmlInputElement(t) {
    return this.eGui.querySelector(t);
  }
  appendChild(t, r) {
    if (t != null)
      if (r || (r = this.eGui), bh(t))
        r.appendChild(t);
      else {
        const i = t;
        r.appendChild(i.getGui());
      }
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(t, r = {}) {
    if (t !== this.visible) {
      this.visible = t;
      const { skipAriaHidden: i } = r;
      D_(this.eGui, t, { skipAriaHidden: i });
    }
  }
  setDisplayed(t, r = {}) {
    if (t !== this.displayed) {
      this.displayed = t;
      const { skipAriaHidden: i } = r;
      We(this.eGui, t, { skipAriaHidden: i });
      const n = {
        type: Vb.EVENT_DISPLAYED_CHANGED,
        visible: this.displayed
      };
      this.dispatchEvent(n);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const t = this.eGui;
    t && t.__agComponent && (t.__agComponent = void 0), super.destroy();
  }
  addGuiEventListener(t, r, i) {
    this.eGui.addEventListener(t, r, i), this.addDestroyFunc(() => this.eGui.removeEventListener(t, r));
  }
  addCssClass(t) {
    this.cssClassManager.addCssClass(t);
  }
  removeCssClass(t) {
    this.cssClassManager.removeCssClass(t);
  }
  containsCssClass(t) {
    return this.cssClassManager.containsCssClass(t);
  }
  addOrRemoveCssClass(t, r) {
    this.cssClassManager.addOrRemoveCssClass(t, r);
  }
  getAttribute(t) {
    const { eGui: r } = this;
    return r ? r.getAttribute(t) : null;
  }
  getRefElement(t) {
    return this.queryForHtmlElement(`[ref="${t}"]`);
  }
};
xh.EVENT_DISPLAYED_CHANGED = "displayedChanged";
v([
  T("agStackComponentsRegistry")
], xh.prototype, "agStackComponentsRegistry", 2);
v([
  FF
], xh.prototype, "preConstructOnComponent", 1);
v([
  FF
], xh.prototype, "createChildComponentsPreConstruct", 1);
var Oe = xh;
function ne(e) {
  return hoe.bind(this, `[ref=${e}]`, e);
}
function hoe(e, t, r, i, n) {
  if (e === null) {
    console.error("AG Grid: QuerySelector selector should not be null");
    return;
  }
  if (typeof n == "number") {
    console.error("AG Grid: QuerySelector should be on an attribute");
    return;
  }
  poe(r, "querySelectors", {
    attributeName: i,
    querySelector: e,
    refSelector: t
  });
}
function poe(e, t, r) {
  const i = foe(e, Pm(e.constructor));
  i[t] || (i[t] = []), i[t].push(r);
}
function foe(e, t) {
  return e.__agComponentMetaData || (e.__agComponentMetaData = {}), e.__agComponentMetaData[t] || (e.__agComponentMetaData[t] = {}), e.__agComponentMetaData[t];
}
var cE = class extends Oe {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
    );
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${r("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const r = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(r);
      }
    });
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.init(e);
  }
};
v([
  ne("eFloatingFilterText")
], cE.prototype, "eFloatingFilterText", 2);
v([
  T("columnModel")
], cE.prototype, "columnModel", 2);
var $_ = class {
  constructor(e, t, r, i, n) {
    this.alive = !0, this.context = e, this.eParent = i, t.getDateCompDetails(r).newAgStackInstance().then((a) => {
      if (!this.alive) {
        e.destroyBean(a);
        return;
      }
      this.dateComp = a, a && (i.appendChild(a.getGui()), a.afterGuiAttached && a.afterGuiAttached(), this.tempValue && a.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled), n == null || n(this));
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    We(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  updateParams(e) {
    var t, r;
    let i = !1;
    (t = this.dateComp) != null && t.refresh && typeof this.dateComp.refresh == "function" && this.dateComp.refresh(e) !== null && (i = !0), !i && ((r = this.dateComp) != null && r.onParamsUpdated) && typeof this.dateComp.onParamsUpdated == "function" && this.dateComp.onParamsUpdated(e) !== null && we("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}, j_ = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string")
        return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], r = (i) => i.some((n) => e[n] != null) ? !0 : (console.warn(`AG Grid: ignoring FilterOptionDef as it doesn't contain one of '${i}'`), !1);
      if (!t.every(r)) {
        this.filterOptions = this.filterOptions.filter((i) => i === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : console.warn("AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else
      console.warn("AG Grid: no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}, z_ = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
}, Hm = class U_ extends Q {
  constructor(t, r = {}) {
    super(), this.eFocusableElement = t, this.callbacks = r, this.callbacks = Ce({
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (i) => {
        if (i.defaultPrevented)
          return;
        const n = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, i.shiftKey);
        n && (n.focus(), i.preventDefault());
      }
    }, r);
  }
  postConstruct() {
    this.eFocusableElement.classList.add(U_.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn), this.callbacks.onFocusOut && this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
  }
  addKeyDownListeners(t) {
    this.addManagedListener(t, "keydown", (r) => {
      if (!(r.defaultPrevented || hn(r))) {
        if (this.callbacks.shouldStopEventPropagation(r)) {
          gn(r);
          return;
        }
        r.key === k.TAB ? this.callbacks.onTabKeyDown(r) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(r);
      }
    });
  }
};
Hm.FOCUS_MANAGED_CLASS = "ag-focus-managed";
v([
  T("focusService")
], Hm.prototype, "focusService", 2);
v([
  te
], Hm.prototype, "postConstruct", 1);
var cs = Hm, Y_ = "ag-resizer-wrapper", goe = (
  /* html */
  `<div class="${Y_}">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
), Vu = class extends Q {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, r = t / 2 - this.getWidth() / 2, i = e / 2 - this.getHeight() / 2;
    this.offsetElement(r, i);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: r, width: i, minHeight: n, height: o, x: s, y: a } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, u = 0;
    const c = ii(this.element);
    if (c) {
      const d = this.findBoundaryElement(), h = window.getComputedStyle(d);
      if (h.minWidth != null) {
        const p = d.offsetWidth - this.element.offsetWidth;
        u = parseInt(h.minWidth, 10) - p;
      }
      if (h.minHeight != null) {
        const p = d.offsetHeight - this.element.offsetHeight;
        l = parseInt(h.minHeight, 10) - p;
      }
    }
    if (this.minHeight = n || l, this.minWidth = r || u, i && this.setWidth(i), o && this.setHeight(o), (!i || !o) && this.refreshSize(), e)
      this.center();
    else if (s || a)
      this.offsetElement(s, a);
    else if (c && t) {
      let d = this.boundaryEl, h = !0;
      if (d || (d = this.findBoundaryElement(), h = !1), d) {
        const p = parseFloat(d.style.top), g = parseFloat(d.style.left);
        h ? this.offsetElement(
          isNaN(g) ? 0 : g,
          isNaN(p) ? 0 : p
        ) : this.setPosition(g, p);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const r = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      const i = !!e[t], n = this.getResizerElement(t), o = {
        dragStartPixels: 0,
        eElement: n,
        onDragStart: (s) => this.onResizeStart(s, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (s) => this.onResizeEnd(s, t)
      };
      (i || !this.isAlive() && !i) && (i ? (this.dragService.addDragSource(o), this.resizeListeners.push(o), n.style.pointerEvents = "all") : n.style.pointerEvents = "none", this.resizable[t] = i);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, r = this.element;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Ys(r, e), e = eE(r), i = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const n = this.getAvailableHeight();
      n && e > n && (e = n);
    }
    this.getHeight() !== e && (i ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : t ? Ys(r, e) : (r.style.height = `${e}px`, r.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: r } = this.offsetParent;
    if (!r)
      return null;
    const i = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), o = e ? this.position.y : i.top, s = e ? 0 : n.top;
    let a = 0;
    if (t) {
      const u = this.element.parentElement;
      if (u) {
        const { bottom: c } = u.getBoundingClientRect();
        a = c - i.bottom;
      }
    }
    return r + s - o - a;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: r } = this.config;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Wi(t, e), e = Od(t), i = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: n } = this.offsetParent, o = r ? this.position.x : this.element.getBoundingClientRect().left;
      n && e + o > n && (e = n - o);
    }
    this.getWidth() !== e && (i ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Wi(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: r } = this.config, i = r ? this.boundaryEl : this.element;
    i && (this.popupService.positionPopup({
      ePopup: i,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(
      parseFloat(i.style.left),
      parseFloat(i.style.top)
    ));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const r = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${r}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(
      this.popupService.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: r, isTop: i, anywhereWithin: n, topBuffer: o } = e, s = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!r, !!n, s) ? 0 : s, u = this.shouldSkipY(t, !!i, o, a) ? 0 : a;
    return { movementX: l, movementY: u };
  }
  shouldSkipX(e, t, r, i) {
    const n = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), s = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.x : n.left;
    let l = a <= 0 && o.left >= e.clientX || o.right <= e.clientX && o.right <= s.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    i < 0 && e.clientX > a + o.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    i > 0 && e.clientX < a + o.left : r ? l = i < 0 && e.clientX > s.right || i > 0 && e.clientX < a + o.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    i < 0 && e.clientX > s.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    i > 0 && e.clientX < s.right, l);
  }
  shouldSkipY(e, t, r = 0, i) {
    const n = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), s = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.y : n.top;
    let l = a <= 0 && o.top >= e.clientY || o.bottom <= e.clientY && o.bottom <= s.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    i < 0 && e.clientY > a + o.top + r || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    i > 0 && e.clientY < a + o.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    i < 0 && e.clientY > s.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    i > 0 && e.clientY < s.bottom, l);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[ref=eTopResizer]") },
      topRight: { element: e.querySelector("[ref=eTopRightResizer]") },
      right: { element: e.querySelector("[ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const r = new DOMParser().parseFromString(goe, "text/html").body;
    e.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${Y_}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: r, forcePopupParentAsOffsetParent: i } = this.config;
    !r && !i && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((r) => !r.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, r = 0;
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = !!n.style.flex && n.style.flex !== "0 0 auto";
      if (n === this.element)
        continue;
      let s = this.minHeight || 0, a = this.minWidth || 0;
      if (o) {
        const l = window.getComputedStyle(n);
        l.minHeight && (s = parseInt(l.minHeight, 10)), l.minWidth && (a = parseInt(l.minWidth, 10));
      } else
        s = n.offsetHeight, a = n.offsetWidth;
      t += s, r += a;
    }
    return { height: t, width: r };
  }
  applySizeToSiblings(e) {
    let t = null;
    const r = this.getSiblings();
    if (r) {
      for (let i = 0; i < r.length; i++) {
        const n = r[i];
        n !== t && (e ? n.style.height = `${n.offsetHeight}px` : n.style.width = `${n.offsetWidth}px`, n.style.flex = "0 0 auto", n === this.element && (t = r[i + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: r } = this.config, { isTop: i, isRight: n, isBottom: o, isLeft: s } = this.currentResizer, a = n || s, l = o || i, { movementX: u, movementY: c } = this.calculateMouseMovement({ e, isLeft: s, isTop: i }), d = this.position.x, h = this.position.y;
    let p = 0, g = 0;
    if (a && u) {
      const m = s ? -1 : 1, f = this.getWidth(), C = f + u * m;
      let w = !1;
      s && (p = f - C, (d + p <= 0 || C <= this.minWidth) && (w = !0, p = 0)), w || this.setWidth(C);
    }
    if (l && c) {
      const m = i ? -1 : 1, f = this.getHeight(), C = f + c * m;
      let w = !1;
      i ? (g = f - C, (h + g <= 0 || C <= this.minHeight) && (w = !0, g = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && f < C && this.getMinSizeOfSiblings().height + C > this.element.parentElement.offsetHeight && (w = !0), w || this.setHeight(C);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || r) && p || g) && this.offsetElement(
      d + p,
      h + g
    );
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null;
    const r = {
      type: "resize"
    };
    this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchEvent(r);
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: r } = this.position;
    let i;
    this.config.calculateTopBuffer && (i = this.config.calculateTopBuffer());
    const { movementX: n, movementY: o } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: i
    });
    this.offsetElement(t + n, r + o), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
};
v([
  T("popupService")
], Vu.prototype, "popupService", 2);
v([
  T("resizeObserverService")
], Vu.prototype, "resizeObserverService", 2);
v([
  T("dragService")
], Vu.prototype, "dragService", 2);
var Bm = class Ac extends Oe {
  constructor(t) {
    super(), this.filterNameKey = t, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.buttonListeners = [];
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(new cs(
      this.getFocusableElement(),
      {
        handleKeyDown: this.handleKeyDown.bind(this)
      }
    )), this.positionableFeature = new Vu(
      this.getPositionableElement(),
      {
        forcePopupParentAsOffsetParent: !0
      }
    ), this.createBean(this.positionableFeature);
  }
  // override
  handleKeyDown(t) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(t) {
    let r = this.getGui();
    r && r.removeEventListener("submit", this.onFormSubmit);
    const i = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(i, t), r = this.getGui(), r && r.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(t) {
    this.setParams(t), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(t) {
    this.providedFilterParams = t, this.applyActive = Ac.isUseApplyButton(t), this.resetButtonsPanel();
  }
  updateParams(t) {
    this.providedFilterParams = t, this.applyActive = Ac.isUseApplyButton(t), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel() {
    const { buttons: t } = this.providedFilterParams, r = t && t.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (Ht(this.eButtonsPanel), this.buttonListeners.forEach((o) => o == null ? void 0 : o()), this.buttonListeners = []) : r && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !r) {
      this.eButtonsPanel && ln(this.eButtonsPanel);
      return;
    }
    const i = document.createDocumentFragment(), n = (o) => {
      let s, a;
      switch (o) {
        case "apply":
          s = this.translate("applyFilter"), a = (c) => this.onBtApply(!1, !1, c);
          break;
        case "clear":
          s = this.translate("clearFilter"), a = () => this.onBtClear();
          break;
        case "reset":
          s = this.translate("resetFilter"), a = () => this.onBtReset();
          break;
        case "cancel":
          s = this.translate("cancelFilter"), a = (c) => {
            this.onBtCancel(c);
          };
          break;
        default:
          console.warn("AG Grid: Unknown button type specified");
          return;
      }
      const u = Qr(
        /* html */
        `<button
                    type="${o === "apply" ? "submit" : "button"}"
                    ref="${o}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${s}
                </button>`
      );
      this.buttonListeners.push(this.addManagedListener(u, "click", a)), i.append(u);
    };
    uE(t).forEach((o) => n(o)), this.eButtonsPanel.append(i), this.getGui().appendChild(this.eButtonsPanel);
  }
  // subclasses can override this to provide alternative debounce defaults
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const t = Ac.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs()), r = kr(this.checkApplyDebounce.bind(this), t);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, r();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(t) {
    return (t != null ? this.setModelIntoUi(t) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(t) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(t);
    });
  }
  handleCancelEnd(t) {
    this.providedFilterParams.closeOnApply && this.close(t);
  }
  resetUiToActiveModel(t, r) {
    const i = () => {
      this.onUiChanged(!1, "prevent"), r == null || r();
    };
    t != null ? this.setModelIntoUi(t).then(i) : this.resetUiToDefaults().then(i);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  applyModel(t = "api") {
    const r = this.getModelFromUi();
    if (!this.isModelValid(r))
      return !1;
    const i = this.appliedModel;
    return this.appliedModel = r, !this.areModelsEqual(i, r);
  }
  isModelValid(t) {
    return !0;
  }
  onFormSubmit(t) {
    t.preventDefault();
  }
  onBtApply(t = !1, r = !1, i) {
    i && i.preventDefault(), this.applyModel(r ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: t, afterDataChange: r, source: "columnFilter" });
    const { closeOnApply: n } = this.providedFilterParams;
    n && this.applyActive && !t && !r && this.close(i);
  }
  onNewRowsLoaded() {
  }
  close(t) {
    if (!this.hidePopup)
      return;
    const r = t, i = r && r.key;
    let n;
    (i === "Enter" || i === "Space") && (n = { keyboardEvent: r }), this.hidePopup(n), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(t = !1, r) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const i = this.isModelValid(this.getModelFromUi()), n = this.getRefElement("applyFilterButton");
      n && Jl(n, !i);
    }
    t && !r || r === "immediately" ? this.onBtApply(t) : (!this.applyActive && !r || r === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(t) {
    t && (this.hidePopup = t.hidePopup), this.refreshFilterResizer(t == null ? void 0 : t.container);
  }
  refreshFilterResizer(t) {
    if (!this.positionableFeature || t === "toolPanel")
      return;
    const r = t === "floatingFilter" || t === "columnFilter", { positionableFeature: i, gos: n } = this;
    r ? (i.restoreLastSize(), i.setResizable(
      n.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1);
  }
  // static, as used by floating filter also
  static getDebounceMs(t, r) {
    return Ac.isUseApplyButton(t) ? (t.debounceMs != null && console.warn("AG Grid: debounceMs is ignored when apply button is present"), 0) : t.debounceMs != null ? t.debounceMs : r;
  }
  // static, as used by floating filter also
  static isUseApplyButton(t) {
    return !!t.buttons && t.buttons.indexOf("apply") >= 0;
  }
  refresh(t) {
    return this.providedFilterParams = t, !0;
  }
  destroy() {
    const t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(t) {
    return this.localeService.getLocaleTextFunc()(t, z_[t]);
  }
  getCellValue(t) {
    return this.providedFilterParams.getValue(t);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
};
v([
  T("rowModel")
], Bm.prototype, "rowModel", 2);
v([
  ne("eFilterBody")
], Bm.prototype, "eFilterBody", 2);
v([
  te
], Bm.prototype, "postConstruct", 1);
var cg = Bm, dE = class extends Oe {
  constructor(e, t) {
    super(t), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: r, labelAlignment: i, disabled: n } = this.config;
    n != null && this.setDisabled(n), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), r != null && this.setLabelWidth(r), this.setLabelAlignment(i || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    Ht(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (We(this.eLabel, !1), Nt(this.eLabel, "presentation")) : (We(this.eLabel, !0), Nt(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const r = this.getGui().classList;
    return r.toggle("ag-label-align-left", e === "left"), r.toggle("ag-label-align-right", e === "right"), r.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (Nd(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return Jl(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
};
v([
  te
], dE.prototype, "postConstruct", 1);
var X_ = class extends dE {
  constructor(e, t, r) {
    super(e, t), this.className = r;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: r } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), r != null && this.onValueChange(r), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId();
    n_(e) !== null ? ql(e, "") : ql(e, t ?? "");
  }
  setAriaLabel(e) {
    return Si(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListener(this, A.EVENT_FIELD_VALUE_CHANGED, () => e(this.getValue())), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Wi(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchEvent({ type: A.EVENT_FIELD_VALUE_CHANGED }), this);
  }
}, moe = (
  /* html */
  `
    <div class="ag-picker-field" role="presentation">
        <div ref="eLabel"></div>
            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
            <div ref="eDisplayField" class="ag-picker-field-display"></div>
            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
        </div>
    </div>`
), Fa = class extends X_ {
  constructor(e) {
    if (super(e, (e == null ? void 0 : e.template) || moe, e == null ? void 0 : e.className), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: r, variableWidth: i, minPickerWidth: n, maxPickerWidth: o } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!i, r != null && this.setPickerMaxHeight(r), n != null && this.setPickerMinWidth(n), o != null && this.setPickerMaxWidth(o);
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedListener(t, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(this.eLabel, "mousedown", this.onLabelOrWrapperMouseDown.bind(this)), this.addManagedListener(this.eWrapper, "mousedown", this.onLabelOrWrapperMouseDown.bind(this));
    const { pickerIcon: r, inputWidth: i } = this.config;
    if (r) {
      const n = It(r, this.gos);
      n && this.eIcon.appendChild(n);
    }
    i != null && this.setInputWidth(i);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), So(e, !1), this.ariaRole && Nt(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case k.UP:
      case k.DOWN:
      case k.ENTER:
      case k.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case k.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.gos.getDocument(), t = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || (this.destroyMouseWheelFunc = this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL, () => {
      this.hidePicker();
    }));
    const r = this.localeService.getLocaleTextFunc(), { pickerAriaLabelKey: i, pickerAriaLabelValue: n, modalPicker: o = !0 } = this.config, s = {
      modal: o,
      eChild: t,
      closeOnEsc: !0,
      closedCallback: () => {
        const p = this.gos.getActiveDomElement(), g = !p || p === e.body;
        this.beforeHidePicker(), g && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: r(i, n)
    }, a = this.popupService.addPopup(s), { maxPickerHeight: l, minPickerWidth: u, maxPickerWidth: c, variableWidth: d } = this;
    d ? (u && (t.style.minWidth = u), t.style.width = km(Od(this.eWrapper)), c && (t.style.maxWidth = c)) : Nd(t, c ?? Od(this.eWrapper));
    const h = l ?? `${yh(this.popupService.getPopupParent())}px`;
    return t.style.setProperty("max-height", h), t.style.position = "absolute", this.alignPickerToComponent(), a.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const { pickerType: e } = this.config, { pickerGap: t } = this, r = this.gos.get("enableRtl") ? "right" : "left";
    this.popupService.positionPopupByComponent({
      type: e,
      eventSource: this.eWrapper,
      ePopup: this.pickerComponent.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: t
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    So(t, e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && this.hideCurrentPicker();
  }
  setInputWidth(e) {
    return Nd(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
};
v([
  T("popupService")
], Fa.prototype, "popupService", 2);
v([
  ne("eLabel")
], Fa.prototype, "eLabel", 2);
v([
  ne("eWrapper")
], Fa.prototype, "eWrapper", 2);
v([
  ne("eDisplayField")
], Fa.prototype, "eDisplayField", 2);
v([
  ne("eIcon")
], Fa.prototype, "eIcon", 2);
var Wm = class Mp extends Oe {
  constructor(t = "default", r = !1) {
    super(
      /* html */
      `<div class="ag-list ag-${t}-list" role="listbox"></div>`
    ), this.cssIdentifier = t, this.unFocusable = r, this.options = [], this.itemEls = [];
  }
  init() {
    const t = this.getGui();
    this.addManagedListener(t, "mouseleave", () => this.clearHighlighted()), !this.unFocusable && this.addManagedListener(t, "keydown", this.handleKeyDown.bind(this));
  }
  handleKeyDown(t) {
    const r = t.key;
    switch (r) {
      case k.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const i = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(i);
        }
        break;
      case k.DOWN:
      case k.UP:
        t.preventDefault(), this.navigate(r);
        break;
      case k.PAGE_DOWN:
      case k.PAGE_UP:
      case k.PAGE_HOME:
      case k.PAGE_END:
        t.preventDefault(), this.navigateToPage(r);
        break;
    }
  }
  navigate(t) {
    const r = t === k.DOWN;
    let i;
    if (!this.highlightedEl)
      i = this.itemEls[r ? 0 : this.itemEls.length - 1];
    else {
      let o = this.itemEls.indexOf(this.highlightedEl) + (r ? 1 : -1);
      o = Math.min(Math.max(o, 0), this.itemEls.length - 1), i = this.itemEls[o];
    }
    this.highlightItem(i);
  }
  navigateToPage(t) {
    if (!this.highlightedEl || this.itemEls.length === 0)
      return;
    const r = this.itemEls.indexOf(this.highlightedEl), i = this.options.length - 1, n = this.itemEls[0].clientHeight, o = Math.floor(this.getGui().clientHeight / n);
    let s = -1;
    t === k.PAGE_HOME ? s = 0 : t === k.PAGE_END ? s = i : t === k.PAGE_DOWN ? s = Math.min(r + o, i) : t === k.PAGE_UP && (s = Math.max(r - o, 0)), s !== -1 && this.highlightItem(this.itemEls[s]);
  }
  addOptions(t) {
    return t.forEach((r) => this.addOption(r)), this;
  }
  addOption(t) {
    const { value: r, text: i } = t, n = i || r;
    return this.options.push({ value: r, text: n }), this.renderOption(r, n), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((t) => {
      ln(t);
    }), this.itemEls = [];
  }
  updateIndices() {
    const t = this.getGui().querySelectorAll(".ag-list-item");
    t.forEach((r, i) => {
      Nm(r, i + 1), _m(r, t.length);
    });
  }
  renderOption(t, r) {
    const i = this.gos.getDocument(), n = i.createElement("div");
    Nt(n, "option"), n.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const o = i.createElement("span");
    n.appendChild(o), o.textContent = r, this.unFocusable || (n.tabIndex = -1), this.itemEls.push(n), this.addManagedListener(n, "mousemove", () => this.highlightItem(n)), this.addManagedListener(n, "mousedown", (s) => {
      s.preventDefault(), this.setValue(t);
    }), this.createManagedBean(new Mo({
      getTooltipValue: () => r,
      getGui: () => n,
      getLocation: () => "UNKNOWN",
      // only show tooltips for items where the text cannot be fully displayed
      shouldDisplayTooltip: () => o.scrollWidth > o.clientWidth
    })), this.getGui().appendChild(n);
  }
  setValue(t, r) {
    if (this.value === t)
      return this.fireItemSelected(), this;
    if (t == null)
      return this.reset(r), this;
    const i = this.options.findIndex((n) => n.value === t);
    if (i !== -1) {
      const n = this.options[i];
      this.value = n.value, this.displayValue = n.text, this.highlightItem(this.itemEls[i]), r || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(t) {
    return this.setValue(this.options[t].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const t = this.options.findIndex((r) => r.value === this.value);
    t !== -1 && this.highlightItem(this.itemEls[t]);
  }
  reset(t) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), t || this.fireChangeEvent();
  }
  highlightItem(t) {
    if (!ii(t))
      return;
    this.clearHighlighted(), this.highlightedEl = t, this.highlightedEl.classList.add(Mp.ACTIVE_CLASS), Zl(this.highlightedEl, !0);
    const r = this.getGui(), { scrollTop: i, clientHeight: n } = r, { offsetTop: o, offsetHeight: s } = t;
    (o + s > i + n || o < i) && this.highlightedEl.scrollIntoView({ block: "nearest" }), this.unFocusable || this.highlightedEl.focus();
  }
  clearHighlighted() {
    !this.highlightedEl || !ii(this.highlightedEl) || (this.highlightedEl.classList.remove(Mp.ACTIVE_CLASS), Zl(this.highlightedEl, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchEvent({ type: A.EVENT_FIELD_VALUE_CHANGED }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchEvent({ type: Mp.EVENT_ITEM_SELECTED });
  }
};
Wm.EVENT_ITEM_SELECTED = "selectedItem";
Wm.ACTIVE_CLASS = "ag-active-item";
v([
  te
], Wm.prototype, "init", 1);
var LT = Wm, K_ = class q_ extends Fa {
  constructor(t) {
    super(Ce({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "smallDown",
      ariaRole: "combobox"
    }, t));
  }
  postConstruct() {
    super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: t, value: r, placeholder: i } = this.config;
    t != null && this.addOptions(t), r != null && this.setValue(r, !0), i && r == null && (this.eDisplayField.textContent = i), this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this));
  }
  onWrapperFocusOut(t) {
    this.eWrapper.contains(t.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    this.listComponent = this.createBean(new LT("select", !0)), this.listComponent.setParentComponent(this);
    const t = this.listComponent.getAriaElement(), r = `ag-select-list-${this.listComponent.getCompId()}`;
    t.setAttribute("id", r), zS(this.getAriaElement(), t), this.listComponent.addManagedListener(
      this.listComponent,
      LT.EVENT_ITEM_SELECTED,
      () => {
        this.hidePicker(), this.dispatchEvent({ type: q_.EVENT_ITEM_SELECTED });
      }
    ), this.listComponent.addManagedListener(
      this.listComponent,
      A.EVENT_FIELD_VALUE_CHANGED,
      () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    );
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(t) {
    var r;
    const { key: i } = t;
    switch (i === k.TAB && this.hidePicker(), i) {
      case k.ENTER:
      case k.UP:
      case k.DOWN:
      case k.PAGE_UP:
      case k.PAGE_DOWN:
      case k.PAGE_HOME:
      case k.PAGE_END:
        t.preventDefault(), this.isPickerDisplayed ? (r = this.listComponent) == null || r.handleKeyDown(t) : super.onKeyDown(t);
        break;
      case k.ESCAPE:
        super.onKeyDown(t);
        break;
    }
  }
  showPicker() {
    this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted());
  }
  addOptions(t) {
    return t.forEach((r) => this.addOption(r)), this;
  }
  addOption(t) {
    return this.listComponent.addOption(t), this;
  }
  clearOptions() {
    var t;
    return (t = this.listComponent) == null || t.clearOptions(), this;
  }
  setValue(t, r, i) {
    if (this.value === t || !this.listComponent)
      return this;
    if (i || this.listComponent.setValue(t, !0), this.listComponent.getValue() === this.getValue())
      return this;
    let o = this.listComponent.getDisplayValue();
    return o == null && this.config.placeholder && (o = this.config.placeholder), this.eDisplayField.textContent = o, this.setTooltip({
      newTooltipText: o ?? null,
      shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
    }), super.setValue(t, r);
  }
  destroy() {
    this.listComponent && (this.destroyBean(this.listComponent), this.listComponent = void 0), super.destroy();
  }
};
K_.EVENT_ITEM_SELECTED = "selectedItem";
var $m = K_, un = class extends X_ {
  constructor(e, t, r = "text", i = "input") {
    super(
      e,
      /* html */
      `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${i} ref="eInput" class="ag-input-field-input"></${i}>
                </div>
            </div>`,
      t
    ), this.inputType = r, this.displayFieldTag = i;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName: e, inputWidth: t } = this.config;
    e != null && this.setInputName(e), t != null && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => this.setValue(e.target.value));
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return Nd(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return Ln(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return Si(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return Jl(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      Ln(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      Ln(this.eInput, "autocomplete", t);
    }
    return this;
  }
};
v([
  ne("eLabel")
], un.prototype, "eLabel", 2);
v([
  ne("eWrapper")
], un.prototype, "eWrapper", 2);
v([
  ne("eInput")
], un.prototype, "eInput", 2);
var jm = class extends un {
  constructor(e, t = "ag-checkbox", r = "checkbox") {
    super(e, t, r), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this)), this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, r) {
    this.dispatchEvent({ type: A.EVENT_FIELD_VALUE_CHANGED, selected: e, previousValue: t, event: r });
    const i = this.getInputElement(), n = {
      type: A.EVENT_CHECKBOX_CHANGED,
      id: i.id,
      name: i.name,
      selected: e,
      previousValue: t
    };
    this.eventService.dispatchEvent(n);
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), r = this.selected = e.target.checked;
    this.refreshSelectedClass(r), this.dispatchChange(r, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === !0), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}, Z_ = class extends jm {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedListener(this.eventService, A.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0);
  }
}, hE = class {
  constructor(e, t, r) {
    this.localeService = e, this.optionsFactory = t, this.valueFormatter = r;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, r = this.localeService.getLocaleTextFunc();
    if (t) {
      const i = e;
      let { conditions: n } = i;
      if (!n) {
        const { condition1: a, condition2: l } = i;
        n = [a, l];
      }
      const o = n.map((a) => this.getModelAsString(a)), s = i.operator === "AND" ? "andCondition" : "orCondition";
      return o.join(` ${r(s, z_[s])} `);
    } else {
      if (e.type === Ft.BLANK || e.type === Ft.NOT_BLANK)
        return r(e.type, e.type);
      {
        const i = e, n = this.optionsFactory.getCustomOption(i.type), { displayKey: o, displayName: s, numberOfInputs: a } = n || {};
        return o && s && a === 0 ? (r(o, s), s) : this.conditionToString(i, n);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    var t;
    return this.valueFormatter ? (t = this.valueFormatter(e ?? null)) != null ? t : "" : String(e);
  }
}, zr = class el extends cg {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(t) {
    const r = this.optionsFactory.getCustomOption(t);
    if (r) {
      const { numberOfInputs: n } = r;
      return n ?? 1;
    }
    const i = [
      el.EMPTY,
      el.NOT_BLANK,
      el.BLANK
    ];
    return t && i.indexOf(t) >= 0 ? 0 : t === el.IN_RANGE ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(t, r) {
    this.setTypeFromFloatingFilter(t), this.setValueFromFloatingFilter(r), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(t) {
    this.eTypes.forEach((r, i) => {
      i === 0 ? r.setValue(t, !0) : r.setValue(this.optionsFactory.getDefaultOption(), !0);
    });
  }
  getModelFromUi() {
    const t = this.getUiCompleteConditions();
    return t.length === 0 ? null : this.maxNumConditions > 1 && t.length > 1 ? {
      filterType: this.getFilterType(),
      operator: this.getJoinOperator(),
      condition1: t[0],
      condition2: t[1],
      conditions: t
    } : t[0];
  }
  getConditionTypes() {
    return this.eTypes.map((t) => t.getValue());
  }
  getConditionType(t) {
    return this.eTypes[t].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(t, r) {
    if (!t && !r)
      return !0;
    if (!t && r || t && !r)
      return !1;
    const i = !t.operator, n = !r.operator;
    if (!i && n || i && !n)
      return !1;
    let s;
    if (i) {
      const a = t, l = r;
      s = this.areSimpleModelsEqual(a, l);
    } else {
      const a = t, l = r;
      s = a.operator === l.operator && On(a.conditions, l.conditions, (u, c) => this.areSimpleModelsEqual(u, c));
    }
    return s;
  }
  shouldRefresh(t) {
    var r, i, n;
    const o = this.getModel(), s = o ? (r = o.conditions) != null ? r : [o] : null, a = (n = (i = t.filterOptions) == null ? void 0 : i.map(
      (u) => typeof u == "string" ? u : u.displayKey
    )) != null ? n : this.getDefaultFilterOptions();
    return !(!(!s || s.every((u) => a.find((c) => c === u.type) !== void 0)) || typeof t.maxNumConditions == "number" && s && s.length > t.maxNumConditions);
  }
  refresh(t) {
    return !this.shouldRefresh(t) || !super.refresh(t) ? !1 : (this.setParams(t), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(t) {
    if (t.operator) {
      let i = t;
      i.conditions || (i.conditions = [
        i.condition1,
        i.condition2
      ]);
      const n = this.validateAndUpdateConditions(i.conditions), o = this.getNumConditions();
      if (n < o)
        this.removeConditionsAndOperators(n);
      else if (n > o)
        for (let a = o; a < n; a++)
          this.createJoinOperatorPanel(), this.createOption();
      const s = i.operator === "OR";
      this.eJoinOperatorsAnd.forEach((a) => a.setValue(!s, !0)), this.eJoinOperatorsOr.forEach((a) => a.setValue(s, !0)), i.conditions.forEach((a, l) => {
        this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l);
      });
    } else {
      const i = t;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(i.type, !0), this.setConditionIntoUi(i, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), qt.resolve();
  }
  validateAndUpdateConditions(t) {
    let r = t.length;
    return r > this.maxNumConditions && (t.splice(this.maxNumConditions), we('Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'), r = this.maxNumConditions), r;
  }
  doesFilterPass(t) {
    var r;
    const i = this.getModel();
    if (i == null)
      return !0;
    const { operator: n } = i, o = [];
    if (n) {
      const a = i;
      o.push(...(r = a.conditions) != null ? r : []);
    } else
      o.push(i);
    return o[n && n === "OR" ? "some" : "every"]((a) => this.individualConditionPasses(t, a));
  }
  setParams(t) {
    super.setParams(t), this.setNumConditions(t), this.defaultJoinOperator = this.getDefaultJoinOperator(t.defaultJoinOperator), this.filterPlaceholder = t.filterPlaceholder, this.optionsFactory = new j_(), this.optionsFactory.init(t, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(t) {
    var r, i;
    t.suppressAndOrCondition != null && we('Since v29.2 "filterParams.suppressAndOrCondition" is deprecated. Use "filterParams.maxNumConditions = 1" instead.'), t.alwaysShowBothConditions != null && we('Since v29.2 "filterParams.alwaysShowBothConditions" is deprecated. Use "filterParams.numAlwaysVisibleConditions = 2" instead.'), this.maxNumConditions = (r = t.maxNumConditions) != null ? r : t.suppressAndOrCondition ? 1 : 2, this.maxNumConditions < 1 && (we('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = (i = t.numAlwaysVisibleConditions) != null ? i : t.alwaysShowBothConditions ? 2 : 1, this.numAlwaysVisibleConditions < 1 && (we('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (we('"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const t = this.createManagedBean(new $m());
    this.eTypes.push(t), t.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(t.getGui());
    const r = this.createValueElement();
    this.eConditionBodies.push(r), this.eFilterBody.appendChild(r), this.putOptionsIntoDropdown(t), this.resetType(t);
    const i = this.getNumConditions() - 1;
    this.forEachPositionInput(i, (n) => this.resetInput(n)), this.addChangedListeners(t, i);
  }
  createJoinOperatorPanel() {
    const t = document.createElement("div");
    this.eJoinOperatorPanels.push(t), t.classList.add("ag-filter-condition");
    const r = this.createJoinOperator(this.eJoinOperatorsAnd, t, "and"), i = this.createJoinOperator(this.eJoinOperatorsOr, t, "or");
    this.eFilterBody.appendChild(t);
    const n = this.eJoinOperatorPanels.length - 1, o = this.joinOperatorId++;
    this.resetJoinOperatorAnd(r, n, o), this.resetJoinOperatorOr(i, n, o), this.isReadOnly() || (r.onValueChange(this.listener), i.onValueChange(this.listener));
  }
  createJoinOperator(t, r, i) {
    const n = this.createManagedBean(new Z_());
    return t.push(n), n.addCssClass("ag-filter-condition-operator"), n.addCssClass(`ag-filter-condition-operator-${i}`), r.appendChild(n.getGui()), n;
  }
  getDefaultJoinOperator(t) {
    return t === "AND" || t === "OR" ? t : "AND";
  }
  createFilterListOptions() {
    const t = this.optionsFactory.getFilterOptions();
    this.filterListOptions = t.map(
      (r) => typeof r == "string" ? this.createBoilerplateListOption(r) : this.createCustomListOption(r)
    );
  }
  putOptionsIntoDropdown(t) {
    this.filterListOptions.forEach((r) => {
      t.addOption(r);
    }), t.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(t) {
    return { value: t, text: this.translate(t) };
  }
  createCustomListOption(t) {
    const { displayKey: r } = t, i = this.optionsFactory.getCustomOption(t.displayKey);
    return {
      value: r,
      text: i ? this.localeService.getLocaleTextFunc()(i.displayKey, i.displayName) : this.translate(r)
    };
  }
  /**
   * @deprecated As of v29.2 filters can have more than two conditions. Check `colDef.filterParams.maxNumConditions` instead.
   */
  isAllowTwoConditions() {
    return this.maxNumConditions >= 2;
  }
  createBodyTemplate() {
    return "";
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const t = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, t);
  }
  updateNumConditions() {
    var t;
    let r = -1, i = !0;
    for (let n = 0; n < this.getNumConditions(); n++)
      this.isConditionUiComplete(n) ? r = n : i = !1;
    if (this.shouldAddNewConditionAtEnd(i))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const n = (t = this.lastUiCompletePosition) != null ? t : this.getNumConditions() - 2;
      if (r < n) {
        this.removeConditionsAndOperators(n + 1);
        const o = r + 1, s = n - o;
        s > 0 && this.removeConditionsAndOperators(o, s), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = r;
  }
  updateConditionStatusesAndValues(t, r) {
    this.eTypes.forEach((n, o) => {
      const s = this.isConditionDisabled(o, t);
      n.setDisabled(s || this.filterListOptions.length <= 1), o === 1 && (Jl(this.eJoinOperatorPanels[0], s), this.eJoinOperatorsAnd[0].setDisabled(s), this.eJoinOperatorsOr[0].setDisabled(s));
    }), this.eConditionBodies.forEach((n, o) => {
      We(n, this.isConditionBodyVisible(o));
    });
    const i = (r ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((n, o) => {
      n.setValue(!i, !0);
    }), this.eJoinOperatorsOr.forEach((n, o) => {
      n.setValue(i, !0);
    }), this.forEachInput((n, o, s, a) => {
      this.setElementDisplayed(n, o < a), this.setElementDisabled(n, this.isConditionDisabled(s, t));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(t) {
    return t && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(t, r) {
    if (t >= this.getNumConditions())
      return;
    this.removeComponents(this.eTypes, t, r), this.removeElements(this.eConditionBodies, t, r), this.removeValueElements(t, r);
    const i = Math.max(t - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, i, r), this.removeComponents(this.eJoinOperatorsAnd, i, r), this.removeComponents(this.eJoinOperatorsOr, i, r);
  }
  removeElements(t, r, i) {
    this.removeItems(t, r, i).forEach((o) => ln(o));
  }
  removeComponents(t, r, i) {
    this.removeItems(t, r, i).forEach((o) => {
      ln(o.getGui()), this.destroyBean(o);
    });
  }
  removeItems(t, r, i) {
    return i == null ? t.splice(r) : t.splice(r, i);
  }
  afterGuiAttached(t) {
    if (super.afterGuiAttached(t), this.resetPlaceholder(), !(t != null && t.suppressFocus))
      if (this.isReadOnly())
        this.eFilterBody.focus();
      else {
        const r = this.getInputs(0)[0];
        if (!r)
          return;
        r instanceof un && r.getInputElement().focus();
      }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const t = this.getModel();
    this.resetUiToActiveModel(t);
    let r = -1, i = -1, n = !1;
    const o = this.getJoinOperator();
    for (let a = this.getNumConditions() - 1; a >= 0; a--)
      if (this.isConditionUiComplete(a))
        r === -1 && (r = a, i = a);
      else {
        const l = a >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(a - 1), u = a < r;
        (l || u) && (this.removeConditionsAndOperators(a, 1), n = !0, u && i--);
      }
    let s = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), s = !0), this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), s = !0), s && this.updateConditionStatusesAndValues(i, o), n && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = i;
  }
  getPlaceholderText(t, r) {
    let i = this.translate(t);
    if (Im(this.filterPlaceholder)) {
      const n = this.filterPlaceholder, o = this.eTypes[r].getValue(), s = this.translate(o);
      i = n({
        filterOptionKey: o,
        filterOption: s,
        placeholder: i
      });
    } else typeof this.filterPlaceholder == "string" && (i = this.filterPlaceholder);
    return i;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const t = this.localeService.getLocaleTextFunc();
    this.forEachInput((r, i, n, o) => {
      if (!(r instanceof un))
        return;
      const s = i === 0 && o > 1 ? "inRangeStart" : i === 0 ? "filterOoo" : "inRangeEnd", a = i === 0 && o > 1 ? t("ariaFilterFromValue", "Filter from value") : i === 0 ? t("ariaFilterValue", "Filter Value") : t("ariaFilterToValue", "Filter to Value");
      r.setInputPlaceholder(this.getPlaceholderText(s, n)), r.setInputAriaLabel(a);
    });
  }
  setElementValue(t, r, i) {
    t instanceof un && t.setValue(r != null ? String(r) : null, !0);
  }
  setElementDisplayed(t, r) {
    t instanceof Oe && We(t.getGui(), r);
  }
  setElementDisabled(t, r) {
    t instanceof Oe && Jl(t.getGui(), r);
  }
  attachElementOnChange(t, r) {
    t instanceof un && t.onValueChange(r);
  }
  forEachInput(t) {
    this.getConditionTypes().forEach((r, i) => {
      this.forEachPositionTypeInput(i, r, t);
    });
  }
  forEachPositionInput(t, r) {
    const i = this.getConditionType(t);
    this.forEachPositionTypeInput(t, i, r);
  }
  forEachPositionTypeInput(t, r, i) {
    const n = this.getNumberOfInputs(r), o = this.getInputs(t);
    for (let s = 0; s < o.length; s++) {
      const a = o[s];
      a != null && i(a, s, t, n);
    }
  }
  isConditionDisabled(t, r) {
    return this.isReadOnly() ? !0 : t === 0 ? !1 : t > r + 1;
  }
  isConditionBodyVisible(t) {
    const r = this.getConditionType(t);
    return this.getNumberOfInputs(r) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(t) {
    return !(t >= this.getNumConditions() || this.getConditionType(t) === el.EMPTY || this.getValues(t).some((i) => i == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const t = [];
    for (let r = 0; r < this.getNumConditions(); r++)
      this.isConditionUiComplete(r) && t.push(this.createCondition(r));
    return t;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let t = this.getNumConditions(); t < this.numAlwaysVisibleConditions; t++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(t) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((r) => this.resetType(r)), this.eJoinOperatorsAnd.forEach((r, i) => this.resetJoinOperatorAnd(r, i, this.joinOperatorId + i)), this.eJoinOperatorsOr.forEach((r, i) => this.resetJoinOperatorOr(r, i, this.joinOperatorId + i)), this.joinOperatorId++, this.forEachInput((r) => this.resetInput(r)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, t || this.onUiChanged(), qt.resolve();
  }
  resetType(t) {
    const i = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    t.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(i).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(t, r, i) {
    this.resetJoinOperator(t, r, this.isDefaultOperator("AND"), this.translate("andCondition"), i);
  }
  resetJoinOperatorOr(t, r, i) {
    this.resetJoinOperator(t, r, this.isDefaultOperator("OR"), this.translate("orCondition"), i);
  }
  resetJoinOperator(t, r, i, n, o) {
    this.updateJoinOperatorDisabled(
      t.setValue(i, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${o}`).setLabel(n),
      r
    );
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((t, r) => this.updateJoinOperatorDisabled(t, r)), this.eJoinOperatorsOr.forEach((t, r) => this.updateJoinOperatorDisabled(t, r));
  }
  updateJoinOperatorDisabled(t, r) {
    t.setDisabled(this.isReadOnly() || r > 0);
  }
  resetInput(t) {
    this.setElementValue(t, null), this.setElementDisabled(t, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(t, r) {
    const i = this.mapValuesFromModel(t);
    this.forEachInput((n, o, s, a) => {
      s === r && this.setElementValue(n, i[o] != null ? i[o] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(t) {
    this.forEachInput((r, i, n, o) => {
      this.setElementValue(r, i === 0 && n === 0 ? t : null, !0);
    });
  }
  isDefaultOperator(t) {
    return t === this.defaultJoinOperator;
  }
  addChangedListeners(t, r) {
    this.isReadOnly() || (t.onValueChange(this.listener), this.forEachPositionInput(r, (i) => {
      this.attachElementOnChange(i, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(t, r) {
    const i = this.getCellValue(t.node), n = this.mapValuesFromModel(r), o = this.optionsFactory.getCustomOption(r.type), s = this.evaluateCustomFilter(o, n, i);
    return s ?? (i == null ? this.evaluateNullValue(r.type) : this.evaluateNonNullValue(n, i, r, t));
  }
  evaluateCustomFilter(t, r, i) {
    if (t == null)
      return;
    const { predicate: n } = t;
    if (n != null && !r.some((o) => o == null))
      return n(r, i);
  }
  isBlank(t) {
    return t == null || typeof t == "string" && t.trim().length === 0;
  }
  hasInvalidInputs() {
    return !1;
  }
};
zr.EMPTY = "empty";
zr.BLANK = "blank";
zr.NOT_BLANK = "notBlank";
zr.EQUALS = "equals";
zr.NOT_EQUAL = "notEqual";
zr.LESS_THAN = "lessThan";
zr.LESS_THAN_OR_EQUAL = "lessThanOrEqual";
zr.GREATER_THAN = "greaterThan";
zr.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual";
zr.IN_RANGE = "inRange";
zr.CONTAINS = "contains";
zr.NOT_CONTAINS = "notContains";
zr.STARTS_WITH = "startsWith";
zr.ENDS_WITH = "endsWith";
var Ft = zr, rr = class lr extends Ft {
  setParams(t) {
    super.setParams(t), this.scalarFilterParams = t;
  }
  evaluateNullValue(t) {
    switch (t) {
      case lr.EQUALS:
      case lr.NOT_EQUAL:
        if (this.scalarFilterParams.includeBlanksInEquals)
          return !0;
        break;
      case lr.GREATER_THAN:
      case lr.GREATER_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInGreaterThan)
          return !0;
        break;
      case lr.LESS_THAN:
      case lr.LESS_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInLessThan)
          return !0;
        break;
      case lr.IN_RANGE:
        if (this.scalarFilterParams.includeBlanksInRange)
          return !0;
        break;
      case lr.BLANK:
        return !0;
      case lr.NOT_BLANK:
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(t, r, i) {
    const n = this.comparator(), o = t[0] != null ? n(t[0], r) : 0;
    switch (i.type) {
      case lr.EQUALS:
        return o === 0;
      case lr.NOT_EQUAL:
        return o !== 0;
      case lr.GREATER_THAN:
        return o > 0;
      case lr.GREATER_THAN_OR_EQUAL:
        return o >= 0;
      case lr.LESS_THAN:
        return o < 0;
      case lr.LESS_THAN_OR_EQUAL:
        return o <= 0;
      case lr.IN_RANGE: {
        const s = n(t[1], r);
        return this.scalarFilterParams.inRangeInclusive ? o >= 0 && s <= 0 : o > 0 && s < 0;
      }
      case lr.BLANK:
        return this.isBlank(r);
      case lr.NOT_BLANK:
        return !this.isBlank(r);
      default:
        return console.warn('AG Grid: Unexpected type of filter "' + i.type + '", it looks like the filter was configured with incorrect Filter Options'), !0;
    }
  }
}, GT = 1e3, kT = 1 / 0, J_ = class extends hE {
  constructor(e, t, r) {
    super(t, r), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: r } = e, { numberOfInputs: i } = t || {}, n = r == Ft.IN_RANGE || i === 2, o = Jr(e.dateFrom), s = Jr(e.dateTo), a = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (n) {
      const l = o !== null ? Cl(o, a) : "null", u = s !== null ? Cl(s, a) : "null";
      return `${l}-${u}`;
    }
    return o != null ? Cl(o, a) : `${r}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, pE = class Q_ extends rr {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = GT, this.maxValidYear = kT, this.minValidDate = null, this.maxValidDate = null;
  }
  afterGuiAttached(t) {
    super.afterGuiAttached(t), this.dateConditionFromComps[0].afterGuiAttached(t);
  }
  mapValuesFromModel(t) {
    const { dateFrom: r, dateTo: i, type: n } = t || {};
    return [
      r && Jr(r) || null,
      i && Jr(i) || null
    ].slice(0, this.getNumberOfInputs(n));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(t, r) {
    const i = r;
    return r == null || i < t ? -1 : i > t ? 1 : 0;
  }
  setParams(t) {
    this.dateFilterParams = t, super.setParams(t);
    const r = (i, n) => {
      if (t[i] != null)
        if (isNaN(t[i]))
          console.warn(`AG Grid: DateFilter ${i} is not a number`);
        else
          return t[i] == null ? n : Number(t[i]);
      return n;
    };
    this.minValidYear = r("minValidYear", GT), this.maxValidYear = r("maxValidYear", kT), this.minValidYear > this.maxValidYear && console.warn("AG Grid: DateFilter minValidYear should be <= maxValidYear"), t.minValidDate ? this.minValidDate = t.minValidDate instanceof Date ? t.minValidDate : Jr(t.minValidDate) : this.minValidDate = null, t.maxValidDate ? this.maxValidDate = t.maxValidDate instanceof Date ? t.maxValidDate : Jr(t.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && console.warn("AG Grid: DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new J_(this.dateFilterParams, this.localeService, this.optionsFactory);
  }
  createDateCompWrapper(t) {
    const r = new $_(
      this.getContext(),
      this.userComponentFactory,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams
      },
      t
    );
    return this.addDestroyFunc(() => r.destroy()), r;
  }
  setElementValue(t, r) {
    t.setDate(r);
  }
  setElementDisplayed(t, r) {
    t.setDisplayed(r);
  }
  setElementDisabled(t, r) {
    t.setDisabled(r);
  }
  getDefaultFilterOptions() {
    return Q_.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const r = this.gos.getDocument().createElement("div");
    return r.classList.add("ag-filter-body"), this.createFromToElement(r, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(r, this.eConditionPanelsTo, this.dateConditionToComps, "to"), r;
  }
  createFromToElement(t, r, i, n) {
    const s = this.gos.getDocument().createElement("div");
    s.classList.add(`ag-filter-${n}`), s.classList.add(`ag-filter-date-${n}`), r.push(s), t.appendChild(s), i.push(this.createDateCompWrapper(s));
  }
  removeValueElements(t, r) {
    this.removeDateComps(this.dateConditionFromComps, t, r), this.removeDateComps(this.dateConditionToComps, t, r), this.removeItems(this.eConditionPanelsFrom, t, r), this.removeItems(this.eConditionPanelsTo, t, r);
  }
  removeDateComps(t, r, i) {
    this.removeItems(t, r, i).forEach((o) => o.destroy());
  }
  isValidDateValue(t) {
    if (t === null)
      return !1;
    if (this.minValidDate) {
      if (t < this.minValidDate)
        return !1;
    } else if (t.getUTCFullYear() < this.minValidYear)
      return !1;
    if (this.maxValidDate) {
      if (t > this.maxValidDate)
        return !1;
    } else if (t.getUTCFullYear() > this.maxValidYear)
      return !1;
    return !0;
  }
  isConditionUiComplete(t) {
    if (!super.isConditionUiComplete(t))
      return !1;
    let r = !0;
    return this.forEachInput((i, n, o, s) => {
      o !== t || !r || n >= s || (r = r && this.isValidDateValue(i.getDate()));
    }), r;
  }
  areSimpleModelsEqual(t, r) {
    return t.dateFrom === r.dateFrom && t.dateTo === r.dateTo && t.type === r.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(t) {
    const r = this.getConditionType(t), i = {}, n = this.getValues(t);
    return n.length > 0 && (i.dateFrom = Bi(n[0])), n.length > 1 && (i.dateTo = Bi(n[1])), Ce({
      dateFrom: null,
      dateTo: null,
      filterType: this.getFilterType(),
      type: r
    }, i);
  }
  resetPlaceholder() {
    const t = this.localeService.getLocaleTextFunc(), r = this.translate("dateFormatOoo"), i = t("ariaFilterValue", "Filter Value");
    this.forEachInput((n) => {
      n.setInputPlaceholder(r), n.setInputAriaLabel(i);
    });
  }
  getInputs(t) {
    return t >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[t], this.dateConditionToComps[t]];
  }
  getValues(t) {
    const r = [];
    return this.forEachPositionInput(t, (i, n, o, s) => {
      n < s && r.push(i.getDate());
    }), r;
  }
  translate(t) {
    return t === rr.LESS_THAN ? super.translate("before") : t === rr.GREATER_THAN ? super.translate("after") : super.translate(t);
  }
  getModelAsString(t) {
    var r;
    return (r = this.filterModelFormatter.getModelAsString(t)) != null ? r : "";
  }
};
pE.DEFAULT_FILTER_OPTIONS = [
  rr.EQUALS,
  rr.NOT_EQUAL,
  rr.LESS_THAN,
  rr.GREATER_THAN,
  rr.IN_RANGE,
  rr.BLANK,
  rr.NOT_BLANK
];
v([
  T("userComponentFactory")
], pE.prototype, "userComponentFactory", 2);
var eN = pE, fE = class extends Oe {
  getDefaultDebounceMs() {
    return 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let r;
    t ? r = e.conditions[0] : r = e, this.lastType = r.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const r = e;
    return this.isTypeEditable(r.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    this.optionsFactory = new j_(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
    const r = this.isTypeEditable(this.optionsFactory.getDefaultOption());
    this.setEditable(r);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: r } = t || {};
    return r == null || r == 1;
  }
  isTypeEditable(e) {
    const t = [
      Ft.IN_RANGE,
      Ft.EMPTY,
      Ft.BLANK,
      Ft.NOT_BLANK
    ];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    return `${t} ${r("ariaFilterInput", "Filter Input")}`;
  }
};
v([
  T("columnModel")
], fE.prototype, "columnModel", 2);
var zm = class extends fE {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`
    );
  }
  getDefaultFilterOptions() {
    return eN.DEFAULT_FILTER_OPTIONS;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new J_(this.filterParams, this.localeService, this.optionsFactory);
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory, dateFilterParams: this.filterParams }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      if (e) {
        const r = e;
        this.dateComp.setDate(Jr(r.dateFrom));
      } else
        this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    We(this.eDateWrapper, e), We(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Bi(e);
    this.params.parentFilterInstance((r) => {
      if (r) {
        const i = Jr(t);
        r.onFloatingFilterChanged(this.getLastType() || null, i);
      }
    });
  }
  getDateComponentParams() {
    const e = cg.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
    return {
      onDateChanged: kr(this.onDateChanged.bind(this), e),
      filterParams: this.params.column.getColDef().filterParams
    };
  }
  createDateComponent() {
    this.dateComp = new $_(this.getContext(), this.userComponentFactory, this.getDateComponentParams(), this.eDateWrapper, (e) => {
      e.setInputAriaLabel(this.getAriaLabel(this.params));
    }), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  updateDateComponent() {
    const e = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(e);
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
};
v([
  T("userComponentFactory")
], zm.prototype, "userComponentFactory", 2);
v([
  ne("eReadOnlyText")
], zm.prototype, "eReadOnlyText", 2);
v([
  ne("eDateWrapper")
], zm.prototype, "eDateWrapper", 2);
var tN = class extends Oe {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`
    );
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListener(t, "mousedown", () => {
      this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus();
    }), this.addManagedListener(t, "input", (r) => {
      r.target === this.gos.getActiveDomElement() && (this.eDateInput.isDisabled() || this.params.onDateChanged());
    });
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), r = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = r && jn(), t.type = r ? "date" : "text";
    const {
      minValidYear: i,
      maxValidYear: n,
      minValidDate: o,
      maxValidDate: s
    } = e.filterParams || {};
    if (o && i && we("DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."), s && n && we("DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."), o && s) {
      const [a, l] = [o, s].map((u) => u instanceof Date ? u : Jr(u));
      a && l && a.getTime() > l.getTime() && we("DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.");
    }
    o ? o instanceof Date ? t.min = Cl(o) : t.min = o : i && (t.min = `${i}-01-01`), s ? s instanceof Date ? t.max = Cl(s) : t.max = s : n && (t.max = `${n}-12-31`);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return Jr(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Bi(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : Gm() || YS() || jn() && US() >= 14.1;
  }
};
v([
  ne("eDateInput")
], tN.prototype, "eDateInput", 2);
var _a = class extends un {
  constructor(e, t = "ag-text-field", r = "text") {
    super(e, t, r);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    return this.eInput.value !== e && (this.eInput.value = q(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (r) => {
      Vm(r) && r.key && !e.test(r.key) && r.preventDefault();
    };
    this.addManagedListener(this.eInput, "keydown", t), this.addManagedListener(this.eInput, "paste", (r) => {
      var i;
      const n = (i = r.clipboardData) == null ? void 0 : i.getData("text");
      n && n.split("").some((o) => !e.test(o)) && r.preventDefault();
    });
  }
}, gE = class extends _a {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListener(this.eInput, "blur", () => {
      const n = parseFloat(this.eInput.value), o = isNaN(n) ? "" : this.normalizeValue(n.toString());
      this.value !== o && this.setValue(o);
    }), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this)), this.eInput.step = "any";
    const { precision: e, min: t, max: r, step: i } = this.config;
    typeof e == "number" && this.setPrecision(e), typeof t == "number" && this.setMin(t), typeof r == "number" && this.setMax(r), typeof i == "number" && this.setStep(i);
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null)
      return e;
    if (t) {
      const i = parseFloat(e).toFixed(this.precision);
      return parseFloat(i).toString();
    }
    const r = String(e).split(".");
    if (r.length > 1) {
      if (r[1].length <= this.precision)
        return e;
      if (this.precision > 0)
        return `${r[0]}.${r[1].slice(0, this.precision)}`;
    }
    return r[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, Ln(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, Ln(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ln(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue((r) => super.setValue(r, t), () => this, e);
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, r) {
    if (q(r)) {
      let i = this.isScientificNotation(r);
      if (i && this.eInput.validity.valid)
        return e(r);
      if (!i) {
        r = this.adjustPrecision(r);
        const n = this.normalizeValue(r);
        i = r != n;
      }
      if (i)
        return t(r);
    }
    return e(r);
  }
  getValue() {
    if (!this.eInput.validity.valid)
      return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, rN = class extends hE {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == Ft.IN_RANGE || r === 2 ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : e.filter != null ? this.formatValue(e.filter) : `${e.type}`;
  }
};
function Hb(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var iN = class nN extends rr {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  refresh(t) {
    return this.numberFilterParams.allowedCharPattern !== t.allowedCharPattern ? !1 : super.refresh(t);
  }
  mapValuesFromModel(t) {
    const { filter: r, filterTo: i, type: n } = t || {};
    return [
      this.processValue(r),
      this.processValue(i)
    ].slice(0, this.getNumberOfInputs(n));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (t, r) => t === r ? 0 : t < r ? 1 : -1;
  }
  setParams(t) {
    this.numberFilterParams = t, super.setParams(t), this.filterModelFormatter = new rN(this.localeService, this.optionsFactory, this.numberFilterParams.numberFormatter);
  }
  getDefaultFilterOptions() {
    return nN.DEFAULT_FILTER_OPTIONS;
  }
  setElementValue(t, r, i) {
    const n = !i && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(r ?? null) : r;
    super.setElementValue(t, n);
  }
  createValueElement() {
    const t = Hb(this.numberFilterParams), r = document.createElement("div");
    return r.classList.add("ag-filter-body"), Nt(r, "presentation"), this.createFromToElement(r, this.eValuesFrom, "from", t), this.createFromToElement(r, this.eValuesTo, "to", t), r;
  }
  createFromToElement(t, r, i, n) {
    const o = this.createManagedBean(n ? new _a({ allowedCharPattern: n }) : new gE());
    o.addCssClass(`ag-filter-${i}`), o.addCssClass("ag-filter-filter"), r.push(o), t.appendChild(o.getGui());
  }
  removeValueElements(t, r) {
    this.removeComponents(this.eValuesFrom, t, r), this.removeComponents(this.eValuesTo, t, r);
  }
  getValues(t) {
    const r = [];
    return this.forEachPositionInput(t, (i, n, o, s) => {
      n < s && r.push(this.processValue(this.stringToFloat(i.getValue())));
    }), r;
  }
  areSimpleModelsEqual(t, r) {
    return t.filter === r.filter && t.filterTo === r.filterTo && t.type === r.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(t) {
    return t == null || isNaN(t) ? null : t;
  }
  stringToFloat(t) {
    if (typeof t == "number")
      return t;
    let r = Nn(t);
    return r != null && r.trim() === "" && (r = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(r) : r == null || r.trim() === "-" ? null : parseFloat(r);
  }
  createCondition(t) {
    const r = this.getConditionType(t), i = {
      filterType: this.getFilterType(),
      type: r
    }, n = this.getValues(t);
    return n.length > 0 && (i.filter = n[0]), n.length > 1 && (i.filterTo = n[1]), i;
  }
  getInputs(t) {
    return t >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[t], this.eValuesTo[t]];
  }
  getModelAsString(t) {
    var r;
    return (r = this.filterModelFormatter.getModelAsString(t)) != null ? r : "";
  }
  hasInvalidInputs() {
    let t = !1;
    return this.forEachInput((r) => {
      if (!r.getInputElement().validity.valid) {
        t = !0;
        return;
      }
    }), t;
  }
};
iN.DEFAULT_FILTER_OPTIONS = [
  rr.EQUALS,
  rr.NOT_EQUAL,
  rr.GREATER_THAN,
  rr.GREATER_THAN_OR_EQUAL,
  rr.LESS_THAN,
  rr.LESS_THAN_OR_EQUAL,
  rr.IN_RANGE,
  rr.BLANK,
  rr.NOT_BLANK
];
var oN = iN, sN = class extends hE {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == Ft.IN_RANGE || r === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
}, nn = class tl extends Ft {
  constructor() {
    super("textFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  static trimInput(t) {
    const r = t && t.trim();
    return r === "" ? t : r;
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(t) {
    this.textFilterParams = t, super.setParams(t), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? tl.DEFAULT_FORMATTER : tl.DEFAULT_LOWERCASE_FORMATTER), this.filterModelFormatter = new sN(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const t = this.textFilterParams.textCustomComparator;
    return t ? (Ae.warnOnce("textCustomComparator is deprecated, use textMatcher instead."), ({ filterOption: r, value: i, filterText: n }) => t(r, i, n)) : this.textFilterParams.textMatcher || tl.DEFAULT_MATCHER;
  }
  createCondition(t) {
    const r = this.getConditionType(t), i = {
      filterType: this.getFilterType(),
      type: r
    }, n = this.getValuesWithSideEffects(t, !0);
    return n.length > 0 && (i.filter = n[0]), n.length > 1 && (i.filterTo = n[1]), i;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(t, r) {
    return t.filter === r.filter && t.filterTo === r.filterTo && t.type === r.type;
  }
  getInputs(t) {
    return t >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[t], this.eValuesTo[t]];
  }
  getValues(t) {
    return this.getValuesWithSideEffects(t, !1);
  }
  getValuesWithSideEffects(t, r) {
    const i = [];
    return this.forEachPositionInput(t, (n, o, s, a) => {
      var l;
      if (o < a) {
        let u = Nn(n.getValue());
        r && this.textFilterParams.trimInput && (u = (l = tl.trimInput(u)) != null ? l : null, n.setValue(u, !0)), i.push(u);
      }
    }), i;
  }
  getDefaultFilterOptions() {
    return tl.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const t = document.createElement("div");
    return t.classList.add("ag-filter-body"), Nt(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from"), this.createFromToElement(t, this.eValuesTo, "to"), t;
  }
  createFromToElement(t, r, i) {
    const n = this.createManagedBean(new _a());
    n.addCssClass(`ag-filter-${i}`), n.addCssClass("ag-filter-filter"), r.push(n), t.appendChild(n.getGui());
  }
  removeValueElements(t, r) {
    this.removeComponents(this.eValuesFrom, t, r), this.removeComponents(this.eValuesTo, t, r);
  }
  mapValuesFromModel(t) {
    const { filter: r, filterTo: i, type: n } = t || {};
    return [
      r || null,
      i || null
    ].slice(0, this.getNumberOfInputs(n));
  }
  evaluateNullValue(t) {
    const r = [
      Ft.NOT_EQUAL,
      Ft.NOT_CONTAINS,
      Ft.BLANK
    ];
    return t ? r.indexOf(t) >= 0 : !1;
  }
  evaluateNonNullValue(t, r, i, n) {
    const o = t.map((g) => this.formatter(g)) || [], s = this.formatter(r), { api: a, colDef: l, column: u, columnApi: c, context: d, textFormatter: h } = this.textFilterParams;
    if (i.type === Ft.BLANK)
      return this.isBlank(r);
    if (i.type === Ft.NOT_BLANK)
      return !this.isBlank(r);
    const p = {
      api: a,
      colDef: l,
      column: u,
      columnApi: c,
      context: d,
      node: n.node,
      data: n.data,
      filterOption: i.type,
      value: s,
      textFormatter: h
    };
    return o.some((g) => this.matcher(Dt(Ce({}, p), { filterText: g })));
  }
  getModelAsString(t) {
    var r;
    return (r = this.filterModelFormatter.getModelAsString(t)) != null ? r : "";
  }
};
nn.DEFAULT_FILTER_OPTIONS = [
  Ft.CONTAINS,
  Ft.NOT_CONTAINS,
  Ft.EQUALS,
  Ft.NOT_EQUAL,
  Ft.STARTS_WITH,
  Ft.ENDS_WITH,
  Ft.BLANK,
  Ft.NOT_BLANK
];
nn.DEFAULT_FORMATTER = (e) => e;
nn.DEFAULT_LOWERCASE_FORMATTER = (e) => e == null ? null : e.toString().toLowerCase();
nn.DEFAULT_MATCHER = ({ filterOption: e, value: t, filterText: r }) => {
  if (r == null)
    return !1;
  switch (e) {
    case nn.CONTAINS:
      return t.indexOf(r) >= 0;
    case nn.NOT_CONTAINS:
      return t.indexOf(r) < 0;
    case nn.EQUALS:
      return t === r;
    case nn.NOT_EQUAL:
      return t != r;
    case nn.STARTS_WITH:
      return t.indexOf(r) === 0;
    case nn.ENDS_WITH:
      const i = t.lastIndexOf(r);
      return i >= 0 && i === t.length - r.length;
    default:
      return !1;
  }
};
var mE = nn, aN = class extends Q {
  constructor(e) {
    super(), this.params = e, this.valueChangedListener = () => {
    };
  }
  setupGui(e) {
    var t;
    this.eFloatingFilterTextInput = this.createManagedBean(new _a((t = this.params) == null ? void 0 : t.config));
    const r = this.eFloatingFilterTextInput.getGui();
    e.appendChild(r), this.addManagedListener(r, "input", (i) => this.valueChangedListener(i)), this.addManagedListener(r, "keydown", (i) => this.valueChangedListener(i));
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  setAutoComplete(e) {
    this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Um = class extends fE {
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    var t;
    this.params = e;
    const r = (t = e.browserAutoComplete) != null ? t : !1;
    if (this.floatingFilterInputService.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: r
    }), this.applyActive = cg.isUseApplyButton(this.params.filterParams), !this.isReadOnly()) {
      const i = cg.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), n = kr(this.syncUpWithParentFilter.bind(this), i);
      this.floatingFilterInputService.setValueChangedListener(n);
    }
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const t = this.floatingFilterInputService.getValue();
    Ht(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === k.ENTER;
    if (this.applyActive && !t)
      return;
    let r = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (r = mE.trimInput(r), this.floatingFilterInputService.setValue(r, !0)), this.params.parentFilterInstance((i) => {
      i && i.onFloatingFilterChanged(this.getLastType() || null, r || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
};
v([
  ne("eFloatingFilterInputContainer")
], Um.prototype, "eFloatingFilterInputContainer", 2);
v([
  te
], Um.prototype, "postConstruct", 1);
var voe = class extends Q {
  constructor() {
    super(...arguments), this.valueChangedListener = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new gE()), this.eFloatingFilterTextInput = this.createManagedBean(new _a()), this.eFloatingFilterTextInput.setDisabled(!0);
    const t = this.eFloatingFilterNumberInput.getGui(), r = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t), e.appendChild(r), this.setupListeners(t, (i) => this.valueChangedListener(i)), this.setupListeners(r, (i) => this.valueChangedListener(i));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setupListeners(e, t) {
    this.addManagedListener(e, "input", t), this.addManagedListener(e, "keydown", t);
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Coe = class extends Um {
  init(e) {
    var t;
    super.init(e), this.filterModelFormatter = new rN(
      this.localeService,
      this.optionsFactory,
      (t = e.filterParams) == null ? void 0 : t.numberFormatter
    );
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    Hb(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return oN.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = Hb(e.filterParams), this.allowedCharPattern ? this.createManagedBean(new aN({
      config: { allowedCharPattern: this.allowedCharPattern }
    })) : this.createManagedBean(new voe());
  }
}, yoe = class extends Um {
  init(e) {
    super.init(e), this.filterModelFormatter = new sN(this.localeService, this.optionsFactory);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return mE.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new aN());
  }
}, Ah = class Dc {
  constructor(t, r = !1) {
    this.destroyFuncs = [], this.touching = !1, this.eventService = new fn(), this.eElement = t, this.preventMouseClick = r;
    const i = this.onTouchStart.bind(this), n = this.onTouchMove.bind(this), o = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", i, { passive: !0 }), this.eElement.addEventListener("touchmove", n, { passive: !0 }), this.eElement.addEventListener("touchend", o, { passive: !1 }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", i, { passive: !0 }), this.eElement.removeEventListener("touchmove", n, { passive: !0 }), this.eElement.removeEventListener("touchend", o, { passive: !1 });
    });
  }
  getActiveTouch(t) {
    for (let r = 0; r < t.length; r++)
      if (t[r].identifier === this.touchStart.identifier)
        return t[r];
    return null;
  }
  addEventListener(t, r) {
    this.eventService.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    this.eventService.removeEventListener(t, r);
  }
  onTouchStart(t) {
    if (this.touching)
      return;
    this.touchStart = t.touches[0], this.touching = !0, this.moved = !1;
    const r = this.touchStart;
    window.setTimeout(() => {
      const i = this.touchStart === r;
      if (this.touching && i && !this.moved) {
        this.moved = !0;
        const n = {
          type: Dc.EVENT_LONG_TAP,
          touchStart: this.touchStart,
          touchEvent: t
        };
        this.eventService.dispatchEvent(n);
      }
    }, 500);
  }
  onTouchMove(t) {
    if (!this.touching)
      return;
    const r = this.getActiveTouch(t.touches);
    if (!r)
      return;
    !lE(r, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(t) {
    if (this.touching) {
      if (!this.moved) {
        const r = {
          type: Dc.EVENT_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(r), this.checkForDoubleTap();
      }
      this.preventMouseClick && t.cancelable && t.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const t = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (t - this.lastTapTime > Dc.DOUBLE_TAP_MILLIS) {
        const i = {
          type: Dc.EVENT_DOUBLE_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(i), this.lastTapTime = null;
      } else
        this.lastTapTime = t;
    else
      this.lastTapTime = t;
  }
  destroy() {
    this.destroyFuncs.forEach((t) => t());
  }
};
Ah.EVENT_TAP = "tap";
Ah.EVENT_DOUBLE_TAP = "doubleTap";
Ah.EVENT_LONG_TAP = "longTap";
Ah.DOUBLE_TAP_MILLIS = 500;
var mr = Ah, Fo = class lN extends Oe {
  constructor(t) {
    super(), t || this.setTemplate(lN.TEMPLATE);
  }
  attachCustomElements(t, r, i, n, o) {
    this.eSortOrder = t, this.eSortAsc = r, this.eSortDesc = i, this.eSortMixed = n, this.eSortNone = o;
  }
  setupSort(t, r = !1) {
    this.column = t, this.suppressOrder = r, this.setupMultiSortIndicator(), !(!this.column.isSortable() && !this.column.getColDef().showRowGroup) && (this.addInIcon("sortAscending", this.eSortAsc, t), this.addInIcon("sortDescending", this.eSortDesc, t), this.addInIcon("sortUnSort", this.eSortNone, t), this.addManagedPropertyListener("unSortIcon", () => this.updateIcons()), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.updateIcons()), this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, () => this.onSortChanged()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onSortChanged()), this.onSortChanged());
  }
  addInIcon(t, r, i) {
    if (r == null)
      return;
    const n = It(t, this.gos, i);
    n && r.appendChild(n);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const t = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const r = t === "asc";
      We(this.eSortAsc, r, { skipAriaHidden: !0 });
    }
    if (this.eSortDesc) {
      const r = t === "desc";
      We(this.eSortDesc, r, { skipAriaHidden: !0 });
    }
    if (this.eSortNone) {
      const r = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"), i = t == null;
      We(this.eSortNone, !r && i, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const t = this.column.getColDef().showRowGroup;
    this.gos.isColumnsSortingCoupledToGroup() && t && (this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, () => this.updateMultiSortIndicator()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateMultiSortIndicator()), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const t = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      We(this.eSortMixed, t, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    var t;
    if (!this.eSortOrder)
      return;
    const r = this.sortController.getColumnsWithSortingOrdered(), i = (t = this.sortController.getDisplaySortIndexForColumn(this.column)) != null ? t : -1, n = r.some((s) => {
      var a;
      return (a = this.sortController.getDisplaySortIndexForColumn(s)) != null ? a : !1;
    }), o = i >= 0 && n;
    We(this.eSortOrder, o, { skipAriaHidden: !0 }), i >= 0 ? this.eSortOrder.textContent = (i + 1).toString() : Ht(this.eSortOrder);
  }
};
Fo.TEMPLATE = /* html */
`<span class="ag-sort-indicator-container">
            <span ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
            <span ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
        </span>`;
v([
  ne("eSortOrder")
], Fo.prototype, "eSortOrder", 2);
v([
  ne("eSortAsc")
], Fo.prototype, "eSortAsc", 2);
v([
  ne("eSortDesc")
], Fo.prototype, "eSortDesc", 2);
v([
  ne("eSortMixed")
], Fo.prototype, "eSortMixed", 2);
v([
  ne("eSortNone")
], Fo.prototype, "eSortNone", 2);
v([
  T("columnModel")
], Fo.prototype, "columnModel", 2);
v([
  T("sortController")
], Fo.prototype, "sortController", 2);
var vE = Fo, Ir = class uN extends Oe {
  constructor() {
    super(...arguments), this.lastMovingChanged = 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  refresh(t) {
    const r = this.params;
    return this.params = t, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || r.enableFilterButton != t.enableFilterButton || r.enableFilterIcon != t.enableFilterIcon ? !1 : (this.setDisplayName(t), !0);
  }
  workOutTemplate() {
    var t;
    let r = (t = this.params.template) != null ? t : uN.TEMPLATE;
    return r = r && r.trim ? r.trim() : r, r;
  }
  init(t) {
    this.params = t, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(t);
  }
  setDisplayName(t) {
    if (this.currentDisplayName != t.displayName) {
      this.currentDisplayName = t.displayName;
      const r = Yt(this.currentDisplayName, !0);
      this.eText && (this.eText.textContent = r);
    }
  }
  addInIcon(t, r, i) {
    if (r == null)
      return;
    const n = It(t, this.gos, i);
    n && r.appendChild(n);
  }
  setupTap() {
    const { gos: t } = this;
    if (t.get("suppressTouch"))
      return;
    const r = new mr(this.getGui(), !0), i = this.shouldSuppressMenuHide(), n = i && q(this.eMenu), o = n ? new mr(this.eMenu, !0) : r;
    if (this.params.enableMenu) {
      const s = n ? "EVENT_TAP" : "EVENT_LONG_TAP", a = (l) => this.params.showColumnMenuAfterMouseClick(l.touchStart);
      this.addManagedListener(o, mr[s], a);
    }
    if (this.params.enableSorting) {
      const s = (a) => {
        var l, u;
        const c = a.touchStart.target;
        i && ((l = this.eMenu) != null && l.contains(c) || (u = this.eFilterButton) != null && u.contains(c)) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted");
      };
      this.addManagedListener(r, mr.EVENT_TAP, s);
    }
    if (this.params.enableFilterButton) {
      const s = new mr(this.eFilterButton, !0);
      this.addManagedListener(s, "tap", () => this.params.showFilter(this.eFilterButton)), this.addDestroyFunc(() => s.destroy());
    }
    this.addDestroyFunc(() => r.destroy()), n && this.addDestroyFunc(() => o.destroy());
  }
  workOutShowMenu() {
    return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      ln(this.eMenu), this.eMenu = void 0;
      return;
    }
    const t = this.menuService.isLegacyMenuEnabled();
    this.addInIcon(t ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !t), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedListener(this.eMenu, "click", () => this.params.showColumnMenu(this.eMenu)), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(t) {
    var r, i, n, o;
    const { column: s } = this.params, a = this.menuService.isLegacyMenuEnabled();
    if (t && !a) {
      if (this.menuService.isFilterMenuInHeaderEnabled(s))
        return this.params.showFilter((i = (r = this.eFilterButton) != null ? r : this.eMenu) != null ? i : this.getGui()), !0;
    } else if (this.params.enableMenu)
      return this.params.showColumnMenu((o = (n = this.eMenu) != null ? n : this.eFilterButton) != null ? o : this.getGui()), !0;
    return !1;
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.context.createBean(new vE(!0)), this.eSortIndicator.attachCustomElements(
      this.eSortOrder,
      this.eSortAsc,
      this.eSortDesc,
      this.eSortMixed,
      this.eSortNone
    )), this.eSortIndicator.setupSort(this.params.column), !this.currentSort)
      return;
    this.addManagedListener(this.params.column, ct.EVENT_MOVING_CHANGED, () => {
      this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
    }), this.eLabel && this.addManagedListener(this.eLabel, "click", (r) => {
      const i = this.params.column.isMoving(), o = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
      if (!(i || o)) {
        const l = this.gos.get("multiSortKey") === "ctrl" ? r.ctrlKey || r.metaKey : r.shiftKey;
        this.params.progressSort(l);
      }
    });
    const t = () => {
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending()), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending()), this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone()), this.params.column.getColDef().showRowGroup) {
        const r = this.columnModel.getSourceColumnsForGroupColumn(this.params.column), n = !(r == null ? void 0 : r.every((o) => this.params.column.getSort() == o.getSort()));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", n);
      }
    };
    this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, t), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, t);
  }
  setupFilterIcon() {
    this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
  }
  setupFilterButton() {
    if (!this.eFilterButton)
      return;
    this.configureFilter(
      this.params.enableFilterButton,
      this.eFilterButton,
      this.onFilterChangedButton.bind(this)
    ) ? this.addManagedListener(this.eFilterButton, "click", () => this.params.showFilter(this.eFilterButton)) : this.eFilterButton = void 0;
  }
  configureFilter(t, r, i) {
    if (!t)
      return ln(r), !1;
    const { column: n } = this.params;
    return this.addInIcon("filter", r, n), this.addManagedListener(n, ct.EVENT_FILTER_CHANGED, i), i(), !0;
  }
  onFilterChangedIcon() {
    const t = this.params.column.isFilterActive();
    We(this.eFilter, t, { skipAriaHidden: !0 });
  }
  onFilterChangedButton() {
    const t = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", t);
  }
  getAnchorElementForMenu(t) {
    var r, i, n, o;
    return t ? (i = (r = this.eFilterButton) != null ? r : this.eMenu) != null ? i : this.getGui() : (o = (n = this.eMenu) != null ? n : this.eFilterButton) != null ? o : this.getGui();
  }
};
Ir.TEMPLATE = /* html */
`<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <span ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
            </div>
        </div>`;
v([
  T("sortController")
], Ir.prototype, "sortController", 2);
v([
  T("menuService")
], Ir.prototype, "menuService", 2);
v([
  T("columnModel")
], Ir.prototype, "columnModel", 2);
v([
  ne("eFilter")
], Ir.prototype, "eFilter", 2);
v([
  ne("eFilterButton")
], Ir.prototype, "eFilterButton", 2);
v([
  ne("eSortIndicator")
], Ir.prototype, "eSortIndicator", 2);
v([
  ne("eMenu")
], Ir.prototype, "eMenu", 2);
v([
  ne("eLabel")
], Ir.prototype, "eLabel", 2);
v([
  ne("eText")
], Ir.prototype, "eText", 2);
v([
  ne("eSortOrder")
], Ir.prototype, "eSortOrder", 2);
v([
  ne("eSortAsc")
], Ir.prototype, "eSortAsc", 2);
v([
  ne("eSortDesc")
], Ir.prototype, "eSortDesc", 2);
v([
  ne("eSortMixed")
], Ir.prototype, "eSortMixed", 2);
v([
  ne("eSortNone")
], Ir.prototype, "eSortNone", 2);
var Bb = Ir, Dh = class cN extends Oe {
  constructor() {
    super(cN.TEMPLATE);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(t) {
    this.params = t, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && we("A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)");
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", "agOpened"), this.addInIcon("columnGroupClosed", "agClosed");
    const t = (n) => {
      if (hn(n))
        return;
      const o = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), o, "uiColumnExpanded");
    };
    this.addTouchAndClickListeners(this.eCloseIcon, t), this.addTouchAndClickListeners(this.eOpenIcon, t);
    const r = (n) => {
      gn(n);
    };
    this.addManagedListener(this.eCloseIcon, "dblclick", r), this.addManagedListener(this.eOpenIcon, "dblclick", r), this.addManagedListener(this.getGui(), "dblclick", t), this.updateIconVisibility();
    const i = this.params.columnGroup.getProvidedColumnGroup();
    this.addManagedListener(i, Ut.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this)), this.addManagedListener(i, Ut.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
  }
  addTouchAndClickListeners(t, r) {
    const i = new mr(t, !0);
    this.addManagedListener(i, mr.EVENT_TAP, r), this.addDestroyFunc(() => i.destroy()), this.addManagedListener(t, "click", r);
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const r = this.params.columnGroup.isExpanded();
      We(this.eOpenIcon, r), We(this.eCloseIcon, !r);
    } else
      We(this.eOpenIcon, !1), We(this.eCloseIcon, !1);
  }
  addInIcon(t, r) {
    const i = It(t, this.gos, null);
    i && this.getRefElement(r).appendChild(i);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      We(this.eOpenIcon, !1), We(this.eCloseIcon, !1);
      return;
    }
  }
  setupLabel() {
    var t;
    const { displayName: r, columnGroup: i } = this.params;
    if (q(r)) {
      const n = Yt(r, !0);
      this.getRefElement("agLabel").textContent = n;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((t = i.getColGroupDef()) != null && t.suppressStickyLabel));
  }
};
Dh.TEMPLATE = /* html */
`<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`;
v([
  T("columnModel")
], Dh.prototype, "columnModel", 2);
v([
  ne("agOpened")
], Dh.prototype, "eOpenIcon", 2);
v([
  ne("agClosed")
], Dh.prototype, "eCloseIcon", 2);
var boe = Dh, Na = class extends Oe {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, CE = class dN extends Na {
  constructor() {
    super(dN.TEMPLATE);
  }
  init(t) {
    this.params = t, this.focusAfterAttached = t.cellStartedEdit, this.eTextArea.setMaxLength(t.maxLength || 200).setCols(t.cols || 60).setRows(t.rows || 10), q(t.value, !0) && this.eTextArea.setValue(t.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(t) {
    const r = t.key;
    (r === k.LEFT || r === k.UP || r === k.RIGHT || r === k.DOWN || t.shiftKey && r === k.ENTER) && t.stopPropagation();
  }
  afterGuiAttached() {
    const t = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(t("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const t = this.eTextArea.getValue();
    return !q(t) && !q(this.params.value) ? this.params.value : this.params.parseValue(t);
  }
};
CE.TEMPLATE = /* html */
`<div class="ag-large-text">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`;
v([
  ne("eTextArea")
], CE.prototype, "eTextArea", 2);
var woe = CE, yE = class extends Na {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" ref="eSelect"></ag-select>
            </div>`
    ), this.startedByEnter = !1;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueService: r, gos: i } = this, { values: n, value: o, eventKey: s } = e;
    if (Re(n)) {
      console.warn("AG Grid: no values found for select cellEditor");
      return;
    }
    this.startedByEnter = s != null ? s === k.ENTER : !1;
    let a = !1;
    n.forEach((d) => {
      const h = { value: d }, p = r.formatValue(e.column, null, d), g = p != null;
      h.text = g ? p : d, t.addOption(h), a = a || o === d;
    }), a ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: u, valueListMaxHeight: c } = e;
    l != null && t.setPickerGap(l), c != null && t.setPickerMaxHeight(c), u != null && t.setPickerMaxWidth(u), i.get("editType") !== "fullRow" && this.addManagedListener(this.eSelect, $m.EVENT_ITEM_SELECTED, () => e.stopEditing());
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
};
v([
  T("valueService")
], yE.prototype, "valueService", 2);
v([
  ne("eSelect")
], yE.prototype, "eSelect", 2);
var Th = class extends Na {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`
    ), this.cellEditorInput = e;
  }
  init(e) {
    this.params = e;
    const t = this.eInput;
    this.cellEditorInput.init(t, e);
    let r;
    if (e.cellStartedEdit) {
      this.focusAfterAttached = !0;
      const i = e.eventKey;
      i === k.BACKSPACE || e.eventKey === k.DELETE ? r = "" : i && i.length === 1 ? r = i : (r = this.cellEditorInput.getStartValue(), i !== k.F2 && (this.highlightAllOnFocus = !0));
    } else
      this.focusAfterAttached = !1, r = this.cellEditorInput.getStartValue();
    r != null && t.setStartValue(r), this.addManagedListener(t.getGui(), "keydown", (i) => {
      const { key: n } = i;
      (n === k.PAGE_UP || n === k.PAGE_DOWN) && i.preventDefault();
    });
  }
  afterGuiAttached() {
    var e, t;
    const r = this.localeService.getLocaleTextFunc(), i = this.eInput;
    if (i.setInputAriaLabel(r("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    jn() || i.getFocusableElement().focus();
    const n = i.getInputElement();
    this.highlightAllOnFocus ? n.select() : (t = (e = this.cellEditorInput).setCaret) == null || t.call(e);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), r = e.getInputElement();
    t.focus(), r.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
};
v([
  ne("eInput")
], Th.prototype, "eInput", 2);
var Soe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !q(e) && !q(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = q(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}, VT = class extends Th {
  constructor() {
    super(new Soe());
  }
}, Eoe = "", xoe = "", hN = class extends Oe {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const r = document.createElement("span");
    r.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(r), this.setTemplateFromElement(e);
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0);
  }
  showDelta(e, t) {
    const r = Math.abs(t), i = e.formatValue(r), n = q(i) ? i : r, o = t >= 0;
    o ? this.eDelta.textContent = Eoe + n : this.eDelta.textContent = xoe + n, this.eDelta.classList.toggle("ag-value-change-delta-up", o), this.eDelta.classList.toggle("ag-value-change-delta-down", !o);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), Ht(this.eDelta);
  }
  refresh(e, t = !1) {
    const r = e.value;
    if (r === this.lastValue || (q(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : q(e.value) ? this.eValue.textContent = r : Ht(this.eValue), this.filterManager.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof r == "number" && typeof this.lastValue == "number") {
      const i = r - this.lastValue;
      this.showDelta(e, i);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = r, !0;
  }
};
v([
  T("filterManager")
], hN.prototype, "filterManager", 2);
var pN = class extends Oe {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    let r = e.value;
    return Re(r) && (r = ""), r === this.lastValue || this.filterManager.isSuppressFlashingCellsBecauseFiltering() ? !1 : (t || this.addSlideAnimation(), this.lastValue = r, q(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : q(e.value) ? this.eCurrent.textContent = r : Ht(this.eCurrent), !0);
  }
};
v([
  T("filterManager")
], pN.prototype, "filterManager", 2);
var Tt = class mt {
  constructor(t) {
    this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = mt.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = t;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(t) {
    this.setDataCommon(t, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(t) {
    this.setDataCommon(t, !0);
  }
  setDataCommon(t, r) {
    const i = this.data;
    this.data = t, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const n = this.createDataChangedEvent(t, i, r);
    this.dispatchLocalEvent(n);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(t, r, i) {
    return {
      type: mt.EVENT_DATA_CHANGED,
      node: this,
      oldData: r,
      newData: t,
      update: i
    };
  }
  createLocalRowEvent(t) {
    return {
      type: t,
      node: this
    };
  }
  getRowIndexString() {
    return this.rowPinned === "top" ? "t-" + this.rowIndex : this.rowPinned === "bottom" ? "b-" + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const t = new mt(this.beans);
    return t.id = this.id, t.data = this.data, t.__daemon = !0, t.selected = this.selected, t.level = this.level, t;
  }
  setDataAndId(t, r) {
    const i = q(this.id) ? this.createDaemonNode() : null, n = this.data;
    this.data = t, this.updateDataOnDetailNode(), this.setId(r), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, i);
    const o = this.createDataChangedEvent(t, n, !1);
    this.dispatchLocalEvent(o);
  }
  checkRowSelectable() {
    const t = this.beans.gos.get("isRowSelectable");
    this.setRowSelectable(t ? t(this) : !0);
  }
  setRowSelectable(t, r) {
    if (this.selectable !== t) {
      if (this.selectable = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_SELECTABLE_CHANGED)), r)
        return;
      if (this.beans.gos.get("groupSelectsChildren")) {
        const n = this.calculateSelectedFromChildren();
        this.setSelectedParams({
          newValue: n ?? !1,
          source: "selectableChanged"
        });
        return;
      }
      this.isSelected() && !this.selectable && this.setSelectedParams({
        newValue: !1,
        source: "selectableChanged"
      });
    }
  }
  setId(t) {
    const r = this.beans.gos.getCallback("getRowId");
    if (r)
      if (this.data) {
        const i = this.getGroupKeys(!0);
        this.id = r({
          data: this.data,
          parentKeys: i.length > 0 ? i : void 0,
          level: this.level
        }), this.id !== null && typeof this.id == "string" && this.id.startsWith(mt.ID_PREFIX_ROW_GROUP) && console.error(`AG Grid: Row IDs cannot start with ${mt.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`), this.id !== null && typeof this.id != "string" && (this.id = "" + this.id);
      } else
        this.id = void 0;
    else
      this.id = t;
  }
  getGroupKeys(t = !1) {
    const r = [];
    let i = this;
    for (t && (i = i.parent); i && i.level >= 0; )
      r.push(i.key), i = i.parent;
    return r.reverse(), r;
  }
  isPixelInRange(t) {
    return !q(this.rowTop) || !q(this.rowHeight) ? !1 : t >= this.rowTop && t < this.rowTop + this.rowHeight;
  }
  setFirstChild(t) {
    this.firstChild !== t && (this.firstChild = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_FIRST_CHILD_CHANGED)));
  }
  setLastChild(t) {
    this.lastChild !== t && (this.lastChild = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_LAST_CHILD_CHANGED)));
  }
  setChildIndex(t) {
    this.childIndex !== t && (this.childIndex = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_CHILD_INDEX_CHANGED)));
  }
  setRowTop(t) {
    this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_TOP_CHANGED)), this.setDisplayed(t !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setDisplayed(t) {
    this.displayed !== t && (this.displayed = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_DISPLAYED_CHANGED)));
  }
  setDragging(t) {
    this.dragging !== t && (this.dragging = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_DRAGGING_CHANGED)));
  }
  setHighlighted(t) {
    t !== this.highlighted && (this.highlighted = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_HIGHLIGHT_CHANGED)));
  }
  setHovered(t) {
    this.hovered !== t && (this.hovered = t);
  }
  isHovered() {
    return this.hovered;
  }
  setAllChildrenCount(t) {
    this.allChildrenCount !== t && (this.allChildrenCount = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_ALL_CHILDREN_COUNT_CHANGED)));
  }
  setMaster(t) {
    this.master !== t && (this.master && !t && (this.expanded = !1), this.master = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_MASTER_CHANGED)));
  }
  setGroup(t) {
    this.group !== t && (this.group && !t && (this.expanded = !1), this.group = t, this.updateHasChildren(), this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_GROUP_CHANGED)));
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(t, r = !1) {
    this.rowHeight = t, this.rowHeightEstimated = r, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_HEIGHT_CHANGED));
  }
  setRowAutoHeight(t, r) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[r.getId()] = t, t != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = kr(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    let t = !1, r = !0, i = 0;
    const n = this.__autoHeights;
    if (n == null || (this.beans.columnModel.getAllDisplayedAutoHeightCols().forEach((a) => {
      let l = n[a.getId()];
      if (l == null)
        if (this.beans.columnModel.isColSpanActive()) {
          let u = [];
          switch (a.getPinned()) {
            case "left":
              u = this.beans.columnModel.getDisplayedLeftColumnsForRow(this);
              break;
            case "right":
              u = this.beans.columnModel.getDisplayedRightColumnsForRow(this);
              break;
            case null:
              u = this.beans.columnModel.getViewportCenterColumnsForRow(this);
              break;
          }
          if (u.includes(a)) {
            t = !0;
            return;
          }
          l = -1;
        } else {
          t = !0;
          return;
        }
      else
        r = !1;
      l > i && (i = l);
    }), t) || ((r || i < 10) && (i = this.beans.gos.getRowHeightForNode(this).height), i == this.rowHeight))
      return;
    this.setRowHeight(i);
    const s = this.beans.rowModel;
    s.onRowHeightChangedDebounced && s.onRowHeightChangedDebounced();
  }
  setRowIndex(t) {
    this.rowIndex !== t && (this.rowIndex = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_ROW_INDEX_CHANGED)));
  }
  setUiLevel(t) {
    this.uiLevel !== t && (this.uiLevel = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_UI_LEVEL_CHANGED)));
  }
  /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */
  setExpanded(t, r, i) {
    if (this.expanded === t)
      return;
    this.expanded = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_EXPANDED_CHANGED));
    const n = Object.assign({}, this.createGlobalRowEvent(A.EVENT_ROW_GROUP_OPENED), {
      expanded: t,
      event: r || null
    });
    this.beans.rowNodeEventThrottle.dispatchExpanded(n, i), this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(t) {
    return this.beans.gos.addGridCommonParams({
      type: t,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned
    });
  }
  dispatchLocalEvent(t) {
    this.eventService && this.eventService.dispatchEvent(t);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(t, r, i) {
    const o = (() => {
      var l;
      return typeof t != "string" ? t : (l = this.beans.columnModel.getGridColumn(t)) != null ? l : this.beans.columnModel.getPrimaryColumn(t);
    })(), s = this.getValueFromValueService(o);
    if (this.beans.gos.get("readOnlyEdit"))
      return this.dispatchEventForSaveValueReadOnly(o, s, r, i), !1;
    const a = this.beans.valueService.setValue(this, o, r, i);
    return this.dispatchCellChangedEvent(o, r, s), this.checkRowSelectable(), a;
  }
  getValueFromValueService(t) {
    var r, i;
    const n = this.leafGroup && this.beans.columnModel.isPivotMode(), o = this.group && this.expanded && !this.footer && !n;
    let s = !1;
    const a = (r = this.beans.gos.get("groupTotalRow")) != null ? r : this.beans.gos.get("groupIncludeFooter");
    typeof a != "function" ? s = !!a : s = !!((i = this.beans.gos.getCallback("groupTotalRow")) != null ? i : this.beans.gos.getCallback("groupIncludeFooter"))({ node: this });
    const l = this.beans.gos.get("groupSuppressBlankHeader"), u = o && s && !l;
    return this.beans.valueService.getValue(t, this, !1, u);
  }
  dispatchEventForSaveValueReadOnly(t, r, i, n) {
    const o = this.beans.gos.addGridCommonParams({
      type: A.EVENT_CELL_EDIT_REQUEST,
      event: null,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      column: t,
      colDef: t.getColDef(),
      data: this.data,
      node: this,
      oldValue: r,
      newValue: i,
      value: i,
      source: n
    });
    this.beans.eventService.dispatchEvent(o);
  }
  setGroupValue(t, r) {
    const i = this.beans.columnModel.getGridColumn(t);
    Re(this.groupData) && (this.groupData = {});
    const n = i.getColId(), o = this.groupData[n];
    o !== r && (this.groupData[n] = r, this.dispatchCellChangedEvent(i, r, o));
  }
  // sets the data for an aggregation
  setAggData(t) {
    const r = this.aggData;
    if (this.aggData = t, this.eventService) {
      const i = (n) => {
        const o = this.aggData ? this.aggData[n] : void 0, s = r ? r[n] : void 0;
        if (o === s)
          return;
        const a = this.beans.columnModel.lookupGridColumn(n);
        a && this.dispatchCellChangedEvent(a, o, s);
      };
      for (const n in this.aggData)
        i(n);
      for (const n in t)
        n in this.aggData || i(n);
    }
  }
  updateHasChildren() {
    let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (this.beans.gos.isRowModelType("serverSide")) {
      const i = this.beans.gos.get("treeData"), n = this.beans.gos.get("isServerSideGroup");
      t = !this.stub && !this.footer && (i ? !!n && n(this.data) : !!this.group);
    }
    t !== this.__hasChildren && (this.__hasChildren = !!t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(mt.EVENT_HAS_CHILDREN_CHANGED)));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  isEmptyRowGroupNode() {
    return this.group && Ni(this.childrenAfterGroup);
  }
  dispatchCellChangedEvent(t, r, i) {
    const n = {
      type: mt.EVENT_CELL_CHANGED,
      node: this,
      column: t,
      newValue: r,
      oldValue: i
    };
    this.dispatchLocalEvent(n);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
  * - `true` if the node can be expanded, i.e it is a group or master row.
  * - `false` if the node cannot be expanded
  */
  isExpandable() {
    return this.footer ? !1 : this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(t) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((r) => r.depthFirstSearch(t)), t(this);
  }
  // + selectionController.calculatedSelectedForAllGroupNodes()
  calculateSelectedFromChildren() {
    var t;
    let r = !1, i = !1, n = !1;
    if (!((t = this.childrenAfterGroup) != null && t.length))
      return this.selectable ? this.selected : null;
    for (let o = 0; o < this.childrenAfterGroup.length; o++) {
      const s = this.childrenAfterGroup[o];
      let a = s.isSelected();
      if (!s.selectable) {
        const l = s.calculateSelectedFromChildren();
        if (l === null)
          continue;
        a = l;
      }
      switch (a) {
        case !0:
          r = !0;
          break;
        case !1:
          i = !0;
          break;
        default:
          n = !0;
          break;
      }
    }
    if (!(n || r && i))
      return r ? !0 : i ? !1 : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(t) {
    this.selected = t;
  }
  selectThisNode(t, r, i = "api") {
    const n = !this.selectable && t, o = this.selected === t;
    if (n || o)
      return !1;
    this.selected = t, this.eventService && this.dispatchLocalEvent(this.createLocalRowEvent(mt.EVENT_ROW_SELECTED));
    const s = this.sibling;
    s && s.footer && s.eventService && s.dispatchLocalEvent(s.createLocalRowEvent(mt.EVENT_ROW_SELECTED));
    const a = Dt(Ce({}, this.createGlobalRowEvent(A.EVENT_ROW_SELECTED)), {
      event: r || null,
      source: i
    });
    return this.beans.eventService.dispatchEvent(a), !0;
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(t, r = !1, i = "api") {
    if (typeof i == "boolean") {
      console.warn("AG Grid: since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
      return;
    }
    this.setSelectedParams({
      newValue: t,
      clearSelection: r,
      rangeSelect: !1,
      source: i
    });
  }
  // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
  setSelectedParams(t) {
    return this.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), 0) : this.id === void 0 ? (console.warn("AG Grid: cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected(Dt(Ce({}, t), { nodes: [this.footer ? this.sibling : this] }));
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return this.rowPinned === "top" || this.rowPinned === "bottom";
  }
  isParentOfNode(t) {
    let r = this.parent;
    for (; r; ) {
      if (r === t)
        return !0;
      r = r.parent;
    }
    return !1;
  }
  /** Add an event listener. */
  addEventListener(t, r) {
    var i, n;
    this.eventService || (this.eventService = new fn()), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.eventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new LS(this.beans.frameworkOverrides));
    const o = (n = (i = this.frameworkEventListenerService) == null ? void 0 : i.wrap(r)) != null ? n : r;
    this.eventService.addEventListener(t, o);
  }
  /** Remove event listener. */
  removeEventListener(t, r) {
    var i, n;
    if (!this.eventService)
      return;
    const o = (n = (i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(r)) != null ? n : r;
    this.eventService.removeEventListener(t, o), this.eventService.noRegisteredListenersExist() && (this.eventService = null);
  }
  onMouseEnter() {
    this.dispatchLocalEvent(this.createLocalRowEvent(mt.EVENT_MOUSE_ENTER));
  }
  onMouseLeave() {
    this.dispatchLocalEvent(this.createLocalRowEvent(mt.EVENT_MOUSE_LEAVE));
  }
  getFirstChildOfFirstChild(t) {
    let r = this, i = !0, n = !1, o = null;
    for (; i && !n; ) {
      const s = r.parent;
      q(s) && r.firstChild ? s.rowGroupColumn === t && (n = !0, o = s) : i = !1, r = s;
    }
    return n ? o : null;
  }
  /**
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (this.detail)
      return !0;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
   * If the Row Node is not a group, it returns `undefined`.
   */
  getRoute() {
    if (this.key == null)
      return;
    const t = [];
    let r = this;
    for (; r.key != null; )
      t.push(r.key), r = r.parent;
    return t.reverse();
  }
  createFooter() {
    if (this.sibling)
      return;
    const t = /* @__PURE__ */ new Set([
      "eventService",
      "__objectId",
      "sticky"
    ]), r = new mt(this.beans);
    Object.keys(this).forEach((i) => {
      t.has(i) || (r[i] = this[i]);
    }), r.footer = !0, r.setRowTop(null), r.setRowIndex(null), r.oldRowTop = null, r.id = "rowGroupFooter_" + this.id, r.sibling = this, this.sibling = r;
  }
  // Only used by SSRM. In CSRM this is never used as footers should always be present for
  // the purpose of exporting collapsed groups. In SSRM it is not possible to export collapsed
  // groups anyway, so can destroy footers.
  destroyFooter() {
    this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0);
  }
};
Tt.ID_PREFIX_ROW_GROUP = "row-group-";
Tt.ID_PREFIX_TOP_PINNED = "t-";
Tt.ID_PREFIX_BOTTOM_PINNED = "b-";
Tt.OBJECT_ID_SEQUENCE = 0;
Tt.EVENT_ROW_SELECTED = "rowSelected";
Tt.EVENT_DATA_CHANGED = "dataChanged";
Tt.EVENT_CELL_CHANGED = "cellChanged";
Tt.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged";
Tt.EVENT_MASTER_CHANGED = "masterChanged";
Tt.EVENT_GROUP_CHANGED = "groupChanged";
Tt.EVENT_MOUSE_ENTER = "mouseEnter";
Tt.EVENT_MOUSE_LEAVE = "mouseLeave";
Tt.EVENT_HEIGHT_CHANGED = "heightChanged";
Tt.EVENT_TOP_CHANGED = "topChanged";
Tt.EVENT_DISPLAYED_CHANGED = "displayedChanged";
Tt.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged";
Tt.EVENT_LAST_CHILD_CHANGED = "lastChildChanged";
Tt.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged";
Tt.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged";
Tt.EVENT_EXPANDED_CHANGED = "expandedChanged";
Tt.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged";
Tt.EVENT_SELECTABLE_CHANGED = "selectableChanged";
Tt.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged";
Tt.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged";
Tt.EVENT_DRAGGING_CHANGED = "draggingChanged";
var Ve = Tt, Ym = class extends Oe {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
    );
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), r = Lm(e, t), [i, n] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], o = e(i, n);
    this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${o} (${r})`);
  }
  onClicked(e, t, r) {
    return this.rowNode.setSelectedParams({ newValue: e, rangeSelect: r.shiftKey, groupSelectsFiltered: t, event: r, source: "checkboxSelected" });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (i) => {
      gn(i);
    }), this.addManagedListener(this.eCheckbox.getInputElement(), "click", (i) => {
      gn(i);
      const n = this.gos.get("groupSelectsFiltered"), o = this.eCheckbox.getValue();
      this.shouldHandleIndeterminateState(o, n) ? this.onClicked(!0, n, i || {}) === 0 && this.onClicked(!1, n, i) : o ? this.onClicked(!1, n, i) : this.onClicked(!0, n, i || {});
    }), this.addManagedListener(this.rowNode, Ve.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_DATA_CHANGED, this.onDataChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this)), this.gos.get("isRowSelectable") || typeof this.getIsVisible() == "function") {
      const i = this.showOrHideSelect.bind(this);
      this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, i), this.addManagedListener(this.rowNode, Ve.EVENT_DATA_CHANGED, i), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, i), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && this.gos.isRowModelType("clientSide");
  }
  showOrHideSelect() {
    var e, t, r;
    let i = this.rowNode.selectable;
    const n = this.getIsVisible();
    if (i)
      if (typeof n == "function") {
        const s = (e = this.overrides) == null ? void 0 : e.callbackParams;
        if (!this.column)
          i = n(Dt(Ce({}, s), { node: this.rowNode, data: this.rowNode.data }));
        else {
          const a = this.column.createColumnFunctionCallbackParams(this.rowNode);
          i = n(Ce(Ce({}, s), a));
        }
      } else
        i = n ?? !1;
    if ((t = this.column) == null ? void 0 : t.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!i), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if ((r = this.overrides) != null && r.removeHidden) {
      this.setDisplayed(i);
      return;
    }
    this.setVisible(i);
  }
  getIsVisible() {
    var e, t;
    return this.overrides ? this.overrides.isVisible : (t = (e = this.column) == null ? void 0 : e.getColDef()) == null ? void 0 : t.checkboxSelection;
  }
};
v([
  ne("eCheckbox")
], Ym.prototype, "eCheckbox", 2);
v([
  te
], Ym.prototype, "postConstruct", 1);
var fN = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(fN || {}), _e = class extends Q {
  constructor() {
    super(...arguments), this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  init() {
    this.ePinnedIcon = Ii("columnMovePin", this.gos, null), this.eHideIcon = Ii("columnMoveHide", this.gos, null), this.eMoveIcon = Ii("columnMoveMove", this.gos, null), this.eLeftIcon = Ii("columnMoveLeft", this.gos, null), this.eRightIcon = Ii("columnMoveRight", this.gos, null), this.eGroupIcon = Ii("columnMoveGroup", this.gos, null), this.eAggregateIcon = Ii("columnMoveValue", this.gos, null), this.ePivotIcon = Ii("columnMovePivot", this.gos, null), this.eDropNotAllowedIcon = Ii("dropNotAllowed", this.gos, null);
  }
  addDragSource(e, t = !1) {
    const r = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: r, dragSource: e }), this.dragService.addDragSource(r);
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((r) => r.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), Xr(this.dragSourceAndParamsList, t));
  }
  clearDragSourceParamsList() {
    this.dragSourceAndParamsList.forEach((e) => this.dragService.removeDragSource(e.params)), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0;
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), this.lastDropTarget = void 0, this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
  }
  onDragStop(e) {
    if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
      const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
      this.lastDropTarget.onDragStop(t);
    }
    this.lastDropTarget = null, this.dragItem = null, this.removeGhost();
  }
  onDragging(e, t) {
    var r, i, n, o;
    const s = this.getHorizontalDirection(e), a = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionGhost(e);
    const l = this.dropTargets.filter((c) => this.isMouseOnDropTarget(e, c)), u = this.findCurrentDropTarget(e, l);
    if (u !== this.lastDropTarget)
      this.leaveLastTargetIfExists(e, s, a, t), this.lastDropTarget !== null && u === null && ((i = (r = this.dragSource).onGridExit) == null || i.call(r, this.dragItem)), this.lastDropTarget === null && u !== null && ((o = (n = this.dragSource).onGridEnter) == null || o.call(n, this.dragItem)), this.enterDragTargetIfExists(u, e, s, a, t), this.lastDropTarget = u;
    else if (u && u.onDragging) {
      const c = this.createDropTargetEvent(u, e, s, a, t);
      u.onDragging(c);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, r = [[e.getContainer()]];
    return t ? r.concat(t) : r;
  }
  allContainersIntersect(e, t) {
    for (const r of t) {
      const i = r.getBoundingClientRect();
      if (i.width === 0 || i.height === 0)
        return !1;
      const n = e.clientX >= i.left && e.clientX < i.right, o = e.clientY >= i.top && e.clientY < i.bottom;
      if (!n || !o)
        return !1;
    }
    return !0;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const r = this.getAllContainersFromDropTarget(t);
    let i = !1;
    for (const n of r)
      if (this.allContainersIntersect(e, n)) {
        i = !0;
        break;
      }
    return t.targetContainsSource && !t.getContainer().contains(this.dragSource.eElement) ? !1 : i && t.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
  }
  findCurrentDropTarget(e, t) {
    const r = t.length;
    if (r === 0)
      return null;
    if (r === 1)
      return t[0];
    const n = this.gos.getRootNode().elementsFromPoint(e.clientX, e.clientY);
    for (const o of n)
      for (const s of t)
        if ($F(this.getAllContainersFromDropTarget(s)).indexOf(o) !== -1)
          return s;
    return null;
  }
  enterDragTargetIfExists(e, t, r, i, n) {
    if (e) {
      if (e.onDragEnter) {
        const o = this.createDropTargetEvent(e, t, r, i, n);
        e.onDragEnter(o);
      }
      this.setGhostIcon(e.getIconName ? e.getIconName() : null);
    }
  }
  leaveLastTargetIfExists(e, t, r, i) {
    if (this.lastDropTarget) {
      if (this.lastDropTarget.onDragLeave) {
        const n = this.createDropTargetEvent(this.lastDropTarget, e, t, r, i);
        this.lastDropTarget.onDragLeave(n);
      }
      this.setGhostIcon(null);
    }
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((r) => r.external).find((r) => r.getContainer() === e.getContainer()) || null;
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, r = e.clientX;
    return t === r ? null : t > r ? 0 : 1;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, r = e.clientY;
    return t === r ? null : t > r ? 0 : 1;
  }
  createDropTargetEvent(e, t, r, i, n) {
    const o = e.getContainer(), s = o.getBoundingClientRect(), { gridApi: a, columnApi: l, dragItem: u, dragSource: c } = this, d = t.clientX - s.left, h = t.clientY - s.top;
    return { event: t, x: d, y: h, vDirection: i, hDirection: r, dragSource: c, fromNudge: n, dragItem: u, api: a, columnApi: l, dropZoneTarget: o };
  }
  positionGhost(e) {
    const t = this.eGhost;
    if (!t)
      return;
    const i = t.getBoundingClientRect().height, n = v_() - 2, o = C_() - 2, s = tE(t.offsetParent), { clientY: a, clientX: l } = e;
    let u = a - s.top - i / 2, c = l - s.left - 10;
    const d = this.gos.getDocument(), h = d.defaultView || window, p = h.pageYOffset || d.documentElement.scrollTop, g = h.pageXOffset || d.documentElement.scrollLeft;
    n > 0 && c + t.clientWidth > n + g && (c = n + g - t.clientWidth), c < 0 && (c = 0), o > 0 && u + t.clientHeight > o + p && (u = o + p - t.clientHeight), u < 0 && (u = 0), t.style.left = `${c}px`, t.style.top = `${u}px`;
  }
  removeGhost() {
    this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
  }
  createGhost() {
    this.eGhost = Qr(_e.GHOST_TEMPLATE), this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
    const { theme: e } = this.environment.getTheme();
    e && this.eGhost.classList.add(e), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
    const t = this.eGhost.querySelector(".ag-dnd-ghost-label");
    let r = this.dragSource.dragItemName;
    Im(r) && (r = r()), t.innerHTML = Yt(r) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
    const i = this.gos.getDocument();
    let n = null, o = null;
    try {
      n = i.fullscreenElement;
    } catch {
    } finally {
      n || (n = this.gos.getRootNode());
      const s = n.querySelector("body");
      s ? o = s : n instanceof ShadowRoot ? o = n : n instanceof Document ? o = n == null ? void 0 : n.documentElement : o = n;
    }
    this.eGhostParent = o, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : console.warn("AG Grid: could not find document body, it is needed for dragging columns");
  }
  setGhostIcon(e, t = !1) {
    Ht(this.eGhostIcon);
    let r = null;
    switch (e || (e = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : _e.ICON_NOT_ALLOWED), e) {
      case _e.ICON_PINNED:
        r = this.ePinnedIcon;
        break;
      case _e.ICON_MOVE:
        r = this.eMoveIcon;
        break;
      case _e.ICON_LEFT:
        r = this.eLeftIcon;
        break;
      case _e.ICON_RIGHT:
        r = this.eRightIcon;
        break;
      case _e.ICON_GROUP:
        r = this.eGroupIcon;
        break;
      case _e.ICON_AGGREGATE:
        r = this.eAggregateIcon;
        break;
      case _e.ICON_PIVOT:
        r = this.ePivotIcon;
        break;
      case _e.ICON_NOT_ALLOWED:
        r = this.eDropNotAllowedIcon;
        break;
      case _e.ICON_HIDE:
        r = this.eHideIcon;
        break;
    }
    this.eGhostIcon.classList.toggle("ag-shake-left-to-right", t), !(r === this.eHideIcon && this.gos.get("suppressDragLeaveHidesColumns")) && r && this.eGhostIcon.appendChild(r);
  }
};
_e.ICON_PINNED = "pinned";
_e.ICON_MOVE = "move";
_e.ICON_LEFT = "left";
_e.ICON_RIGHT = "right";
_e.ICON_GROUP = "group";
_e.ICON_AGGREGATE = "aggregate";
_e.ICON_PIVOT = "pivot";
_e.ICON_NOT_ALLOWED = "notAllowed";
_e.ICON_HIDE = "hide";
_e.GHOST_TEMPLATE = /* html */
`<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`;
v([
  T("dragService")
], _e.prototype, "dragService", 2);
v([
  T("mouseEventService")
], _e.prototype, "mouseEventService", 2);
v([
  T("columnApi")
], _e.prototype, "columnApi", 2);
v([
  T("gridApi")
], _e.prototype, "gridApi", 2);
v([
  te
], _e.prototype, "init", 1);
v([
  jr
], _e.prototype, "clearDragSourceParamsList", 1);
_e = v([
  de("dragAndDropService")
], _e);
var ua = class extends Oe {
  constructor(e, t, r, i, n, o) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = r, this.customGui = i, this.dragStartPixels = n, this.suppressVisibilityChange = o, this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(It("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gos.get("rowDragManaged") ? new vN(this, this.beans, this.rowNode, this.column) : new mN(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gos.get("rowDragMultiRow"))
      return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  // returns true if all compatibility items work out
  checkCompatibility() {
    const e = this.gos.get("rowDragManaged");
    this.gos.get("treeData") && e && we("If using row drag with tree data, you cannot have rowDragManaged=true");
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: this.getGui(),
      dragItemName: () => {
        var r;
        const i = this.getDragItem(), n = ((r = i.rowNodes) == null ? void 0 : r.length) || 1, o = this.getRowDragText(this.column);
        return o ? o(i, n) : n === 1 ? this.cellValueFn() : `${n} ${t("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
  }
  removeDragSource() {
    this.dragSource && this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null;
  }
};
v([
  T("beans")
], ua.prototype, "beans", 2);
v([
  te
], ua.prototype, "postConstruct", 1);
v([
  jr
], ua.prototype, "removeDragSource", 1);
var gN = class extends Q {
  constructor(e, t, r) {
    super(), this.parent = e, this.rowNode = t, this.column = r;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let r = !0, i = !1;
      this.column && (r = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), i = Im(this.column.getColDef().rowDrag)), i ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(r, t)) : (this.parent.setDisplayed(r, t), this.parent.setVisible(!0, t));
    }
  }
}, mN = class extends gN {
  constructor(e, t, r, i) {
    super(e, r, i), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
};
v([
  te
], mN.prototype, "postConstruct", 1);
var vN = class extends gN {
  constructor(e, t, r, i) {
    super(e, r, i), this.beans = t;
  }
  postConstruct() {
    this.addManagedListener(this.beans.eventService, A.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, A.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), r = t && t.shouldPreventRowMove(), i = this.gos.get("suppressRowDrag"), n = this.beans.dragAndDropService.hasExternalDropZones(), o = r && !n || i;
    this.setDisplayedOrVisible(o);
  }
};
v([
  te
], vN.prototype, "postConstruct", 1);
var La = class extends Q {
  init(e, t, r, i, n, o, s) {
    var a, l, u, c;
    this.params = s, this.eGui = t, this.eCheckbox = r, this.eExpanded = i, this.eContracted = n, this.comp = e, this.compClass = o;
    const { node: d, value: h, colDef: p } = s, g = this.isTopLevelFooter();
    if (!g) {
      if (this.isEmbeddedRowMismatch())
        return;
      if (d.footer && this.gos.get("groupHideOpenParents")) {
        const f = p && p.showRowGroup, C = d.rowGroupColumn && d.rowGroupColumn.getColId();
        if (f !== C)
          return;
      }
    }
    if (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), !g) {
      const m = s.node.footer && s.node.rowGroupIndex === this.columnModel.getRowGroupColumns().findIndex((S) => {
        var x;
        return S.getColId() === ((x = s.colDef) == null ? void 0 : x.showRowGroup);
      }), C = this.gos.get("groupDisplayType") != "multipleColumns" || this.gos.get("treeData") || this.gos.get("showOpenedGroup") && !s.node.footer && (!s.node.group || s.node.rowGroupIndex != null && s.node.rowGroupIndex > this.columnModel.getRowGroupColumns().findIndex((S) => {
        var x;
        return S.getColId() === ((x = s.colDef) == null ? void 0 : x.showRowGroup);
      })), w = !d.group && (((a = this.params.colDef) == null ? void 0 : a.field) || ((l = this.params.colDef) == null ? void 0 : l.valueGetter)), E = this.isExpandable(), b = this.columnModel.isPivotMode() && d.leafGroup && ((u = d.rowGroupColumn) == null ? void 0 : u.getColId()) === ((c = s.column) == null ? void 0 : c.getColDef().showRowGroup);
      if (!this.showingValueForOpenedParent && !E && !w && !C && !m && !b)
        return;
    }
    this.addExpandAndContract(), this.addFullWidthRowDraggerIfNeeded(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent(), this.refreshAriaExpanded();
  }
  getCellAriaRole() {
    var e, t;
    const r = (e = this.params.colDef) == null ? void 0 : e.cellAriaRole, i = (t = this.params.column) == null ? void 0 : t.getColDef().cellAriaRole;
    return r || i || "gridcell";
  }
  destroy() {
    super.destroy(), this.expandListener = null;
  }
  refreshAriaExpanded() {
    const { node: e, eGridCell: t } = this.params;
    if (this.expandListener && (this.expandListener = this.expandListener()), !this.isExpandable()) {
      l_(t);
      return;
    }
    const r = () => {
      So(t, !!e.expanded);
    };
    this.expandListener = this.addManagedListener(e, Ve.EVENT_EXPANDED_CHANGED, r) || null, r();
  }
  isTopLevelFooter() {
    if (!this.gos.getGrandTotalRow() || this.params.value != null || this.params.node.level != -1)
      return !1;
    const t = this.params.colDef;
    if (t == null || t.showRowGroup === !0)
      return !0;
    const i = this.columnModel.getRowGroupColumns();
    return !i || i.length === 0 ? !0 : i[0].getId() === t.showRowGroup;
  }
  // if we are doing embedded full width rows, we only show the renderer when
  // in the body, or if pinning in the pinned section, or if pinning and RTL,
  // in the right section. otherwise we would have the cell repeated in each section.
  isEmbeddedRowMismatch() {
    if (!this.params.fullWidth || !this.gos.get("embedFullWidthRows"))
      return !1;
    const e = this.params.pinned === "left", t = this.params.pinned === "right", r = !e && !t;
    return this.gos.get("enableRtl") ? this.columnModel.isPinningLeft() ? !t : !r : this.columnModel.isPinningLeft() ? !e : !r;
  }
  findDisplayedGroupNode() {
    const e = this.params.column, t = this.params.node;
    if (this.showingValueForOpenedParent) {
      let r = t.parent;
      for (; r != null; ) {
        if (r.rowGroupColumn && e.isRowGroupDisplayed(r.rowGroupColumn.getId())) {
          this.displayedGroupNode = r;
          break;
        }
        r = r.parent;
      }
    }
    Re(this.displayedGroupNode) && (this.displayedGroupNode = t);
  }
  setupShowingValueForOpenedParent() {
    const e = this.params.node, t = this.params.column;
    if (!this.gos.get("groupHideOpenParents")) {
      this.showingValueForOpenedParent = !1;
      return;
    }
    if (!e.groupData) {
      this.showingValueForOpenedParent = !1;
      return;
    }
    if (e.rowGroupColumn != null) {
      const n = e.rowGroupColumn.getId();
      if (t.isRowGroupDisplayed(n)) {
        this.showingValueForOpenedParent = !1;
        return;
      }
    }
    const i = e.groupData[t.getId()] != null;
    this.showingValueForOpenedParent = i;
  }
  addValueElement() {
    this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount());
  }
  addGroupValue() {
    var e;
    const t = this.adjustParamsWithDetailsFromRelatedColumn(), r = this.getInnerCompDetails(t), { valueFormatted: i, value: n } = t;
    let o = i;
    if (o == null) {
      const s = this.displayedGroupNode.rowGroupColumn && ((e = this.params.column) == null ? void 0 : e.isRowGroupDisplayed(this.displayedGroupNode.rowGroupColumn.getId()));
      this.displayedGroupNode.key === "" && this.displayedGroupNode.group && s ? o = this.localeService.getLocaleTextFunc()("blanks", "(Blanks)") : o = n ?? null;
    }
    this.comp.setInnerRenderer(r, o);
  }
  adjustParamsWithDetailsFromRelatedColumn() {
    const e = this.displayedGroupNode.rowGroupColumn, t = this.params.column;
    if (!e)
      return this.params;
    if (t != null && !t.isRowGroupDisplayed(e.getId()))
      return this.params;
    const i = this.params, { value: n, node: o } = this.params, s = this.valueService.formatValue(e, o, n);
    return Dt(Ce({}, i), {
      valueFormatted: s
    });
  }
  addFooterValue() {
    let e = this.params.totalValueGetter;
    if (!e) {
      const i = this.params.footerValueGetter;
      i && (e = i, we("As of v31.3, footerValueGetter is deprecated. Use `totalValueGetter` instead."));
    }
    let t = "";
    if (e) {
      const i = _S(this.params);
      i.value = this.params.value, typeof e == "function" ? t = e(i) : typeof e == "string" ? t = this.expressionService.evaluate(e, i) : console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
    } else
      t = this.localeService.getLocaleTextFunc()("footerTotal", "Total") + " " + (this.params.value != null ? this.params.value : "");
    const r = this.getInnerCompDetails(this.params);
    this.comp.setInnerRenderer(r, t);
  }
  getInnerCompDetails(e) {
    if (e.fullWidth)
      return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(
        this.gos.get("groupRowRendererParams"),
        e
      );
    const t = this.userComponentFactory.getInnerRendererDetails(e, e), r = (s) => s && s.componentClass == this.compClass;
    if (t && !r(t))
      return t;
    const i = this.displayedGroupNode.rowGroupColumn, n = i ? i.getColDef() : void 0;
    if (!n)
      return;
    const o = this.userComponentFactory.getCellRendererDetails(n, e);
    if (o && !r(o))
      return o;
    if (r(o) && n.cellRendererParams && n.cellRendererParams.innerRenderer)
      return this.userComponentFactory.getInnerRendererDetails(n.cellRendererParams, e);
  }
  addChildCount() {
    this.params.suppressCount || (this.addManagedListener(this.displayedGroupNode, Ve.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this)), this.updateChildCount());
  }
  updateChildCount() {
    const e = this.displayedGroupNode.allChildrenCount, i = this.isShowRowGroupForThisRow() && e != null && e >= 0 ? `(${e})` : "";
    this.comp.setChildCount(i);
  }
  isShowRowGroupForThisRow() {
    if (this.gos.get("treeData"))
      return !0;
    const e = this.displayedGroupNode.rowGroupColumn;
    if (!e)
      return !1;
    const t = this.params.column;
    return t == null || t.isRowGroupDisplayed(e.getId());
  }
  addExpandAndContract() {
    var e;
    const t = this.params, r = It("groupExpanded", this.gos, null), i = It("groupContracted", this.gos, null);
    r && this.eExpanded.appendChild(r), i && this.eContracted.appendChild(i);
    const n = t.eGridCell;
    !(((e = this.params.column) == null ? void 0 : e.isCellEditable(t.node)) && this.gos.get("enableGroupEdit")) && this.isExpandable() && !t.suppressDoubleClickExpand && this.addManagedListener(n, "dblclick", this.onCellDblClicked.bind(this)), this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this)), this.addManagedListener(n, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(t.node, Ve.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this)), this.showExpandAndContractIcons();
    const s = this.onRowNodeIsExpandableChanged.bind(this);
    this.addManagedListener(this.displayedGroupNode, Ve.EVENT_ALL_CHILDREN_COUNT_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Ve.EVENT_MASTER_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Ve.EVENT_GROUP_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Ve.EVENT_HAS_CHILDREN_CHANGED, s);
  }
  onExpandClicked(e) {
    hn(e) || (gn(e), this.onExpandOrContract(e));
  }
  onExpandOrContract(e) {
    const t = this.displayedGroupNode, r = !t.expanded;
    !r && t.sticky && this.scrollToStickyNode(t), t.setExpanded(r, e);
  }
  scrollToStickyNode(e) {
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().setVerticalScrollPosition(e.rowTop - e.stickyRowTop);
  }
  isExpandable() {
    if (this.showingValueForOpenedParent)
      return !0;
    const e = this.displayedGroupNode, t = this.columnModel.isPivotMode() && e.leafGroup;
    if (!(e.isExpandable() && !e.footer && !t))
      return !1;
    const i = this.params.column;
    return i != null && typeof i.getColDef().showRowGroup == "string" ? this.isShowRowGroupForThisRow() : !0;
  }
  showExpandAndContractIcons() {
    const { params: e, displayedGroupNode: t, columnModel: r } = this, { node: i } = e, n = this.isExpandable();
    if (n) {
      const u = this.showingValueForOpenedParent ? !0 : i.expanded;
      this.comp.setExpandedDisplayed(u), this.comp.setContractedDisplayed(!u);
    } else
      this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
    const o = r.isPivotMode(), s = o && t.leafGroup, a = n && !s, l = i.footer && i.level === -1;
    this.comp.addOrRemoveCssClass("ag-cell-expandable", a), this.comp.addOrRemoveCssClass("ag-row-group", a), o ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", s) : l || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !a);
  }
  onRowNodeIsExpandableChanged() {
    this.showExpandAndContractIcons(), this.setIndent(), this.refreshAriaExpanded();
  }
  setupIndent() {
    const e = this.params.node;
    this.params.suppressPadding || (this.addManagedListener(e, Ve.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this)), this.setIndent());
  }
  setIndent() {
    if (this.gos.get("groupHideOpenParents"))
      return;
    const e = this.params, t = e.node, r = !!e.colDef, i = this.gos.get("treeData"), o = !r || i || e.colDef.showRowGroup === !0 ? t.uiLevel : 0;
    this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + o, this.comp.addOrRemoveCssClass(this.indentClass, !0);
  }
  addFullWidthRowDraggerIfNeeded() {
    if (!this.params.fullWidth || !this.params.rowDrag)
      return;
    const e = new ua(() => this.params.value, this.params.node);
    this.createManagedBean(e, this.context), this.eGui.insertAdjacentElement("afterbegin", e.getGui());
  }
  isUserWantsSelected() {
    const e = this.params.checkbox;
    return typeof e == "function" || e === !0;
  }
  addCheckboxIfNeeded() {
    const e = this.displayedGroupNode, t = this.isUserWantsSelected() && // footers cannot be selected
    !e.footer && // pinned rows cannot be selected
    !e.rowPinned && // details cannot be selected
    !e.detail;
    if (t) {
      const r = new Ym();
      this.getContext().createBean(r), r.init({
        rowNode: this.params.node,
        // when groupHideOpenParents = true and group expanded, we want the checkbox to refer to leaf node state (not group node state)
        column: this.params.column,
        overrides: {
          isVisible: this.params.checkbox,
          callbackParams: this.params,
          removeHidden: !0
        }
      }), this.eCheckbox.appendChild(r.getGui()), this.addDestroyFunc(() => this.getContext().destroyBean(r));
    }
    this.comp.setCheckboxVisible(t);
  }
  onKeyDown(e) {
    !(e.key === k.ENTER) || this.params.suppressEnterExpand || this.params.column && this.params.column.isCellEditable(this.params.node) || this.onExpandOrContract(e);
  }
  onCellDblClicked(e) {
    if (hn(e))
      return;
    sg(this.eExpanded, e) || sg(this.eContracted, e) || this.onExpandOrContract(e);
  }
};
v([
  T("expressionService")
], La.prototype, "expressionService", 2);
v([
  T("valueService")
], La.prototype, "valueService", 2);
v([
  T("columnModel")
], La.prototype, "columnModel", 2);
v([
  T("userComponentFactory")
], La.prototype, "userComponentFactory", 2);
v([
  T("ctrlsService")
], La.prototype, "ctrlsService", 2);
var Ga = class CN extends Oe {
  constructor() {
    super(CN.TEMPLATE);
  }
  init(t) {
    const r = {
      setInnerRenderer: (s, a) => this.setRenderDetails(s, a),
      setChildCount: (s) => this.eChildCount.textContent = s,
      addOrRemoveCssClass: (s, a) => this.addOrRemoveCssClass(s, a),
      setContractedDisplayed: (s) => We(this.eContracted, s),
      setExpandedDisplayed: (s) => We(this.eExpanded, s),
      setCheckboxVisible: (s) => this.eCheckbox.classList.toggle("ag-invisible", !s)
    }, i = this.createManagedBean(new La()), n = !t.colDef, o = this.getGui();
    i.init(r, o, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, t), n && Nt(o, i.getCellAriaRole());
  }
  setRenderDetails(t, r) {
    if (t) {
      const i = t.newAgStackInstance();
      if (!i)
        return;
      i.then((n) => {
        if (!n)
          return;
        const o = () => this.context.destroyBean(n);
        this.isAlive() ? (this.eValue.appendChild(n.getGui()), this.addDestroyFunc(o)) : o();
      });
    } else
      this.eValue.innerText = r;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to have public here instead of private or protected
  destroy() {
    this.getContext().destroyBean(this.innerCellRenderer), super.destroy();
  }
  refresh() {
    return !1;
  }
};
Ga.TEMPLATE = /* html */
`<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`;
v([
  ne("eExpanded")
], Ga.prototype, "eExpanded", 2);
v([
  ne("eContracted")
], Ga.prototype, "eContracted", 2);
v([
  ne("eCheckbox")
], Ga.prototype, "eCheckbox", 2);
v([
  ne("eValue")
], Ga.prototype, "eValue", 2);
v([
  ne("eChildCount")
], Ga.prototype, "eChildCount", 2);
var HT = Ga, Xm = class yN extends Oe {
  constructor() {
    super(yN.TEMPLATE);
  }
  init(t) {
    t.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingError", "ERR");
  }
  setupLoading() {
    const t = It("groupLoading", this.gos, null);
    t && this.eLoadingIcon.appendChild(t);
    const r = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = r("loadingOoo", "Loading");
  }
  refresh(t) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
};
Xm.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`;
v([
  ne("eLoadingIcon")
], Xm.prototype, "eLoadingIcon", 2);
v([
  ne("eLoadingText")
], Xm.prototype, "eLoadingText", 2);
var Aoe = Xm, bN = class wN extends Oe {
  constructor() {
    super(wN.TEMPLATE);
  }
  init(t) {
    const r = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", r), this.addDestroyFunc(() => ql(t.eParentOfValue)), ql(t.eParentOfValue, r), t.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const t = this.localeService.getLocaleTextFunc();
    this.getGui().innerText = t("loadingError", "ERR");
    const r = t("ariaSkeletonCellLoadingFailed", "Row failed to load");
    Si(this.getGui(), r);
  }
  setupLoading() {
    const r = this.gos.getDocument().createElement("div");
    r.classList.add("ag-skeleton-effect"), this.getGui().appendChild(r);
    const n = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    Si(this.getGui(), n);
  }
  refresh(t) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
};
bN.TEMPLATE = '<div class="ag-skeleton-container"></div>';
var Doe = bN, SN = class EN extends Oe {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(t) {
    const r = this.gos.get("overlayLoadingTemplate");
    if (this.setTemplate(r ?? EN.DEFAULT_LOADING_OVERLAY_TEMPLATE), !r) {
      const i = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = i("loadingOoo", "Loading...");
      });
    }
  }
};
SN.DEFAULT_LOADING_OVERLAY_TEMPLATE = /* html */
'<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>';
var Toe = SN, xN = class AN extends Oe {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(t) {
    const r = this.gos.get("overlayNoRowsTemplate");
    if (this.setTemplate(r ?? AN.DEFAULT_NO_ROWS_TEMPLATE), !r) {
      const i = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = i("noRowsToShow", "No Rows To Show");
      });
    }
  }
};
xN.DEFAULT_NO_ROWS_TEMPLATE = /* html */
'<span class="ag-overlay-no-rows-center"></span>';
var Roe = xN, Poe = class extends Na {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = Yt(t, !0);
  }
}, Ioe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" ref="eInput"></ag-input-number-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step);
    const r = e.getInputElement();
    t.preventStepping ? e.addManagedListener(r, "keydown", this.preventStepping) : t.showStepperButtons && r.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === k.UP || e.key === k.DOWN) && e.preventDefault();
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!q(e) && !q(this.params.value))
      return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null)
      return t;
    if (typeof t == "string") {
      if (t === "")
        return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
}, Ooe = class extends Th {
  constructor() {
    super(new Ioe());
  }
}, Moe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !q(e) && !q(this.params.value) ? this.params.value : e ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Bi(e, !1);
  }
}, Foe = class extends Th {
  constructor() {
    super(new Moe());
  }
}, _oe = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !q(e) && !q(this.params.value) ? this.params.value : this.params.parseValue(e ?? "");
  }
  getStartValue() {
    var e, t;
    return Bi((t = this.parseDate((e = this.params.value) != null ? e : void 0)) != null ? t : null, !1);
  }
  parseDate(e) {
    return this.getDataTypeService().getDateParserFunction(this.params.column)(e);
  }
  formatDate(e) {
    return this.getDataTypeService().getDateFormatterFunction(this.params.column)(e);
  }
}, DN = class extends Th {
  constructor() {
    super(new _oe(() => this.dataTypeService));
  }
};
v([
  T("dataTypeService")
], DN.prototype, "dataTypeService", 2);
var bE = class TN extends Oe {
  constructor() {
    super(TN.TEMPLATE);
  }
  init(t) {
    this.params = t, this.updateCheckbox(t);
    const r = this.eCheckbox.getInputElement();
    r.setAttribute("tabindex", "-1"), HS(r, "polite"), this.addManagedListener(r, "click", (i) => {
      if (gn(i), this.eCheckbox.isDisabled())
        return;
      const n = this.eCheckbox.getValue();
      this.onCheckboxChanged(n);
    }), this.addManagedListener(r, "dblclick", (i) => {
      gn(i);
    }), this.addManagedListener(this.params.eGridCell, "keydown", (i) => {
      if (i.key === k.SPACE && !this.eCheckbox.isDisabled()) {
        this.params.eGridCell === this.gos.getActiveDomElement() && this.eCheckbox.toggle();
        const n = this.eCheckbox.getValue();
        this.onCheckboxChanged(n), i.preventDefault();
      }
    });
  }
  refresh(t) {
    return this.params = t, this.updateCheckbox(t), !0;
  }
  updateCheckbox(t) {
    var r, i, n;
    let o, s = !0;
    if (t.node.group && t.column) {
      const d = t.column.getColId();
      d.startsWith(Kl) ? o = t.value == null || t.value === "" ? void 0 : t.value === "true" : t.node.aggData && t.node.aggData[d] !== void 0 ? o = (r = t.value) != null ? r : void 0 : s = !1;
    } else
      o = (i = t.value) != null ? i : void 0;
    if (!s) {
      this.eCheckbox.setDisplayed(!1);
      return;
    }
    this.eCheckbox.setValue(o);
    const a = t.disabled != null ? t.disabled : !((n = t.column) != null && n.isCellEditable(t.node));
    this.eCheckbox.setDisabled(a);
    const l = this.localeService.getLocaleTextFunc(), u = Lm(l, o), c = a ? u : `${l("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${u})`;
    this.eCheckbox.setInputAriaLabel(c);
  }
  onCheckboxChanged(t) {
    const { column: r, node: i, rowIndex: n, value: o } = this.params, s = {
      type: A.EVENT_CELL_EDITING_STARTED,
      column: r,
      colDef: r == null ? void 0 : r.getColDef(),
      data: i.data,
      node: i,
      rowIndex: n,
      rowPinned: i.rowPinned,
      value: o
    };
    this.eventService.dispatchEvent(s);
    const a = this.params.node.setDataValue(this.params.column, t, "edit"), l = {
      type: A.EVENT_CELL_EDITING_STOPPED,
      column: r,
      colDef: r == null ? void 0 : r.getColDef(),
      data: i.data,
      node: i,
      rowIndex: n,
      rowPinned: i.rowPinned,
      value: o,
      oldValue: o,
      newValue: t,
      valueChanged: a
    };
    this.eventService.dispatchEvent(l);
  }
};
bE.TEMPLATE = /* html*/
`
        <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
            <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
        </div>`;
v([
  ne("eCheckbox")
], bE.prototype, "eCheckbox", 2);
var Noe = bE, RN = class extends Na {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
    );
  }
  init(e) {
    var t;
    this.params = e;
    const r = (t = e.value) != null ? t : void 0;
    this.eCheckbox.setValue(r), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(r), this.addManagedListener(
      this.eCheckbox,
      A.EVENT_FIELD_VALUE_CHANGED,
      (n) => this.setAriaLabel(n.selected)
    );
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), r = Lm(t, e), i = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${i} (${r})`);
  }
};
v([
  ne("eCheckbox")
], RN.prototype, "eCheckbox", 2);
var Loe = class extends Oe {
  constructor() {
    super(), this.setTemplate(
      /* html */
      "<div></div>"
    );
  }
  init(e) {
    var t;
    this.params = e, this.cssClassPrefix = (t = this.params.cssClassPrefix) != null ? t : "ag-menu-option", this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu();
  }
  configureDefaults() {
    return !0;
  }
  addIcon() {
    if (this.params.isCompact)
      return;
    const e = Qr(
      /* html */
      `<span ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`
    );
    this.params.checked ? e.appendChild(It("check", this.gos)) : this.params.icon && (bh(this.params.icon) ? e.appendChild(this.params.icon) : typeof this.params.icon == "string" ? e.innerHTML = this.params.icon : console.warn("AG Grid: menu item icon must be DOM node or string")), this.getGui().appendChild(e);
  }
  addName() {
    const e = Qr(
      /* html */
      `<span ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addShortcut() {
    if (this.params.isCompact)
      return;
    const e = Qr(
      /* html */
      `<span ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addSubMenu() {
    const e = Qr(
      /* html */
      `<span ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`
    ), t = this.getGui();
    if (this.params.subMenu) {
      const r = this.gos.get("enableRtl") ? "smallLeft" : "smallRight";
      So(t, !1), e.appendChild(It(r, this.gos));
    }
    t.appendChild(e);
  }
  getClassName(e) {
    return `${this.cssClassPrefix}-${e}`;
  }
  destroy() {
    super.destroy();
  }
}, dg = class extends Q {
  constructor() {
    super(...arguments), this.agGridDefaults = {
      //date
      agDateInput: tN,
      //header
      agColumnHeader: Bb,
      agColumnGroupHeader: boe,
      agSortIndicator: vE,
      //floating filters
      agTextColumnFloatingFilter: yoe,
      agNumberColumnFloatingFilter: Coe,
      agDateColumnFloatingFilter: zm,
      agReadOnlyFloatingFilter: cE,
      // renderers
      agAnimateShowChangeCellRenderer: hN,
      agAnimateSlideCellRenderer: pN,
      agGroupCellRenderer: HT,
      agGroupRowRenderer: HT,
      agLoadingCellRenderer: Aoe,
      agSkeletonCellRenderer: Doe,
      agCheckboxCellRenderer: Noe,
      //editors
      agCellEditor: VT,
      agTextCellEditor: VT,
      agNumberCellEditor: Ooe,
      agDateCellEditor: Foe,
      agDateStringCellEditor: DN,
      agSelectCellEditor: yE,
      agLargeTextCellEditor: woe,
      agCheckboxCellEditor: RN,
      //filter
      agTextColumnFilter: mE,
      agNumberColumnFilter: oN,
      agDateColumnFilter: eN,
      //overlays
      agLoadingOverlay: Toe,
      agNoRowsOverlay: Roe,
      // tooltips
      agTooltipComponent: Poe,
      // menu item
      agMenuItem: Loe
    }, this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: "@ag-grid-enterprise/set-filter",
      agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
      agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
      agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
      agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
      agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
      agRichSelect: "@ag-grid-enterprise/rich-select",
      agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
      agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
      agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
      /* SparklinesModule */
    }, this.jsComps = {};
  }
  init() {
    const e = this.gos.get("components");
    e != null && Tr(e, (t, r) => this.registerJsComponent(t, r));
  }
  registerDefaultComponent(e, t) {
    if (this.agGridDefaults[e]) {
      console.error("Trying to overwrite a default component. You should call registerComponent");
      return;
    }
    this.agGridDefaults[e] = t;
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const r = (a, l) => ({ componentFromFramework: l, component: a }), i = this.getFrameworkOverrides().frameworkComponent(t, this.gos.get("components"));
    if (i != null)
      return r(i, !0);
    const n = this.jsComps[t];
    if (n) {
      const a = this.getFrameworkOverrides().isFrameworkComponent(n);
      return r(n, a);
    }
    const o = this.agGridDefaults[t];
    if (o)
      return r(o, !1);
    const s = this.enterpriseAgDefaultCompsModule[t];
    return s ? Xe.__assertRegistered(s, `AG Grid '${e}' component: ${t}`, this.context.getGridId()) : Xl(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const r = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(this.agGridDefaults).filter((n) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(n)),
      ...Object.keys(this.jsComps)
    ], i = wh(t, r, !0, 0.8).values;
    console.warn(`AG Grid: Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`), i.length > 0 && console.warn(`         Did you mean: [${i.slice(0, 3)}]?`), console.warn(`If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`);
  }
};
v([
  te
], dg.prototype, "init", 1);
dg = v([
  de("userComponentRegistry")
], dg);
var Goe = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, koe = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, Voe = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, BT = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, Hoe = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, Boe = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, WT = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, Woe = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, $oe = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, joe = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, Wb = {
  propertyName: "filter",
  cellRenderer: !1
}, zoe = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, Uoe = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, Yoe = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, Xoe = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, Koe = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, qoe = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, Zoe = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
}, Joe = {
  propertyName: "menuItem",
  cellRenderer: !1
}, PN = class {
  static getFloatingFilterType(e) {
    return this.filterToFloatingFilterMapping[e];
  }
};
PN.filterToFloatingFilterMapping = {
  set: "agSetColumnFloatingFilter",
  agSetColumnFilter: "agSetColumnFloatingFilter",
  multi: "agMultiColumnFloatingFilter",
  agMultiColumnFilter: "agMultiColumnFloatingFilter",
  group: "agGroupColumnFloatingFilter",
  agGroupColumnFilter: "agGroupColumnFloatingFilter",
  number: "agNumberColumnFloatingFilter",
  agNumberColumnFilter: "agNumberColumnFloatingFilter",
  date: "agDateColumnFloatingFilter",
  agDateColumnFilter: "agDateColumnFloatingFilter",
  text: "agTextColumnFloatingFilter",
  agTextColumnFilter: "agTextColumnFloatingFilter"
};
var Zo = class extends Q {
  getHeaderCompDetails(e, t) {
    return this.getCompDetails(e, koe, "agColumnHeader", t);
  }
  getHeaderGroupCompDetails(e) {
    const t = e.columnGroup.getColGroupDef();
    return this.getCompDetails(t, Voe, "agColumnGroupHeader", e);
  }
  // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
  // so we have to pass the type in.
  getFullWidthCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, Xoe, null, e, !0);
  }
  getFullWidthLoadingCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, Koe, "agLoadingCellRenderer", e, !0);
  }
  getFullWidthGroupCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, qoe, "agGroupRowRenderer", e, !0);
  }
  getFullWidthDetailCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, Zoe, "agDetailCellRenderer", e, !0);
  }
  // CELL RENDERER
  getInnerRendererDetails(e, t) {
    return this.getCompDetails(e, WT, null, t);
  }
  getFullWidthGroupRowInnerCellRenderer(e, t) {
    return this.getCompDetails(e, WT, null, t);
  }
  getCellRendererDetails(e, t) {
    return this.getCompDetails(e, BT, null, t);
  }
  getLoadingCellRendererDetails(e, t) {
    return this.getCompDetails(e, Hoe, "agSkeletonCellRenderer", t, !0);
  }
  // CELL EDITOR
  getCellEditorDetails(e, t) {
    return this.getCompDetails(e, Boe, "agCellEditor", t, !0);
  }
  // FILTER
  getFilterDetails(e, t, r) {
    return this.getCompDetails(e, Wb, r, t, !0);
  }
  getDateCompDetails(e) {
    return this.getCompDetails(this.gridOptions, Goe, "agDateInput", e, !0);
  }
  getLoadingOverlayCompDetails(e) {
    return this.getCompDetails(this.gridOptions, Woe, "agLoadingOverlay", e, !0);
  }
  getNoRowsOverlayCompDetails(e) {
    return this.getCompDetails(this.gridOptions, $oe, "agNoRowsOverlay", e, !0);
  }
  getTooltipCompDetails(e) {
    return this.getCompDetails(e.colDef, joe, "agTooltipComponent", e, !0);
  }
  getSetFilterCellRendererDetails(e, t) {
    return this.getCompDetails(e, BT, null, t);
  }
  getFloatingFilterCompDetails(e, t, r) {
    return this.getCompDetails(e, zoe, r, t);
  }
  getToolPanelCompDetails(e, t) {
    return this.getCompDetails(e, Uoe, null, t, !0);
  }
  getStatusPanelCompDetails(e, t) {
    return this.getCompDetails(e, Yoe, null, t, !0);
  }
  getMenuItemCompDetails(e, t) {
    return this.getCompDetails(e, Joe, "agMenuItem", t, !0);
  }
  getCompDetails(e, t, r, i, n = !1) {
    const { propertyName: o, cellRenderer: s } = t;
    let { compName: a, jsComp: l, fwComp: u, paramsFromSelector: c, popupFromSelector: d, popupPositionFromSelector: h } = this.getCompKeys(e, t, i);
    const p = (C) => {
      const w = this.userComponentRegistry.retrieve(o, C);
      w && (l = w.componentFromFramework ? void 0 : w.component, u = w.componentFromFramework ? w.component : void 0);
    };
    if (a != null && p(a), l == null && u == null && r != null && p(r), l && s && !this.agComponentUtils.doesImplementIComponent(l) && (l = this.agComponentUtils.adaptFunction(o, l)), !l && !u) {
      n && console.error(`AG Grid: Could not find component ${a}, did you forget to configure this component?`);
      return;
    }
    const g = this.mergeParamsWithApplicationProvidedParams(e, t, i, c), m = l == null, f = l || u;
    return {
      componentFromFramework: m,
      componentClass: f,
      params: g,
      type: t,
      popupFromSelector: d,
      popupPositionFromSelector: h,
      newAgStackInstance: () => this.newAgStackInstance(f, m, g, t)
    };
  }
  getCompKeys(e, t, r) {
    const { propertyName: i } = t;
    let n, o, s, a, l, u;
    if (e) {
      const c = e, d = c[i + "Selector"], h = d ? d(r) : null, p = (g) => {
        typeof g == "string" ? n = g : g != null && g !== !0 && (this.getFrameworkOverrides().isFrameworkComponent(g) ? s = g : o = g);
      };
      h ? (p(h.component), a = h.params, l = h.popup, u = h.popupPosition) : p(c[i]);
    }
    return { compName: n, jsComp: o, fwComp: s, paramsFromSelector: a, popupFromSelector: l, popupPositionFromSelector: u };
  }
  newAgStackInstance(e, t, r, i) {
    const n = i.propertyName, o = !t;
    let s;
    if (o)
      s = new e();
    else {
      const l = this.componentMetadataProvider.retrieve(n);
      s = this.frameworkComponentWrapper.wrap(
        e,
        l.mandatoryMethodList,
        l.optionalMethodList,
        i
      );
    }
    const a = this.initComponent(s, r);
    return a == null ? qt.resolve(s) : a.then(() => s);
  }
  // used by Floating Filter
  mergeParamsWithApplicationProvidedParams(e, t, r, i = null) {
    const n = this.gos.getGridCommonParams();
    Zr(n, r);
    const o = e, s = o && o[t.propertyName + "Params"];
    if (typeof s == "function") {
      const a = s(r);
      Zr(n, a);
    } else typeof s == "object" && Zr(n, s);
    return Zr(n, i), n;
  }
  initComponent(e, t) {
    if (this.context.createBean(e), e.init != null)
      return e.init(t);
  }
  getDefaultFloatingFilterType(e, t) {
    if (e == null)
      return null;
    let r = null, { compName: i, jsComp: n, fwComp: o } = this.getCompKeys(e, Wb);
    return i ? r = PN.getFloatingFilterType(i) : n == null && o == null && e.filter === !0 && (r = t()), r;
  }
};
v([
  T("gridOptions")
], Zo.prototype, "gridOptions", 2);
v([
  T("agComponentUtils")
], Zo.prototype, "agComponentUtils", 2);
v([
  T("componentMetadataProvider")
], Zo.prototype, "componentMetadataProvider", 2);
v([
  T("userComponentRegistry")
], Zo.prototype, "userComponentRegistry", 2);
v([
  Qe("frameworkComponentWrapper")
], Zo.prototype, "frameworkComponentWrapper", 2);
Zo = v([
  de("userComponentFactory")
], Zo);
var IN = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const r = t || this.shouldSkipVerticalScroll();
    if (r && this.shouldSkipHorizontalScroll())
      return;
    const i = this.scrollContainer.getBoundingClientRect(), n = this.scrollByTick;
    this.tickLeft = e.clientX < i.left + n, this.tickRight = e.clientX > i.right - n, this.tickUp = e.clientY < i.top + n && !r, this.tickDown = e.clientY > i.bottom - n && !r, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    let e;
    if (e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40, this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, Ai = class extends Q {
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady((e) => {
      const t = e.gridBodyCtrl;
      this.autoScrollService = new IN({
        scrollContainer: t.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (r) => t.getScrollFeature().setVerticalScrollPosition(r),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? _e.ICON_NOT_ALLOWED : _e.ICON_MOVE;
  }
  shouldPreventRowMove() {
    return !!(this.columnModel.getRowGroupColumns().length || this.filterManager.isAnyFilterPresent() || this.sortController.isSortActive());
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const i = [...this.selectionService.getSelectedNodes()].sort(
        (n, o) => n.rowIndex == null || o.rowIndex == null ? 0 : this.getRowIndexNumber(n) - this.getRowIndexNumber(o)
      );
      if (i.indexOf(t) !== -1)
        return i;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent(A.EVENT_ROW_DRAG_ENTER, e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  isDropZoneWithinThisGrid(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: i } = e;
    return !r.contains(i);
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent(A.EVENT_ROW_DRAG_MOVE, e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const r = this.isFromThisGrid(e), i = this.gos.get("rowDragManaged"), n = e.dragItem.rowNodes;
    i && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !r ? this.isDropZoneWithinThisGrid(e) || this.clientSideRowModel.highlightRowAtPixel(n[0], t) : this.moveRows(n, t));
  }
  getRowIndexNumber(e) {
    return parseInt(ze(e.getRowIndexString().split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), r = t && t.highlighted === 1, i = this.mouseEventService.getNormalisedPosition(e).y, n = e.dragItem.rowNodes;
    let o = r ? 1 : 0;
    if (this.isFromThisGrid(e))
      n.forEach((s) => {
        s.rowTop < i && (o -= 1);
      }), this.moveRows(n, i, o);
    else {
      const s = this.gos.getCallback("getRowId");
      let a = this.clientSideRowModel.getRowIndexAtPixel(i) + 1;
      this.clientSideRowModel.getHighlightPosition(i) === 0 && a--, this.clientSideRowModel.updateRowData({
        add: n.map((l) => l.data).filter(
          (l) => !this.clientSideRowModel.getRowNode(
            s ? s({ data: l, level: 0 }) : l.id
          )
        ),
        addIndex: a
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, r = 0) {
    var i;
    this.clientSideRowModel.ensureRowsAtPixel(e, t, r) && (this.focusService.clearFocusedCell(), (i = this.rangeService) == null || i.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      we("addRowDropZone - A container target needs to be provided");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
      return;
    }
    let t = {
      getContainer: e.getContainer
    };
    e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = (r) => {
      e.onDragEnter(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_ENTER, r));
    }), e.onDragLeave && (t.onDragLeave = (r) => {
      e.onDragLeave(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_LEAVE, r));
    }), e.onDragging && (t.onDragging = (r) => {
      e.onDragging(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_MOVE, r));
    }), e.onDragStop && (t.onDragStop = (r) => {
      e.onDragStop(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_END, r));
    })), this.dragAndDropService.addDropTarget(Ce({
      isInterestedIn: (r) => r === 2,
      getIconName: () => _e.ICON_MOVE,
      external: !0
    }, t));
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), r = this.onDragEnter.bind(this), i = this.onDragLeave.bind(this), n = this.onDragging.bind(this), o = this.onDragStop.bind(this);
    return e ? {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (s) => {
        r(s), e.onDragEnter(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_ENTER, s));
      } : r,
      onDragLeave: e.onDragLeave ? (s) => {
        i(s), e.onDragLeave(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_LEAVE, s));
      } : i,
      onDragging: e.onDragging ? (s) => {
        n(s), e.onDragging(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_MOVE, s));
      } : n,
      onDragStop: e.onDragStop ? (s) => {
        o(s), e.onDragStop(this.draggingToRowDragEvent(A.EVENT_ROW_DRAG_END, s));
      } : o,
      fromGrid: !0
      /* @private */
    } : {
      getContainer: t,
      onDragEnter: r,
      onDragLeave: i,
      onDragging: n,
      onDragStop: o,
      /* @private */
      fromGrid: !0
    };
  }
  draggingToRowDragEvent(e, t) {
    const r = this.mouseEventService.getNormalisedPosition(t).y, i = r > this.paginationProxy.getCurrentPageHeight();
    let n = -1, o;
    i || (n = this.rowModel.getRowIndexAtPixel(r), o = this.rowModel.getRow(n));
    let s;
    switch (t.vDirection) {
      case 1:
        s = "down";
        break;
      case 0:
        s = "up";
        break;
      default:
        s = null;
        break;
    }
    return this.gos.addGridCommonParams({
      type: e,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: n,
      overNode: o,
      y: r,
      vDirection: s
    });
  }
  dispatchGridEvent(e, t) {
    const r = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(r);
  }
  onDragLeave(e) {
    this.dispatchGridEvent(A.EVENT_ROW_DRAG_LEAVE, e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent(A.EVENT_ROW_DRAG_END, e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && !this.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!1);
    });
  }
};
v([
  T("dragAndDropService")
], Ai.prototype, "dragAndDropService", 2);
v([
  T("rowModel")
], Ai.prototype, "rowModel", 2);
v([
  T("paginationProxy")
], Ai.prototype, "paginationProxy", 2);
v([
  T("columnModel")
], Ai.prototype, "columnModel", 2);
v([
  T("focusService")
], Ai.prototype, "focusService", 2);
v([
  T("sortController")
], Ai.prototype, "sortController", 2);
v([
  T("filterManager")
], Ai.prototype, "filterManager", 2);
v([
  T("selectionService")
], Ai.prototype, "selectionService", 2);
v([
  T("mouseEventService")
], Ai.prototype, "mouseEventService", 2);
v([
  T("ctrlsService")
], Ai.prototype, "ctrlsService", 2);
v([
  Qe("rangeService")
], Ai.prototype, "rangeService", 2);
v([
  te
], Ai.prototype, "postConstruct", 1);
var Ld = class extends Q {
  constructor() {
    super(...arguments), this.dragEndFunctions = [], this.dragSources = [];
  }
  removeAllListeners() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0;
  }
  removeListener(e) {
    const t = e.dragSource.eElement, r = e.mouseDownListener;
    if (t.removeEventListener("mousedown", r), e.touchEnabled) {
      const i = e.touchStartListener;
      t.removeEventListener("touchstart", i, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((r) => r.dragSource === e);
    t && (this.removeListener(t), Xr(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: r, includeTouch: i, stopPropagationForTouch: n } = e;
    r.addEventListener("mousedown", t);
    let o = null;
    const s = this.gos.get("suppressTouch");
    i && !s && (o = (a) => {
      QS(a.target) || (a.cancelable && (a.preventDefault(), n && a.stopPropagation()), this.onTouchStart(e, a));
    }, r.addEventListener("touchstart", o, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: o,
      touchEnabled: !!i
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const r = t.touches[0];
    this.touchLastTime = r, this.touchStart = r;
    const i = (l) => this.onTouchMove(l, e.eElement), n = (l) => this.onTouchUp(l, e.eElement), o = (l) => {
      l.cancelable && l.preventDefault();
    }, s = t.target, a = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      { target: this.gos.getRootNode(), type: "touchmove", listener: o, options: { passive: !1 } },
      { target: s, type: "touchmove", listener: i, options: { passive: !0 } },
      { target: s, type: "touchend", listener: n, options: { passive: !0 } },
      { target: s, type: "touchcancel", listener: n, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onCommonMove(r, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const r = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || r._alreadyProcessedByDragService || (r._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const i = (l) => this.onMouseMove(l, e.eElement), n = (l) => this.onMouseUp(l, e.eElement), o = (l) => l.preventDefault(), s = this.gos.getRootNode(), a = [
      { target: s, type: "mousemove", listener: i },
      { target: s, type: "mouseup", listener: n },
      { target: s, type: "contextmenu", listener: o }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: r, type: i, listener: n, options: o } = t;
      r.addEventListener(i, n, o);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: r, type: i, listener: n, options: o } = t;
        r.removeEventListener(i, n, o);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: r } = this.currentDragParams, i = q(r) ? r : 4;
    return lE(e, t, i);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, r) {
    if (!this.dragging) {
      if (!this.dragging && this.isEventNearStartEvent(e, t))
        return;
      this.dragging = !0;
      const i = {
        type: A.EVENT_DRAG_STARTED,
        target: r
      };
      this.eventService.dispatchEvent(i), this.currentDragParams.onDragStart(t), this.currentDragParams.onDragging(t);
    }
    this.currentDragParams.onDragging(e);
  }
  onTouchMove(e, t) {
    const r = this.getFirstActiveTouch(e.touches);
    r && this.onCommonMove(r, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var r;
    jn() && ((r = this.gos.getDocument().getSelection()) == null || r.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gos.get("enableCellTextSelection"), r = e.type === "mousemove";
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      t && r && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
    );
  }
  isOverFormFieldElement(e) {
    const t = e.target, r = t == null ? void 0 : t.tagName.toLocaleLowerCase();
    return !!(r != null && r.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let r = this.getFirstActiveTouch(e.changedTouches);
    r || (r = this.touchLastTime), this.onUpCommon(r, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    if (this.dragging) {
      this.dragging = !1, this.currentDragParams.onDragStop(e);
      const r = {
        type: A.EVENT_DRAG_STOPPED,
        target: t
      };
      this.eventService.dispatchEvent(r);
    }
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((r) => r()), this.dragEndFunctions.length = 0;
  }
};
v([
  T("mouseEventService")
], Ld.prototype, "mouseEventService", 2);
v([
  jr
], Ld.prototype, "removeAllListeners", 1);
Ld = v([
  de("dragService")
], Ld);
var mC = "ag-list-item-hovered", ON = class extends Q {
  constructor(e, t, r) {
    super(), this.comp = e, this.virtualList = t, this.params = r, this.currentDragValue = null, this.lastHoveredListItem = null;
  }
  postConstruct() {
    this.addManagedListener(this.params.eventSource, this.params.listItemDragStartEvent, this.listItemDragStart.bind(this)), this.addManagedListener(this.params.eventSource, this.params.listItemDragEndEvent, this.listItemDragEnd.bind(this)), this.createDropTarget(), this.createAutoScrollService();
  }
  listItemDragStart(e) {
    this.currentDragValue = this.params.getCurrentDragValue(e), this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue);
  }
  listItemDragEnd() {
    window.setTimeout(() => {
      this.currentDragValue = null, this.moveBlocked = !1;
    }, 10);
  }
  createDropTarget() {
    const e = {
      isInterestedIn: (t) => t === this.params.dragSourceType,
      getIconName: () => this.moveBlocked ? _e.ICON_PINNED : _e.ICON_MOVE,
      getContainer: () => this.comp.getGui(),
      onDragging: (t) => this.onDragging(t),
      onDragStop: () => this.onDragStop(),
      onDragLeave: () => this.onDragLeave()
    };
    this.dragAndDropService.addDropTarget(e);
  }
  createAutoScrollService() {
    const e = this.virtualList.getGui();
    this.autoScrollService = new IN({
      scrollContainer: e,
      scrollAxis: "y",
      getVerticalPosition: () => e.scrollTop,
      setVerticalPosition: (t) => e.scrollTop = t
    });
  }
  onDragging(e) {
    if (!this.currentDragValue || this.moveBlocked)
      return;
    const t = this.getListDragItem(e), r = this.virtualList.getComponentAt(t.rowIndex);
    if (!r)
      return;
    const i = r.getGui().parentElement;
    this.lastHoveredListItem && this.lastHoveredListItem.rowIndex === t.rowIndex && this.lastHoveredListItem.position === t.position || (this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredListItem = t, kb(i, mC), kb(i, `ag-item-highlight-${t.position}`));
  }
  getListDragItem(e) {
    const t = this.virtualList.getGui(), r = parseFloat(window.getComputedStyle(t).paddingTop), i = this.virtualList.getRowHeight(), n = this.virtualList.getScrollTop(), o = Math.max(0, (e.y - r + n) / i), s = this.params.getNumRows(this.comp) - 1, a = Math.min(s, o) | 0;
    return {
      rowIndex: a,
      position: Math.round(o) > o || o > s ? "bottom" : "top",
      component: this.virtualList.getComponentAt(a)
    };
  }
  onDragStop() {
    this.moveBlocked || (this.params.moveItem(this.currentDragValue, this.lastHoveredListItem), this.clearHoveredItems(), this.autoScrollService.ensureCleared());
  }
  onDragLeave() {
    this.clearHoveredItems(), this.autoScrollService.ensureCleared();
  }
  clearHoveredItems() {
    this.virtualList.getGui().querySelectorAll(`.${mC}`).forEach((t) => {
      [
        mC,
        "ag-item-highlight-top",
        "ag-item-highlight-bottom"
      ].forEach((r) => {
        t.classList.remove(r);
      });
    }), this.lastHoveredListItem = null;
  }
};
v([
  T("dragAndDropService")
], ON.prototype, "dragAndDropService", 2);
v([
  te
], ON.prototype, "postConstruct", 1);
function Vs(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var Be = class {
  constructor() {
    this.detailGridInfoMap = {}, this.destroyCalled = !1;
  }
  init() {
    switch (this.rowModel.getType()) {
      case "clientSide":
        this.clientSideRowModel = this.rowModel;
        break;
      case "infinite":
        this.infiniteRowModel = this.rowModel;
        break;
      case "serverSide":
        this.serverSideRowModel = this.rowModel;
        break;
    }
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    });
  }
  /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
  __getAlignedGridService() {
    return this.alignedGridsService;
  }
  /** Returns the `gridId` for the current grid as specified via the gridOptions property `gridId` or the auto assigned grid id if none was provided. */
  getGridId() {
    return this.context.getGridId();
  }
  /** Register a detail grid with the master grid when it is created. */
  addDetailGridInfo(e, t) {
    this.detailGridInfoMap[e] = t;
  }
  /** Unregister a detail grid from the master grid when it is destroyed. */
  removeDetailGridInfo(e) {
    delete this.detailGridInfoMap[e];
  }
  /** Returns the `DetailGridInfo` corresponding to the supplied `detailGridId`. */
  getDetailGridInfo(e) {
    return this.detailGridInfoMap[e];
  }
  /** Iterates through each `DetailGridInfo` in the grid and calls the supplied callback on each. */
  forEachDetailGridInfo(e) {
    let t = 0;
    Tr(this.detailGridInfoMap, (r, i) => {
      q(i) && (e(i, t), t++);
    });
  }
  /** Similar to `exportDataAsCsv`, except returns the result as a string rather than download it. */
  getDataAsCsv(e) {
    if (Xe.__assertRegistered("@ag-grid-community/csv-export", "api.getDataAsCsv", this.context.getGridId()))
      return this.csvCreator.getDataAsCsv(e);
  }
  /** Downloads a CSV export of the grid's data. */
  exportDataAsCsv(e) {
    Xe.__assertRegistered("@ag-grid-community/csv-export", "api.exportDataAsCsv", this.context.getGridId()) && this.csvCreator.exportDataAsCsv(e);
  }
  assertNotExcelMultiSheet(e, t) {
    return Xe.__assertRegistered("@ag-grid-enterprise/excel-export", "api." + e, this.context.getGridId()) ? this.excelCreator.getFactoryMode() === 1 ? (console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'"), !1) : !0 : !1;
  }
  /** Similar to `exportDataAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
  getDataAsExcel(e) {
    if (this.assertNotExcelMultiSheet("getDataAsExcel", e))
      return this.excelCreator.getDataAsExcel(e);
  }
  /** Downloads an Excel export of the grid's data. */
  exportDataAsExcel(e) {
    this.assertNotExcelMultiSheet("exportDataAsExcel", e) && this.excelCreator.exportDataAsExcel(e);
  }
  /** This is method to be used to get the grid's data as a sheet, that will later be exported either by `getMultipleSheetsAsExcel()` or `exportMultipleSheetsAsExcel()`. */
  getSheetDataForExcel(e) {
    if (Xe.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getSheetDataForExcel", this.context.getGridId()))
      return this.excelCreator.setFactoryMode(
        1
        /* MULTI_SHEET */
      ), this.excelCreator.getSheetDataForExcel(e);
  }
  /** Similar to `exportMultipleSheetsAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
  getMultipleSheetsAsExcel(e) {
    if (Xe.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getMultipleSheetsAsExcel", this.context.getGridId()))
      return this.excelCreator.getMultipleSheetsAsExcel(e);
  }
  /** Downloads an Excel export of multiple sheets in one file. */
  exportMultipleSheetsAsExcel(e) {
    Xe.__assertRegistered("@ag-grid-enterprise/excel-export", "api.exportMultipleSheetsAsExcel", this.context.getGridId()) && this.excelCreator.exportMultipleSheetsAsExcel(e);
  }
  /**
   * Sets an ARIA property in the grid panel (element with `role=\"grid\"`), and removes an ARIA property when the value is null.
   *
   * Example: `api.setGridAriaProperty('label', 'my grid')` will set `aria-label=\"my grid\"`.
   *
   * `api.setGridAriaProperty('label', null)` will remove the `aria-label` attribute from the grid element.
   */
  setGridAriaProperty(e, t) {
    if (!e)
      return;
    const r = this.ctrlsService.getGridBodyCtrl().getGui(), i = `aria-${e}`;
    t === null ? r.removeAttribute(i) : r.setAttribute(i, t);
  }
  logMissingRowModel(e, ...t) {
    console.error(`AG Grid: api.${e} can only be called when gridOptions.rowModelType is ${t.join(" or ")}`);
  }
  logDeprecation(e, t, r, i) {
    we(`Since ${e} api.${t} is deprecated. Please use ${r} instead. ${i ?? ""}`);
  }
  /** Gets the number of top pinned rows. */
  getPinnedTopRowCount() {
    return this.pinnedRowModel.getPinnedTopRowCount();
  }
  /** Gets the number of bottom pinned rows. */
  getPinnedBottomRowCount() {
    return this.pinnedRowModel.getPinnedBottomRowCount();
  }
  /** Gets the top pinned row with the specified index. */
  getPinnedTopRow(e) {
    return this.pinnedRowModel.getPinnedTopRow(e);
  }
  /** Gets the bottom pinned row with the specified index. */
  getPinnedBottomRow(e) {
    return this.pinnedRowModel.getPinnedBottomRow(e);
  }
  expireValueCache() {
    this.valueCache.expire();
  }
  /**
   * Returns an object with two properties:
   *  - `top`: The top pixel position of the current scroll in the grid
   *  - `bottom`: The bottom pixel position of the current scroll in the grid
   */
  getVerticalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getVScrollPosition();
  }
  /**
   * Returns an object with two properties:
   * - `left`: The left pixel position of the current scroll in the grid
   * - `right`: The right pixel position of the current scroll in the grid
   */
  getHorizontalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getHScrollPosition();
  }
  /** Performs change detection on all cells, refreshing cells where required. */
  refreshCells(e = {}) {
    this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.refreshCells(e));
  }
  /** Flash rows, columns or individual cells. */
  flashCells(e = {}) {
    const t = (r) => we(`Since v31.1 api.flashCells parameter '${r}Delay' is deprecated. Please use '${r}Duration' instead.`);
    q(e.fadeDelay) && t("fade"), q(e.flashDelay) && t("flash"), this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.flashCells(e));
  }
  /** Remove row(s) from the DOM and recreate them again from scratch. */
  redrawRows(e = {}) {
    const t = e ? e.rowNodes : void 0;
    this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.redrawRows(t));
  }
  /** Redraws the header. Useful if a column name changes, or something else that changes how the column header is displayed. */
  refreshHeader() {
    this.frameworkOverrides.wrapIncoming(() => this.ctrlsService.getHeaderRowContainerCtrls().forEach((e) => e.refresh()));
  }
  /** Returns `true` if any filter is set. This includes quick filter, column filter, external filter or advanced filter. */
  isAnyFilterPresent() {
    return this.filterManager.isAnyFilterPresent();
  }
  /** Returns `true` if any column filter is set, otherwise `false`. */
  isColumnFilterPresent() {
    return this.filterManager.isColumnFilterPresent() || this.filterManager.isAggregateFilterPresent();
  }
  /** Returns `true` if the Quick Filter is set, otherwise `false`. */
  isQuickFilterPresent() {
    return this.filterManager.isQuickFilterPresent();
  }
  /**
   * Returns the row model inside the table.
   * From here you can see the original rows, rows after filter has been applied,
   * rows after aggregation has been applied, and the final set of 'to be displayed' rows.
   *
   * @deprecated As of v31.1, getModel() is deprecated and will not be available in future versions.
   * Please use the appropriate grid API methods instead
   */
  getModel() {
    return we("Since v31.1 getModel() is deprecated. Please use the appropriate grid API methods instead."), this.rowModel;
  }
  /** 
   * Expand or collapse a specific row node, optionally expanding/collapsing all of its parent nodes.
   * By default rows are expanded asynchronously for best performance. Set forceSync: `true` if you need to interact with the expanded row immediately after this function.
   */
  setRowNodeExpanded(e, t, r, i) {
    this.expansionService.setRowNodeExpanded(e, t, r, i);
  }
  /**
   * Informs the grid that row group expanded state has changed and it needs to rerender the group nodes.
   * Typically called after updating the row node expanded state explicitly, i.e `rowNode.expanded = false`,
   * across multiple groups and you want to update the grid view in a single rerender instead of on every group change.
   */
  onGroupExpandedOrCollapsed() {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("onGroupExpandedOrCollapsed", "clientSide");
      return;
    }
    this.expansionService.onGroupExpandedOrCollapsed();
  }
  /**
   * Refresh the Client-Side Row Model, executing the grouping, filtering and sorting again.
   * Optionally provide the step you wish the refresh to apply from. Defaults to `everything`.
   */
  refreshClientSideRowModel(e) {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("refreshClientSideRowModel", "clientSide");
      return;
    }
    this.clientSideRowModel.refreshModel(e);
  }
  /** Returns `true` when there are no more animation frames left to process. */
  isAnimationFrameQueueEmpty() {
    return this.animationFrameService.isQueueEmpty();
  }
  flushAllAnimationFrames() {
    this.animationFrameService.flushAllFrames();
  }
  /**
   * Returns the row node with the given ID.
   * The row node ID is the one you provide from the callback `getRowId(params)`,
   * otherwise the ID is a number (cast as string) auto-generated by the grid when
   * the row data is set.
   */
  getRowNode(e) {
    return this.rowModel.getRowNode(e);
  }
  /**
   * Gets the sizes that various UI elements will be rendered at with the current theme.
   * If you override the row or header height using `gridOptions`, the override value you provided will be returned.
   */
  getSizesForCurrentTheme() {
    return {
      rowHeight: this.gos.getRowHeightAsNumber(),
      headerHeight: this.columnModel.getHeaderHeight()
    };
  }
  /** Expand all groups. */
  expandAll() {
    this.clientSideRowModel || this.serverSideRowModel ? this.expansionService.expandAll(!0) : this.logMissingRowModel("expandAll", "clientSide", "serverSide");
  }
  /** Collapse all groups. */
  collapseAll() {
    this.clientSideRowModel || this.serverSideRowModel ? this.expansionService.expandAll(!1) : this.logMissingRowModel("collapseAll", "clientSide", "serverSide");
  }
  /**
   * Registers a callback to a virtual row.
   * A virtual row is a row that is visually rendered on the screen (rows that are not visible because of the scroll position are not rendered).
   * Unlike normal events, you do not need to unregister rendered row listeners.
   * When the rendered row is removed from the grid, all associated rendered row listeners will also be removed.
   * listen for this event if your `cellRenderer` needs to do cleanup when the row no longer exists.
   */
  addRenderedRowListener(e, t, r) {
    this.rowRenderer.addRenderedRowListener(e, t, r);
  }
  /** Get the current Quick Filter text from the grid, or `undefined` if none is set. */
  getQuickFilter() {
    return this.gos.get("quickFilterText");
  }
  /** Get the state of the Advanced Filter. Used for saving Advanced Filter state */
  getAdvancedFilterModel() {
    return Xe.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.getAdvancedFilterModel", this.context.getGridId()) ? this.filterManager.getAdvancedFilterModel() : null;
  }
  /** Set the state of the Advanced Filter. Used for restoring Advanced Filter state */
  setAdvancedFilterModel(e) {
    this.filterManager.setAdvancedFilterModel(e);
  }
  /** Open the Advanced Filter Builder dialog (if enabled). */
  showAdvancedFilterBuilder() {
    Xe.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.setAdvancedFilterModel", this.context.getGridId()) && this.filterManager.showAdvancedFilterBuilder("api");
  }
  /**
   * Set all of the provided nodes selection state to the provided value.
   */
  setNodesSelected(e) {
    if (!e.nodes.every((s) => s.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), !1) : s.id === void 0 ? (console.warn("AG Grid: cannot select node until id for node is known"), !1) : !0))
      return;
    const { nodes: r, source: i, newValue: n } = e, o = r;
    this.selectionService.setNodesSelected({ nodes: o, source: i ?? "api", newValue: n });
  }
  /**
   * Select all rows, regardless of filtering and rows that are not visible due to grouping being enabled and their groups not expanded.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
   */
  selectAll(e = "apiSelectAll") {
    this.selectionService.selectAllRowNodes({ source: e });
  }
  /**
   * Clear all row selections, regardless of filtering.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
   */
  deselectAll(e = "apiSelectAll") {
    this.selectionService.deselectAllRowNodes({ source: e });
  }
  /**
   * Select all filtered rows.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
   */
  selectAllFiltered(e = "apiSelectAllFiltered") {
    this.selectionService.selectAllRowNodes({ source: e, justFiltered: !0 });
  }
  /**
   * Clear all filtered selections.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
   */
  deselectAllFiltered(e = "apiSelectAllFiltered") {
    this.selectionService.deselectAllRowNodes({ source: e, justFiltered: !0 });
  }
  /**
   * Returns an object containing rules matching the selected rows in the SSRM.
   * 
   * If `groupSelectsChildren=false` the returned object will be flat, and will conform to IServerSideSelectionState.
   * If `groupSelectsChildren=true` the returned object will be hierarchical, and will conform to IServerSideGroupSelectionState.
   */
  getServerSideSelectionState() {
    return Re(this.serverSideRowModel) ? (this.logMissingRowModel("getServerSideSelectionState", "serverSide"), null) : this.selectionService.getSelectionState();
  }
  /**
   * Set the rules matching the selected rows in the SSRM.
   * 
   * If `groupSelectsChildren=false` the param will be flat, and should conform to IServerSideSelectionState.
   * If `groupSelectsChildren=true` the param will be hierarchical, and should conform to IServerSideGroupSelectionState.
   */
  setServerSideSelectionState(e) {
    if (Re(this.serverSideRowModel)) {
      this.logMissingRowModel("setServerSideSelectionState", "serverSide");
      return;
    }
    this.selectionService.setSelectionState(e, "api");
  }
  /**
   * Select all rows on the current page.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
   */
  selectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
    this.selectionService.selectAllRowNodes({ source: e, justCurrentPage: !0 });
  }
  /**
   * Clear all filtered on the current page.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
   */
  deselectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
    this.selectionService.deselectAllRowNodes({ source: e, justCurrentPage: !0 });
  }
  /** Show the 'loading' overlay. */
  showLoadingOverlay() {
    this.overlayService.showLoadingOverlay();
  }
  /** Show the 'no rows' overlay. */
  showNoRowsOverlay() {
    this.overlayService.showNoRowsOverlay();
  }
  /** Hides the overlay if showing. */
  hideOverlay() {
    this.overlayService.hideOverlay();
  }
  /**
   * Returns an unsorted list of selected nodes.
   * Getting the underlying node (rather than the data) is useful when working with tree / aggregated data,
   * as the node can be traversed.
   */
  getSelectedNodes() {
    return this.selectionService.getSelectedNodes();
  }
  /** Returns an unsorted list of selected rows (i.e. row data that you provided). */
  getSelectedRows() {
    return this.selectionService.getSelectedRows();
  }
  /**
   * Returns a list of all selected nodes at 'best cost', a feature to be used with groups / trees.
   * If a group has all its children selected, then the group appears in the result, but not the children.
   * Designed for use with `'children'` as the group selection type, where groups don't actually appear in the selection normally.
   */
  getBestCostNodeSelection() {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("getBestCostNodeSelection", "clientSide");
      return;
    }
    return this.selectionService.getBestCostNodeSelection();
  }
  /** Retrieve rendered nodes. Due to virtualisation this will contain only the current visible rows and those in the buffer. */
  getRenderedNodes() {
    return this.rowRenderer.getRenderedNodes();
  }
  /**
   *  Ensures the column is visible by scrolling the table if needed.
   *
   * This will have no effect before the firstDataRendered event has fired.
   *
   * @param key - The column to ensure visible
   * @param position - Where the column will be positioned.
   * - `auto` - Scrolls the minimum amount to make sure the column is visible.
   * - `start` - Scrolls the column to the start of the viewport.
   * - `middle` - Scrolls the column to the middle of the viewport.
   * - `end` - Scrolls the column to the end of the viewport.
  */
  ensureColumnVisible(e, t = "auto") {
    this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureColumnVisible(e, t), "ensureVisible");
  }
  /**
   * Vertically scrolls the grid until the provided row index is inside the visible viewport.
   * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
   * This will have no effect before the firstDataRendered event has fired.
   */
  ensureIndexVisible(e, t) {
    this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(e, t), "ensureVisible");
  }
  /**
   * Vertically scrolls the grid until the provided row (or a row matching the provided comparator) is inside the visible viewport.
   * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
   * This will have no effect before the firstDataRendered event has fired.
   */
  ensureNodeVisible(e, t = null) {
    this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureNodeVisible(e, t), "ensureVisible");
  }
  /**
   * Similar to `forEachNode`, except lists all the leaf nodes.
   * This effectively goes through all the data that you provided to the grid before the grid performed any grouping.
   * If using tree data, goes through all the nodes for the data you provided, including nodes that have children,
   * but excluding groups the grid created where gaps were missing in the hierarchy.
   */
  forEachLeafNode(e) {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachLeafNode", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachLeafNode(e);
  }
  /**
   * Iterates through each node (row) in the grid and calls the callback for each node.
   * This works similar to the `forEach` method on a JavaScript array.
   * This is called for every node, ignoring any filtering or sorting applied within the grid.
   * If using the Infinite Row Model, then this gets called for each page loaded in the page cache.
   */
  forEachNode(e, t) {
    this.rowModel.forEachNode(e, t);
  }
  /** Similar to `forEachNode`, except skips any filtered out data. */
  forEachNodeAfterFilter(e) {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilter", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilter(e);
  }
  /** Similar to `forEachNodeAfterFilter`, except the callbacks are called in the order the rows are displayed in the grid. */
  forEachNodeAfterFilterAndSort(e) {
    if (Re(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilterAndSort", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilterAndSort(e);
  }
  /**
   * @deprecated v31.1 To get/set individual filter models, use `getColumnFilterModel` or `setColumnFilterModel` instead.
   * To get hold of the filter instance, use `getColumnFilterInstance` which returns the instance asynchronously.
   */
  getFilterInstance(e, t) {
    return we("'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously."), this.filterManager.getFilterInstance(e, t);
  }
  /**
   * Returns the filter component instance for a column.
   * For getting/setting models for individual column filters, use `getColumnFilterModel` and `setColumnFilterModel` instead of this.
   * `key` can be a column ID or a `Column` object.
   */
  getColumnFilterInstance(e) {
    return this.filterManager.getColumnFilterInstance(e);
  }
  /** Destroys a filter. Useful to force a particular filter to be created from scratch again. */
  destroyFilter(e) {
    const t = this.columnModel.getPrimaryColumn(e);
    if (t)
      return this.filterManager.destroyFilter(t, "api");
  }
  /** Gets the status panel instance corresponding to the supplied `id`. */
  getStatusPanel(e) {
    if (!Xe.__assertRegistered("@ag-grid-enterprise/status-bar", "api.getStatusPanel", this.context.getGridId()))
      return;
    const t = this.statusBarService.getStatusPanel(e);
    return Vs(t);
  }
  getColumnDef(e) {
    const t = this.columnModel.getPrimaryColumn(e);
    return t ? t.getColDef() : null;
  }
  /**
   * Returns the current column definitions.
  */
  getColumnDefs() {
    return this.columnModel.getColumnDefs();
  }
  /**
   * Informs the grid that a filter has changed. This is typically called after a filter change through one of the filter APIs.
   * @param source The source of the filter change event. If not specified defaults to `'api'`.
   */
  onFilterChanged(e = "api") {
    this.filterManager.onFilterChanged({ source: e });
  }
  /**
   * Gets the grid to act as if the sort was changed.
   * Useful if you update some values and want to get the grid to reorder them according to the new values.
   */
  onSortChanged() {
    this.sortController.onSortChanged("api");
  }
  /**
   * Sets the state of all the column filters. Provide it with what you get from `getFilterModel()` to restore filter state.
   * If inferring cell data types, and row data is provided asynchronously and is yet to be set,
   * the filter model will be applied asynchronously after row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition,
   * or provide cell data types for every column.
   */
  setFilterModel(e) {
    this.frameworkOverrides.wrapIncoming(() => this.filterManager.setFilterModel(e));
  }
  /** Gets the current state of all the column filters. Used for saving filter state. */
  getFilterModel() {
    return this.filterManager.getFilterModel();
  }
  /**
   * Gets the current filter model for the specified column.
   * Will return `null` if no active filter.
   */
  getColumnFilterModel(e) {
    return this.filterManager.getColumnFilterModel(e);
  }
  /**
   * Sets the filter model for the specified column.
   * Setting a `model` of `null` will reset the filter (make inactive).
   * Must wait on the response before calling `api.onFilterChanged()`.
   */
  setColumnFilterModel(e, t) {
    return this.filterManager.setColumnFilterModel(e, t);
  }
  /** Returns the focused cell (or the last focused cell if the grid lost focus). */
  getFocusedCell() {
    return this.focusService.getFocusedCell();
  }
  /** Clears the focused cell. */
  clearFocusedCell() {
    return this.focusService.clearFocusedCell();
  }
  /** Sets the focus to the specified cell. `rowPinned` can be either 'top', 'bottom' or null (for not pinned). */
  setFocusedCell(e, t, r) {
    this.focusService.setFocusedCell({ rowIndex: e, column: t, rowPinned: r, forceBrowserFocus: !0 });
  }
  /** Adds a drop zone outside of the grid where rows can be dropped. */
  addRowDropZone(e) {
    this.gridBodyCtrl.getRowDragFeature().addRowDropZone(e);
  }
  /** Removes an external drop zone added by `addRowDropZone`. */
  removeRowDropZone(e) {
    const t = this.dragAndDropService.findExternalZone(e);
    t && this.dragAndDropService.removeDropTarget(t);
  }
  /** Returns the `RowDropZoneParams` to be used by another grid's `addRowDropZone` method. */
  getRowDropZoneParams(e) {
    return this.gridBodyCtrl.getRowDragFeature().getRowDropZone(e);
  }
  assertSideBarLoaded(e) {
    return Xe.__assertRegistered("@ag-grid-enterprise/side-bar", "api." + e, this.context.getGridId());
  }
  /** Returns `true` if the side bar is visible. */
  isSideBarVisible() {
    return this.assertSideBarLoaded("isSideBarVisible") && this.sideBarService.getSideBarComp().isDisplayed();
  }
  /** Show/hide the entire side bar, including any visible panel and the tab buttons. */
  setSideBarVisible(e) {
    this.assertSideBarLoaded("setSideBarVisible") && this.sideBarService.getSideBarComp().setDisplayed(e);
  }
  /** Sets the side bar position relative to the grid. Possible values are `'left'` or `'right'`. */
  setSideBarPosition(e) {
    this.assertSideBarLoaded("setSideBarPosition") && this.sideBarService.getSideBarComp().setSideBarPosition(e);
  }
  /** Opens a particular tool panel. Provide the ID of the tool panel to open. */
  openToolPanel(e) {
    this.assertSideBarLoaded("openToolPanel") && this.sideBarService.getSideBarComp().openToolPanel(e, "api");
  }
  /** Closes the currently open tool panel (if any). */
  closeToolPanel() {
    this.assertSideBarLoaded("closeToolPanel") && this.sideBarService.getSideBarComp().close("api");
  }
  /** Returns the ID of the currently shown tool panel if any, otherwise `null`. */
  getOpenedToolPanel() {
    return this.assertSideBarLoaded("getOpenedToolPanel") ? this.sideBarService.getSideBarComp().openedItem() : null;
  }
  /** Force refresh all tool panels by calling their `refresh` method. */
  refreshToolPanel() {
    this.assertSideBarLoaded("refreshToolPanel") && this.sideBarService.getSideBarComp().refresh();
  }
  /** Returns `true` if the tool panel is showing, otherwise `false`. */
  isToolPanelShowing() {
    return this.assertSideBarLoaded("isToolPanelShowing") && this.sideBarService.getSideBarComp().isToolPanelShowing();
  }
  /** Gets the tool panel instance corresponding to the supplied `id`. */
  getToolPanelInstance(e) {
    if (this.assertSideBarLoaded("getToolPanelInstance")) {
      const t = this.sideBarService.getSideBarComp().getToolPanelInstance(e);
      return Vs(t);
    }
  }
  /** Returns the current side bar configuration. If a shortcut was used, returns the detailed long form. */
  getSideBar() {
    if (this.assertSideBarLoaded("getSideBar"))
      return this.sideBarService.getSideBarComp().getDef();
  }
  /** Tells the grid to recalculate the row heights. */
  resetRowHeights() {
    if (q(this.clientSideRowModel)) {
      if (this.columnModel.isAutoRowHeightActive()) {
        console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
        return;
      }
      this.clientSideRowModel.resetRowHeights();
    }
  }
  /**
   * Sets the `rowCount` and `maxRowFound` properties.
   * The second parameter, `maxRowFound`, is optional and if left out, only `rowCount` is set.
   * Set `rowCount` to adjust the height of the vertical scroll.
   * Set `maxRowFound` to enable / disable searching for more rows.
   * Use this method if you add or remove rows into the dataset and need to reset the number of rows or instruct the grid that the entire row count is no longer known.
   */
  setRowCount(e, t) {
    if (this.serverSideRowModel) {
      if (this.columnModel.isRowGroupEmpty()) {
        this.serverSideRowModel.setRowCount(e, t);
        return;
      }
      console.error("AG Grid: setRowCount cannot be used while using row grouping.");
      return;
    }
    if (this.infiniteRowModel) {
      this.infiniteRowModel.setRowCount(e, t);
      return;
    }
    this.logMissingRowModel("setRowCount", "infinite", "serverSide");
  }
  /** Tells the grid a row height has changed. To be used after calling `rowNode.setRowHeight(newHeight)`. */
  onRowHeightChanged() {
    this.clientSideRowModel ? this.clientSideRowModel.onRowHeightChanged() : this.serverSideRowModel && this.serverSideRowModel.onRowHeightChanged();
  }
  /**
   * @deprecated v31.3 Use `getCellValue` instead.
   */
  getValue(e, t) {
    return this.logDeprecation("31.3", "getValue", "getCellValue"), this.getCellValue({ colKey: e, rowNode: t });
  }
  getCellValue(e) {
    var t;
    const { colKey: r, rowNode: i, useFormatter: n } = e;
    let o = (t = this.columnModel.getPrimaryColumn(r)) != null ? t : this.columnModel.getGridColumn(r);
    if (Re(o))
      return null;
    const s = this.valueService.getValue(o, i);
    if (n) {
      const a = this.valueService.formatValue(o, i, s);
      return a ?? Yt(s, !0);
    }
    return s;
  }
  /**
   * Add an event listener for the specified `eventType`.
   * Works similar to `addEventListener` for a browser DOM element.
   * Listeners will be automatically removed when the grid is destroyed.
   */
  addEventListener(e, t) {
    this.apiEventService.addEventListener(e, t);
  }
  /**
   * Add an event listener for all event types coming from the grid.
   * Listeners will be automatically removed when the grid is destroyed.
   */
  addGlobalListener(e) {
    this.apiEventService.addGlobalListener(e);
  }
  /** Remove an event listener. */
  removeEventListener(e, t) {
    this.apiEventService.removeEventListener(e, t);
  }
  /** Remove a global event listener. */
  removeGlobalListener(e) {
    this.apiEventService.removeGlobalListener(e);
  }
  dispatchEvent(e) {
    this.eventService.dispatchEvent(e);
  }
  /** Will destroy the grid and release resources. If you are using a framework you do not need to call this, as the grid links in with the framework lifecycle. However if you are using Web Components or native JavaScript, you do need to call this, to avoid a memory leak in your application. */
  destroy() {
    var e;
    const t = `See ${this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed")}`;
    if (this.destroyCalled)
      return;
    const r = {
      type: A.EVENT_GRID_PRE_DESTROYED,
      state: this.getState()
    };
    this.dispatchEvent(r), this.destroyCalled = !0, (e = this.ctrlsService.get("gridCtrl")) == null || e.destroyGridUi(), this.context.destroy(), this.detailGridInfoMap = {}, RF(this, ["isDestroyed"], t);
  }
  /** Returns `true` if the grid has been destroyed. */
  isDestroyed() {
    return this.destroyCalled;
  }
  /** Reset the Quick Filter cache text on every rowNode. */
  resetQuickFilter() {
    this.filterManager.resetQuickFilterCache();
  }
  /** Returns the list of selected cell ranges. */
  getCellRanges() {
    return this.rangeService ? this.rangeService.getCellRanges() : (Xe.__assertRegistered("@ag-grid-enterprise/range-selection", "api.getCellRanges", this.context.getGridId()), null);
  }
  /** Adds the provided cell range to the selected ranges. */
  addCellRange(e) {
    if (this.rangeService) {
      this.rangeService.addCellRange(e);
      return;
    }
    Xe.__assertRegistered("@ag-grid-enterprise/range-selection", "api.addCellRange", this.context.getGridId());
  }
  /** Clears the selected ranges. */
  clearRangeSelection() {
    this.rangeService && this.rangeService.removeAllCellRanges(), Xe.__assertRegistered("@ag-grid-enterprise/range-selection", "gridApi.clearRangeSelection", this.context.getGridId());
  }
  /** Reverts the last cell edit. */
  undoCellEditing() {
    this.undoRedoService.undo("api");
  }
  /** Re-applies the most recently undone cell edit. */
  redoCellEditing() {
    this.undoRedoService.redo("api");
  }
  /** Returns current number of available cell edit undo operations. */
  getCurrentUndoSize() {
    return this.undoRedoService.getCurrentUndoStackSize();
  }
  /** Returns current number of available cell edit redo operations. */
  getCurrentRedoSize() {
    return this.undoRedoService.getCurrentRedoStackSize();
  }
  assertChart(e, t) {
    if (Xe.__assertRegistered("@ag-grid-enterprise/charts", "api." + e, this.context.getGridId()))
      return this.frameworkOverrides.wrapIncoming(() => t());
  }
  /** Returns a list of models with information about the charts that are currently rendered from the grid. */
  getChartModels() {
    return this.assertChart("getChartModels", () => this.chartService.getChartModels());
  }
  /** Returns the `ChartRef` using the supplied `chartId`. */
  getChartRef(e) {
    return this.assertChart("getChartRef", () => this.chartService.getChartRef(e));
  }
  /** Returns a base64-encoded image data URL for the referenced chartId. */
  getChartImageDataURL(e) {
    return this.assertChart("getChartImageDataURL", () => this.chartService.getChartImageDataURL(e));
  }
  /** Starts a browser-based image download for the referenced chartId. */
  downloadChart(e) {
    return this.assertChart("downloadChart", () => this.chartService.downloadChart(e));
  }
  /** Open the Chart Tool Panel. */
  openChartToolPanel(e) {
    return this.assertChart("openChartToolPanel", () => this.chartService.openChartToolPanel(e));
  }
  /** Close the Chart Tool Panel. */
  closeChartToolPanel(e) {
    return this.assertChart("closeChartToolPanel", () => this.chartService.closeChartToolPanel(e.chartId));
  }
  /** Used to programmatically create charts from a range. */
  createRangeChart(e) {
    return this.assertChart("createRangeChart", () => this.chartService.createRangeChart(e));
  }
  /** Used to programmatically create pivot charts from a grid. */
  createPivotChart(e) {
    return this.assertChart("createPivotChart", () => this.chartService.createPivotChart(e));
  }
  /** Used to programmatically create cross filter charts from a range. */
  createCrossFilterChart(e) {
    return this.assertChart("createCrossFilterChart", () => this.chartService.createCrossFilterChart(e));
  }
  /** Used to programmatically update a chart. */
  updateChart(e) {
    return this.assertChart("updateChart", () => this.chartService.updateChart(e));
  }
  /** Restores a chart using the `ChartModel` that was previously obtained from `getChartModels()`. */
  restoreChart(e, t) {
    return this.assertChart("restoreChart", () => this.chartService.restoreChart(e, t));
  }
  assertClipboard(e, t) {
    Xe.__assertRegistered("@ag-grid-enterprise/clipboard", "api" + e, this.context.getGridId()) && t();
  }
  /** Copies data to clipboard by following the same rules as pressing Ctrl+C. */
  copyToClipboard(e) {
    this.assertClipboard("copyToClipboard", () => this.clipboardService.copyToClipboard(e));
  }
  /** Cuts data to clipboard by following the same rules as pressing Ctrl+X. */
  cutToClipboard(e) {
    this.assertClipboard("cutToClipboard", () => this.clipboardService.cutToClipboard(e));
  }
  /** Copies the selected rows to the clipboard. */
  copySelectedRowsToClipboard(e) {
    this.assertClipboard("copySelectedRowsToClipboard", () => this.clipboardService.copySelectedRowsToClipboard(e));
  }
  /** Copies the selected ranges to the clipboard. */
  copySelectedRangeToClipboard(e) {
    this.assertClipboard("copySelectedRangeToClipboard", () => this.clipboardService.copySelectedRangeToClipboard(e));
  }
  /** Copies the selected range down, similar to `Ctrl + D` in Excel. */
  copySelectedRangeDown() {
    this.assertClipboard("copySelectedRangeDown", () => this.clipboardService.copyRangeDown());
  }
  /** Pastes the data from the Clipboard into the focused cell of the grid. If no grid cell is focused, calling this method has no effect. */
  pasteFromClipboard() {
    this.assertClipboard("pasteFromClipboard", () => this.clipboardService.pasteFromClipboard());
  }
  /** @deprecated v31.1 Use `IHeaderParams.showColumnMenu` within a header component, or `api.showColumnMenu` elsewhere. */
  showColumnMenuAfterButtonClick(e, t) {
    we("'showColumnMenuAfterButtonClick' is deprecated. Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere.");
    const r = this.columnModel.getGridColumn(e);
    this.menuService.showColumnMenu({
      column: r,
      buttonElement: t,
      positionBy: "button"
    });
  }
  /** @deprecated v31.1 Use `IHeaderParams.showColumnMenuAfterMouseClick` within a header component, or `api.showColumnMenu` elsewhere. */
  showColumnMenuAfterMouseClick(e, t) {
    we("'showColumnMenuAfterMouseClick' is deprecated. Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere.");
    let r = this.columnModel.getGridColumn(e);
    if (r || (r = this.columnModel.getPrimaryColumn(e)), !r) {
      console.error(`AG Grid: column '${e}' not found`);
      return;
    }
    this.menuService.showColumnMenu({
      column: r,
      mouseEvent: t,
      positionBy: "mouse"
    });
  }
  /**
   * Displays the AG Grid context menu
   */
  showContextMenu(e) {
    const { rowNode: t, column: r, value: i, x: n, y: o } = e || {};
    let { x: s, y: a } = this.menuService.getContextMenuPosition(t, r);
    n != null && (s = n), o != null && (a = o), this.menuService.showContextMenu({
      mouseEvent: new MouseEvent("mousedown", { clientX: s, clientY: a }),
      rowNode: t,
      column: r,
      value: i
    });
  }
  /** Show the column chooser. */
  showColumnChooser(e) {
    this.menuService.showColumnChooser({ chooserParams: e });
  }
  /** Show the filter for the provided column. */
  showColumnFilter(e) {
    const t = this.columnModel.getGridColumn(e);
    if (!t) {
      console.error(`AG Grid: column '${e}' not found`);
      return;
    }
    this.menuService.showFilterMenu({
      column: t,
      containerType: "columnFilter",
      positionBy: "auto"
    });
  }
  /** Show the column menu for the provided column. */
  showColumnMenu(e) {
    const t = this.columnModel.getGridColumn(e);
    if (!t) {
      console.error(`AG Grid: column '${e}' not found`);
      return;
    }
    this.menuService.showColumnMenu({
      column: t,
      positionBy: "auto"
    });
  }
  /** Hides any visible context menu or column menu. */
  hidePopupMenu() {
    this.menuService.hidePopupMenu();
  }
  /** Hide the column chooser if visible. */
  hideColumnChooser() {
    this.menuService.hideColumnChooser();
  }
  /** Navigates the grid focus to the next cell, as if tabbing. */
  tabToNextCell(e) {
    return this.navigationService.tabToNextCell(!1, e);
  }
  /** Navigates the grid focus to the previous cell, as if shift-tabbing. */
  tabToPreviousCell(e) {
    return this.navigationService.tabToNextCell(!0, e);
  }
  /** Returns the list of active cell renderer instances. */
  getCellRendererInstances(e = {}) {
    return this.rowRenderer.getCellRendererInstances(e).map(Vs);
  }
  /** Returns the list of active cell editor instances. Optionally provide parameters to restrict to certain columns / row nodes. */
  getCellEditorInstances(e = {}) {
    return this.rowRenderer.getCellEditorInstances(e).map(Vs);
  }
  /** If the grid is editing, returns back details of the editing cell(s). */
  getEditingCells() {
    return this.rowRenderer.getEditingCells();
  }
  /** If a cell is editing, it stops the editing. Pass `true` if you want to cancel the editing (i.e. don't accept changes). */
  stopEditing(e = !1) {
    this.rowRenderer.stopEditing(e);
  }
  /** Start editing the provided cell. If another cell is editing, the editing will be stopped in that other cell. */
  startEditingCell(e) {
    const t = this.columnModel.getGridColumn(e.colKey);
    if (!t) {
      console.warn(`AG Grid: no column found for ${e.colKey}`);
      return;
    }
    const r = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned || null,
      column: t
    };
    e.rowPinned == null && this.ensureIndexVisible(e.rowIndex), this.ensureColumnVisible(e.colKey);
    const n = this.navigationService.getCellByPosition(r);
    n && (this.focusService.isCellFocused(r) || this.focusService.setFocusedCell(r), n.startRowOrCellEdit(e.key));
  }
  /** @deprecated v31.1 addAggFunc(key, func) is  deprecated, please use addAggFuncs({ key: func }) instead. */
  addAggFunc(e, t) {
    this.logDeprecation("v31.1", "addAggFunc(key, func)", "addAggFuncs({ key: func })"), this.aggFuncService && this.aggFuncService.addAggFuncs({ key: t });
  }
  /** Add aggregations function with the specified keys. */
  addAggFuncs(e) {
    this.aggFuncService && this.aggFuncService.addAggFuncs(e);
  }
  /** Clears all aggregation functions (including those provided by the grid). */
  clearAggFuncs() {
    this.aggFuncService && this.aggFuncService.clear();
  }
  /** Apply transactions to the server side row model. */
  applyServerSideTransaction(e) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransaction", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransaction(e);
  }
  /** Batch apply transactions to the server side row model. */
  applyServerSideTransactionAsync(e, t) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransactionAsync", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransactionAsync(e, t);
  }
  /**
   * Applies row data to a server side store.
   * New rows will overwrite rows at the same index in the same way as if provided by a datasource success callback.
  */
  applyServerSideRowData(e) {
    var t, r;
    const i = (t = e.startRow) != null ? t : 0, n = (r = e.route) != null ? r : [];
    if (i < 0) {
      console.warn(`AG Grid: invalid value ${e.startRow} for startRow, the value should be >= 0`);
      return;
    }
    this.serverSideRowModel ? this.serverSideRowModel.applyRowData(e.successParams, i, n) : this.logMissingRowModel("setServerSideDatasource", "serverSide");
  }
  /** Gets all failed server side loads to retry. */
  retryServerSideLoads() {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("retryServerSideLoads", "serverSide");
      return;
    }
    this.serverSideRowModel.retryLoads();
  }
  flushServerSideAsyncTransactions() {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("flushServerSideAsyncTransactions", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.flushAsyncTransactions();
  }
  /** Update row data. Pass a transaction object with lists for `add`, `remove` and `update`. */
  applyTransaction(e) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransaction", "clientSide");
      return;
    }
    return this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.updateRowData(e));
  }
  /** Same as `applyTransaction` except executes asynchronously for efficiency. */
  applyTransactionAsync(e, t) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransactionAsync", "clientSide");
      return;
    }
    this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.batchUpdateRowData(e, t));
  }
  /** Executes any remaining asynchronous grid transactions, if any are waiting to be executed. */
  flushAsyncTransactions() {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("flushAsyncTransactions", "clientSide");
      return;
    }
    this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.flushAsyncTransactions());
  }
  /**
   * Marks all the currently loaded blocks in the cache for reload.
   * If you have 10 blocks in the cache, all 10 will be marked for reload.
   * The old data will continue to be displayed until the new data is loaded.
   */
  refreshInfiniteCache() {
    this.infiniteRowModel ? this.infiniteRowModel.refreshCache() : this.logMissingRowModel("refreshInfiniteCache", "infinite");
  }
  /**
   * Purges the cache.
   * The grid is then told to refresh. Only the blocks required to display the current data on screen are fetched (typically no more than 2).
   * The grid will display nothing while the new blocks are loaded.
   * Use this to immediately remove the old data from the user.
   */
  purgeInfiniteCache() {
    this.infiniteRowModel ? this.infiniteRowModel.purgeCache() : this.logMissingRowModel("purgeInfiniteCache", "infinite");
  }
  /**
   * Refresh a server-side store level.
   * If you pass no parameters, then the top level store is refreshed.
   * To refresh a child level, pass in the string of keys to get to the desired level.
   * Once the store refresh is complete, the storeRefreshed event is fired.
   */
  refreshServerSide(e) {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("refreshServerSide", "serverSide");
      return;
    }
    this.serverSideRowModel.refreshStore(e);
  }
  /** Returns info on all server side group levels. */
  getServerSideGroupLevelState() {
    return this.serverSideRowModel ? this.serverSideRowModel.getStoreState() : (this.logMissingRowModel("getServerSideGroupLevelState", "serverSide"), []);
  }
  /** The row count defines how many rows the grid allows scrolling to. */
  getInfiniteRowCount() {
    if (this.infiniteRowModel)
      return this.infiniteRowModel.getRowCount();
    this.logMissingRowModel("getInfiniteRowCount", "infinite");
  }
  /** Returns `true` if grid allows for scrolling past the last row to load more rows, thus providing infinite scroll. */
  isLastRowIndexKnown() {
    if (this.infiniteRowModel)
      return this.infiniteRowModel.isLastRowIndexKnown();
    this.logMissingRowModel("isLastRowIndexKnown", "infinite");
  }
  /**
   * Returns an object representing the state of the cache. This is useful for debugging and understanding how the cache is working.
   */
  getCacheBlockState() {
    return this.rowNodeBlockLoader.getBlockState();
  }
  /** @deprecated v31.1 `getFirstDisplayedRow` is deprecated. Please use `getFirstDisplayedRowIndex` instead. */
  getFirstDisplayedRow() {
    return this.logDeprecation("v31.1", "getFirstDisplayedRow", "getFirstDisplayedRowIndex"), this.getFirstDisplayedRowIndex();
  }
  /** Get the index of the first displayed row due to scrolling (includes invisible rendered rows in the buffer). */
  getFirstDisplayedRowIndex() {
    return this.rowRenderer.getFirstVirtualRenderedRow();
  }
  /** @deprecated v31.1 `getLastDisplayedRow` is deprecated. Please use `getLastDisplayedRowIndex` instead. */
  getLastDisplayedRow() {
    return this.logDeprecation("v31.1", "getLastDisplayedRow", "getLastDisplayedRowIndex"), this.getLastDisplayedRowIndex();
  }
  /** Get the index of the last displayed row due to scrolling (includes invisible rendered rows in the buffer). */
  getLastDisplayedRowIndex() {
    return this.rowRenderer.getLastVirtualRenderedRow();
  }
  /** Returns the displayed `RowNode` at the given `index`. */
  getDisplayedRowAtIndex(e) {
    return this.rowModel.getRow(e);
  }
  /** Returns the total number of displayed rows. */
  getDisplayedRowCount() {
    return this.rowModel.getRowCount();
  }
  /**
   * Returns `true` when the last page is known.
   * This will always be `true` if you are using the Client-Side Row Model for pagination.
   * Returns `false` when the last page is not known; this only happens when using Infinite Row Model.
   */
  paginationIsLastPageFound() {
    return this.paginationProxy.isLastPageFound();
  }
  /** Returns how many rows are being shown per page. */
  paginationGetPageSize() {
    return this.paginationProxy.getPageSize();
  }
  /** Returns the 0-based index of the page which is showing. */
  paginationGetCurrentPage() {
    return this.paginationProxy.getCurrentPage();
  }
  /** Returns the total number of pages. Returns `null` if `paginationIsLastPageFound() === false`. */
  paginationGetTotalPages() {
    return this.paginationProxy.getTotalPages();
  }
  /** The total number of rows. Returns `null` if `paginationIsLastPageFound() === false`. */
  paginationGetRowCount() {
    return this.paginationProxy.getMasterRowCount();
  }
  /** Navigates to the next page. */
  paginationGoToNextPage() {
    this.paginationProxy.goToNextPage();
  }
  /** Navigates to the previous page. */
  paginationGoToPreviousPage() {
    this.paginationProxy.goToPreviousPage();
  }
  /** Navigates to the first page. */
  paginationGoToFirstPage() {
    this.paginationProxy.goToFirstPage();
  }
  /** Navigates to the last page. */
  paginationGoToLastPage() {
    this.paginationProxy.goToLastPage();
  }
  /** Goes to the specified page. If the page requested doesn't exist, it will go to the last page. */
  paginationGoToPage(e) {
    this.paginationProxy.goToPage(e);
  }
  // Methods migrated from old ColumnApi
  /**
   * Adjusts the size of columns to fit the available horizontal space.
   *
   * Note: it is not recommended to call this method rapidly e.g. in response
   * to window resize events or as the container size is animated. This can
   * cause the scrollbar to flicker. Use column flex for smoother results.
   * 
   * If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   **/
  sizeColumnsToFit(e) {
    typeof e == "number" ? this.columnModel.sizeColumnsToFit(e, "api") : this.gridBodyCtrl.sizeColumnsToFit(e);
  }
  /** Call this if you want to open or close a column group. */
  setColumnGroupOpened(e, t) {
    this.columnModel.setColumnGroupOpened(e, t, "api");
  }
  /** Returns the column group with the given name. */
  getColumnGroup(e, t) {
    return this.columnModel.getColumnGroup(e, t);
  }
  /** Returns the provided column group with the given name. */
  getProvidedColumnGroup(e) {
    return this.columnModel.getProvidedColumnGroup(e);
  }
  /** Returns the display name for a column. Useful if you are doing your own header rendering and want the grid to work out if `headerValueGetter` is used, or if you are doing your own column management GUI, to know what to show as the column name. */
  getDisplayNameForColumn(e, t) {
    return this.columnModel.getDisplayNameForColumn(e, t) || "";
  }
  /** Returns the display name for a column group (when grouping columns). */
  getDisplayNameForColumnGroup(e, t) {
    return this.columnModel.getDisplayNameForColumnGroup(e, t) || "";
  }
  /** Returns the column with the given `colKey`, which can either be the `colId` (a string) or the `colDef` (an object). */
  getColumn(e) {
    return this.columnModel.getPrimaryColumn(e);
  }
  /** Returns all the columns, regardless of visible or not. */
  getColumns() {
    return this.columnModel.getAllPrimaryColumns();
  }
  /** Applies the state of the columns from a previous state. Returns `false` if one or more columns could not be found. */
  applyColumnState(e) {
    return this.columnModel.applyColumnState(e, "api");
  }
  /** Gets the state of the columns. Typically used when saving column state. */
  getColumnState() {
    return this.columnModel.getColumnState();
  }
  /** Sets the state back to match the originally provided column definitions. */
  resetColumnState() {
    this.columnModel.resetColumnState("api");
  }
  /** Gets the state of the column groups. Typically used when saving column group state. */
  getColumnGroupState() {
    return this.columnModel.getColumnGroupState();
  }
  /** Sets the state of the column group state from a previous state. */
  setColumnGroupState(e) {
    this.columnModel.setColumnGroupState(e, "api");
  }
  /** Sets the state back to match the originally provided column definitions. */
  resetColumnGroupState() {
    this.columnModel.resetColumnGroupState("api");
  }
  /** Returns `true` if pinning left or right, otherwise `false`. */
  isPinning() {
    return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
  }
  /** Returns `true` if pinning left, otherwise `false`. */
  isPinningLeft() {
    return this.columnModel.isPinningLeft();
  }
  /** Returns `true` if pinning right, otherwise `false`. */
  isPinningRight() {
    return this.columnModel.isPinningRight();
  }
  /** Returns the column to the right of the provided column, taking into consideration open / closed column groups and visible columns. This is useful if you need to know what column is beside yours e.g. if implementing your own cell navigation. */
  getDisplayedColAfter(e) {
    return this.columnModel.getDisplayedColAfter(e);
  }
  /** Same as `getVisibleColAfter` except gives column to the left. */
  getDisplayedColBefore(e) {
    return this.columnModel.getDisplayedColBefore(e);
  }
  /** @deprecated v31.1 setColumnVisible(key, visible) deprecated, please use setColumnsVisible([key], visible) instead. */
  setColumnVisible(e, t) {
    this.logDeprecation("v31.1", "setColumnVisible(key,visible)", "setColumnsVisible([key],visible)"), this.columnModel.setColumnsVisible([e], t, "api");
  }
  /** Sets the visibility of columns. Key can be the column ID or `Column` object. */
  setColumnsVisible(e, t) {
    this.columnModel.setColumnsVisible(e, t, "api");
  }
  /** @deprecated v31.1 setColumnPinned(key, pinned) deprecated, please use setColumnsPinned([key], pinned) instead. */
  setColumnPinned(e, t) {
    this.logDeprecation("v31.1", "setColumnPinned(key,pinned)", "setColumnsPinned([key],pinned)"), this.columnModel.setColumnsPinned([e], t, "api");
  }
  /** Set a column's pinned / unpinned state. Key can be the column ID, field, `ColDef` object or `Column` object. */
  setColumnsPinned(e, t) {
    this.columnModel.setColumnsPinned(e, t, "api");
  }
  /**
   * Returns all the grid columns, same as `getColumns()`, except
   *
   *  a) it has the order of the columns that are presented in the grid
   *
   *  b) it's after the 'pivot' step, so if pivoting, has the value columns for the pivot.
   */
  getAllGridColumns() {
    return this.columnModel.getAllGridColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the pinned left portion of the grid. */
  getDisplayedLeftColumns() {
    return this.columnModel.getDisplayedLeftColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the center portion of the grid. */
  getDisplayedCenterColumns() {
    return this.columnModel.getDisplayedCenterColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the pinned right portion of the grid. */
  getDisplayedRightColumns() {
    return this.columnModel.getDisplayedRightColumns();
  }
  /** Returns all columns currently displayed (e.g. are visible and if in a group, the group is showing the columns) for the pinned left, centre and pinned right portions of the grid. */
  getAllDisplayedColumns() {
    return this.columnModel.getAllDisplayedColumns();
  }
  /** Same as `getAllGridColumns()`, except only returns rendered columns, i.e. columns that are not within the viewport and therefore not rendered, due to column virtualisation, are not displayed. */
  getAllDisplayedVirtualColumns() {
    return this.columnModel.getViewportColumns();
  }
  /** @deprecated v31.1 moveColumn(key, toIndex) deprecated, please use moveColumns([key], toIndex) instead. */
  moveColumn(e, t) {
    this.logDeprecation("v31.1", "moveColumn(key, toIndex)", "moveColumns([key], toIndex)"), this.columnModel.moveColumns([e], t, "api");
  }
  /** Moves the column at `fromIdex` to `toIndex`. The column is first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */
  moveColumnByIndex(e, t) {
    this.columnModel.moveColumnByIndex(e, t, "api");
  }
  /** Moves columns to `toIndex`. The columns are first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */
  moveColumns(e, t) {
    this.columnModel.moveColumns(e, t, "api");
  }
  /** Move the column to a new position in the row grouping order. */
  moveRowGroupColumn(e, t) {
    this.columnModel.moveRowGroupColumn(e, t, "api");
  }
  /** Sets the agg function for a column. `aggFunc` can be one of the built-in aggregations or a custom aggregation by name or direct function. */
  setColumnAggFunc(e, t) {
    this.columnModel.setColumnAggFunc(e, t, "api");
  }
  /** @deprecated v31.1 setColumnWidths(key, newWidth) deprecated, please use setColumnWidths( [{key: newWidth}] ) instead. */
  setColumnWidth(e, t, r = !0, i = "api") {
    this.logDeprecation("v31.1", "setColumnWidth(col, width)", "setColumnWidths([{key: col, newWidth: width}])"), this.columnModel.setColumnWidths([{ key: e, newWidth: t }], !1, r, i);
  }
  /** Sets the column widths of the columns provided. The finished flag gets included in the resulting event and not used internally by the grid. The finished flag is intended for dragging, where a dragging action will produce many `columnWidth` events, so the consumer of events knows when it receives the last event in a stream. The finished parameter is optional, and defaults to `true`. */
  setColumnWidths(e, t = !0, r = "api") {
    this.columnModel.setColumnWidths(e, !1, t, r);
  }
  /** Get the pivot mode. */
  isPivotMode() {
    return this.columnModel.isPivotMode();
  }
  /** Returns the pivot result column for the given `pivotKeys` and `valueColId`. Useful to then call operations on the pivot column. */
  getPivotResultColumn(e, t) {
    return this.columnModel.getSecondaryPivotColumn(e, t);
  }
  /** Set the value columns to the provided list of columns. */
  setValueColumns(e) {
    this.columnModel.setValueColumns(e, "api");
  }
  /** Get a list of the existing value columns. */
  getValueColumns() {
    return this.columnModel.getValueColumns();
  }
  /** @deprecated v31.1 removeValueColumn(colKey) deprecated, please use removeValueColumns([colKey]) instead. */
  removeValueColumn(e) {
    this.logDeprecation("v31.1", "removeValueColumn(colKey)", "removeValueColumns([colKey])"), this.columnModel.removeValueColumns([e], "api");
  }
  /** Remove the given list of columns from the existing set of value columns. */
  removeValueColumns(e) {
    this.columnModel.removeValueColumns(e, "api");
  }
  /** @deprecated v31.1 addValueColumn(colKey) deprecated, please use addValueColumns([colKey]) instead. */
  addValueColumn(e) {
    this.logDeprecation("v31.1", "addValueColumn(colKey)", "addValueColumns([colKey])"), this.columnModel.addValueColumns([e], "api");
  }
  /** Add the given list of columns to the existing set of value columns. */
  addValueColumns(e) {
    this.columnModel.addValueColumns(e, "api");
  }
  /** Set the row group columns. */
  setRowGroupColumns(e) {
    this.columnModel.setRowGroupColumns(e, "api");
  }
  /** @deprecated v31.1 removeRowGroupColumn(colKey) deprecated, please use removeRowGroupColumns([colKey]) instead. */
  removeRowGroupColumn(e) {
    this.logDeprecation("v31.1", "removeRowGroupColumn(colKey)", "removeRowGroupColumns([colKey])"), this.columnModel.removeRowGroupColumns([e], "api");
  }
  /** Remove columns from the row groups. */
  removeRowGroupColumns(e) {
    this.columnModel.removeRowGroupColumns(e, "api");
  }
  /** @deprecated v31.1 addRowGroupColumn(colKey) deprecated, please use addRowGroupColumns([colKey]) instead. */
  addRowGroupColumn(e) {
    this.logDeprecation("v31.1", "addRowGroupColumn(colKey)", "addRowGroupColumns([colKey])"), this.columnModel.addRowGroupColumns([e], "api");
  }
  /** Add columns to the row groups. */
  addRowGroupColumns(e) {
    this.columnModel.addRowGroupColumns(e, "api");
  }
  /** Get row group columns. */
  getRowGroupColumns() {
    return this.columnModel.getRowGroupColumns();
  }
  /** Set the pivot columns. */
  setPivotColumns(e) {
    this.columnModel.setPivotColumns(e, "api");
  }
  /** @deprecated v31.1 removePivotColumn(colKey) deprecated, please use removePivotColumns([colKey]) instead. */
  removePivotColumn(e) {
    this.logDeprecation("v31.1", "removePivotColumn(colKey)", "removePivotColumns([colKey])"), this.columnModel.removePivotColumns([e], "api");
  }
  /** Remove pivot columns. */
  removePivotColumns(e) {
    this.columnModel.removePivotColumns(e, "api");
  }
  /** @deprecated v31.1 addPivotColumn(colKey) deprecated, please use addPivotColumns([colKey]) instead. */
  addPivotColumn(e) {
    this.logDeprecation("v31.1", "addPivotColumn(colKey)", "addPivotColumns([colKey])"), this.columnModel.addPivotColumns([e], "api");
  }
  /** Add pivot columns. */
  addPivotColumns(e) {
    this.columnModel.addPivotColumns(e, "api");
  }
  /** Get the pivot columns. */
  getPivotColumns() {
    return this.columnModel.getPivotColumns();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the pinned left portion of the grid. */
  getLeftDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeLeft();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the center portion of the grid. */
  getCenterDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeCentre();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the pinned right portion of the grid. */
  getRightDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeRight();
  }
  /** Returns all 'root' column headers. If you are not grouping columns, these return the columns. If you are grouping, these return the top level groups - you can navigate down through each one to get the other lower level headers and finally the columns at the bottom. */
  getAllDisplayedColumnGroups() {
    return this.columnModel.getAllDisplayedTrees();
  }
  /** @deprecated v31.1 autoSizeColumn(key) deprecated, please use autoSizeColumns([colKey]) instead. */
  autoSizeColumn(e, t) {
    return this.logDeprecation("v31.1", "autoSizeColumn(key, skipHeader)", "autoSizeColumns([key], skipHeader)"), this.columnModel.autoSizeColumns({ columns: [e], skipHeader: t, source: "api" });
  }
  /**
   * Auto-sizes columns based on their contents. If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   */
  autoSizeColumns(e, t) {
    this.columnModel.autoSizeColumns({ columns: e, skipHeader: t, source: "api" });
  }
  /**
   * Calls `autoSizeColumns` on all displayed columns. If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   */
  autoSizeAllColumns(e) {
    this.columnModel.autoSizeAllColumns("api", e);
  }
  /** Set the pivot result columns. */
  setPivotResultColumns(e) {
    this.columnModel.setSecondaryColumns(e, "api");
  }
  /** Returns the grid's pivot result columns. */
  getPivotResultColumns() {
    return this.columnModel.getSecondaryColumns();
  }
  /** Get the current state of the grid. Can be used in conjunction with the `initialState` grid option to save and restore grid state. */
  getState() {
    return this.stateService.getState();
  }
  /**
   * Returns the grid option value for a provided key.
   */
  getGridOption(e) {
    return this.gos.get(e);
  }
  /**
   * Updates a single gridOption to the new value provided. (Cannot be used on `Initial` properties.)
   * If updating multiple options, it is recommended to instead use `api.updateGridOptions()` which batches update logic.
   */
  setGridOption(e, t) {
    this.updateGridOptions({ [e]: t });
  }
  /**
   * Updates the provided subset of gridOptions with the provided values. (Cannot be used on `Initial` properties.)
   */
  updateGridOptions(e) {
    this.gos.updateGridOptions({ options: e });
  }
  /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
  __internalUpdateGridOptions(e, t) {
    this.gos.updateGridOptions({ options: e, force: t, source: "gridOptionsUpdated" });
  }
  deprecatedUpdateGridOption(e, t) {
    we(`set${e.charAt(0).toUpperCase()}${e.slice(1, e.length)} is deprecated. Please use 'api.setGridOption('${e}', newValue)' or 'api.updateGridOptions({ ${e}: newValue })' instead.`), this.setGridOption(e, t);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set the top pinned rows. Call with no rows / undefined to clear top pinned rows. 
   **/
  setPivotMode(e) {
    this.deprecatedUpdateGridOption("pivotMode", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set the top pinned rows. Call with no rows / undefined to clear top pinned rows. 
   **/
  setPinnedTopRowData(e) {
    this.deprecatedUpdateGridOption("pinnedTopRowData", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set the bottom pinned rows. Call with no rows / undefined to clear bottom pinned rows.
   * */
  setPinnedBottomRowData(e) {
    this.deprecatedUpdateGridOption("pinnedBottomRowData", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * DOM element to use as the popup parent for grid popups (context menu, column menu etc).
   * */
  setPopupParent(e) {
    this.deprecatedUpdateGridOption("popupParent", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setSuppressModelUpdateAfterUpdateTransaction(e) {
    this.deprecatedUpdateGridOption("suppressModelUpdateAfterUpdateTransaction", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Resets the data type definitions. This will update the columns in the grid.
   * */
  setDataTypeDefinitions(e) {
    this.deprecatedUpdateGridOption("dataTypeDefinitions", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set whether the grid paginates the data or not.
   *  - `true` to enable pagination
   *  - `false` to disable pagination
   */
  setPagination(e) {
    this.deprecatedUpdateGridOption("pagination", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `paginationPageSize`, then re-paginates the grid so the changes are applied immediately.
   * */
  paginationSetPageSize(e) {
    this.deprecatedUpdateGridOption("paginationPageSize", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Resets the side bar to the provided configuration. The parameter is the same as the sideBar grid property. The side bar is re-created from scratch with the new config.
   * */
  setSideBar(e) {
    this.deprecatedUpdateGridOption("sideBar", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setSuppressClipboardPaste(e) {
    this.deprecatedUpdateGridOption("suppressClipboardPaste", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setGroupRemoveSingleChildren(e) {
    this.deprecatedUpdateGridOption("groupRemoveSingleChildren", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setGroupRemoveLowestSingleChildren(e) {
    this.deprecatedUpdateGridOption("groupRemoveLowestSingleChildren", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setGroupDisplayType(e) {
    this.deprecatedUpdateGridOption("groupDisplayType", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `groupIncludeFooter` property
   */
  setGroupIncludeFooter(e) {
    this.deprecatedUpdateGridOption("groupIncludeFooter", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `groupIncludeTotalFooter` property
   */
  setGroupIncludeTotalFooter(e) {
    this.deprecatedUpdateGridOption("groupIncludeTotalFooter", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setRowClass(e) {
    this.deprecatedUpdateGridOption("rowClass", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `deltaSort` property
   * */
  setDeltaSort(e) {
    this.deprecatedUpdateGridOption("deltaSort", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `suppressRowDrag` property.
   * */
  setSuppressRowDrag(e) {
    this.deprecatedUpdateGridOption("suppressRowDrag", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `suppressMoveWhenRowDragging` property.
   * */
  setSuppressMoveWhenRowDragging(e) {
    this.deprecatedUpdateGridOption("suppressMoveWhenRowDragging", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `suppressRowClickSelection` property.
   * */
  setSuppressRowClickSelection(e) {
    this.deprecatedUpdateGridOption("suppressRowClickSelection", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Enable/disable the Advanced Filter
   * */
  setEnableAdvancedFilter(e) {
    this.deprecatedUpdateGridOption("enableAdvancedFilter", e);
  }
  /** 
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Updates the `includeHiddenColumnsInAdvancedFilter` grid option.
   * By default hidden columns are excluded from the Advanced Filter.
   * Set to `true` to include them.
   */
  setIncludeHiddenColumnsInAdvancedFilter(e) {
    this.deprecatedUpdateGridOption("includeHiddenColumnsInAdvancedFilter", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * DOM element to use as the parent for the Advanced Filter, to allow it to appear outside of the grid.
   * Set to `null` to appear inside the grid.
   */
  setAdvancedFilterParent(e) {
    this.deprecatedUpdateGridOption("advancedFilterParent", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Updates the Advanced Filter Builder parameters.
   * */
  setAdvancedFilterBuilderParams(e) {
    this.deprecatedUpdateGridOption("advancedFilterBuilderParams", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Pass a Quick Filter text into the grid for filtering.
   * */
  setQuickFilter(e) {
    we("setQuickFilter is deprecated. Please use 'api.setGridOption('quickFilterText', newValue)' or 'api.updateGridOptions({ quickFilterText: newValue })' instead."), this.gos.updateGridOptions({ options: { quickFilterText: e } });
  }
  /** 
   * @deprecated As of v30, hidden columns are excluded from the Quick Filter by default. To include hidden columns, use `setIncludeHiddenColumnsInQuickFilter` instead.
   */
  setExcludeHiddenColumnsFromQuickFilter(e) {
    this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", !e);
  }
  /** 
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Updates the `includeHiddenColumnsInQuickFilter` grid option.
   * By default hidden columns are excluded from the Quick Filter.
   * Set to `true` to include them.
   */
  setIncludeHiddenColumnsInQuickFilter(e) {
    this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Updates the `quickFilterParser` grid option,
   * which changes how the Quick Filter splits the Quick Filter text into search terms.
   */
  setQuickFilterParser(e) {
    this.deprecatedUpdateGridOption("quickFilterParser", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Updates the `quickFilterMatcher` grid option,
   * which changes the matching logic for whether a row passes the Quick Filter.
   */
  setQuickFilterMatcher(e) {
    this.deprecatedUpdateGridOption("quickFilterMatcher", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * If `true`, the horizontal scrollbar will always be present, even if not required. Otherwise, it will only be displayed when necessary.
   * */
  setAlwaysShowHorizontalScroll(e) {
    this.deprecatedUpdateGridOption("alwaysShowHorizontalScroll", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * If `true`, the vertical scrollbar will always be present, even if not required. Otherwise it will only be displayed when necessary.
   * */
  setAlwaysShowVerticalScroll(e) {
    this.deprecatedUpdateGridOption("alwaysShowVerticalScroll", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   */
  setFunctionsReadOnly(e) {
    this.deprecatedUpdateGridOption("functionsReadOnly", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Call to set new column definitions. The grid will redraw all the column headers, and then redraw all of the rows.
   */
  setColumnDefs(e, t = "api") {
    we("setColumnDefs is deprecated. Please use 'api.setGridOption('columnDefs', newValue)' or 'api.updateGridOptions({ columnDefs: newValue })' instead."), this.gos.updateGridOptions({
      options: { columnDefs: e },
      source: t
    });
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Call to set new auto group column definition. The grid will recreate any auto-group columns if present.
   * */
  setAutoGroupColumnDef(e, t = "api") {
    we("setAutoGroupColumnDef is deprecated. Please use 'api.setGridOption('autoGroupColumnDef', newValue)' or 'api.updateGridOptions({ autoGroupColumnDef: newValue })' instead."), this.gos.updateGridOptions({
      options: { autoGroupColumnDef: e },
      source: t
    });
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Call to set new Default Column Definition.
   * */
  setDefaultColDef(e, t = "api") {
    we("setDefaultColDef is deprecated. Please use 'api.setGridOption('defaultColDef', newValue)' or 'api.updateGridOptions({ defaultColDef: newValue })' instead."), this.gos.updateGridOptions({
      options: { defaultColDef: e },
      source: t
    });
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Call to set new Column Types.
   * */
  setColumnTypes(e, t = "api") {
    we("setColumnTypes is deprecated. Please use 'api.setGridOption('columnTypes', newValue)' or 'api.updateGridOptions({ columnTypes: newValue })' instead."), this.gos.updateGridOptions({
      options: { columnTypes: e },
      source: t
    });
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `treeData` property.
   * */
  setTreeData(e) {
    this.deprecatedUpdateGridOption("treeData", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set new datasource for Server-Side Row Model.
   * */
  setServerSideDatasource(e) {
    this.deprecatedUpdateGridOption("serverSideDatasource", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * 
   * Note this purges all the cached data and reloads all the rows of the grid.
   * */
  setCacheBlockSize(e) {
    this.deprecatedUpdateGridOption("cacheBlockSize", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set new datasource for Infinite Row Model.
   * */
  setDatasource(e) {
    this.deprecatedUpdateGridOption("datasource", e);
  }
  /** 
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set new datasource for Viewport Row Model.
   * */
  setViewportDatasource(e) {
    this.deprecatedUpdateGridOption("viewportDatasource", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Set the row data.
   * */
  setRowData(e) {
    this.deprecatedUpdateGridOption("rowData", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the `enableCellTextSelection` property.
   * */
  setEnableCellTextSelection(e) {
    this.deprecatedUpdateGridOption("enableCellTextSelection", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the height in pixels for the row containing the column label header.
   * */
  setHeaderHeight(e) {
    this.deprecatedUpdateGridOption("headerHeight", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Switch between layout options: `normal`, `autoHeight`, `print`.
   * Defaults to `normal` if no domLayout provided.
   */
  setDomLayout(e) {
    this.deprecatedUpdateGridOption("domLayout", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the preferred direction for the selection fill handle.
   * */
  setFillHandleDirection(e) {
    this.deprecatedUpdateGridOption("fillHandleDirection", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the height in pixels for the rows containing header column groups.
   * */
  setGroupHeaderHeight(e) {
    this.deprecatedUpdateGridOption("groupHeaderHeight", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the height in pixels for the row containing the floating filters.
   * */
  setFloatingFiltersHeight(e) {
    this.deprecatedUpdateGridOption("floatingFiltersHeight", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the height in pixels for the row containing the columns when in pivot mode.
   * */
  setPivotHeaderHeight(e) {
    this.deprecatedUpdateGridOption("pivotHeaderHeight", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   * Sets the height in pixels for the row containing header column groups when in pivot mode.
   * */
  setPivotGroupHeaderHeight(e) {
    this.deprecatedUpdateGridOption("pivotGroupHeaderHeight", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setAnimateRows(e) {
    this.deprecatedUpdateGridOption("animateRows", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsExternalFilterPresent(e) {
    this.deprecatedUpdateGridOption("isExternalFilterPresent", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setDoesExternalFilterPass(e) {
    this.deprecatedUpdateGridOption("doesExternalFilterPass", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setNavigateToNextCell(e) {
    this.deprecatedUpdateGridOption("navigateToNextCell", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setTabToNextCell(e) {
    this.deprecatedUpdateGridOption("tabToNextCell", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setTabToNextHeader(e) {
    this.deprecatedUpdateGridOption("tabToNextHeader", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setNavigateToNextHeader(e) {
    this.deprecatedUpdateGridOption("navigateToNextHeader", e);
  }
  setRowGroupPanelShow(e) {
    this.deprecatedUpdateGridOption("rowGroupPanelShow", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetGroupRowAgg(e) {
    this.deprecatedUpdateGridOption("getGroupRowAgg", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetBusinessKeyForNode(e) {
    this.deprecatedUpdateGridOption("getBusinessKeyForNode", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetChildCount(e) {
    this.deprecatedUpdateGridOption("getChildCount", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setProcessRowPostCreate(e) {
    this.deprecatedUpdateGridOption("processRowPostCreate", e);
  }
  /**
   * @deprecated v31 `getRowId` is a static property and cannot be updated.
   *  */
  setGetRowId(e) {
    we("getRowId is a static property and can no longer be updated.");
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetRowClass(e) {
    this.deprecatedUpdateGridOption("getRowClass", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsFullWidthRow(e) {
    this.deprecatedUpdateGridOption("isFullWidthRow", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsRowSelectable(e) {
    this.deprecatedUpdateGridOption("isRowSelectable", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsRowMaster(e) {
    this.deprecatedUpdateGridOption("isRowMaster", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setPostSortRows(e) {
    this.deprecatedUpdateGridOption("postSortRows", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetDocument(e) {
    this.deprecatedUpdateGridOption("getDocument", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetContextMenuItems(e) {
    this.deprecatedUpdateGridOption("getContextMenuItems", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetMainMenuItems(e) {
    this.deprecatedUpdateGridOption("getMainMenuItems", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setProcessCellForClipboard(e) {
    this.deprecatedUpdateGridOption("processCellForClipboard", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setSendToClipboard(e) {
    this.deprecatedUpdateGridOption("sendToClipboard", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setProcessCellFromClipboard(e) {
    this.deprecatedUpdateGridOption("processCellFromClipboard", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setProcessPivotResultColDef(e) {
    this.deprecatedUpdateGridOption("processPivotResultColDef", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setProcessPivotResultColGroupDef(e) {
    this.deprecatedUpdateGridOption("processPivotResultColGroupDef", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setPostProcessPopup(e) {
    this.deprecatedUpdateGridOption("postProcessPopup", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setInitialGroupOrderComparator(e) {
    this.deprecatedUpdateGridOption("initialGroupOrderComparator", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetChartToolbarItems(e) {
    this.deprecatedUpdateGridOption("getChartToolbarItems", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setPaginationNumberFormatter(e) {
    this.deprecatedUpdateGridOption("paginationNumberFormatter", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetServerSideGroupLevelParams(e) {
    this.deprecatedUpdateGridOption("getServerSideGroupLevelParams", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsServerSideGroupOpenByDefault(e) {
    this.deprecatedUpdateGridOption("isServerSideGroupOpenByDefault", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsApplyServerSideTransaction(e) {
    this.deprecatedUpdateGridOption("isApplyServerSideTransaction", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setIsServerSideGroup(e) {
    this.deprecatedUpdateGridOption("isServerSideGroup", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetServerSideGroupKey(e) {
    this.deprecatedUpdateGridOption("getServerSideGroupKey", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetRowStyle(e) {
    this.deprecatedUpdateGridOption("getRowStyle", e);
  }
  /**
   * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
   *  */
  setGetRowHeight(e) {
    this.deprecatedUpdateGridOption("getRowHeight", e);
  }
};
v([
  T("rowRenderer")
], Be.prototype, "rowRenderer", 2);
v([
  T("navigationService")
], Be.prototype, "navigationService", 2);
v([
  T("filterManager")
], Be.prototype, "filterManager", 2);
v([
  T("columnModel")
], Be.prototype, "columnModel", 2);
v([
  T("selectionService")
], Be.prototype, "selectionService", 2);
v([
  T("gridOptionsService")
], Be.prototype, "gos", 2);
v([
  T("valueService")
], Be.prototype, "valueService", 2);
v([
  T("alignedGridsService")
], Be.prototype, "alignedGridsService", 2);
v([
  T("eventService")
], Be.prototype, "eventService", 2);
v([
  T("pinnedRowModel")
], Be.prototype, "pinnedRowModel", 2);
v([
  T("context")
], Be.prototype, "context", 2);
v([
  T("rowModel")
], Be.prototype, "rowModel", 2);
v([
  T("sortController")
], Be.prototype, "sortController", 2);
v([
  T("paginationProxy")
], Be.prototype, "paginationProxy", 2);
v([
  T("focusService")
], Be.prototype, "focusService", 2);
v([
  T("dragAndDropService")
], Be.prototype, "dragAndDropService", 2);
v([
  T("menuService")
], Be.prototype, "menuService", 2);
v([
  T("valueCache")
], Be.prototype, "valueCache", 2);
v([
  T("animationFrameService")
], Be.prototype, "animationFrameService", 2);
v([
  T("ctrlsService")
], Be.prototype, "ctrlsService", 2);
v([
  T("overlayService")
], Be.prototype, "overlayService", 2);
v([
  T("stateService")
], Be.prototype, "stateService", 2);
v([
  T("expansionService")
], Be.prototype, "expansionService", 2);
v([
  T("apiEventService")
], Be.prototype, "apiEventService", 2);
v([
  T("frameworkOverrides")
], Be.prototype, "frameworkOverrides", 2);
v([
  T("undoRedoService")
], Be.prototype, "undoRedoService", 2);
v([
  T("rowNodeBlockLoader")
], Be.prototype, "rowNodeBlockLoader", 2);
v([
  Qe("csvCreator")
], Be.prototype, "csvCreator", 2);
v([
  Qe("excelCreator")
], Be.prototype, "excelCreator", 2);
v([
  Qe("rangeService")
], Be.prototype, "rangeService", 2);
v([
  Qe("clipboardService")
], Be.prototype, "clipboardService", 2);
v([
  Qe("aggFuncService")
], Be.prototype, "aggFuncService", 2);
v([
  Qe("statusBarService")
], Be.prototype, "statusBarService", 2);
v([
  Qe("chartService")
], Be.prototype, "chartService", 2);
v([
  Qe("ssrmTransactionManager")
], Be.prototype, "serverSideTransactionManager", 2);
v([
  Qe("sideBarService")
], Be.prototype, "sideBarService", 2);
v([
  te
], Be.prototype, "init", 1);
Be = v([
  de("gridApi")
], Be);
var ei = class extends Q {
  constructor() {
    super(...arguments), this.quickFilter = null, this.quickFilterParts = null;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VISIBLE, () => {
      this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
    }), this.addManagedPropertyListener("quickFilterText", (e) => this.setQuickFilter(e.currentValue)), this.addManagedPropertyListeners([
      "includeHiddenColumnsInQuickFilter",
      "applyQuickFilterBeforePivotOrAgg"
    ], () => this.onQuickFilterColumnConfigChanged()), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setQuickFilterParserAndMatcher());
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every(
      (r) => t ? this.doesRowPassQuickFilterCache(e, r) : this.doesRowPassQuickFilterNoCache(e, r)
    );
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setQuickFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseQuickFilter(e) {
    return q(e) ? this.gos.isRowModelType("clientSide") ? e.toUpperCase() : (console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      console.warn(`AG Grid - Grid option quickFilterText only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchEvent({ type: ei.EVENT_QUICK_FILTER_CHANGED }));
  }
  setQuickFilterParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), r = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, r && (this.setQuickFilterParts(), this.dispatchEvent({ type: ei.EVENT_QUICK_FILTER_CHANGED }));
  }
  onQuickFilterColumnConfigChanged() {
    this.columnModel.refreshQuickFilterColumns(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchEvent({ type: ei.EVENT_QUICK_FILTER_CHANGED });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.columnModel.getAllColumnsForQuickFilter().some((i) => {
      const n = this.getQuickFilterTextForColumn(i, e);
      return q(n) && n.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilterMatcher(e, t) {
    let r;
    e ? (this.checkGenerateQuickFilterAggregateText(t), r = t.quickFilterAggregateText) : r = this.getQuickFilterAggregateText(t);
    const { quickFilterParts: i, matcher: n } = this;
    return n(i, r);
  }
  checkGenerateQuickFilterAggregateText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e));
  }
  getQuickFilterTextForColumn(e, t) {
    let r = this.valueService.getValue(e, t, !0);
    const i = e.getColDef();
    if (i.getQuickFilterText) {
      const n = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t.data,
        column: e,
        colDef: i
      });
      r = i.getQuickFilterText(n);
    }
    return q(r) ? r.toString().toUpperCase() : null;
  }
  getQuickFilterAggregateText(e) {
    const t = [];
    return this.columnModel.getAllColumnsForQuickFilter().forEach((i) => {
      const n = this.getQuickFilterTextForColumn(i, e);
      q(n) && t.push(n);
    }), t.join(ei.QUICK_FILTER_SEPARATOR);
  }
};
ei.EVENT_QUICK_FILTER_CHANGED = "quickFilterChanged";
ei.QUICK_FILTER_SEPARATOR = `
`;
v([
  T("valueService")
], ei.prototype, "valueService", 2);
v([
  T("columnModel")
], ei.prototype, "columnModel", 2);
v([
  T("rowModel")
], ei.prototype, "rowModel", 2);
v([
  te
], ei.prototype, "postConstruct", 1);
ei = v([
  de("quickFilterService")
], ei);
var zi = class extends Q {
  constructor() {
    super(...arguments), this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [], this.advancedFilterModelUpdateQueue = [];
  }
  init() {
    var e, t, r;
    this.addManagedListener(this.eventService, A.EVENT_GRID_COLUMNS_CHANGED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VALUE_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.updateAdvancedFilterColumns()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VISIBLE, () => this.updateAdvancedFilterColumns()), this.addManagedListener(this.eventService, A.EVENT_ROW_DATA_UPDATED, () => this.onNewRowsLoaded("rowDataUpdated")), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.addManagedPropertyListener("advancedFilterModel", (i) => this.setAdvancedFilterModel(i.currentValue)), this.addManagedListener(
      this.eventService,
      A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED,
      ({ enabled: i }) => this.onAdvancedFilterEnabledChanged(i)
    ), this.addManagedListener(this.eventService, A.EVENT_DATA_TYPES_INFERRED, () => this.processFilterModelUpdateQueue()), this.addManagedListener(this.quickFilterService, ei.EVENT_QUICK_FILTER_CHANGED, () => this.onFilterChanged({ source: "quickFilter" })), this.initialFilterModel = Ce({}, (r = (t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) != null ? r : {});
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : !1;
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : !1;
  }
  setFilterModel(e, t = "api") {
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    if (this.dataTypeService.isPendingInference()) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const r = [], i = this.getFilterModel();
    if (e) {
      const n = uE(Object.keys(e));
      this.allColumnFilters.forEach((o, s) => {
        const a = e[s];
        r.push(this.setModelOnFilterWrapper(o.filterPromise, a)), n.delete(s);
      }), n.forEach((o) => {
        const s = this.columnModel.getPrimaryColumn(o) || this.columnModel.getGridColumn(o);
        if (!s) {
          console.warn("AG Grid: setFilterModel() - no column found for colId: " + o);
          return;
        }
        if (!s.isFilterAllowed()) {
          console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + o);
          return;
        }
        const a = this.getOrCreateFilterWrapper(s, "NO_UI");
        if (!a) {
          console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + o);
          return;
        }
        r.push(this.setModelOnFilterWrapper(a.filterPromise, e[o]));
      });
    } else
      this.allColumnFilters.forEach((n) => {
        r.push(this.setModelOnFilterWrapper(n.filterPromise, null));
      });
    qt.all(r).then(() => {
      const n = this.getFilterModel(), o = [];
      this.allColumnFilters.forEach((s, a) => {
        const l = i ? i[a] : null, u = n ? n[a] : null;
        Ae.jsonEquals(l, u) || o.push(s.column);
      }), o.length > 0 && this.onFilterChanged({ columns: o, source: t });
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new qt((r) => {
      e.then((i) => {
        typeof i.setModel != "function" && (console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel"), r()), (i.setModel(t) || qt.resolve()).then(() => r());
      });
    });
  }
  getFilterModel() {
    const e = {};
    return this.allColumnFilters.forEach((t, r) => {
      const i = this.getModelFromFilterWrapper(t);
      q(i) && (e[r] = i);
    }), e;
  }
  getModelFromFilterWrapper(e) {
    var t;
    const i = e.filterPromise.resolveNow(null, (n) => n);
    return i == null ? (t = this.initialFilterModel[e.column.getColId()]) != null ? t : null : typeof i.getModel != "function" ? (console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel"), null) : i.getModel();
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  isAdvancedFilterPresent() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
  }
  onAdvancedFilterEnabledChanged(e) {
    var t;
    e ? this.allColumnFilters.size && (this.allColumnFilters.forEach((r) => this.disposeFilterWrapper(r, "advancedFilterEnabled")), this.onFilterChanged({ source: "advancedFilter" })) : (t = this.advancedFilterService) != null && t.isFilterPresent() && (this.advancedFilterService.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvancedFilterEnabled() {
    var e;
    return !!((e = this.advancedFilterService) != null && e.isEnabled());
  }
  isAdvancedFilterHeaderActive() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  // called by:
  // 1) onFilterChanged()
  // 2) onNewRowsLoaded()
  updateActiveFilters() {
    this.activeColumnFilters.length = 0, this.activeAggregateFilters.length = 0;
    const e = (i) => i ? i.isFilterActive ? i.isFilterActive() : (console.warn("AG Grid: Filter is missing isFilterActive() method"), !1) : !1, t = !!this.gos.getGroupAggFiltering(), r = (i) => {
      if (!i.isPrimary())
        return !0;
      const o = !this.columnModel.isPivotActive();
      return !i.isValueActive() || !o ? !1 : this.columnModel.isPivotMode() ? !0 : t;
    };
    this.allColumnFilters.forEach((i) => {
      if (i.filterPromise.resolveNow(!1, e)) {
        const n = i.filterPromise.resolveNow(null, (o) => o);
        r(i.column) ? this.activeAggregateFilters.push(n) : this.activeColumnFilters.push(n);
      }
    });
  }
  updateFilterFlagInColumns(e, t) {
    this.allColumnFilters.forEach((r) => {
      const i = r.filterPromise.resolveNow(!1, (n) => n.isFilterActive());
      r.column.setFilterActive(i, e, t);
    });
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  doColumnFiltersPass(e, t, r) {
    const { data: i, aggData: n } = e, o = r ? this.activeAggregateFilters : this.activeColumnFilters, s = r ? n : i;
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function")
          throw new Error("Filter is missing method doesFilterPass");
        if (!l.doesFilterPass({ node: e, data: s }))
          return !1;
      }
    }
    return !0;
  }
  resetQuickFilterCache() {
    this.quickFilterService.resetQuickFilterCache();
  }
  refreshFiltersForAggregations() {
    this.gos.getGroupAggFiltering() && this.onFilterChanged();
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const t = () => this.onFilterChanged(e);
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  onFilterChanged(e = {}) {
    const { source: t, filterInstance: r, additionalEventAttributes: i, columns: n } = e;
    this.updateDependantFilters(), this.updateActiveFilters(), this.updateFilterFlagInColumns("filterChanged", i), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.allColumnFilters.forEach((s) => {
      s.filterPromise && s.filterPromise.then((a) => {
        a && a !== r && a.onAnyFilterChanged && a.onAnyFilterChanged();
      });
    });
    const o = {
      source: t,
      type: A.EVENT_FILTER_CHANGED,
      columns: n || []
    };
    i && Zr(o, i), this.processingFilterChange = !0, this.eventService.dispatchEvent(o), this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !((e = this.gos.get("allowShowChangeAfterFilter")) != null ? e : !1) && this.processingFilterChange;
  }
  isQuickFilterPresent() {
    return this.quickFilterService.isQuickFilterPresent();
  }
  updateAggFiltering() {
    this.aggFiltering = !!this.gos.getGroupAggFiltering();
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip) || this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode));
  }
  onNewRowsLoaded(e) {
    this.allColumnFilters.forEach((t) => {
      t.filterPromise.then((r) => {
        r.onNewRowsLoaded && r.onNewRowsLoaded();
      });
    }), this.updateFilterFlagInColumns(e, { afterDataChange: !0 }), this.updateActiveFilters();
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, !0);
  }
  createGetValue(e) {
    return (t, r) => {
      const i = r ? this.columnModel.getGridColumn(r) : e;
      return i ? this.valueService.getValue(i, t, !0) : void 0;
    };
  }
  getFilterComponent(e, t, r = !0) {
    var i;
    if (r)
      return ((i = this.getOrCreateFilterWrapper(e, t)) == null ? void 0 : i.filterPromise) || null;
    const n = this.cachedFilter(e);
    return n ? n.filterPromise : null;
  }
  isFilterActive(e) {
    const t = this.cachedFilter(e);
    return !!t && t.filterPromise.resolveNow(!1, (r) => r.isFilterActive());
  }
  getOrCreateFilterWrapper(e, t) {
    if (!e.isFilterAllowed())
      return null;
    let r = this.cachedFilter(e);
    return r || (r = this.createFilterWrapper(e, t), this.setColumnFilterWrapper(e, r)), r;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    let t;
    if (Xe.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId()))
      t = "agSetColumnFilter";
    else {
      const r = this.dataTypeService.getBaseDataType(e);
      r === "number" ? t = "agNumberColumnFilter" : r === "date" || r === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    let t;
    if (Xe.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId()))
      t = "agSetColumnFloatingFilter";
    else {
      const r = this.dataTypeService.getBaseDataType(e);
      r === "number" ? t = "agNumberColumnFloatingFilter" : r === "date" || r === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e) {
    const t = this.getDefaultFilter(e), r = e.getColDef();
    let i;
    const n = Dt(Ce({}, this.createFilterParams(e, r)), {
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(i, e)(),
      filterChangedCallback: (s) => this.filterChangedCallbackFactory(i, e)(s),
      doesRowPassOtherFilter: (s) => this.doesRowPassOtherFilters(i, s)
    }), o = this.userComponentFactory.getFilterDetails(r, n, t);
    return o ? {
      filterPromise: () => {
        const s = o.newAgStackInstance();
        return s && s.then((a) => i = a), s;
      },
      compDetails: o
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({
      column: e,
      colDef: _S(t),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(e),
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e, t) {
    var r;
    const i = {
      column: e,
      filterPromise: null,
      compiledElement: null,
      compDetails: null
    }, { filterPromise: n, compDetails: o } = this.createFilterInstance(e);
    return i.filterPromise = (r = n == null ? void 0 : n()) != null ? r : null, i.compDetails = o, i;
  }
  onColumnsChanged() {
    const e = [];
    this.allColumnFilters.forEach((t, r) => {
      let i;
      t.column.isPrimary() ? i = this.columnModel.getPrimaryColumn(r) : i = this.columnModel.getGridColumn(r), !(i && i === t.column) && (e.push(t.column), this.disposeFilterWrapper(t, "columnChanged"), this.disposeColumnListener(r));
    }), e.length > 0 ? this.onFilterChanged({ columns: e, source: "api" }) : this.updateDependantFilters();
  }
  updateDependantFilters() {
    const e = this.columnModel.getGroupAutoColumns();
    e == null || e.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t, "NO_UI");
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t, r;
    if (this.isAdvancedFilterEnabled() || !e.isFilterAllowed())
      return !1;
    const n = this.allColumnFilters.get(e.getColId());
    return (r = (t = n == null ? void 0 : n.filterPromise) == null ? void 0 : t.resolveNow(
      !0,
      // defer to filter component isFilterAllowed if it exists
      (o) => typeof (o == null ? void 0 : o.isFilterAllowed) == "function" ? o == null ? void 0 : o.isFilterAllowed() : !0
    )) != null ? r : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const r = (l) => {
      const u = this.getFilterComponent(e, "NO_UI");
      u != null && u.then((c) => {
        l(Vs(c));
      });
    }, i = e.getColDef(), n = Dt(Ce({}, this.createFilterParams(e, i)), {
      filterChangedCallback: () => r((l) => this.filterChangedCallbackFactory(l, e)())
    }), o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(i, Wb, n);
    let s = this.userComponentFactory.getDefaultFloatingFilterType(i, () => this.getDefaultFloatingFilter(e));
    s == null && (s = "agReadOnlyFloatingFilter");
    const a = {
      column: e,
      filterParams: o,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: r,
      showParentFilter: t,
      suppressFilterButton: !1
      // This one might be overridden from the colDef
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(i, a, s);
  }
  getCurrentFloatingFilterParentModel(e) {
    const t = this.getFilterComponent(e, "NO_UI", !1);
    return t ? t.resolveNow(null, (r) => r && r.getModel()) : null;
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    const r = e.getColId(), i = this.allColumnFilters.get(r);
    this.disposeColumnListener(r), delete this.initialFilterModel[r], i && (this.disposeFilterWrapper(i, t), this.onFilterChanged({
      columns: [e],
      source: "api"
    }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((r) => {
      this.getContext().destroyBean(r), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId());
      const i = {
        type: A.EVENT_FILTER_DESTROYED,
        source: t,
        column: e.column
      };
      this.eventService.dispatchEvent(i);
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      const r = {
        type: A.EVENT_FILTER_MODIFIED,
        column: t,
        filterInstance: e
      };
      this.eventService.dispatchEvent(r);
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (r) => {
      var i;
      const n = (i = r == null ? void 0 : r.source) != null ? i : "api", o = {
        filter: e,
        additionalEventAttributes: r,
        columns: [t],
        source: n
      };
      this.callOnFilterChangedOutsideRenderCycle(o);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const r = t.column, { compDetails: i } = r.isFilterAllowed() ? this.createFilterInstance(r) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, i)) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    const n = r.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    t.filterPromise.then((o) => {
      (o != null && o.refresh ? o.refresh(Ce(Dt(Ce({}, this.createFilterParams(r, r.getColDef())), {
        filterModifiedCallback: this.filterModifiedCallbackFactory(o, r),
        filterChangedCallback: this.filterChangedCallbackFactory(o, r),
        doesRowPassOtherFilter: (a) => this.doesRowPassOtherFilters(o, a)
      }), n)) : !0) === !1 && this.destroyFilter(r, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const r = e.getColId();
    this.allColumnFilters.set(r, t), this.allColumnListeners.set(
      r,
      this.addManagedListener(
        e,
        ct.EVENT_COL_DEF_CHANGED,
        () => this.checkDestroyFilter(r)
      )
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: r } = e, { componentClass: i } = t;
    return !(r === i || // react hooks returns new wrappers, so check nested render method
    (r == null ? void 0 : r.render) && (i == null ? void 0 : i.render) && r.render === i.render);
  }
  getAdvancedFilterModel() {
    return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
  }
  setAdvancedFilterModel(e) {
    if (this.isAdvancedFilterEnabled()) {
      if (this.dataTypeService.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilterService.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  showAdvancedFilterBuilder(e) {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder(e, !0);
  }
  updateAdvancedFilterColumns() {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    return this.isAdvancedFilterEnabled() ? !1 : this.columnModel.getAllGridColumns().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e, t) {
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    const r = this.getFilterInstanceImpl(e, (n) => {
      if (!t)
        return;
      const o = Vs(n);
      t(o);
    });
    return Vs(r);
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstance(e, (r) => {
        t(r);
      });
    });
  }
  getFilterInstanceImpl(e, t) {
    const r = this.columnModel.getPrimaryColumn(e);
    if (!r)
      return;
    const i = this.getFilterComponent(r, "NO_UI"), n = i && i.resolveNow(null, (o) => o);
    return n ? setTimeout(t, 0, n) : i && i.then((o) => {
      t(o);
    }), n;
  }
  warnAdvancedFilters() {
    we("Column Filter API methods have been disabled as Advanced Filters are enabled.");
  }
  setupAdvancedFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilterService) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvancedFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: r }) => {
      this.setColumnFilterModel(e, t).then(() => r());
    }), this.columnFilterModelUpdateQueue = [], this.advancedFilterModelUpdateQueue.forEach((e) => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    if (this.isAdvancedFilterEnabled())
      return this.warnAdvancedFilters(), Promise.resolve();
    if (this.dataTypeService.isPendingInference()) {
      let o = () => {
      };
      const s = new Promise((a) => {
        o = a;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: o }), s;
    }
    const r = this.columnModel.getPrimaryColumn(e), i = r ? this.getOrCreateFilterWrapper(r, "NO_UI") : null;
    return i ? ((o) => new Promise((s) => {
      o.then((a) => s(a));
    }))(this.setModelOnFilterWrapper(i.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    var t;
    const r = this.columnModel.getPrimaryColumn(e);
    return r && (t = this.cachedFilter(r)) != null ? t : null;
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
v([
  T("valueService")
], zi.prototype, "valueService", 2);
v([
  T("columnModel")
], zi.prototype, "columnModel", 2);
v([
  T("rowModel")
], zi.prototype, "rowModel", 2);
v([
  T("userComponentFactory")
], zi.prototype, "userComponentFactory", 2);
v([
  T("rowRenderer")
], zi.prototype, "rowRenderer", 2);
v([
  T("dataTypeService")
], zi.prototype, "dataTypeService", 2);
v([
  T("quickFilterService")
], zi.prototype, "quickFilterService", 2);
v([
  Qe("advancedFilterService")
], zi.prototype, "advancedFilterService", 2);
v([
  te
], zi.prototype, "init", 1);
zi = v([
  de("filterManager")
], zi);
var Km = class extends Oe {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-filter"></div>'
    ), this.column = e, this.source = t, this.filterWrapper = null;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedListener(this.eventService, A.EVENT_FILTER_DESTROYED, this.onFilterDestroyed.bind(this));
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e, t;
    return (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) != null ? t : null;
  }
  afterInit() {
    var e, t, r;
    return (r = (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) != null ? r : qt.resolve();
  }
  afterGuiAttached(e) {
    var t, r;
    (r = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || r.then((i) => {
      var n;
      (n = i == null ? void 0 : i.afterGuiAttached) == null || n.call(i, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((r) => {
      var i;
      (i = r == null ? void 0 : r.afterGuiDetached) == null || i.call(r);
    });
  }
  createFilter(e) {
    var t;
    const { column: r, source: i } = this;
    this.filterWrapper = this.filterManager.getOrCreateFilterWrapper(r, i), (t = this.filterWrapper) != null && t.filterPromise && this.filterWrapper.filterPromise.then((n) => {
      let o = n.getGui();
      if (q(o) || console.warn(`AG Grid: getGui method from filter returned ${o}, it should be a DOM element or an HTML template string.`), typeof o == "string" && (o = Qr(o)), this.appendChild(o), e) {
        const s = {
          type: A.EVENT_FILTER_OPENED,
          column: r,
          source: i,
          eGui: this.getGui()
        };
        this.eventService.dispatchEvent(s);
      }
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.columnModel.getPrimaryColumn(this.column) && (Ht(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
};
v([
  T("filterManager")
], Km.prototype, "filterManager", 2);
v([
  T("columnModel")
], Km.prototype, "columnModel", 2);
v([
  te
], Km.prototype, "postConstruct", 1);
var wE = class extends Oe {
  constructor(e, t) {
    super(e), this.ctrl = t;
  }
  getCtrl() {
    return this.ctrl;
  }
}, ka = class MN extends wE {
  constructor(t) {
    super(MN.TEMPLATE, t);
  }
  postConstruct() {
    const t = this.getGui(), r = {
      addOrRemoveCssClass: (i, n) => this.addOrRemoveCssClass(i, n),
      addOrRemoveBodyCssClass: (i, n) => this.eFloatingFilterBody.classList.toggle(i, n),
      setButtonWrapperDisplayed: (i) => We(this.eButtonWrapper, i),
      setCompDetails: (i) => this.setCompDetails(i),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (i) => t.style.width = i,
      setMenuIcon: (i) => this.eButtonShowMainFilter.appendChild(i)
    };
    this.ctrl.setComp(r, t, this.eButtonShowMainFilter, this.eFloatingFilterBody);
  }
  setCompDetails(t) {
    if (!t) {
      this.destroyFloatingFilterComp(), this.compPromise = null;
      return;
    }
    this.compPromise = t.newAgStackInstance(), this.compPromise.then((r) => this.afterCompCreated(r));
  }
  destroyFloatingFilterComp() {
    this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp));
  }
  afterCompCreated(t) {
    if (t) {
      if (!this.isAlive()) {
        this.destroyBean(t);
        return;
      }
      this.destroyFloatingFilterComp(), this.floatingFilterComp = t, this.eFloatingFilterBody.appendChild(t.getGui()), t.afterGuiAttached && t.afterGuiAttached();
    }
  }
};
ka.TEMPLATE = /* html */
`<div class="ag-header-cell ag-floating-filter" role="gridcell">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`;
v([
  ne("eFloatingFilterBody")
], ka.prototype, "eFloatingFilterBody", 2);
v([
  ne("eButtonWrapper")
], ka.prototype, "eButtonWrapper", 2);
v([
  ne("eButtonShowMainFilter")
], ka.prototype, "eButtonShowMainFilter", 2);
v([
  te
], ka.prototype, "postConstruct", 1);
v([
  jr
], ka.prototype, "destroyFloatingFilterComp", 1);
var Qoe = ka, qm = class extends Q {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, r = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
    this.view.updateLayoutClasses(r, t);
  }
  // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
  getDomLayout() {
    var e;
    const t = (e = this.gos.get("domLayout")) != null ? e : "normal";
    return ["normal", "print", "autoHeight"].indexOf(t) === -1 ? (we(`${t} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : t;
  }
};
v([
  te
], qm.prototype, "postConstruct", 1);
var _o = class extends Q {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = kr(() => this.lastScrollSource[
      1
      /* Horizontal */
    ] = null, 500), this.resetLastVScrollDebounced = kr(() => this.lastScrollSource[
      0
      /* Vertical */
    ] = null, 500);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    const { fakeHScrollComp: e, fakeVScrollComp: t } = this.ctrlsService.getParams();
    this.addManagedListener(this.centerRowsCtrl.getViewportElement(), "scroll", this.onHScroll.bind(this)), e.onScrollCallback(this.onFakeHScroll.bind(this));
    const r = this.gos.get("debounceVerticalScrollbar"), i = r ? kr(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this), n = r ? kr(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
    this.addManagedListener(this.eBodyViewport, "scroll", i), t.onScrollCallback(n);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    if (this.centerRowsCtrl == null)
      return;
    e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft());
    const r = this.enableRtl ? e : -e, {
      topCenter: i,
      stickyTopCenter: n,
      stickyBottomCenter: o,
      centerHeader: s,
      bottomCenter: a,
      fakeHScrollComp: l
    } = this.ctrlsService.getParams();
    s.setHorizontalScroll(-r), a.setContainerTranslateX(r), i.setContainerTranslateX(r), n.setContainerTranslateX(r), o.setContainerTranslateX(r);
    const u = this.centerRowsCtrl.getViewportElement(), c = this.lastScrollSource[
      1
      /* Horizontal */
    ] === 0;
    e = Math.abs(e), c ? l.setScrollPosition(e) : _d(u, e, this.enableRtl);
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (this.lastScrollSource[t] = e, !0) : this.lastScrollSource[t] === e;
  }
  onFakeHScroll() {
    this.isControllingScroll(
      1,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onHScroll() {
    this.isControllingScroll(
      0,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  onHScrollCommon(e) {
    const t = this.centerRowsCtrl.getViewportElement(), { scrollLeft: r } = t;
    if (this.shouldBlockScrollUpdate(1, r, !0))
      return;
    let i;
    e === 0 ? i = Fd(t, this.enableRtl) : i = this.ctrlsService.get("fakeHScrollComp").getScrollPosition(), this.doHorizontalScroll(Math.round(i)), this.resetLastHScrollDebounced();
  }
  onFakeVScroll() {
    this.isControllingScroll(
      1,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onVScroll() {
    this.isControllingScroll(
      0,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      0
      /* Container */
    );
  }
  onVScrollCommon(e) {
    let t;
    e === 0 ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), !this.shouldBlockScrollUpdate(0, t, !0) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === 0 ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: A.EVENT_BODY_SCROLL,
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      const r = Dt(Ce({}, t), {
        type: A.EVENT_BODY_SCROLL_END
      });
      this.eventService.dispatchEvent(r);
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, r = !1) {
    return r && !Oo() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = yh(this.eBodyViewport), { scrollHeight: r } = this.eBodyViewport;
    return e < 0 || e + t > r;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: r } = this.centerRowsCtrl.getViewportElement();
    if (this.enableRtl && Md()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > r;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const i = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && Md() ? e = e > 0 ? 0 : i : e = Math.min(Math.max(e, 0), i)), _d(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight, {
      top: this.lastScrollTop,
      bottom: this.lastScrollTop + this.lastOffsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const r = this.rowModel.getRowCount();
    let i = -1;
    for (let n = 0; n < r; n++) {
      const o = this.rowModel.getRow(n);
      if (typeof e == "function") {
        if (o && e(o)) {
          i = n;
          break;
        }
      } else if (e === o || e === o.data) {
        i = n;
        break;
      }
    }
    i >= 0 && this.ensureIndexVisible(i, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (this.gos.isDomLayout("print"))
      return;
    const r = this.paginationProxy.getRowCount();
    if (typeof e != "number" || e < 0 || e >= r) {
      console.warn("AG Grid: Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const n = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.getFrameworkOverrides().wrapIncoming(() => {
      n || this.paginationProxy.goToPageWithIndex(e);
      const o = this.ctrlsService.getGridBodyCtrl(), s = o.getStickyTopHeight(), a = o.getStickyBottomHeight(), l = this.paginationProxy.getRow(e);
      let u;
      do {
        const c = l.rowTop, d = l.rowHeight, h = this.paginationProxy.getPixelOffset(), p = l.rowTop - h, g = p + l.rowHeight, m = this.getVScrollPosition(), f = this.heightScaler.getDivStretchOffset(), C = m.top + f, w = m.bottom + f, E = w - C, b = this.heightScaler.getScrollPositionForPixel(p), y = this.heightScaler.getScrollPositionForPixel(g - E), S = Math.min((b + y) / 2, p), x = C + s > p, R = w - a < g;
        let P = null;
        t === "top" ? P = b : t === "bottom" ? P = y : t === "middle" ? P = S : x ? P = b - s : R && (P = y + a), P !== null && (this.setVerticalScrollPosition(P), this.rowRenderer.redraw({ afterScroll: !0 })), u = c !== l.rowTop || d !== l.rowHeight;
      } while (u);
      this.animationFrameService.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const r = this.columnModel.getGridColumn(e);
    if (!r || r.isPinned() || !this.columnModel.isColumnDisplayed(r))
      return;
    const i = this.getPositionedHorizontalScroll(r, t);
    this.getFrameworkOverrides().wrapIncoming(() => {
      i !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(i), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
    });
  }
  setScrollPosition(e, t) {
    this.getFrameworkOverrides().wrapIncoming(() => {
      this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({ afterScroll: !0 }), this.animationFrameService.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: r, columnAfterEnd: i } = this.isColumnOutsideViewport(e), n = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), o = this.centerRowsCtrl.getCenterWidth(), s = this.enableRtl;
    let a = (s ? r : i) || n, l = s ? i : r;
    t !== "auto" && (a = t === "start", l = t === "end");
    const u = t === "middle";
    if (a || l || u) {
      const { colLeft: c, colMiddle: d, colRight: h } = this.getColumnBounds(e);
      return u ? d - o / 2 : a ? s ? h : c : s ? c - o : h - o;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: r } = this.getViewportBounds(), { colLeft: i, colRight: n } = this.getColumnBounds(e), o = this.enableRtl, s = o ? t > n : r < n, a = o ? r < i : t > i;
    return { columnBeforeStart: s, columnAfterEnd: a };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, r = this.columnModel.getBodyContainerWidth(), i = e.getActualWidth(), n = e.getLeft(), o = t ? -1 : 1, s = t ? r - n : n, a = s + i * o, l = s + i / 2 * o;
    return { colLeft: s, colMiddle: l, colRight: a };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), r = t, i = e + t;
    return { start: r, end: i, width: e };
  }
};
v([
  T("ctrlsService")
], _o.prototype, "ctrlsService", 2);
v([
  T("animationFrameService")
], _o.prototype, "animationFrameService", 2);
v([
  T("paginationProxy")
], _o.prototype, "paginationProxy", 2);
v([
  T("rowModel")
], _o.prototype, "rowModel", 2);
v([
  T("rowContainerHeightService")
], _o.prototype, "heightScaler", 2);
v([
  T("rowRenderer")
], _o.prototype, "rowRenderer", 2);
v([
  T("columnModel")
], _o.prototype, "columnModel", 2);
v([
  te
], _o.prototype, "postConstruct", 1);
var FN = "ag-force-vertical-scroll", ese = "ag-selectable", tse = "ag-column-moving", Or = class extends Q {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, r, i, n, o, s) {
    this.comp = e, this.eGridBody = t, this.eBodyViewport = r, this.eTop = i, this.eBottom = n, this.eStickyTop = o, this.eStickyBottom = s, this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener("enableCellTextSelection", (a) => this.setCellTextSelection(a.currentValue)), this.createManagedBean(new qm(this.comp)), this.bodyScrollFeature = this.createManagedBean(new _o(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([i, r, n, o, s]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.filterManager.setupAdvancedFilterHeaderComp(i), this.ctrlsService.register("gridBodyCtrl", this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, A.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedListener(t, "focusin", (r) => {
        const { target: i } = r, n = Us(i, "ag-root", t);
        t.classList.toggle("ag-has-focus", !n);
      }), this.addManagedListener(t, "focusout", (r) => {
        const { target: i, relatedTarget: n } = r, o = t.contains(n), s = Us(n, "ag-root", t);
        Us(i, "ag-root", t) || (!o || s) && t.classList.remove("ag-has-focus");
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(tse, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(ese, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
    const t = e && this.gos.getScrollbarWidth() || 0, r = qS() ? 16 : 0, i = `calc(100% + ${t + r}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(i));
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getAllGridColumns();
    this.comp.setColumnCount(e.length);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedListener(this.eGridBody, "dragstart", (e) => {
      if (e.target instanceof HTMLImageElement)
        return e.preventDefault(), !1;
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus"))
      return;
    const e = (r) => {
      const i = r.relatedTarget;
      if (lg(i) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let n = (
        // see if click came from inside the viewports
        t.some((o) => o.contains(i)) && this.mouseEventService.isElementInThisGrid(i)
      );
      if (!n) {
        const o = this.popupService;
        n = o.getActivePopups().some((s) => s.contains(i)) || o.isElementWithinCustomPopup(i);
      }
      n || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
    t.forEach((r) => this.addManagedListener(r, "focusout", e));
  }
  updateRowCount() {
    const e = this.headerNavigationService.getHeaderRowCount() + this.filterManager.getHeaderRowCount(), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, r = t === -1 ? -1 : e + t;
    this.comp.setRowCount(r);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? FN : null, r = this.gos.isDomLayout("normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || r && P_(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const e = () => {
      const t = this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching(), r = t ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(r, t);
    };
    e(), this.addManagedListener(this.eventService, A.EVENT_HEIGHT_SCALE_CHANGED, e), this.addManagedPropertyListener("animateRows", e);
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedListener(this.eBodyViewport, "contextmenu", e), this.mockContextMenuForIPad(e), this.addManagedListener(this.eBodyViewport, "wheel", this.onBodyViewportWheel.bind(this)), this.addManagedListener(this.eStickyTop, "wheel", this.onStickyWheel.bind(this)), this.addManagedListener(this.eStickyBottom, "wheel", this.onStickyWheel.bind(this)), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    const e = this.eBodyViewport.querySelector(".ag-full-width-container"), t = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
    e && t && this.addManagedListener(e, "wheel", (r) => this.onFullWidthContainerWheel(r, t));
  }
  onFullWidthContainerWheel(e, t) {
    !e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e) || (e.preventDefault(), t.scrollBy({ left: e.deltaX }));
  }
  onBodyViewportContextMenu(e, t, r) {
    if (!e && !r)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || r).preventDefault();
    const { target: i } = e || t;
    (i === this.eBodyViewport || i === this.ctrlsService.get("center").getViewportElement()) && this.menuService.showContextMenu({ mouseEvent: e, touchEvent: r, value: null, anchorToElement: this.eGridBody });
  }
  mockContextMenuForIPad(e) {
    if (!Oo())
      return;
    const t = new mr(this.eBodyViewport), r = (i) => {
      e(void 0, i.touchStart, i.touchEvent);
    };
    this.addManagedListener(t, mr.EVENT_LONG_TAP, r), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  onStickyWheel(e) {
    e.preventDefault(), e.offsetY && this.scrollVertically(e.deltaY);
  }
  getGui() {
    return this.eGridBody;
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new Ai(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  onPinnedRowDataChanged() {
    this.setFloatingHeights();
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this;
    let t = e.getPinnedTopTotalHeight(), r = e.getPinnedBottomTotalHeight();
    this.comp.setTopHeight(t), this.comp.setBottomHeight(r), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  getStickyBottomHeight() {
    return this.stickyBottomHeight;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.gos.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    const t = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + this.filterManager.getHeaderHeight(), r = this.pinnedRowModel.getPinnedTopTotalHeight();
    let i = 0;
    t > 0 && (i += t), r > 0 && (i += r), i > 0 && (i += 1), this.comp.setStickyTopTop(`${i}px`);
  }
  setStickyBottomOffsetBottom() {
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight(), r = this.scrollVisibleService.isHorizontalScrollShowing() && this.gos.getScrollbarWidth() || 0, i = e + r;
    this.comp.setStickyBottomBottom(`${i}px`);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFit(e, t) {
    const i = this.isVerticalScrollShowing() ? this.gos.getScrollbarWidth() : 0, o = Ma(this.eGridBody) - i;
    if (o > 0) {
      this.columnModel.sizeColumnsToFit(o, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
  }
  // + rangeService
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: !0 });
  }
  // + focusService
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
};
v([
  T("animationFrameService")
], Or.prototype, "animationFrameService", 2);
v([
  T("rowContainerHeightService")
], Or.prototype, "rowContainerHeightService", 2);
v([
  T("ctrlsService")
], Or.prototype, "ctrlsService", 2);
v([
  T("columnModel")
], Or.prototype, "columnModel", 2);
v([
  T("scrollVisibleService")
], Or.prototype, "scrollVisibleService", 2);
v([
  T("menuService")
], Or.prototype, "menuService", 2);
v([
  T("headerNavigationService")
], Or.prototype, "headerNavigationService", 2);
v([
  T("dragAndDropService")
], Or.prototype, "dragAndDropService", 2);
v([
  T("pinnedRowModel")
], Or.prototype, "pinnedRowModel", 2);
v([
  T("rowRenderer")
], Or.prototype, "rowRenderer", 2);
v([
  T("popupService")
], Or.prototype, "popupService", 2);
v([
  T("mouseEventService")
], Or.prototype, "mouseEventService", 2);
v([
  T("rowModel")
], Or.prototype, "rowModel", 2);
v([
  T("filterManager")
], Or.prototype, "filterManager", 2);
var gc = "ag-cell-range-selected", rse = "ag-cell-range-chart", ise = "ag-cell-range-single-cell", nse = "ag-cell-range-chart-category", ose = "ag-cell-range-handle", sse = "ag-cell-range-top", ase = "ag-cell-range-right", lse = "ag-cell-range-bottom", use = "ag-cell-range-left", cse = class {
  constructor(e, t) {
    this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
  }
  onRangeSelectionChanged() {
    this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(gc, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${gc}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${gc}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${gc}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${gc}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(rse, this.hasChartRange), Zl(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(ise, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), r = !t && e.top, i = !t && e.right, n = !t && e.bottom, o = !t && e.left;
    this.cellComp.addOrRemoveCssClass(sse, r), this.cellComp.addOrRemoveCssClass(ase, i), this.cellComp.addOrRemoveCssClass(lse, n), this.cellComp.addOrRemoveCssClass(use, o);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((r) => yi([
      1,
      0
      /* VALUE */
    ], r.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = !1, r = !1, i = !1, n = !1;
    const o = this.cellCtrl.getCellPosition().column, s = this.beans.columnModel;
    let a, l;
    e ? (a = s.getDisplayedColAfter(o), l = s.getDisplayedColBefore(o)) : (a = s.getDisplayedColBefore(o), l = s.getDisplayedColAfter(o));
    const u = this.rangeService.getCellRanges().filter(
      (c) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), c)
    );
    a || (n = !0), l || (r = !0);
    for (let c = 0; c < u.length && !(t && r && i && n); c++) {
      const d = u[c], h = this.rangeService.getRangeStartRow(d), p = this.rangeService.getRangeEndRow(d);
      !t && this.beans.rowPositionUtils.sameRow(h, this.cellCtrl.getCellPosition()) && (t = !0), !i && this.beans.rowPositionUtils.sameRow(p, this.cellCtrl.getCellPosition()) && (i = !0), !n && a && d.columns.indexOf(a) < 0 && (n = !0), !r && l && d.columns.indexOf(l) < 0 && (r = !0);
    }
    return { top: t, right: r, bottom: i, left: n };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed())
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(ose, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeService.getCellRanges(), r = t.length;
    if (this.rangeCount < 1 || r < 1)
      return !1;
    const i = ze(t), n = this.cellCtrl.getCellPosition(), o = e.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle(), s = e.get("enableRangeHandle");
    let a = r === 1 && !this.cellCtrl.isEditing() && (o || s);
    if (this.hasChartRange) {
      const u = t[0].type === 1 && this.rangeService.isCellInSpecificRange(n, t[0]);
      this.cellComp.addOrRemoveCssClass(nse, u), a = i.type === 0;
    }
    return a && i.endRow != null && this.rangeService.isContiguousRange(i) && this.rangeService.isBottomRightCell(i, n);
  }
  addSelectionHandle() {
    const e = this.beans.gos, t = ze(this.rangeService.getCellRanges()).type, i = e.get("enableFillHandle") && Re(t) ? 0 : 1;
    this.selectionHandle && this.selectionHandle.getType() !== i && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(i)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, dse = class extends Q {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListener(this.beans.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded());
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    On(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListener(this.beans.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)), this.addManagedListener(this.beans.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this)));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1)
      t.push(this.column);
    else {
      let r = this.column;
      const i = this.column.getPinned();
      for (let n = 0; r && n < e && (t.push(r), r = this.beans.columnModel.getDisplayedColAfter(r), !(!r || Re(r) || i !== r.getPinned())); n++)
        ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = ze(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left")
      return e;
    const t = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (this.column.getPinned() === "right") {
      const r = this.beans.columnModel.getBodyContainerWidth();
      return t + r + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const r = this.beans.gos.getRowHeightAsNumber() * this.rowSpan;
    this.eGui.style.height = `${r}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, hse = class extends Q {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), { cellClassRules: t } = e, r = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef: e,
      column: this.column,
      rowIndex: this.rowNode.rowIndex
    });
    this.beans.stylingService.processClassRules(
      // if current was previous, skip
      t === this.cellClassRules ? void 0 : this.cellClassRules,
      t,
      r,
      (i) => this.cellComp.addOrRemoveCssClass(i, !0),
      (i) => this.cellComp.addOrRemoveCssClass(i, !1)
    ), this.cellClassRules = t;
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle)
      return;
    let t;
    if (typeof e.cellStyle == "function") {
      const r = this.beans.gos.addGridCommonParams({
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef: e,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      }), i = e.cellStyle;
      t = i(r);
    } else
      t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef: e,
      rowIndex: this.rowNode.rowIndex
    });
    this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !0));
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, Ge = class {
  postConstruct() {
    this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.gos.isRowModelType("serverSide") && (this.serverSideRowModel = this.rowModel);
  }
};
v([
  T("resizeObserverService")
], Ge.prototype, "resizeObserverService", 2);
v([
  T("paginationProxy")
], Ge.prototype, "paginationProxy", 2);
v([
  T("context")
], Ge.prototype, "context", 2);
v([
  T("gridOptionsService")
], Ge.prototype, "gos", 2);
v([
  T("environment")
], Ge.prototype, "environment", 2);
v([
  T("rowRenderer")
], Ge.prototype, "rowRenderer", 2);
v([
  T("valueService")
], Ge.prototype, "valueService", 2);
v([
  T("eventService")
], Ge.prototype, "eventService", 2);
v([
  T("columnModel")
], Ge.prototype, "columnModel", 2);
v([
  T("headerNavigationService")
], Ge.prototype, "headerNavigationService", 2);
v([
  T("navigationService")
], Ge.prototype, "navigationService", 2);
v([
  T("columnAnimationService")
], Ge.prototype, "columnAnimationService", 2);
v([
  T("focusService")
], Ge.prototype, "focusService", 2);
v([
  T("popupService")
], Ge.prototype, "popupService", 2);
v([
  T("stylingService")
], Ge.prototype, "stylingService", 2);
v([
  T("columnHoverService")
], Ge.prototype, "columnHoverService", 2);
v([
  T("userComponentFactory")
], Ge.prototype, "userComponentFactory", 2);
v([
  T("userComponentRegistry")
], Ge.prototype, "userComponentRegistry", 2);
v([
  T("animationFrameService")
], Ge.prototype, "animationFrameService", 2);
v([
  T("dragService")
], Ge.prototype, "dragService", 2);
v([
  T("dragAndDropService")
], Ge.prototype, "dragAndDropService", 2);
v([
  T("sortController")
], Ge.prototype, "sortController", 2);
v([
  T("filterManager")
], Ge.prototype, "filterManager", 2);
v([
  T("rowContainerHeightService")
], Ge.prototype, "rowContainerHeightService", 2);
v([
  T("frameworkOverrides")
], Ge.prototype, "frameworkOverrides", 2);
v([
  T("cellPositionUtils")
], Ge.prototype, "cellPositionUtils", 2);
v([
  T("rowPositionUtils")
], Ge.prototype, "rowPositionUtils", 2);
v([
  T("selectionService")
], Ge.prototype, "selectionService", 2);
v([
  T("rowCssClassCalculator")
], Ge.prototype, "rowCssClassCalculator", 2);
v([
  T("rowModel")
], Ge.prototype, "rowModel", 2);
v([
  T("ctrlsService")
], Ge.prototype, "ctrlsService", 2);
v([
  T("ctrlsFactory")
], Ge.prototype, "ctrlsFactory", 2);
v([
  T("agStackComponentsRegistry")
], Ge.prototype, "agStackComponentsRegistry", 2);
v([
  T("valueCache")
], Ge.prototype, "valueCache", 2);
v([
  T("rowNodeEventThrottle")
], Ge.prototype, "rowNodeEventThrottle", 2);
v([
  T("localeService")
], Ge.prototype, "localeService", 2);
v([
  T("syncService")
], Ge.prototype, "syncService", 2);
v([
  T("ariaAnnouncementService")
], Ge.prototype, "ariaAnnouncementService", 2);
v([
  Qe("rangeService")
], Ge.prototype, "rangeService", 2);
v([
  Qe("selectionHandleFactory")
], Ge.prototype, "selectionHandleFactory", 2);
v([
  te
], Ge.prototype, "postConstruct", 1);
Ge = v([
  de("beans")
], Ge);
var pse = class extends Ge {
  constructor(e, t, r) {
    super(), this.cellCtrl = e, this.beans = t, this.column = r;
  }
  onMouseEvent(e, t) {
    if (!hn(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: r, gos: i } = this.beans, n = e.ctrlKey || e.metaKey;
    r && n && r.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && r.intersectLastRange(!0);
    const o = this.cellCtrl.createEvent(e, A.EVENT_CELL_CLICKED);
    t.dispatchEvent(o);
    const s = this.column.getColDef();
    s.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        s.onCellClicked(o);
      });
    }, 0), (i.get("singleClickEdit") || s.singleClickEdit) && !i.get("suppressClickEdit") && !(e.shiftKey && (r == null ? void 0 : r.getCellRanges().length) != 0) && this.cellCtrl.startRowOrCellEdit();
  }
  // returns true if on iPad and this is second 'click' event in 200ms
  isDoubleClickOnIPad() {
    if (!Oo() || kS("dblclick"))
      return !1;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const t = this.column.getColDef(), r = this.cellCtrl.createEvent(e, A.EVENT_CELL_DOUBLE_CLICKED);
    this.beans.eventService.dispatchEvent(r), typeof t.onCellDoubleClicked == "function" && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        t.onCellDoubleClicked(r);
      });
    }, 0), !this.beans.gos.get("singleClickEdit") && !this.beans.gos.get("suppressClickEdit") && this.cellCtrl.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: r, shiftKey: i } = e, n = e.target, { cellCtrl: o, beans: s } = this, { eventService: a, rangeService: l, focusService: u } = s;
    if (this.isRightClickInExistingRange(e))
      return;
    const c = l && l.getCellRanges().length != 0;
    if (!i || !c) {
      const d = jn() && !o.isEditing() && !QS(n);
      o.focusCell(d);
    }
    if (i && c && !u.isCellFocused(o.getCellPosition())) {
      e.preventDefault();
      const d = u.getFocusedCell();
      if (d) {
        const { column: h, rowIndex: p, rowPinned: g } = d, m = s.rowRenderer.getRowByPosition({ rowIndex: p, rowPinned: g }), f = m == null ? void 0 : m.getCellCtrl(h);
        f != null && f.isEditing() && f.stopEditing(), u.setFocusedCell({
          column: h,
          rowIndex: p,
          rowPinned: g,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!this.containsWidget(n)) {
      if (l) {
        const d = this.cellCtrl.getCellPosition();
        if (i)
          l.extendLatestRangeToCell(d);
        else {
          const h = t || r;
          l.setRangeToCell(d, h);
        }
      }
      a.dispatchEvent(this.cellCtrl.createEvent(e, A.EVENT_CELL_MOUSE_DOWN));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    if (t) {
      const r = t.isCellInAnyRange(this.cellCtrl.getCellPosition()), i = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (r && i)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Us(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, A.EVENT_CELL_MOUSE_OUT);
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, A.EVENT_CELL_MOUSE_OVER);
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.getGui(), r = t.contains(e.target), i = t.contains(e.relatedTarget);
    return r && i;
  }
  destroy() {
  }
}, fse = class extends Q {
  constructor(e, t, r, i, n) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = i, this.rowCtrl = n;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case k.ENTER:
        this.onEnterKeyDown(e);
        break;
      case k.F2:
        this.onF2KeyDown(e);
        break;
      case k.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case k.TAB:
        this.onTabKeyDown(e);
        break;
      case k.BACKSPACE:
      case k.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case k.DOWN:
      case k.UP:
      case k.RIGHT:
      case k.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService)
      return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    var r;
    const { cellCtrl: i, beans: n, rowNode: o } = this, { gos: s, rangeService: a, eventService: l } = n;
    if (!i.isEditing()) {
      if (l.dispatchEvent({ type: A.EVENT_KEY_SHORTCUT_CHANGED_CELL_START }), V_(e, s.get("enableCellEditingOnBackspace"))) {
        if (a && s.get("enableRangeSelection"))
          a.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (i.isCellEditable()) {
          const u = i.getColumn(), c = (r = this.beans.valueService.parseValue(u, o, "", o.getValueFromValueService(u))) != null ? r : null;
          o.setDataValue(u, c, "cellClear");
        }
      } else
        i.startRowOrCellEdit(e, t);
      l.dispatchEvent({ type: A.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });
    }
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
      this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
    else if (this.beans.gos.get("enterNavigatesVertically")) {
      const t = e.shiftKey ? k.UP : k.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1);
    } else
      this.cellCtrl.startRowOrCellEdit(k.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(k.F2, e);
  }
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing())
      return;
    const i = e.key;
    i === " " ? this.onSpaceKeyDown(e) : (this.cellCtrl.startRowOrCellEdit(i, e), e.preventDefault());
  }
  onSpaceKeyDown(e) {
    const { gos: t } = this.beans;
    if (!this.cellCtrl.isEditing() && t.isRowSelection()) {
      const r = this.rowNode.isSelected(), i = !r;
      if (i || !t.get("suppressRowDeselection")) {
        const n = this.beans.gos.get("groupSelectsFiltered"), o = this.rowNode.setSelectedParams({
          newValue: i,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: n,
          event: e,
          source: "spaceKey"
        });
        r === void 0 && o === 0 && this.rowNode.setSelectedParams({
          newValue: !1,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: n,
          event: e,
          source: "spaceKey"
        });
      }
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, _N = class extends Oe {
  constructor(e, t, r) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = r;
  }
  postConstruct() {
    this.getGui().appendChild(It("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const r = () => {
      try {
        const i = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", i), e.dataTransfer.setData("text/plain", i);
      } catch {
      }
    };
    if (t) {
      const i = this.gos.addGridCommonParams({
        rowNode: this.rowNode,
        dragEvent: e
      });
      t(i);
    } else
      r();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
};
v([
  te
], _N.prototype, "postConstruct", 1);
var gse = "ag-column-first", mse = "ag-column-last", Zm = class {
  static getHeaderClassesFromColDef(e, t, r, i) {
    return Re(e) ? [] : this.getColumnClassesFromCollDef(
      e.headerClass,
      e,
      t,
      r,
      i
    );
  }
  static getToolPanelClassesFromColDef(e, t, r, i) {
    return Re(e) ? [] : this.getColumnClassesFromCollDef(
      e.toolPanelClass,
      e,
      t,
      r,
      i
    );
  }
  static refreshFirstAndLastStyles(e, t, r) {
    e.addOrRemoveCssClass(gse, r.isColumnAtEdge(t, "first")), e.addOrRemoveCssClass(mse, r.isColumnAtEdge(t, "last"));
  }
  static getClassParams(e, t, r, i) {
    return t.addGridCommonParams({
      // bad naming, as colDef here can be a group or a column,
      // however most people won't appreciate the difference,
      // so keeping it as colDef to avoid confusion.
      colDef: e,
      column: r,
      columnGroup: i
    });
  }
  static getColumnClassesFromCollDef(e, t, r, i, n) {
    if (Re(e))
      return [];
    let o;
    if (typeof e == "function") {
      const s = this.getClassParams(t, r, i, n);
      o = e(s);
    } else
      o = e;
    return typeof o == "string" ? [o] : Array.isArray(o) ? [...o] : [];
  }
}, vse = "ag-cell", Cse = "ag-cell-auto-height", yse = "ag-cell-normal-height", bse = "ag-cell-focus", wse = "ag-cell-first-right-pinned", Sse = "ag-cell-last-left-pinned", Ese = "ag-cell-not-inline-editing", xse = "ag-column-hover", Ase = "ag-cell-wrap-text", Dse = 0, NN = class $b extends Q {
  constructor(t, r, i, n) {
    super(), this.cellRangeFeature = null, this.cellPositionFeature = null, this.cellCustomStyleFeature = null, this.tooltipFeature = null, this.cellMouseListenerFeature = null, this.cellKeyboardListenerFeature = null, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.column = t, this.rowNode = r, this.beans = i, this.rowCtrl = n, this.instanceId = t.getId() + "-" + Dse++, this.colIdSanitised = Yt(this.column.getId()), i.gos.get("suppressCellFocus") || (this.tabIndex = -1), this.createCellPosition(), this.addFeatures(), this.updateAndFormatValue(!1);
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  addFeatures() {
    this.cellPositionFeature = new dse(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellPositionFeature) == null || r.destroy(), this.cellPositionFeature = null;
    }), this.cellCustomStyleFeature = new hse(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellCustomStyleFeature) == null || r.destroy(), this.cellCustomStyleFeature = null;
    }), this.cellMouseListenerFeature = new pse(this, this.beans, this.column), this.addDestroyFunc(() => {
      var r;
      (r = this.cellMouseListenerFeature) == null || r.destroy(), this.cellMouseListenerFeature = null;
    }), this.cellKeyboardListenerFeature = new fse(this, this.beans, this.column, this.rowNode, this.rowCtrl), this.addDestroyFunc(() => {
      var r;
      (r = this.cellKeyboardListenerFeature) == null || r.destroy(), this.cellKeyboardListenerFeature = null;
    }), this.column.isTooltipEnabled() && (this.enableTooltipFeature(), this.addDestroyFunc(() => {
      this.disableTooltipFeature();
    })), this.beans.rangeService && this.beans.gos.get("enableRangeSelection") && (this.cellRangeFeature = new cse(this.beans, this), this.addDestroyFunc(() => {
      var r;
      (r = this.cellRangeFeature) == null || r.destroy(), this.cellRangeFeature = null;
    }));
  }
  enableTooltipFeature(t, r) {
    const i = () => {
      const s = this.column.getColDef(), a = this.rowNode.data;
      if (s.tooltipField && q(a))
        return ml(a, s.tooltipField, this.column.isTooltipFieldContainsDots());
      const l = s.tooltipValueGetter;
      return l ? l(this.beans.gos.addGridCommonParams({
        location: "cell",
        colDef: this.column.getColDef(),
        column: this.column,
        rowIndex: this.cellPosition.rowIndex,
        node: this.rowNode,
        data: this.rowNode.data,
        value: this.value,
        valueFormatted: this.valueFormatted
      })) : null;
    }, n = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
    !r && n && !this.isCellRenderer() && (r = () => {
      const s = this.getGui(), a = s.children.length === 0 ? s : s.querySelector(".ag-cell-value");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue: t != null ? () => t : i,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => this.valueFormatted,
      shouldDisplayTooltip: r
    };
    this.tooltipFeature = new Mo(o, this.beans);
  }
  disableTooltipFeature() {
    this.tooltipFeature && (this.tooltipFeature.destroy(), this.tooltipFeature = null);
  }
  setComp(t, r, i, n, o) {
    var s, a, l, u;
    this.cellComp = t, this.eGui = r, this.printLayout = n, this.addDomData(), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(i), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (s = this.cellPositionFeature) == null || s.setComp(r), (a = this.cellCustomStyleFeature) == null || a.setComp(t), (l = this.tooltipFeature) == null || l.refreshToolTip(), (u = this.cellKeyboardListenerFeature) == null || u.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), o && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((c) => c()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(t) {
    if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !t)
      return;
    const r = t.parentElement, i = this.beans.gos.getRowHeightForNode(this.rowNode).height, n = (a) => {
      if (this.editing || !this.isAlive())
        return;
      const { paddingTop: l, paddingBottom: u, borderBottomWidth: c, borderTopWidth: d } = us(r), h = l + u + c + d, g = t.offsetHeight + h;
      if (a < 5) {
        const f = this.beans.gos.getDocument(), C = !f || !f.contains(t), w = g == 0;
        if (C || w) {
          window.setTimeout(() => n(a + 1), 0);
          return;
        }
      }
      const m = Math.max(g, i);
      this.rowNode.setRowAutoHeight(m, this.column);
    }, o = () => n(0);
    o();
    const s = this.beans.resizeObserverService.observeResize(t, o);
    this.addDestroyFunc(() => {
      s(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getCellAriaRole() {
    var t;
    return (t = this.column.getColDef().cellAriaRole) != null ? t : "gridcell";
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnIdSanitised() {
    return this.colIdSanitised;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isCellRenderer() {
    const t = this.column.getColDef();
    return t.cellRenderer != null || t.cellRendererSelector != null;
  }
  getValueToDisplay() {
    var t;
    return (t = this.valueFormatted) != null ? t : this.value;
  }
  showValue(t = !1) {
    var r;
    const i = this.getValueToDisplay();
    let n;
    if (this.rowNode.stub) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getLoadingCellRendererDetails(this.column.getColDef(), o);
    } else if (this.isCellRenderer()) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), o);
    }
    this.cellComp.setRenderDetails(n, i, t), (r = this.cellRangeFeature) == null || r.refreshHandle();
  }
  setupControlComps() {
    const t = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(t.checkboxSelection), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  isIncludeControl(t) {
    return this.rowNode.rowPinned != null ? !1 : typeof t == "function" || t === !0;
  }
  refreshShouldDestroy() {
    const t = this.column.getColDef(), r = this.includeSelection != this.isIncludeControl(t.checkboxSelection), i = this.includeRowDrag != this.isIncludeControl(t.rowDrag), n = this.includeDndSource != this.isIncludeControl(t.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return r || i || n || o;
  }
  // either called internally if single cell editing, or called by rowRenderer if row editing
  startEditing(t = null, r = !1, i = null) {
    if (!this.isCellEditable() || this.editing)
      return;
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startEditing(t, r, i);
      });
      return;
    }
    const n = this.createCellEditorParams(t, r), o = this.column.getColDef(), s = this.beans.userComponentFactory.getCellEditorDetails(o, n);
    this.editCompDetails = s;
    const a = (s == null ? void 0 : s.popupFromSelector) != null ? s.popupFromSelector : !!o.cellEditorPopup, l = (s == null ? void 0 : s.popupPositionFromSelector) != null ? s.popupPositionFromSelector : o.cellEditorPopupPosition;
    this.setEditing(!0), this.cellComp.setEditDetails(s, a, l, this.beans.gos.get("reactiveCustomComponents"));
    const u = this.createEvent(i, A.EVENT_CELL_EDITING_STARTED);
    this.beans.eventService.dispatchEvent(u);
  }
  setEditing(t) {
    var r;
    this.editing !== t && (this.editing = t, (r = this.cellRangeFeature) == null || r.refreshHandle());
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(t = !1) {
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.stopEditing(t) : this.stopEditing(t);
  }
  onPopupEditorClosed() {
    this.isEditing() && this.stopEditingAndFocus();
  }
  takeValueFromCellEditor(t) {
    const r = { newValueExists: !1 };
    if (t)
      return r;
    const i = this.cellComp.getCellEditor();
    return !i || i.isCancelAfterEnd && i.isCancelAfterEnd() ? r : {
      newValue: i.getValue(),
      newValueExists: !0
    };
  }
  /**
   * @returns `True` if the value changes, otherwise `False`.
   */
  saveNewValue(t, r) {
    if (r === t)
      return !1;
    this.suppressRefreshCell = !0;
    const i = this.rowNode.setDataValue(this.column, r, "edit");
    return this.suppressRefreshCell = !1, i;
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(t = !1) {
    if (!this.editing)
      return !1;
    const { newValue: r, newValueExists: i } = this.takeValueFromCellEditor(t), n = this.rowNode.getValueFromValueService(this.column);
    let o = !1;
    return i && (o = this.saveNewValue(n, r)), this.setEditing(!1), this.cellComp.setEditDetails(), this.editCompDetails = void 0, this.updateAndFormatValue(!1), this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.dispatchEditingStoppedEvent(n, r, !t && !!o), o;
  }
  dispatchEditingStoppedEvent(t, r, i) {
    const n = Dt(Ce({}, this.createEvent(null, A.EVENT_CELL_EDITING_STOPPED)), {
      oldValue: t,
      newValue: r,
      valueChanged: i
    });
    this.beans.eventService.dispatchEvent(n);
  }
  createCellEditorParams(t, r) {
    return this.beans.gos.addGridCommonParams({
      value: this.rowNode.getValueFromValueService(this.column),
      eventKey: t,
      column: this.column,
      colDef: this.column.getColDef(),
      rowIndex: this.getCellPosition().rowIndex,
      node: this.rowNode,
      data: this.rowNode.data,
      cellStartedEdit: r,
      onKeyDown: this.onKeyDown.bind(this),
      stopEditing: this.stopEditingAndFocus.bind(this),
      eGridCell: this.getGui(),
      parseValue: this.parseValue.bind(this),
      formatValue: this.formatValue.bind(this)
    });
  }
  createCellRendererParams() {
    return this.beans.gos.addGridCommonParams({
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.rowNode.getValueFromValueService(this.column),
      setValue: (r) => this.beans.valueService.setValue(this.rowNode, this.column, r),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      rowIndex: this.getCellPosition().rowIndex,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (r, i, n, o) => this.registerRowDragger(r, i, o),
      setTooltip: (r, i) => {
        var n;
        this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(r, i), (n = this.tooltipFeature) == null || n.refreshToolTip();
      }
    });
  }
  parseValue(t) {
    return this.beans.valueService.parseValue(this.column, this.rowNode, t, this.getValue());
  }
  setFocusOutOnEditor() {
    if (!this.editing)
      return;
    const t = this.cellComp.getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor() {
    if (!this.editing)
      return;
    const t = this.cellComp.getCellEditor();
    t && t.focusIn ? t.focusIn() : this.focusCell(!0);
  }
  onCellChanged(t) {
    t.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(t) {
    var r;
    this.refreshShouldDestroy() ? (r = this.rowCtrl) == null || r.recreateCell(this) : this.refreshCell(t);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(t) {
    var r, i, n, o;
    if (this.suppressRefreshCell || this.editing)
      return;
    const s = this.column.getColDef(), a = t != null && !!t.newData, l = t != null && !!t.suppressFlash || !!s.suppressCellFlash, u = s.field == null && s.valueGetter == null && s.showRowGroup == null, c = t && t.forceRefresh || u || a, d = !!this.cellComp, h = this.updateAndFormatValue(d), p = c || h;
    if (d) {
      if (p) {
        this.showValue(a);
        const g = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();
        !l && !g && (this.beans.gos.get("enableCellChangeFlash") || s.enableCellChangeFlash) && this.flashCell(), (r = this.cellCustomStyleFeature) == null || r.applyUserStyles(), (i = this.cellCustomStyleFeature) == null || i.applyClassesFromColDef();
      }
      (n = this.tooltipFeature) == null || n.refreshToolTip(), (o = this.cellCustomStyleFeature) == null || o.applyCellClassRules();
    }
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(t = !1, r = !1) {
    this.stopRowOrCellEdit(), this.focusCell(!0), t || this.navigateAfterEdit(r);
  }
  navigateAfterEdit(t) {
    if (this.beans.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const i = t ? k.UP : k.DOWN;
      this.beans.navigationService.navigateToNextCell(null, i, this.getCellPosition(), !1);
    }
  }
  // user can also call this via API
  flashCell(t) {
    var r, i;
    const n = (r = t == null ? void 0 : t.flashDuration) != null ? r : t == null ? void 0 : t.flashDelay, o = (i = t == null ? void 0 : t.fadeDuration) != null ? i : t == null ? void 0 : t.fadeDelay;
    this.animateCell("data-changed", n, o);
  }
  animateCell(t, r, i) {
    if (!this.cellComp)
      return;
    const n = `ag-cell-${t}`, o = `ag-cell-${t}-animation`, { gos: s } = this.beans;
    r || (r = s.get("cellFlashDuration")), q(i) || (i = s.get("cellFadeDuration")), this.cellComp.addOrRemoveCssClass(n, !0), this.cellComp.addOrRemoveCssClass(o, !1), this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(n, !1), this.cellComp.addOrRemoveCssClass(o, !0), this.eGui.style.transition = `background-color ${i}ms`, window.setTimeout(() => {
          this.isAlive() && (this.cellComp.addOrRemoveCssClass(o, !1), this.eGui.style.transition = "");
        }, i));
      }, r);
    });
  }
  onFlashCells(t) {
    if (!this.cellComp)
      return;
    const r = this.beans.cellPositionUtils.createId(this.getCellPosition());
    t.cells[r] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(t) {
    var r;
    return (r = this.callValueFormatter(t)) != null ? r : t;
  }
  callValueFormatter(t) {
    return this.beans.valueService.formatValue(this.column, this.rowNode, t);
  }
  updateAndFormatValue(t) {
    const r = this.value, i = this.valueFormatted;
    return this.value = this.rowNode.getValueFromValueService(this.column), this.valueFormatted = this.callValueFormatter(this.value), t ? !this.valuesAreEqual(r, this.value) || this.valueFormatted != i : !0;
  }
  valuesAreEqual(t, r) {
    const i = this.column.getColDef();
    return i.equals ? i.equals(t, r) : t === r;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  addDomData() {
    const t = this.getGui();
    this.beans.gos.setDomData(t, $b.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(() => this.beans.gos.setDomData(t, $b.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(t, r) {
    return this.beans.gos.addGridCommonParams({
      type: r,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      rowPinned: this.rowNode.rowPinned,
      event: t,
      rowIndex: this.rowNode.rowIndex
    });
  }
  processCharacter(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.processCharacter(t);
  }
  onKeyDown(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.onKeyDown(t);
  }
  onMouseEvent(t, r) {
    var i;
    (i = this.cellMouseListenerFeature) == null || i.onMouseEvent(t, r);
  }
  getGui() {
    return this.eGui;
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var t;
    this.cellComp && ((t = this.cellPositionFeature) == null || t.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { cellComp: t, column: r, beans: i } = this;
    Zm.refreshFirstAndLastStyles(t, r, i.columnModel);
  }
  refreshAriaColIndex() {
    const t = this.beans.columnModel.getAriaColumnIndex(this.column);
    jS(this.getGui(), t);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var t;
    return (t = this.cellPositionFeature) == null ? void 0 : t.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(t, r = null) {
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startRowOrCellEdit(t, r);
      });
      return;
    }
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(t, this) : this.startEditing(t, !0, r);
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onRangeSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(t = !1) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: t
    });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(wse, t);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(Sse, t);
  }
  onCellFocused(t) {
    if (this.beans.gos.get("suppressCellFocus"))
      return;
    const r = this.beans.focusService.isCellFocused(this.cellPosition);
    if (!this.cellComp) {
      r && (t != null && t.forceBrowserFocus) && (this.focusEventToRestore = t);
      return;
    }
    this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass(bse, r), r && t && t.forceBrowserFocus && this.cellComp.getFocusableElement().focus({ preventScroll: !!t.preventScrollOnBrowserFocus });
    const i = this.beans.gos.get("editType") === "fullRow";
    !r && !i && this.editing && this.stopRowOrCellEdit(), r && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: Nn(this.rowNode.rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(vse, !0), this.cellComp.addOrRemoveCssClass(Ese, !0);
    const t = this.column.isAutoHeight() == !0;
    this.cellComp.addOrRemoveCssClass(Cse, t), this.cellComp.addOrRemoveCssClass(yse, !t);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gos.get("columnHoverHighlight"))
      return;
    const t = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(xse, t);
  }
  onColDefChanged() {
    if (!this.cellComp)
      return;
    if (this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), !this.editing)
      this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 });
    else {
      const r = this.getCellEditor();
      if (r != null && r.refresh) {
        const { eventKey: i, cellStartedEdit: n } = this.editCompDetails.params, o = this.createCellEditorParams(i, n), s = this.column.getColDef(), a = this.beans.userComponentFactory.getCellEditorDetails(s, o);
        r.refresh(a.params);
      }
    }
  }
  setWrapText() {
    const t = this.column.getColDef().wrapText == !0;
    this.cellComp.addOrRemoveCssClass(Ase, t);
  }
  dispatchCellContextMenuEvent(t) {
    const r = this.column.getColDef(), i = this.createEvent(t, A.EVENT_CELL_CONTEXT_MENU);
    this.beans.eventService.dispatchEvent(i), r.onCellContextMenu && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        r.onCellContextMenu(i);
      });
    }, 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const t = new Ym();
    return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
  }
  createDndSource() {
    const t = new _N(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(t), t;
  }
  registerRowDragger(t, r, i) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(t, r);
      return;
    }
    const n = this.createRowDragComp(t, r, i);
    n && (this.customRowDragComp = n, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(n), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(t, r, i) {
    const n = this.beans.gos.get("pagination"), o = this.beans.gos.get("rowDragManaged"), s = this.beans.gos.isRowModelType("clientSide");
    if (o) {
      if (!s) {
        we("managed row dragging is only allowed in the Client Side Row Model");
        return;
      }
      if (n) {
        we("managed row dragging is not possible when doing pagination");
        return;
      }
    }
    const a = new ua(() => this.value, this.rowNode, this.column, t, r, i);
    return this.beans.context.createBean(a), a;
  }
};
NN.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var Xs = NN, Tse = 0, LN = class jb extends Q {
  constructor(t, r, i, n, o) {
    super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKeySanitised = null, this.beans = r, this.gos = r.gos, this.rowNode = t, this.paginationPage = r.paginationProxy.getCurrentPage(), this.useAnimationFrameForCreate = n, this.printLayout = o, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = t.id + "-" + Tse++, this.rowId = Yt(t.id), this.initRowBusinessKey(), this.rowFocused = r.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = r.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(i), this.rowStyles = this.processStylesFromGridOptions(), this.isFullWidth() && !this.gos.get("suppressCellFocus") && (this.tabIndex = -1), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const t = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = Yt(t);
  }
  getRowId() {
    return this.rowId;
  }
  getRowStyles() {
    return this.rowStyles;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setComp(t, r, i) {
    const n = { rowComp: t, element: r, containerType: i };
    this.allRowGuis.push(n), i === "left" ? this.leftGui = n : i === "right" ? this.rightGui = n : i === "fullWidth" ? this.fullWidthGui = n : this.centerGui = n, this.initialiseRowComp(n), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(t) {
    switch (this.allRowGuis = this.allRowGuis.filter((r) => r.containerType !== t), t) {
      case "left":
        this.leftGui = void 0;
        break;
      case "right":
        this.rightGui = void 0;
        break;
      case "fullWidth":
        this.fullWidthGui = void 0;
        break;
      case "center":
        this.centerGui = void 0;
        break;
    }
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(t) {
    const r = t ? "none" : "";
    this.allRowGuis.forEach((i) => i.element.style.display = r);
  }
  initialiseRowComp(t) {
    const r = this.gos;
    this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(!1, t), r.isRowSelection() && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const i = t.rowComp;
    this.getInitialRowClasses(t.containerType).forEach((o) => i.addOrRemoveCssClass(o, !0)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && So(t.element, this.rowNode.expanded == !0), this.setRowCompRowId(i), this.setRowCompRowBusinessKey(i), r.setDomData(t.element, jb.DOM_DATA_KEY_ROW_CTRL, this), this.addDestroyFunc(
      () => r.setDomData(t.element, jb.DOM_DATA_KEY_ROW_CTRL, null)
    ), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(
      this.addHoverFunctionality.bind(this, t.element),
      this.rowNode.rowIndex,
      "createTasksP2"
    ) : this.addHoverFunctionality(t.element), this.isFullWidth() && this.setupFullWidth(t), r.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(t) {
    this.businessKeySanitised != null && t.setRowBusinessKey(this.businessKeySanitised);
  }
  getBusinessKey() {
    return this.businessKeySanitised;
  }
  setRowCompRowId(t) {
    this.rowId = Yt(this.rowNode.id), this.rowId != null && t.setRowId(this.rowId);
  }
  executeSlideAndFadeAnimations(t) {
    const { containerType: r } = t;
    this.slideInAnimation[r] && (Pb(() => {
      this.onTopChanged();
    }), this.slideInAnimation[r] = !1), this.fadeInAnimation[r] && (Pb(() => {
      t.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[r] = !1);
  }
  addRowDraggerToRow(t) {
    if (this.gos.get("enableRangeSelection")) {
      we("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
      return;
    }
    const r = this.beans.localeService.getLocaleTextFunc(), i = new ua(
      () => `1 ${r("rowDragRow", "row")}`,
      this.rowNode,
      void 0,
      t.element,
      void 0,
      !0
    ), n = this.createBean(i, this.beans.context);
    this.rowDragComps.push(n);
  }
  setupFullWidth(t) {
    const r = this.getPinnedForContainer(t.containerType);
    if (this.rowType == "FullWidthDetail" && !Xe.__assertRegistered("@ag-grid-enterprise/master-detail", "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId()))
      return;
    const i = this.createFullWidthCompDetails(t.element, r);
    t.rowComp.showFullWidth(i);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderers() {
    var t, r;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((i) => {
      var n;
      return (n = i == null ? void 0 : i.rowComp) == null ? void 0 : n.getFullWidthCellRenderer();
    }) : [(r = (t = this.fullWidthGui) == null ? void 0 : t.rowComp) == null ? void 0 : r.getFullWidthCellRenderer()];
  }
  // use by autoWidthCalculator, as it clones the elements
  getCellElement(t) {
    const r = this.getCellCtrl(t);
    return r ? r.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    const t = this.gos.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady())
      return;
    const r = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    t(r);
  }
  areAllContainersReady() {
    const t = !!this.leftGui || !this.beans.columnModel.isPinningLeft(), r = !!this.centerGui, i = !!this.rightGui || !this.beans.columnModel.isPinningRight();
    return t && r && i;
  }
  setRowType() {
    const t = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow"), r = this.rowNode.isFullWidthCell(), i = this.gos.get("masterDetail") && this.rowNode.detail, n = this.beans.columnModel.isPivotMode(), s = !!this.rowNode.group && !this.rowNode.footer && this.gos.isGroupUseEntireRow(n);
    t ? this.rowType = "FullWidthLoading" : i ? this.rowType = "FullWidthDetail" : r ? this.rowType = "FullWidth" : s ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(t = !1, r = !1) {
    if (this.isFullWidth())
      return;
    if (t || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(r);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    ), this.updateColumnListsPending = !0);
  }
  createCellCtrls(t, r, i = null) {
    const n = {
      list: [],
      map: {}
    }, o = (s, a) => {
      n.list.push(a), n.map[s] = a;
    };
    return r.forEach((s) => {
      const a = s.getInstanceId();
      let l = t.map[a];
      l || (l = new Xs(s, this.rowNode, this.beans, this)), o(a, l);
    }), t.list.forEach((s) => {
      if (n.map[s.getColumn().getInstanceId()] != null)
        return;
      if (!this.isCellEligibleToBeRemoved(s, i)) {
        o(s.getColumn().getInstanceId(), s);
        return;
      }
      s.destroy();
    }), n;
  }
  updateColumnListsImpl(t) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(t);
  }
  setCellCtrls(t) {
    this.allRowGuis.forEach((r) => {
      const i = this.getCellCtrlsForContainer(r.containerType);
      r.rowComp.setCellCtrls(i, t);
    });
  }
  getCellCtrlsForContainer(t) {
    switch (t) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
      default:
        const r = t;
        throw new Error(`Unhandled case: ${r}`);
    }
  }
  createAllCellCtrls() {
    const t = this.beans.columnModel;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t.getAllDisplayedColumns()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const r = t.getViewportCenterColumnsForRow(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r);
      const i = t.getDisplayedLeftColumnsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const n = t.getDisplayedRightColumnsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, n, "right");
    }
  }
  isCellEligibleToBeRemoved(t, r) {
    if (t.getColumn().getPinned() != r)
      return !0;
    const s = t.isEditing(), a = this.beans.focusService.isCellFocused(t.getCellPosition());
    if (s || a) {
      const u = t.getColumn();
      return !(this.beans.columnModel.getAllDisplayedColumns().indexOf(u) >= 0);
    }
    return !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || this.gos.isDomLayout("print");
  }
  listenOnDomOrder(t) {
    const r = () => {
      t.rowComp.setDomOrder(this.getDomOrder());
    };
    this.addManagedPropertyListener("domLayout", r), this.addManagedPropertyListener("ensureDomOrder", r);
  }
  setAnimateFlags(t) {
    if (this.isSticky() || !t)
      return;
    const r = q(this.rowNode.oldRowTop), i = this.beans.columnModel.isPinningLeft(), n = this.beans.columnModel.isPinningRight();
    if (r) {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.slideInAnimation.fullWidth = !0;
        return;
      }
      this.slideInAnimation.center = !0, this.slideInAnimation.left = i, this.slideInAnimation.right = n;
    } else {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.fadeInAnimation.fullWidth = !0;
        return;
      }
      this.fadeInAnimation.center = !0, this.fadeInAnimation.left = i, this.fadeInAnimation.right = n;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const t = (a, l) => a ? a.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(a.element, l).params) : !0, r = t(this.fullWidthGui, null), i = t(this.centerGui, null), n = t(this.leftGui, "left"), o = t(this.rightGui, "right");
    return r && i && n && o;
  }
  addListeners() {
    this.addManagedListener(this.rowNode, Ve.EVENT_HEIGHT_CHANGED, () => this.onRowHeightChanged()), this.addManagedListener(this.rowNode, Ve.EVENT_ROW_SELECTED, () => this.onRowSelected()), this.addManagedListener(this.rowNode, Ve.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_TOP_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this)), this.rowNode.detail && this.addManagedListener(this.rowNode.parent, Ve.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, this.postProcessCss.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_DRAGGING_CHANGED, this.postProcessRowDragging.bind(this)), this.addManagedListener(this.rowNode, Ve.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
    const t = this.beans.eventService;
    this.addManagedListener(t, A.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this)), this.addManagedListener(t, A.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(t, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(t, A.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(t, A.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this)), this.addManagedListener(t, A.EVENT_CELL_FOCUS_CLEARED, this.onCellFocusChanged.bind(this)), this.addManagedListener(t, A.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), this.addManagedListener(t, A.EVENT_MODEL_UPDATED, this.refreshFirstAndLastRowStyles.bind(this)), this.addManagedListener(t, A.EVENT_COLUMN_MOVED, this.updateColumnLists.bind(this)), this.addDestroyFunc(() => {
      this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context));
    }), this.addManagedPropertyListeners(["rowDragEntireRow"], () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((i) => {
          this.addRowDraggerToRow(i);
        });
        return;
      }
      this.destroyBeans(this.rowDragComps, this.beans.context), this.rowDragComps = [];
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListener(this.rowNode, Ve.EVENT_ROW_INDEX_CHANGED, () => {
      this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged());
    }), this.addManagedListener(this.rowNode, Ve.EVENT_CELL_CHANGED, (t) => {
      this.getAllCellCtrls().forEach((r) => r.onCellChanged(t));
    });
  }
  onRowNodeDataChanged(t) {
    if (this.isFullWidth() !== !!this.rowNode.isFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (i) => i.refreshCell({
        suppressFlash: !t.update,
        newData: !t.update
      })
    ), this.allRowGuis.forEach((i) => {
      this.setRowCompRowId(i.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(i.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const t = this.rowNode.highlighted;
    this.allRowGuis.forEach((r) => {
      const i = t === 0, n = t === 1;
      r.rowComp.addOrRemoveCssClass("ag-row-highlight-above", i), r.rowComp.addOrRemoveCssClass("ag-row-highlight-below", n);
    });
  }
  postProcessRowDragging() {
    const t = this.rowNode.dragging;
    this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass("ag-row-dragging", t));
  }
  updateExpandedCss() {
    const t = this.rowNode.isExpandable(), r = this.rowNode.expanded == !0;
    this.allRowGuis.forEach((i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-group", t), i.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && r), i.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !r), So(i.element, t && r);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: Nn(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(t) {
    const r = this.allRowGuis.find((l) => l.element.contains(t.target));
    if (!((r ? r.element : null) === t.target))
      return;
    const o = this.rowNode, s = this.beans.focusService.getFocusedCell(), a = {
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: s && s.column
    };
    this.beans.navigationService.navigateToNextCell(t, t.key, a, !0), t.preventDefault();
  }
  onTabKeyDown(t) {
    if (t.defaultPrevented || hn(t))
      return;
    const r = this.allRowGuis.find((s) => s.element.contains(t.target)), i = r ? r.element : null, n = i === t.target;
    let o = null;
    n || (o = this.beans.focusService.findNextFocusableElement(i, !1, t.shiftKey)), (this.isFullWidth() && n || !o) && this.beans.navigationService.onTabKeyDown(this, t);
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var t;
    const r = (t = this.allRowGuis.find((i) => ii(i.element))) == null ? void 0 : t.element;
    return r ? r.getBoundingClientRect().top : 0;
  }
  onFullWidthRowFocused(t) {
    var r;
    const i = this.rowNode, n = t ? this.isFullWidth() && t.rowIndex === i.rowIndex && t.rowPinned == i.rowPinned : !1, o = this.fullWidthGui ? this.fullWidthGui.element : (r = this.centerGui) == null ? void 0 : r.element;
    o && (o.classList.toggle("ag-full-width-focus", n), n && o.focus({ preventScroll: !0 }));
  }
  recreateCell(t) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), t.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(t, r) {
    const i = {
      list: [],
      map: {}
    };
    return t.list.forEach((n) => {
      n !== r && (i.list.push(n), i.map[n.getColumn().getInstanceId()] = n);
    }), i;
  }
  onMouseEvent(t, r) {
    switch (t) {
      case "dblclick":
        this.onRowDblClick(r);
        break;
      case "click":
        this.onRowClick(r);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(r);
        break;
    }
  }
  createRowEvent(t, r) {
    return this.gos.addGridCommonParams({
      type: t,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      event: r
    });
  }
  createRowEventWithSource(t, r) {
    const i = this.createRowEvent(t, r);
    return i.source = this, i;
  }
  onRowDblClick(t) {
    if (hn(t))
      return;
    const r = this.createRowEventWithSource(A.EVENT_ROW_DOUBLE_CLICKED, t);
    this.beans.eventService.dispatchEvent(r);
  }
  onRowMouseDown(t) {
    if (this.lastMouseDownOnDragger = Us(t.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const r = this.rowNode, i = this.beans.columnModel;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges(), this.beans.focusService.setFocusedCell({
      rowIndex: r.rowIndex,
      column: i.getAllDisplayedColumns()[0],
      rowPinned: r.rowPinned,
      forceBrowserFocus: !0
    });
  }
  onRowClick(t) {
    if (hn(t) || this.lastMouseDownOnDragger)
      return;
    const i = this.createRowEventWithSource(A.EVENT_ROW_CLICKED, t);
    this.beans.eventService.dispatchEvent(i);
    const n = t.ctrlKey || t.metaKey, o = t.shiftKey;
    if (
      // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
      // so return if it's a group row
      this.gos.get("groupSelectsChildren") && this.rowNode.group || this.isRowSelectionBlocked() || // if click selection suppressed, do nothing
      this.gos.get("suppressRowClickSelection")
    )
      return;
    const a = this.gos.get("rowMultiSelectWithClick"), l = !this.gos.get("suppressRowDeselection"), u = "rowClicked";
    if (this.rowNode.isSelected())
      a ? this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : n ? l && this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : this.rowNode.setSelectedParams({ newValue: !0, clearSelection: !o, rangeSelect: o, event: t, source: u });
    else {
      const c = a ? !1 : !n;
      this.rowNode.setSelectedParams({ newValue: !0, clearSelection: c, rangeSelect: o, event: t, source: u });
    }
  }
  isRowSelectionBlocked() {
    return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection();
  }
  setupDetailRowAutoHeight(t) {
    if (this.rowType !== "FullWidthDetail" || !this.gos.get("detailRowAutoHeight"))
      return;
    const r = () => {
      const n = t.clientHeight;
      if (n != null && n > 0) {
        const o = () => {
          this.rowNode.setRowHeight(n), this.beans.clientSideRowModel ? this.beans.clientSideRowModel.onRowHeightChanged() : this.beans.serverSideRowModel && this.beans.serverSideRowModel.onRowHeightChanged();
        };
        window.setTimeout(o, 0);
      }
    }, i = this.beans.resizeObserverService.observeResize(t, r);
    this.addDestroyFunc(i), r();
  }
  createFullWidthCompDetails(t, r) {
    const i = this.gos.addGridCommonParams({
      fullWidth: !0,
      data: this.rowNode.data,
      node: this.rowNode,
      value: this.rowNode.key,
      valueFormatted: this.rowNode.key,
      rowIndex: this.rowNode.rowIndex,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: t,
      eParentOfValue: t,
      pinned: r,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (n, o, s, a) => this.addFullWidthRowDragging(n, o, s, a),
      setTooltip: (n, o) => this.refreshRowTooltip(n, o)
    });
    switch (this.rowType) {
      case "FullWidthDetail":
        return this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(i);
      case "FullWidthGroup":
        return this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(i);
      case "FullWidthLoading":
        return this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(i);
      default:
        return this.beans.userComponentFactory.getFullWidthCellRendererDetails(i);
    }
  }
  refreshRowTooltip(t, r) {
    if (!this.fullWidthGui)
      return;
    const i = {
      getGui: () => this.fullWidthGui.element,
      getTooltipValue: () => t,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: r
    };
    this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new Mo(i, this.beans));
  }
  addFullWidthRowDragging(t, r, i = "", n) {
    if (!this.isFullWidth())
      return;
    const o = new ua(() => i, this.rowNode, void 0, t, r, n);
    this.createBean(o, this.beans.context), this.addDestroyFunc(() => {
      this.destroyBean(o, this.beans.context);
    });
  }
  onUiLevelChanged() {
    const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != t) {
      const r = "ag-row-level-" + t, i = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((n) => {
        n.rowComp.addOrRemoveCssClass(r, !0), n.rowComp.addOrRemoveCssClass(i, !1);
      });
    }
    this.rowLevel = t;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const t = this.isFirstRowOnPage(), r = this.isLastRowOnPage();
    this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-first", t))), this.lastRowOnPage !== r && (this.lastRowOnPage = r, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-last", r)));
  }
  stopEditing(t = !1) {
    if (this.stoppingRowEdit)
      return;
    const r = this.getAllCellCtrls(), i = this.editingRow;
    this.stoppingRowEdit = !0;
    let n = !1;
    for (const o of r) {
      const s = o.stopEditing(t);
      i && !t && !n && s && (n = !0);
    }
    if (n) {
      const o = this.createRowEvent(A.EVENT_ROW_VALUE_CHANGED);
      this.beans.eventService.dispatchEvent(o);
    }
    i && this.setEditingRow(!1), this.stoppingRowEdit = !1;
  }
  setInlineEditingCss(t) {
    this.allRowGuis.forEach((r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), r.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  setEditingRow(t) {
    this.editingRow = t, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const r = t ? this.createRowEvent(A.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(A.EVENT_ROW_EDITING_STOPPED);
    this.beans.eventService.dispatchEvent(r);
  }
  startRowEditing(t = null, r = null, i = null) {
    if (this.editingRow)
      return;
    this.getAllCellCtrls().reduce((o, s) => {
      const a = s === r;
      return a ? s.startEditing(t, a, i) : s.startEditing(null, a, i), o ? !0 : s.isEditing();
    }, !1) && this.setEditingRow(!0);
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !t || !t.length || t.forEach((r) => {
      this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(r, !0));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !1));
      }
    );
  }
  setStylesFromGridOptions(t, r) {
    t && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(r, (i) => i.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(t) {
    return t === "left" ? "left" : t === "right" ? "right" : null;
  }
  getInitialRowClasses(t) {
    const r = this.getPinnedForContainer(t), i = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[t],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned: r
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(i);
  }
  processStylesFromGridOptions() {
    const t = this.gos.get("rowStyle");
    if (t && typeof t == "function") {
      console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const r = this.gos.getCallback("getRowStyle");
    let i;
    if (r) {
      const n = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      i = r(n);
    }
    return i || t ? Object.assign({}, t, i) : this.emptyStyle;
  }
  onRowSelected(t) {
    const r = !!this.rowNode.isSelected();
    this.forEachGui(t, (i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-selected", r), Zl(i.element, r), i.element.contains(this.beans.gos.getActiveDomElement()) && (i === this.centerGui || i === this.fullWidthGui) && this.announceDescription();
    });
  }
  announceDescription() {
    if (this.isRowSelectionBlocked())
      return;
    const t = this.rowNode.isSelected();
    if (t && this.beans.gos.get("suppressRowDeselection"))
      return;
    const i = this.beans.localeService.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row.`
    );
    this.beans.ariaAnnouncementService.announceValue(i);
  }
  addHoverFunctionality(t) {
    this.active && (this.addManagedListener(t, "mouseenter", () => this.rowNode.onMouseEnter()), this.addManagedListener(t, "mouseleave", () => this.rowNode.onMouseLeave()), this.addManagedListener(this.rowNode, Ve.EVENT_MOUSE_ENTER, () => {
      !this.beans.dragService.isDragging() && !this.gos.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), this.rowNode.setHovered(!0));
    }), this.addManagedListener(this.rowNode, Ve.EVENT_MOUSE_LEAVE, () => {
      t.classList.remove("ag-row-hover"), this.rowNode.setHovered(!1);
    }));
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(t) {
    const r = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(), i = this.applyPaginationOffset(r.top, !0) - 100, n = this.applyPaginationOffset(r.bottom, !0) + 100;
    return Math.min(Math.max(i, t), n);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(t, r) {
    t ? r(t) : this.allRowGuis.forEach(r);
  }
  onRowHeightChanged(t) {
    if (this.rowNode.rowHeight == null)
      return;
    const r = this.rowNode.rowHeight, i = this.beans.environment.getDefaultRowHeight(), o = this.gos.isGetRowHeightFunction() ? this.gos.getRowHeightForNode(this.rowNode).height : void 0, s = o ? `${Math.min(i, o) - 2}px` : void 0;
    this.forEachGui(t, (a) => {
      a.element.style.height = `${r}px`, s && a.element.style.setProperty("--ag-line-height", s);
    });
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(t = !1) {
    if (this.active = !1, !t && this.gos.isAnimateRows() && !this.isSticky())
      if (this.rowNode.rowTop != null) {
        const n = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(n);
      } else
        this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
    this.rowNode.setHovered(!1);
    const r = this.createRowEvent(A.EVENT_VIRTUAL_ROW_REMOVED);
    this.dispatchEvent(r), this.beans.eventService.dispatchEvent(r), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0, this.stopEditing();
    const t = (r) => (r.list.forEach((i) => i.destroy()), { list: [], map: {} });
    this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
  }
  setFocusedClasses(t) {
    this.forEachGui(t, (r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), r.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
  }
  onPaginationChanged() {
    const t = this.beans.paginationProxy.getCurrentPage();
    this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(t, r = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return t;
    const i = this.beans.paginationProxy.getPixelOffset();
    return t + i * (r ? 1 : -1);
  }
  setRowTop(t) {
    if (!this.printLayout && q(t)) {
      const r = this.applyPaginationOffset(t), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(t) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0;
  }
  getInitialTransform(t) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(t)})`;
  }
  getInitialRowTopShared(t) {
    if (this.printLayout)
      return "";
    let r;
    if (this.isSticky())
      r = this.rowNode.stickyRowTop;
    else {
      const i = this.slideInAnimation[t] ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop, n = this.applyPaginationOffset(i);
      r = this.rowNode.isRowPinned() ? n : this.beans.rowContainerHeightService.getRealPixelPosition(n);
    }
    return r + "px";
  }
  setRowTopStyle(t) {
    this.allRowGuis.forEach(
      (r) => this.suppressRowTransform ? r.rowComp.setTop(t) : r.rowComp.setTransform(`translateY(${t})`)
    );
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(t) {
    let r = null;
    return this.getAllCellCtrls().forEach((i) => {
      i.getColumn() == t && (r = i);
    }), r != null || this.getAllCellCtrls().forEach((i) => {
      i.getColSpanningList().indexOf(t) >= 0 && (r = i);
    }), r;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  getRowIndex() {
    return this.rowNode.getRowIndexString();
  }
  updateRowIndexes(t) {
    const r = this.rowNode.getRowIndexString(), i = this.beans.headerNavigationService.getHeaderRowCount() + this.beans.filterManager.getHeaderRowCount(), n = this.rowNode.rowIndex % 2 === 0, o = i + this.rowNode.rowIndex + 1;
    this.forEachGui(t, (s) => {
      s.rowComp.setRowIndex(r), s.rowComp.addOrRemoveCssClass("ag-row-even", n), s.rowComp.addOrRemoveCssClass("ag-row-odd", !n), $S(s.element, o);
    });
  }
};
LN.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var Ks = LN, si = class extends Q {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedListener(this.element, e, t);
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", kS("touchstart") ? "touchstart" : "mousedown"].forEach((r) => {
      const i = this.processMouseEvent.bind(this, r);
      this.addManagedListener(this.element, r, i);
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || hn(t))
      return;
    const r = this.getRowForEvent(t), i = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, void 0, r, i) : (i && i.onMouseEvent(e, t), r && r.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!Oo())
      return;
    const e = new mr(this.element), t = (r) => {
      const i = this.getRowForEvent(r.touchEvent), n = this.mouseEventService.getRenderedCellForEvent(r.touchEvent);
      this.handleContextMenuMouseEvent(void 0, r.touchEvent, i, n);
    };
    this.addManagedListener(e, mr.EVENT_LONG_TAP, t), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const r = this.gos.getDomData(t, Ks.DOM_DATA_KEY_ROW_CTRL);
      if (r)
        return r;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, r, i) {
    const n = r ? r.getRowNode() : null, o = i ? i.getColumn() : null;
    let s = null;
    if (o) {
      const u = e || t;
      i.dispatchCellContextMenuEvent(u ?? null), s = this.valueService.getValue(o, n);
    }
    const a = this.ctrlsService.getGridBodyCtrl(), l = i ? i.getGui() : a.getGridBodyElement();
    this.menuService.showContextMenu({ mouseEvent: e, touchEvent: t, rowNode: n, column: o, value: s, anchorToElement: l });
  }
  getControlsForEventTarget(e) {
    return {
      cellCtrl: og(this.gos, e, Xs.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: og(this.gos, e, Ks.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: r, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (r ? this.processCellKeyboardEvent(r, e, t) : i && i.isFullWidth() && this.processFullWidthRowKeyboardEvent(i, e, t));
  }
  processCellKeyboardEvent(e, t, r) {
    const i = e.getRowNode(), n = e.getColumn(), o = e.isEditing();
    if (!ug(this.gos, r, i, n, o) && t === "keydown" && (!o && this.navigationService.handlePageScrollingKey(r) || e.onKeyDown(r), this.doGridOperations(r, e.isEditing()), Vm(r) && e.processCharacter(r)), t === "keydown") {
      const a = e.createEvent(r, A.EVENT_CELL_KEY_DOWN);
      this.eventService.dispatchEvent(a);
    }
  }
  processFullWidthRowKeyboardEvent(e, t, r) {
    const i = e.getRowNode(), n = this.focusService.getFocusedCell(), o = n && n.column;
    if (!ug(this.gos, r, i, o, !1)) {
      const a = r.key;
      if (t === "keydown")
        switch (a) {
          case k.PAGE_HOME:
          case k.PAGE_END:
          case k.PAGE_UP:
          case k.PAGE_DOWN:
            this.navigationService.handlePageScrollingKey(r, !0);
            break;
          case k.UP:
          case k.DOWN:
            e.onKeyboardNavigate(r);
            break;
          case k.TAB:
            e.onTabKeyDown(r);
            break;
        }
    }
    if (t === "keydown") {
      const a = e.createRowEvent(A.EVENT_CELL_KEY_DOWN, r);
      this.eventService.dispatchEvent(a);
    }
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e))
      return;
    const r = k_(e);
    if (r === k.A)
      return this.onCtrlAndA(e);
    if (r === k.C)
      return this.onCtrlAndC(e);
    if (r === k.D)
      return this.onCtrlAndD(e);
    if (r === k.V)
      return this.onCtrlAndV(e);
    if (r === k.X)
      return this.onCtrlAndX(e);
    if (r === k.Y)
      return this.onCtrlAndY();
    if (r === k.Z)
      return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, paginationProxy: r, rangeService: i } = this;
    if (i && r.isRowsToRender()) {
      const [n, o] = [
        t.isEmpty("top"),
        t.isEmpty("bottom")
      ], s = n ? null : "top";
      let a, l;
      o ? (a = null, l = this.paginationProxy.getRowCount() - 1) : (a = "bottom", l = t.getPinnedBottomRowData().length - 1);
      const u = this.columnModel.getAllDisplayedColumns();
      if (Ni(u))
        return;
      i.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: s,
        rowEndIndex: l,
        rowEndPinned: a,
        columnStart: u[0],
        columnEnd: ze(u)
      });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    this.gos.get("undoRedoCellEditing") && (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    this.undoRedoService.redo("ui");
  }
};
v([
  T("mouseEventService")
], si.prototype, "mouseEventService", 2);
v([
  T("valueService")
], si.prototype, "valueService", 2);
v([
  T("menuService")
], si.prototype, "menuService", 2);
v([
  T("ctrlsService")
], si.prototype, "ctrlsService", 2);
v([
  T("navigationService")
], si.prototype, "navigationService", 2);
v([
  T("focusService")
], si.prototype, "focusService", 2);
v([
  T("undoRedoService")
], si.prototype, "undoRedoService", 2);
v([
  T("columnModel")
], si.prototype, "columnModel", 2);
v([
  T("paginationProxy")
], si.prototype, "paginationProxy", 2);
v([
  T("pinnedRowModel")
], si.prototype, "pinnedRowModel", 2);
v([
  Qe("rangeService")
], si.prototype, "rangeService", 2);
v([
  Qe("clipboardService")
], si.prototype, "clipboardService", 2);
v([
  te
], si.prototype, "postConstruct", 1);
var Hu = class extends Q {
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedListener(this.eventService, A.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this)), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const e = () => this.onCenterViewportResized();
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
      this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnModel.refreshFlexedColumns(
        { viewportWidth: this.centerWidth, updateBodyWidths: !0, fireResizedEvent: !0 }
      ));
    } else
      this.bodyHeight = 0;
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = Ma(e);
    if (t <= 50)
      return;
    let r = this.getPinnedColumnsOverflowingViewport(t - 50);
    const i = this.gos.getCallback("processUnpinnedColumns");
    r.length && (i && (r = i({
      columns: r,
      viewportWidth: t
    })), this.columnModel.setColumnsPinned(r, null, "viewportSizeFeature"));
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.pinnedWidthService.getPinnedRightWidth(), r = this.pinnedWidthService.getPinnedLeftWidth(), i = t + r;
    if (i < e)
      return [];
    const n = [...this.columnModel.getDisplayedLeftColumns()], o = [...this.columnModel.getDisplayedRightColumns()];
    let s = 0, a = 0, l = 0;
    const u = [];
    let c = i - l - e;
    for (; (a < n.length || s < o.length) && c > 0; ) {
      if (s < o.length) {
        const d = o[s++];
        c -= d.getActualWidth(), u.push(d);
      }
      if (a < n.length && c > 0) {
        const d = n[a++];
        c -= d.getActualWidth(), u.push(d);
      }
    }
    return u;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = yh(e);
    if (this.bodyHeight !== t) {
      this.bodyHeight = t;
      const r = {
        type: A.EVENT_BODY_HEIGHT_CHANGED
      };
      this.eventService.dispatchEvent(r);
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnModel.setViewportPosition(e, t);
  }
};
v([
  T("ctrlsService")
], Hu.prototype, "ctrlsService", 2);
v([
  T("pinnedWidthService")
], Hu.prototype, "pinnedWidthService", 2);
v([
  T("columnModel")
], Hu.prototype, "columnModel", 2);
v([
  T("scrollVisibleService")
], Hu.prototype, "scrollVisibleService", 2);
v([
  te
], Hu.prototype, "postConstruct", 1);
var SE = class extends Q {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    We(this.element, t), Wi(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
};
v([
  T("pinnedWidthService")
], SE.prototype, "pinnedWidthService", 2);
v([
  te
], SE.prototype, "postConstruct", 1);
var EE = class extends Q {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    We(this.element, t), Wi(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
};
v([
  T("pinnedWidthService")
], EE.prototype, "pinnedWidthService", 2);
v([
  te
], EE.prototype, "postConstruct", 1);
var Jm = class extends Q {
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t);
  }
};
v([
  T("rowContainerHeightService")
], Jm.prototype, "maxDivHeightScaler", 2);
v([
  te
], Jm.prototype, "postConstruct", 1);
var Qm = class extends Q {
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.rangeService)
      return;
    this.params = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    }, this.addManagedPropertyListener("enableRangeSelection", (t) => {
      if (t.currentValue) {
        this.enableFeature();
        return;
      }
      this.disableFeature();
    }), this.addDestroyFunc(() => this.disableFeature()), this.gos.get("enableRangeSelection") && this.enableFeature();
  }
  enableFeature() {
    this.dragService.addDragSource(this.params);
  }
  disableFeature() {
    this.dragService.removeDragSource(this.params);
  }
};
v([
  T("dragService")
], Qm.prototype, "dragService", 2);
v([
  Qe("rangeService")
], Qm.prototype, "rangeService", 2);
v([
  te
], Qm.prototype, "postConstruct", 1);
var Bu = class extends Q {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedListener(this.eventService, A.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_LEFT_PINNED_WIDTH_CHANGED, e), this.addSpacer && (this.addManagedListener(this.eventService, A.EVENT_RIGHT_PINNED_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_SCROLL_VISIBILITY_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_SCROLLBAR_WIDTH_CHANGED, e)), this.setWidth();
  }
  setWidth() {
    const { columnModel: e } = this, t = this.gos.isDomLayout("print"), r = e.getBodyContainerWidth(), i = e.getDisplayedColumnsLeftWidth(), n = e.getDisplayedColumnsRightWidth();
    let o;
    t ? o = r + i + n : (o = r, this.addSpacer && (this.gos.get("enableRtl") ? i : n) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (o += this.gos.getScrollbarWidth())), this.callback(o);
  }
};
v([
  T("columnModel")
], Bu.prototype, "columnModel", 2);
v([
  T("scrollVisibleService")
], Bu.prototype, "scrollVisibleService", 2);
v([
  te
], Bu.prototype, "postConstruct", 1);
var St = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e.CENTER = "center", e.FULL_WIDTH = "fullWidth", e.TOP_LEFT = "topLeft", e.TOP_RIGHT = "topRight", e.TOP_CENTER = "topCenter", e.TOP_FULL_WIDTH = "topFullWidth", e.STICKY_TOP_LEFT = "stickyTopLeft", e.STICKY_TOP_RIGHT = "stickyTopRight", e.STICKY_TOP_CENTER = "stickyTopCenter", e.STICKY_TOP_FULL_WIDTH = "stickyTopFullWidth", e.STICKY_BOTTOM_LEFT = "stickyBottomLeft", e.STICKY_BOTTOM_RIGHT = "stickyBottomRight", e.STICKY_BOTTOM_CENTER = "stickyBottomCenter", e.STICKY_BOTTOM_FULL_WIDTH = "stickyBottomFullWidth", e.BOTTOM_LEFT = "bottomLeft", e.BOTTOM_RIGHT = "bottomRight", e.BOTTOM_CENTER = "bottomCenter", e.BOTTOM_FULL_WIDTH = "bottomFullWidth", e))(St || {});
function GN(e) {
  switch (e) {
    case "center":
    case "topCenter":
    case "stickyTopCenter":
    case "bottomCenter":
    case "stickyBottomCenter":
      return "center";
    case "left":
    case "topLeft":
    case "stickyTopLeft":
    case "bottomLeft":
    case "stickyBottomLeft":
      return "left";
    case "right":
    case "topRight":
    case "stickyTopRight":
    case "bottomRight":
    case "stickyBottomRight":
      return "right";
    case "fullWidth":
    case "topFullWidth":
    case "stickyTopFullWidth":
    case "bottomFullWidth":
    case "stickyBottomFullWidth":
      return "fullWidth";
    default:
      throw Error("Invalid Row Container Type");
  }
}
var Rse = Wo([
  ["center", "ag-center-cols-container"],
  ["left", "ag-pinned-left-cols-container"],
  ["right", "ag-pinned-right-cols-container"],
  ["fullWidth", "ag-full-width-container"],
  ["topCenter", "ag-floating-top-container"],
  ["topLeft", "ag-pinned-left-floating-top"],
  ["topRight", "ag-pinned-right-floating-top"],
  ["topFullWidth", "ag-floating-top-full-width-container"],
  ["stickyTopCenter", "ag-sticky-top-container"],
  ["stickyTopLeft", "ag-pinned-left-sticky-top"],
  ["stickyTopRight", "ag-pinned-right-sticky-top"],
  ["stickyTopFullWidth", "ag-sticky-top-full-width-container"],
  ["stickyBottomCenter", "ag-sticky-bottom-container"],
  ["stickyBottomLeft", "ag-pinned-left-sticky-bottom"],
  ["stickyBottomRight", "ag-pinned-right-sticky-bottom"],
  ["stickyBottomFullWidth", "ag-sticky-bottom-full-width-container"],
  ["bottomCenter", "ag-floating-bottom-container"],
  ["bottomLeft", "ag-pinned-left-floating-bottom"],
  ["bottomRight", "ag-pinned-right-floating-bottom"],
  ["bottomFullWidth", "ag-floating-bottom-full-width-container"]
]), Pse = Wo([
  ["center", "ag-center-cols-viewport"],
  ["topCenter", "ag-floating-top-viewport"],
  ["stickyTopCenter", "ag-sticky-top-viewport"],
  ["bottomCenter", "ag-floating-bottom-viewport"],
  ["stickyBottomCenter", "ag-sticky-bottom-viewport"]
]), Va = class kN extends Q {
  constructor(t) {
    super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = t, this.isFullWithContainer = this.name === "topFullWidth" || this.name === "stickyTopFullWidth" || this.name === "stickyBottomFullWidth" || this.name === "bottomFullWidth" || this.name === "fullWidth";
  }
  static getRowContainerCssClasses(t) {
    const r = Rse.get(t), i = Pse.get(t);
    return { container: r, viewport: i };
  }
  static getPinned(t) {
    switch (t) {
      case "bottomLeft":
      case "topLeft":
      case "stickyTopLeft":
      case "stickyBottomLeft":
      case "left":
        return "left";
      case "bottomRight":
      case "topRight":
      case "stickyTopRight":
      case "stickyBottomRight":
      case "right":
        return "right";
      default:
        return null;
    }
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(
      [
        "center"
        /* CENTER */
      ],
      () => this.viewportSizeFeature = this.createManagedBean(new Hu(this))
    );
  }
  registerWithCtrlsService() {
    switch (this.name) {
      case "fullWidth":
      case "topFullWidth":
      case "stickyTopFullWidth":
      case "bottomFullWidth":
      case "stickyBottomFullWidth":
        return;
      default:
        this.ctrlsService.register(this.name, this);
    }
  }
  forContainers(t, r) {
    t.indexOf(this.name) >= 0 && r();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(t, r, i) {
    this.comp = t, this.eContainer = r, this.eViewport = i, this.createManagedBean(new si(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows();
    const n = [
      "topCenter",
      "topLeft",
      "topRight"
      /* TOP_RIGHT */
    ], o = [
      "stickyTopCenter",
      "stickyTopLeft",
      "stickyTopRight"
      /* STICKY_TOP_RIGHT */
    ], s = [
      "stickyBottomCenter",
      "stickyBottomLeft",
      "stickyBottomRight"
      /* STICKY_BOTTOM_RIGHT */
    ], a = [
      "bottomCenter",
      "bottomLeft",
      "bottomRight"
      /* BOTTOM_RIGHT */
    ], l = [
      "center",
      "left",
      "right"
      /* RIGHT */
    ], u = [...n, ...a, ...l, ...o, ...s], c = [
      "center",
      "left",
      "right",
      "fullWidth"
      /* FULL_WIDTH */
    ], d = [
      "center",
      "topCenter",
      "stickyTopCenter",
      "bottomCenter",
      "stickyBottomCenter"
      /* STICKY_BOTTOM_CENTER */
    ], h = [
      "left",
      "bottomLeft",
      "topLeft",
      "stickyTopLeft",
      "stickyBottomLeft"
      /* STICKY_BOTTOM_LEFT */
    ], p = [
      "right",
      "bottomRight",
      "topRight",
      "stickyTopRight",
      "stickyBottomRight"
      /* STICKY_BOTTOM_RIGHT */
    ];
    this.forContainers(h, () => {
      this.pinnedWidthFeature = this.createManagedBean(new SE(this.eContainer)), this.addManagedListener(this.eventService, A.EVENT_LEFT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    }), this.forContainers(p, () => {
      this.pinnedWidthFeature = this.createManagedBean(new EE(this.eContainer)), this.addManagedListener(this.eventService, A.EVENT_RIGHT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    }), this.forContainers(c, () => this.createManagedBean(new Jm(this.eContainer, this.name === "center" ? i : void 0))), this.forContainers(u, () => this.createManagedBean(new Qm(this.eContainer))), this.forContainers(d, () => this.createManagedBean(
      new Bu((g) => this.comp.setContainerWidth(`${g}px`))
    )), this.addListeners(), this.registerWithCtrlsService();
  }
  addListeners() {
    this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, () => this.onDisplayedColumnsChanged()), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => this.onDisplayedColumnsWidthChanged()), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_ROWS_CHANGED, (t) => this.onDisplayedRowsChanged(t.afterScroll)), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if ([
      "stickyTopCenter",
      "stickyTopLeft",
      "stickyTopRight",
      "stickyTopFullWidth",
      "stickyBottomCenter",
      "stickyBottomLeft",
      "stickyBottomRight",
      "stickyBottomFullWidth"
      /* STICKY_BOTTOM_FULL_WIDTH */
    ].indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const i = () => {
      const n = this.gos.get("ensureDomOrder"), o = this.gos.isDomLayout("print");
      this.comp.setDomOrder(n || o);
    };
    this.addManagedPropertyListener("domLayout", i), i();
  }
  // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
  // scroll the column into view. we do not want this, the pinned sections should never scroll.
  // so we listen to scrolls on these containers and reset the scroll if we find one.
  stopHScrollOnPinnedRows() {
    this.forContainers([
      "topCenter",
      "stickyTopCenter",
      "bottomCenter",
      "stickyBottomCenter"
      /* STICKY_BOTTOM_CENTER */
    ], () => {
      const t = () => this.eViewport.scrollLeft = 0;
      this.addManagedListener(this.eViewport, "scroll", t);
    });
  }
  onDisplayedColumnsChanged() {
    this.forContainers([
      "center"
      /* CENTER */
    ], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers([
      "center"
      /* CENTER */
    ], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const t = (r) => {
      this.dragService.isDragging() && r.cancelable && r.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", t, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", t));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(t = !1) {
    const r = this.getCenterWidth(), i = this.getCenterViewportScrollLeft();
    this.columnModel.setViewportPosition(r, i, t);
  }
  getCenterWidth() {
    return Ma(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return Fd(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(t) {
    const r = this.resizeObserverService.observeResize(this.eViewport, t);
    this.addDestroyFunc(() => r());
  }
  isViewportInTheDOMTree() {
    return rE(this.eViewport);
  }
  getViewportScrollLeft() {
    return Fd(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || R_(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setContainerTranslateX(t) {
    this.eContainer.style.transform = `translateX(${t}px)`;
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(t) {
    _d(this.eViewport, t, this.enableRtl);
  }
  isContainerVisible() {
    return !kN.getPinned(this.name) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const t = this.isContainerVisible();
    this.visible != t && (this.visible = t, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(t = !1) {
    const r = this.getRowCtrls();
    if (!this.visible || r.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const i = this.gos.isDomLayout("print"), o = this.gos.get("embedFullWidthRows") || i, s = r.filter((a) => {
      const l = a.isFullWidth();
      return this.isFullWithContainer ? !o && l : o || !l;
    });
    this.comp.setRowCtrls({ rowCtrls: s, useFlushSync: t });
  }
  getRowCtrls() {
    switch (this.name) {
      case "topCenter":
      case "topLeft":
      case "topRight":
      case "topFullWidth":
        return this.rowRenderer.getTopRowCtrls();
      case "stickyTopCenter":
      case "stickyTopLeft":
      case "stickyTopRight":
      case "stickyTopFullWidth":
        return this.rowRenderer.getStickyTopRowCtrls();
      case "stickyBottomCenter":
      case "stickyBottomLeft":
      case "stickyBottomRight":
      case "stickyBottomFullWidth":
        return this.rowRenderer.getStickyBottomRowCtrls();
      case "bottomCenter":
      case "bottomLeft":
      case "bottomRight":
      case "bottomFullWidth":
        return this.rowRenderer.getBottomRowCtrls();
      default:
        return this.rowRenderer.getCentreRowCtrls();
    }
  }
};
v([
  T("dragService")
], Va.prototype, "dragService", 2);
v([
  T("ctrlsService")
], Va.prototype, "ctrlsService", 2);
v([
  T("columnModel")
], Va.prototype, "columnModel", 2);
v([
  T("resizeObserverService")
], Va.prototype, "resizeObserverService", 2);
v([
  T("rowRenderer")
], Va.prototype, "rowRenderer", 2);
v([
  te
], Va.prototype, "postConstruct", 1);
var hg = Va, Ise = (
  /* html */
  `<div class="ag-root ag-unselectable" role="treegrid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="topLeft"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="topCenter"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="topRight"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="topFullWidth"></ag-row-container>
        </div>
        <div class="ag-body" ref="eBody" role="presentation">
            <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
                <ag-row-container ref="leftContainer" name="left"></ag-row-container>
                <ag-row-container ref="centerContainer" name="center"></ag-row-container>
                <ag-row-container ref="rightContainer" name="right"></ag-row-container>
                <ag-row-container ref="fullWidthContainer" name="fullWidth"></ag-row-container>
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" ref="eStickyTop" role="presentation">
            <ag-row-container ref="stickyTopLeftContainer" name="stickyTopLeft"></ag-row-container>
            <ag-row-container ref="stickyTopCenterContainer" name="stickyTopCenter"></ag-row-container>
            <ag-row-container ref="stickyTopRightContainer" name="stickyTopRight"></ag-row-container>
            <ag-row-container ref="stickyTopFullWidthContainer" name="stickyTopFullWidth"></ag-row-container>
        </div>
        <div class="ag-sticky-bottom" ref="eStickyBottom" role="presentation">
            <ag-row-container ref="stickyBottomLeftContainer" name="stickyBottomLeft"></ag-row-container>
            <ag-row-container ref="stickyBottomCenterContainer" name="stickyBottomCenter"></ag-row-container>
            <ag-row-container ref="stickyBottomRightContainer" name="stickyBottomRight"></ag-row-container>
            <ag-row-container ref="stickyBottomFullWidthContainer" name="stickyBottomFullWidth"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="bottomLeft"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="bottomCenter"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="bottomRight"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="bottomFullWidth"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`
), bn = class extends Oe {
  constructor() {
    super(Ise);
  }
  init() {
    const t = (i, n) => {
      const o = `${i}px`;
      n.style.minHeight = o, n.style.height = o;
    }, r = {
      setRowAnimationCssOnBodyViewport: (i, n) => this.setRowAnimationCssOnBodyViewport(i, n),
      setColumnCount: (i) => d_(this.getGui(), i),
      setRowCount: (i) => c_(this.getGui(), i),
      setTopHeight: (i) => t(i, this.eTop),
      setBottomHeight: (i) => t(i, this.eBottom),
      setTopDisplay: (i) => this.eTop.style.display = i,
      setBottomDisplay: (i) => this.eBottom.style.display = i,
      setStickyTopHeight: (i) => this.eStickyTop.style.height = i,
      setStickyTopTop: (i) => this.eStickyTop.style.top = i,
      setStickyTopWidth: (i) => this.eStickyTop.style.width = i,
      setStickyBottomHeight: (i) => this.eStickyBottom.style.height = i,
      setStickyBottomBottom: (i) => this.eStickyBottom.style.bottom = i,
      setStickyBottomWidth: (i) => this.eStickyBottom.style.width = i,
      setColumnMovingCss: (i, n) => this.addOrRemoveCssClass(i, n),
      updateLayoutClasses: (i, n) => {
        [
          this.eBodyViewport.classList,
          this.eBody.classList
        ].forEach((s) => {
          s.toggle("ag-layout-auto-height", n.autoHeight), s.toggle("ag-layout-normal", n.normal), s.toggle("ag-layout-print", n.print);
        }), this.addOrRemoveCssClass("ag-layout-auto-height", n.autoHeight), this.addOrRemoveCssClass("ag-layout-normal", n.normal), this.addOrRemoveCssClass("ag-layout-print", n.print);
      },
      setAlwaysVerticalScrollClass: (i, n) => this.eBodyViewport.classList.toggle(FN, n),
      registerBodyViewportResizeListener: (i) => {
        const n = this.resizeObserverService.observeResize(this.eBodyViewport, i);
        this.addDestroyFunc(() => n());
      },
      setPinnedTopBottomOverflowY: (i) => this.eTop.style.overflowY = this.eBottom.style.overflowY = i,
      setCellSelectableCss: (i, n) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach((o) => o.classList.toggle(i, n));
      },
      setBodyViewportWidth: (i) => this.eBodyViewport.style.width = i
    };
    this.ctrl = this.createManagedBean(new Or()), this.ctrl.setComp(
      r,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    ), (this.rangeService && this.gos.get("enableRangeSelection") || this.gos.get("rowSelection") === "multiple") && u_(this.getGui(), !0);
  }
  setRowAnimationCssOnBodyViewport(t, r) {
    const i = this.eBodyViewport.classList;
    i.toggle("ag-row-animation", r), i.toggle("ag-row-no-animation", !r);
  }
  getFloatingTopBottom() {
    return [this.eTop, this.eBottom];
  }
};
v([
  T("resizeObserverService")
], bn.prototype, "resizeObserverService", 2);
v([
  Qe("rangeService")
], bn.prototype, "rangeService", 2);
v([
  ne("eBodyViewport")
], bn.prototype, "eBodyViewport", 2);
v([
  ne("eStickyTop")
], bn.prototype, "eStickyTop", 2);
v([
  ne("eStickyBottom")
], bn.prototype, "eStickyBottom", 2);
v([
  ne("eTop")
], bn.prototype, "eTop", 2);
v([
  ne("eBottom")
], bn.prototype, "eBottom", 2);
v([
  ne("gridHeader")
], bn.prototype, "headerRootComp", 2);
v([
  ne("eBody")
], bn.prototype, "eBody", 2);
v([
  te
], bn.prototype, "init", 1);
var eu = class extends Q {
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
  }
  onDisplayedColumnsChanged() {
    this.update();
  }
  onDisplayedColumnsWidthChanged() {
    this.update();
  }
  update() {
    this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
      this.columnAnimationService.executeLaterVMTurn(() => this.updateImpl());
    }) : this.updateImpl();
  }
  updateImpl() {
    const e = this.ctrlsService.get("center");
    if (!e || this.columnAnimationService.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(t);
  }
  setScrollsVisible(e) {
    if (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) {
      this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing;
      const r = {
        type: A.EVENT_SCROLL_VISIBILITY_CHANGED
      };
      this.eventService.dispatchEvent(r);
    }
  }
  // used by pagination service - to know page height
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  // used by header container
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
};
v([
  T("ctrlsService")
], eu.prototype, "ctrlsService", 2);
v([
  T("columnAnimationService")
], eu.prototype, "columnAnimationService", 2);
v([
  te
], eu.prototype, "postConstruct", 1);
eu = v([
  de("scrollVisibleService")
], eu);
var po = class extends Q {
  constructor() {
    super(...arguments), this.gridInstanceId = po.gridInstanceSequence.next();
  }
  // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
  // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
  // for where this is used.
  stampTopLevelGridCompWithGridInstance(e) {
    e[po.GRID_DOM_KEY] = this.gridInstanceId;
  }
  getRenderedCellForEvent(e) {
    return og(this.gos, e.target, Xs.DOM_DATA_KEY_CELL_CTRL);
  }
  // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
  // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
  // getting executed on many grids at the same time.
  isEventFromThisGrid(e) {
    return this.isElementInThisGrid(e.target);
  }
  isElementInThisGrid(e) {
    let t = e;
    for (; t; ) {
      const r = t[po.GRID_DOM_KEY];
      if (q(r))
        return r === this.gridInstanceId;
      t = t.parentElement;
    }
    return !1;
  }
  getCellPositionForEvent(e) {
    const t = this.getRenderedCellForEvent(e);
    return t ? t.getCellPosition() : null;
  }
  getNormalisedPosition(e) {
    const t = this.gos.isDomLayout("normal"), r = e;
    let i, n;
    if (r.clientX != null || r.clientY != null ? (i = r.clientX, n = r.clientY) : (i = r.x, n = r.y), t) {
      const o = this.ctrlsService.getGridBodyCtrl(), s = o.getScrollFeature().getVScrollPosition(), a = o.getScrollFeature().getHScrollPosition();
      i += a.left, n += s.top;
    }
    return { x: i, y: n };
  }
};
po.gridInstanceSequence = new Ql();
po.GRID_DOM_KEY = "__ag_grid_instance";
v([
  T("ctrlsService")
], po.prototype, "ctrlsService", 2);
po = v([
  de("mouseEventService")
], po);
var Pr = class extends Q {
  constructor() {
    super(), this.onPageDown = Ib(this.onPageDown, 100), this.onPageUp = Ib(this.onPageUp, 100);
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const r = e.key, i = e.altKey, n = e.ctrlKey || e.metaKey, o = !!this.rangeService && e.shiftKey, s = this.mouseEventService.getCellPositionForEvent(e);
    let a = !1;
    switch (r) {
      case k.PAGE_HOME:
      case k.PAGE_END:
        !n && !i && (this.onHomeOrEndKey(r), a = !0);
        break;
      case k.LEFT:
      case k.RIGHT:
      case k.UP:
      case k.DOWN:
        if (!s)
          return !1;
        n && !i && !o && (this.onCtrlUpDownLeftRight(r, s), a = !0);
        break;
      case k.PAGE_DOWN:
      case k.PAGE_UP:
        !n && !i && (a = this.handlePageUpDown(r, s, t));
        break;
    }
    return a && e.preventDefault(), a;
  }
  handlePageUpDown(e, t, r) {
    return r && (t = this.focusService.getFocusedCell()), t ? (e === k.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    var t;
    const { scrollIndex: r, scrollType: i, scrollColumn: n, focusIndex: o, focusColumn: s } = e;
    q(n) && !n.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(n), q(r) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(r, i), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(o), this.focusService.setFocusedCell({ rowIndex: o, column: s, rowPinned: null, forceBrowserFocus: !0 }), (t = this.rangeService) == null || t.setRangeToCell({ rowIndex: o, rowPinned: null, column: s });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), i = this.getViewportHeight(), n = this.paginationProxy.getPixelOffset(), o = r.top + i, s = this.paginationProxy.getRowIndexAtPixel(o + n);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, s) : this.navigateToNextPage(e, s);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), i = this.paginationProxy.getPixelOffset(), n = r.top, o = this.paginationProxy.getRowIndexAtPixel(n + i);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, o, !0) : this.navigateToNextPage(e, o, !0);
  }
  navigateToNextPage(e, t, r = !1) {
    const i = this.getViewportHeight(), n = this.paginationProxy.getPageFirstRow(), o = this.paginationProxy.getPageLastRow(), s = this.paginationProxy.getPixelOffset(), a = this.paginationProxy.getRow(e.rowIndex), l = r ? (a == null ? void 0 : a.rowHeight) - i - s : i - s, u = (a == null ? void 0 : a.rowTop) + l;
    let c = this.paginationProxy.getRowIndexAtPixel(u + s);
    if (c === e.rowIndex) {
      const h = r ? -1 : 1;
      t = c = e.rowIndex + h;
    }
    let d;
    r ? (d = "bottom", c < n && (c = n), t < n && (t = n)) : (d = "top", c > o && (c = o), t > o && (t = o)), this.isRowTallerThanView(c) && (t = c, d = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: d,
      scrollColumn: null,
      focusIndex: c,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, r = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: r ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const i = this.getNextFocusIndexForAutoHeight(e, r);
      this.navigateTo({
        scrollIndex: t,
        scrollType: r ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: i,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    var r;
    const i = t ? -1 : 1, n = this.getViewportHeight(), o = this.paginationProxy.getPageLastRow();
    let s = 0, a = e.rowIndex;
    for (; a >= 0 && a <= o; ) {
      const l = this.paginationProxy.getRow(a);
      if (l) {
        const u = (r = l.rowHeight) != null ? r : 0;
        if (s + u > n)
          break;
        s += u;
      }
      a += i;
    }
    return Math.max(0, Math.min(a, o));
  }
  getViewportHeight() {
    const { gridBodyCtrl: e, center: t } = this.ctrlsService.getParams(), r = e.getScrollFeature().getVScrollPosition(), i = this.gos.getScrollbarWidth();
    let n = r.bottom - r.top;
    return t.isHorizontalScrollShowing() && (n -= i), n;
  }
  isRowTallerThanView(e) {
    const t = this.paginationProxy.getRow(e);
    if (!t)
      return !1;
    const r = t.rowHeight;
    return typeof r != "number" ? !1 : r > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const r = this.cellNavigationService.getNextCellToFocus(e, t, !0), { rowIndex: i, column: n } = r;
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: n,
      focusIndex: i,
      focusColumn: n
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === k.PAGE_HOME, r = this.columnModel.getAllDisplayedColumns(), i = t ? r[0] : ze(r), n = t ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: i,
      focusIndex: n,
      focusColumn: i
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const r = t.shiftKey, i = this.tabToNextCellCommon(e, r, t);
    if (i !== !1) {
      i && t.preventDefault();
      return;
    }
    if (r) {
      const { rowIndex: n, rowPinned: o } = e.getRowPosition();
      (o ? n === 0 : n === this.paginationProxy.getPageFirstRow()) && (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus") ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)));
    } else
      e instanceof Xs && e.focusCell(!0), this.focusService.focusNextGridCoreContainer(r) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const r = this.focusService.getFocusedCell();
    if (!r)
      return !1;
    let i = this.getCellByPosition(r);
    return !i && (i = this.rowRenderer.getRowByPosition(r), !i || !i.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(i, e, t);
  }
  tabToNextCellCommon(e, t, r) {
    let i = e.isEditing();
    if (!i && e instanceof Xs) {
      const s = e.getRowCtrl();
      s && (i = s.isEditing());
    }
    let n;
    return i ? this.gos.get("editType") === "fullRow" ? n = this.moveToNextEditingRow(e, t, r) : n = this.moveToNextEditingCell(e, t, r) : n = this.moveToNextCellNotEditing(e, t), n === null ? n : n || !!this.focusService.getFocusedHeader();
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, r = null) {
    const i = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const n = this.findNextCellToFocusOn(i, t, !0);
    return n === !1 ? null : n == null ? !1 : (n.startEditing(null, !0, r), n.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, r = null) {
    const i = e.getCellPosition(), n = this.findNextCellToFocusOn(i, t, !0);
    if (n === !1)
      return null;
    if (n == null)
      return !1;
    const o = n.getCellPosition(), s = this.isCellEditable(i), a = this.isCellEditable(o), l = o && i.rowIndex === o.rowIndex && i.rowPinned === o.rowPinned;
    return s && e.setFocusOutOnEditor(), l || (e.getRowCtrl().stopEditing(), n.getRowCtrl().startRowEditing(void 0, void 0, r)), a ? (n.setFocusInOnEditor(), n.focusCell()) : n.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t) {
    const r = this.columnModel.getAllDisplayedColumns();
    let i;
    e instanceof Ks ? i = Dt(Ce({}, e.getRowPosition()), {
      column: t ? r[0] : ze(r)
    }) : i = e.getCellPosition();
    const n = this.findNextCellToFocusOn(i, t, !1);
    if (n === !1)
      return null;
    if (n instanceof Xs)
      n.focusCell(!0);
    else if (n)
      return this.tryToFocusFullWidthRow(n.getRowPosition(), t);
    return q(n);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, r) {
    var i;
    let n = e;
    for (; ; ) {
      e !== n && (e = n), t || (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextTabbedCell(n, t);
      const o = this.gos.getCallback("tabToNextCell");
      if (q(o)) {
        const u = o({
          backwards: t,
          editing: r,
          previousCellPosition: e,
          nextCellPosition: n || null
        });
        if (u === !0 || u === null)
          u === null && we("Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."), n = e;
        else {
          if (u === !1)
            return !1;
          u.floating && (we("tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?"), u.rowPinned = u.floating), n = {
            rowIndex: u.rowIndex,
            column: u.column,
            rowPinned: u.rowPinned
          };
        }
      }
      if (!n)
        return null;
      if (n.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: l + n.rowIndex,
            column: n.column
          },
          fromCell: !0
        }), null;
      }
      const s = this.gos.get("editType") === "fullRow";
      if (r && !s && !this.isCellEditable(n))
        continue;
      this.ensureCellVisible(n);
      const a = this.getCellByPosition(n);
      if (!a) {
        const l = this.rowRenderer.getRowByPosition(n);
        if (!l || !l.isFullWidth() || r)
          continue;
        return l;
      }
      if (!a.isSuppressNavigable())
        return (i = this.rangeService) == null || i.setRangeToCell(n), a;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.paginationProxy.getRow(e.rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, r, i) {
    let n = r, o = !1;
    for (; n && (n === r || !this.isValidNavigateCell(n)); )
      this.gos.get("enableRtl") ? t === k.LEFT && (n = this.getLastCellOfColSpan(n)) : t === k.RIGHT && (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextCellToFocus(t, n), o = Re(n);
    if (o && e && e.key === k.UP && (n = {
      rowIndex: -1,
      rowPinned: null,
      column: r.column
    }), i) {
      const a = this.gos.getCallback("navigateToNextCell");
      if (q(a)) {
        const u = a({
          key: t,
          previousCellPosition: r,
          nextCellPosition: n || null,
          event: e
        });
        q(u) ? (u.floating && (we("tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?"), u.rowPinned = u.floating), n = {
          rowPinned: u.rowPinned,
          rowIndex: u.rowIndex,
          column: u.column
        }) : n = null;
      }
    }
    if (!n)
      return;
    if (n.rowIndex < 0) {
      const a = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: a + n.rowIndex, column: r.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const s = this.getNormalisedPosition(n);
    s ? this.focusPosition(s) : this.tryToFocusFullWidthRow(n);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t = !1) {
    const r = this.columnModel.getAllDisplayedColumns(), i = this.rowRenderer.getRowByPosition(e);
    if (!i || !i.isFullWidth())
      return !1;
    const n = this.focusService.getFocusedCell(), o = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? ze(r) : r[0])
    };
    this.focusPosition(o);
    const s = n != null ? this.rowPositionUtils.before(o, n) : !1, a = {
      type: A.EVENT_FULL_WIDTH_ROW_FOCUSED,
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: o.column,
      isFullWidthCell: !0,
      floating: o.rowPinned,
      fromBelow: s
    };
    return this.eventService.dispatchEvent(a), !0;
  }
  focusPosition(e) {
    var t;
    this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), (t = this.rangeService) == null || t.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t)
      return e;
    const r = t.getColSpanningList();
    return r.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: ze(r),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = this.gos.isGroupRowsSticky(), r = this.rowModel.getRow(e.rowIndex);
    !(t && (r == null ? void 0 : r.sticky)) && Re(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
};
v([
  T("mouseEventService")
], Pr.prototype, "mouseEventService", 2);
v([
  T("paginationProxy")
], Pr.prototype, "paginationProxy", 2);
v([
  T("focusService")
], Pr.prototype, "focusService", 2);
v([
  T("columnModel")
], Pr.prototype, "columnModel", 2);
v([
  T("rowModel")
], Pr.prototype, "rowModel", 2);
v([
  T("ctrlsService")
], Pr.prototype, "ctrlsService", 2);
v([
  T("rowRenderer")
], Pr.prototype, "rowRenderer", 2);
v([
  T("headerNavigationService")
], Pr.prototype, "headerNavigationService", 2);
v([
  T("rowPositionUtils")
], Pr.prototype, "rowPositionUtils", 2);
v([
  T("cellNavigationService")
], Pr.prototype, "cellNavigationService", 2);
v([
  T("pinnedRowModel")
], Pr.prototype, "pinnedRowModel", 2);
v([
  Qe("rangeService")
], Pr.prototype, "rangeService", 2);
v([
  te
], Pr.prototype, "postConstruct", 1);
Pr = v([
  de("navigationService")
], Pr);
var xE = class VN extends Na {
  constructor(t) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = t;
  }
  postConstruct() {
    this.gos.setDomData(this.getGui(), VN.DOM_KEY_POPUP_EDITOR_WRAPPER, !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const t = this.getGui(), r = this.params, i = (n) => {
      ug(this.gos, n, r.node, r.column, !0) || r.onKeyDown(n);
    };
    this.addManagedListener(t, "keydown", i);
  }
};
xE.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper";
v([
  te
], xE.prototype, "postConstruct", 1);
var HN = xE, Ose = class extends Oe {
  constructor(t, r, i, n, o) {
    super(), this.rendererVersion = 0, this.editorVersion = 0, this.beans = t, this.column = r.getColumn(), this.rowNode = r.getRowNode(), this.rowCtrl = r.getRowCtrl(), this.eRow = n, this.cellCtrl = r;
    const s = document.createElement("div");
    s.setAttribute("comp-id", `${this.getCompId()}`), this.setTemplateFromElement(s);
    const a = this.getGui();
    this.forceWrapper = r.isForceWrapper(), this.refreshWrapper(!1);
    const l = (d, h) => {
      h != null && h != "" ? a.setAttribute(d, h) : a.removeAttribute(d);
    };
    Nt(a, r.getCellAriaRole()), l("col-id", r.getColumnIdSanitised());
    const u = r.getTabIndex();
    u !== void 0 && l("tabindex", u.toString());
    const c = {
      addOrRemoveCssClass: (d, h) => this.addOrRemoveCssClass(d, h),
      setUserStyles: (d) => oE(a, d),
      getFocusableElement: () => this.getFocusableElement(),
      setIncludeSelection: (d) => this.includeSelection = d,
      setIncludeRowDrag: (d) => this.includeRowDrag = d,
      setIncludeDndSource: (d) => this.includeDndSource = d,
      setRenderDetails: (d, h, p) => this.setRenderDetails(d, h, p),
      setEditDetails: (d, h, p) => this.setEditDetails(d, h, p),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    r.setComp(c, this.getGui(), this.eCellWrapper, i, o);
  }
  getParentOfValue() {
    return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui();
  }
  setRenderDetails(t, r, i) {
    if (this.cellEditor && !this.cellEditorPopupWrapper)
      return;
    this.firstRender = this.firstRender == null;
    const o = this.refreshWrapper(!1);
    this.refreshEditStyles(!1), t ? !(i || o) && this.refreshCellRenderer(t) || (this.destroyRenderer(), this.createCellRendererInstance(t)) : (this.destroyRenderer(), this.insertValueWithoutCellRenderer(r));
  }
  setEditDetails(t, r, i) {
    t ? this.createCellEditorInstance(t, r, i) : this.destroyEditor();
  }
  removeControls() {
    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(t) {
    const r = this.includeRowDrag || this.includeDndSource || this.includeSelection, i = r || this.forceWrapper, n = i && this.eCellWrapper == null;
    if (n) {
      const c = document.createElement("div");
      c.setAttribute("role", "presentation"), c.setAttribute("class", "ag-cell-wrapper"), this.eCellWrapper = c, this.getGui().appendChild(this.eCellWrapper);
    }
    const o = !i && this.eCellWrapper != null;
    o && (ln(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !i);
    const s = !t && i, a = s && this.eCellValue == null;
    if (a) {
      const c = document.createElement("span");
      c.setAttribute("role", "presentation"), c.setAttribute("class", "ag-cell-value"), this.eCellValue = c, this.eCellWrapper.appendChild(this.eCellValue);
    }
    const l = !s && this.eCellValue != null;
    l && (ln(this.eCellValue), this.eCellValue = void 0);
    const u = n || o || a || l;
    return u && this.removeControls(), t || r && this.addControls(), u;
  }
  addControls() {
    this.includeRowDrag && this.rowDraggingComp == null && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && this.dndSourceComp == null && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && this.checkboxSelectionComp == null && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue));
  }
  createCellEditorInstance(t, r, i) {
    const n = this.editorVersion, o = t.newAgStackInstance();
    if (!o)
      return;
    const { params: s } = t;
    o.then((l) => this.afterCellEditorCreated(n, l, s, r, i)), Re(this.cellEditor) && s.cellStartedEdit && this.cellCtrl.focusCell(!0);
  }
  insertValueWithoutCellRenderer(t) {
    const r = this.getParentOfValue();
    Ht(r);
    const i = t != null ? Yt(t, !0) : null;
    i != null && (r.textContent = i);
  }
  destroyEditorAndRenderer() {
    this.destroyRenderer(), this.destroyEditor();
  }
  destroyRenderer() {
    const { context: t } = this.beans;
    this.cellRenderer = t.destroyBean(this.cellRenderer), ln(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
  }
  destroyEditor() {
    const { context: t } = this.beans;
    this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = t.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = t.destroyBean(this.cellEditorPopupWrapper), ln(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
  }
  refreshCellRenderer(t) {
    if (this.cellRenderer == null || this.cellRenderer.refresh == null || this.cellRendererClass !== t.componentClass)
      return !1;
    const r = this.cellRenderer.refresh(t.params);
    return r === !0 || r === void 0;
  }
  createCellRendererInstance(t) {
    const i = !this.beans.gos.get("suppressAnimationFrame"), n = this.rendererVersion, { componentClass: o } = t, s = () => {
      if (this.rendererVersion !== n || !this.isAlive())
        return;
      const l = t.newAgStackInstance(), u = this.afterCellRendererCreated.bind(this, n, o);
      l && l.then(u);
    };
    i && this.firstRender ? this.beans.animationFrameService.createTask(s, this.rowNode.rowIndex, "createTasksP2") : s();
  }
  getCtrl() {
    return this.cellCtrl;
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getCellRenderer() {
    return this.cellRenderer;
  }
  getCellEditor() {
    return this.cellEditor;
  }
  afterCellRendererCreated(t, r, i) {
    if (!this.isAlive() || t !== this.rendererVersion) {
      this.beans.context.destroyBean(i);
      return;
    }
    if (this.cellRenderer = i, this.cellRendererClass = r, this.cellRendererGui = this.cellRenderer.getGui(), this.cellRendererGui != null) {
      const o = this.getParentOfValue();
      Ht(o), o.appendChild(this.cellRendererGui);
    }
  }
  afterCellEditorCreated(t, r, i, n, o) {
    if (t !== this.editorVersion) {
      this.beans.context.destroyBean(r);
      return;
    }
    if (r.isCancelBeforeStart && r.isCancelBeforeStart()) {
      this.beans.context.destroyBean(r), this.cellCtrl.stopEditing(!0);
      return;
    }
    if (!r.getGui) {
      console.warn(`AG Grid: cellEditor for column ${this.column.getId()} is missing getGui() method`), this.beans.context.destroyBean(r);
      return;
    }
    this.cellEditor = r, this.cellEditorGui = r.getGui();
    const l = n || r.isPopup !== void 0 && r.isPopup();
    l ? this.addPopupCellEditor(i, o) : this.addInCellEditor(), this.refreshEditStyles(!0, l), r.afterGuiAttached && r.afterGuiAttached();
  }
  refreshEditStyles(t, r) {
    var i;
    this.addOrRemoveCssClass("ag-cell-inline-editing", t && !r), this.addOrRemoveCssClass("ag-cell-popup-editing", t && !!r), this.addOrRemoveCssClass("ag-cell-not-inline-editing", !t || !!r), (i = this.rowCtrl) == null || i.setInlineEditingCss(t);
  }
  addInCellEditor() {
    const t = this.getGui();
    t.contains(this.beans.gos.getActiveDomElement()) && t.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui && this.getParentOfValue().appendChild(this.cellEditorGui);
  }
  addPopupCellEditor(t, r) {
    this.beans.gos.get("editType") === "fullRow" && console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
    const i = this.cellEditor;
    this.cellEditorPopupWrapper = this.beans.context.createBean(new HN(t));
    const n = this.cellEditorPopupWrapper.getGui();
    this.cellEditorGui && n.appendChild(this.cellEditorGui);
    const o = this.beans.popupService, s = this.beans.gos.get("stopEditingWhenCellsLoseFocus"), a = r ?? (i.getPopupPosition ? i.getPopupPosition() : "over"), l = this.beans.gos.get("enableRtl"), u = {
      ePopup: n,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.getGui(),
      position: a,
      alignSide: l ? "right" : "left",
      keepWithinBounds: !0
    }, c = o.positionPopupByComponent.bind(o, u), d = this.beans.localeService.getLocaleTextFunc(), h = o.addPopup({
      modal: s,
      eChild: n,
      closeOnEsc: !0,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.getGui(),
      positionCallback: c,
      ariaLabel: d("ariaLabelCellEditor", "Cell Editor")
    });
    h && (this.hideEditorPopup = h.hideFunc);
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), super.destroy();
  }
  clearParentOfValue() {
    const t = this.getGui();
    t.contains(this.beans.gos.getActiveDomElement()) && KS() && t.focus({ preventScroll: !0 }), Ht(this.getParentOfValue());
  }
}, Mse = class extends Oe {
  constructor(t, r, i) {
    super(), this.cellComps = {}, this.beans = r, this.rowCtrl = t;
    const n = document.createElement("div");
    n.setAttribute("comp-id", `${this.getCompId()}`), n.setAttribute("style", this.getInitialStyle(i)), this.setTemplateFromElement(n);
    const o = this.getGui(), s = o.style;
    this.domOrder = this.rowCtrl.getDomOrder(), Nt(o, "row");
    const a = this.rowCtrl.getTabIndex();
    a != null && o.setAttribute("tabindex", a.toString());
    const l = {
      setDomOrder: (u) => this.domOrder = u,
      setCellCtrls: (u) => this.setCellCtrls(u),
      showFullWidth: (u) => this.showFullWidth(u),
      getFullWidthCellRenderer: () => this.getFullWidthCellRenderer(),
      addOrRemoveCssClass: (u, c) => this.addOrRemoveCssClass(u, c),
      setUserStyles: (u) => oE(o, u),
      setTop: (u) => s.top = u,
      setTransform: (u) => s.transform = u,
      setRowIndex: (u) => o.setAttribute("row-index", u),
      setRowId: (u) => o.setAttribute("row-id", u),
      setRowBusinessKey: (u) => o.setAttribute("row-business-key", u),
      refreshFullWidth: (u) => this.refreshFullWidth(u)
    };
    t.setComp(l, this.getGui(), i), this.addDestroyFunc(() => {
      t.unsetComp(i);
    });
  }
  getInitialStyle(t) {
    const r = this.rowCtrl.getInitialTransform(t);
    return r ? `transform: ${r}` : `top: ${this.rowCtrl.getInitialRowTop(t)}`;
  }
  showFullWidth(t) {
    const r = (n) => {
      if (this.isAlive()) {
        const o = n.getGui();
        this.getGui().appendChild(o), this.rowCtrl.setupDetailRowAutoHeight(o), this.setFullWidthRowComp(n);
      } else
        this.beans.context.destroyBean(n);
    }, i = t.newAgStackInstance();
    i && i.then(r);
  }
  setCellCtrls(t) {
    const r = Object.assign({}, this.cellComps);
    t.forEach((n) => {
      const o = n.getInstanceId();
      this.cellComps[o] == null ? this.newCellComp(n) : r[o] = null;
    });
    const i = qo(r).filter((n) => n != null);
    this.destroyCells(i), this.ensureDomOrder(t);
  }
  ensureDomOrder(t) {
    if (!this.domOrder)
      return;
    const r = [];
    t.forEach((i) => {
      const n = this.cellComps[i.getInstanceId()];
      n && r.push(n.getGui());
    }), nE(this.getGui(), r);
  }
  newCellComp(t) {
    const r = new Ose(
      this.beans,
      t,
      this.rowCtrl.isPrintLayout(),
      this.getGui(),
      this.rowCtrl.isEditing()
    );
    this.cellComps[t.getInstanceId()] = r, this.getGui().appendChild(r.getGui());
  }
  destroy() {
    super.destroy(), this.destroyAllCells();
  }
  destroyAllCells() {
    const t = qo(this.cellComps).filter((r) => r != null);
    this.destroyCells(t);
  }
  setFullWidthRowComp(t) {
    this.fullWidthCellRenderer && console.error("AG Grid - should not be setting fullWidthRowComponent twice"), this.fullWidthCellRenderer = t, this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  getFullWidthCellRenderer() {
    return this.fullWidthCellRenderer;
  }
  destroyCells(t) {
    t.forEach((r) => {
      if (!r)
        return;
      const i = r.getCtrl().getInstanceId();
      this.cellComps[i] === r && (r.detach(), r.destroy(), this.cellComps[i] = null);
    });
  }
  refreshFullWidth(t) {
    const { fullWidthCellRenderer: r } = this;
    if (!r || !r.refresh)
      return !1;
    const i = t();
    return r.refresh(i);
  }
};
function Fse() {
  const e = Oe.elementGettingCreated.getAttribute("name"), t = hg.getRowContainerCssClasses(e);
  let r;
  return e === "center" || e === "topCenter" || e === "stickyTopCenter" || e === "bottomCenter" || e === "stickyBottomCenter" ? r = /* html */
  `<div class="${t.viewport}" ref="eViewport" role="presentation">
                <div class="${t.container}" ref="eContainer"></div>
            </div>` : r = /* html */
  `<div class="${t.container}" ref="eContainer"></div>`, r;
}
var Wu = class extends Oe {
  constructor() {
    super(Fse()), this.rowComps = {}, this.name = Oe.elementGettingCreated.getAttribute("name"), this.type = GN(this.name);
  }
  postConstruct() {
    const t = {
      setViewportHeight: (i) => this.eViewport.style.height = i,
      setRowCtrls: ({ rowCtrls: i }) => this.setRowCtrls(i),
      setDomOrder: (i) => {
        this.domOrder = i;
      },
      setContainerWidth: (i) => this.eContainer.style.width = i
    };
    this.createManagedBean(new hg(this.name)).setComp(t, this.eContainer, this.eViewport);
  }
  preDestroy() {
    this.setRowCtrls([]);
  }
  setRowCtrls(t) {
    const r = Ce({}, this.rowComps);
    this.rowComps = {}, this.lastPlacedElement = null;
    const i = (n) => {
      const o = n.getInstanceId(), s = r[o];
      if (s)
        this.rowComps[o] = s, delete r[o], this.ensureDomOrder(s.getGui());
      else {
        if (!n.getRowNode().displayed)
          return;
        const a = new Mse(n, this.beans, this.type);
        this.rowComps[o] = a, this.appendRow(a.getGui());
      }
    };
    t.forEach(i), qo(r).forEach((n) => {
      this.eContainer.removeChild(n.getGui()), n.destroy();
    }), Nt(this.eContainer, "rowgroup");
  }
  appendRow(t) {
    this.domOrder ? T_(this.eContainer, t, this.lastPlacedElement) : this.eContainer.appendChild(t), this.lastPlacedElement = t;
  }
  ensureDomOrder(t) {
    this.domOrder && (iE(this.eContainer, t, this.lastPlacedElement), this.lastPlacedElement = t);
  }
};
v([
  T("beans")
], Wu.prototype, "beans", 2);
v([
  ne("eViewport")
], Wu.prototype, "eViewport", 2);
v([
  ne("eContainer")
], Wu.prototype, "eContainer", 2);
v([
  te
], Wu.prototype, "postConstruct", 1);
v([
  jr
], Wu.prototype, "preDestroy", 1);
var AE = class {
  constructor(e) {
    this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((r) => {
      r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? this.columnsToAggregate.push(r) : r.isAllowRowGroup() ? this.columnsToGroup.push(r) : r.isAllowPivot() && this.columnsToPivot.push(r)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? _e.ICON_PINNED : _e.ICON_MOVE : null;
  }
  /** Callback for when drag leaves */
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  onDragging(e) {
  }
  /** Callback for when drag stops */
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
};
v([
  T("columnModel")
], AE.prototype, "columnModel", 2);
v([
  T("gridOptionsService")
], AE.prototype, "gos", 2);
var qs = class {
  static attemptMoveColumns(e) {
    const { isFromHeader: t, hDirection: r, xPosition: i, fromEnter: n, fakeEvent: o, pinned: s, gos: a, columnModel: l } = e, u = r === 0, c = r === 1;
    let { allMovingColumns: d } = e;
    if (t) {
      let b = [];
      d.forEach((y) => {
        var S;
        let x = null, R = y.getParent();
        for (; R != null && R.getDisplayedLeafColumns().length === 1; )
          x = R, R = R.getParent();
        x != null ? (!!((S = x.getColGroupDef()) != null && S.marryChildren) ? x.getProvidedColumnGroup().getLeafColumns() : x.getLeafColumns()).forEach((I) => {
          b.includes(I) || b.push(I);
        }) : b.includes(y) || b.push(y);
      }), d = b;
    }
    const h = d.slice();
    l.sortColumnsLikeGridColumns(h);
    const p = this.calculateValidMoves({
      movingCols: h,
      draggingRight: c,
      xPosition: i,
      pinned: s,
      gos: a,
      columnModel: l
    }), g = this.calculateOldIndex(h, l);
    if (p.length === 0)
      return;
    const m = p[0];
    let f = g !== null && !n;
    if (t && (f = g !== null), f && !o && (u && m >= g || c && m <= g))
      return;
    const C = l.getAllDisplayedColumns();
    let w = [], E = null;
    for (let b = 0; b < p.length; b++) {
      const y = p[b], S = l.getProposedColumnOrder(h, y);
      if (!l.doesOrderPassRules(S))
        continue;
      const x = S.filter((P) => C.includes(P));
      if (E === null)
        E = x;
      else if (!On(x, E))
        break;
      const R = this.groupFragCount(S);
      w.push({ move: y, fragCount: R });
    }
    if (w.length !== 0)
      return w.sort((b, y) => b.fragCount - y.fragCount), this.moveColumns(d, w[0].move, "uiColumnMoved", !1, l);
  }
  static moveColumns(e, t, r, i, n) {
    return n.moveColumns(e, t, r, i), i ? null : { columns: e, toIndex: t };
  }
  // returns the index of the first column in the list ONLY if the cols are all beside
  // each other. if the cols are not beside each other, then returns null
  static calculateOldIndex(e, t) {
    const r = t.getAllGridColumns(), i = HF(e.map((l) => r.indexOf(l))), n = i[0];
    return ze(i) - n !== i.length - 1 ? null : n;
  }
  // A measure of how fragmented in terms of groups an order of columns is
  static groupFragCount(e) {
    function t(i) {
      let n = [], o = i.getOriginalParent();
      for (; o != null; )
        n.push(o), o = o.getOriginalParent();
      return n;
    }
    let r = 0;
    for (let i = 0; i < e.length - 1; i++) {
      let n = t(e[i]), o = t(e[i + 1]);
      [n, o] = n.length > o.length ? [n, o] : [o, n], n.forEach((s) => {
        o.indexOf(s) === -1 && r++;
      });
    }
    return r;
  }
  static getDisplayedColumns(e, t) {
    switch (t) {
      case "left":
        return e.getDisplayedLeftColumns();
      case "right":
        return e.getDisplayedRightColumns();
      default:
        return e.getDisplayedCenterColumns();
    }
  }
  static calculateValidMoves(e) {
    const { movingCols: t, draggingRight: r, xPosition: i, pinned: n, gos: o, columnModel: s } = e;
    if (o.get("suppressMovableColumns") || t.some((w) => w.getColDef().suppressMovable))
      return [];
    const l = this.getDisplayedColumns(s, n), u = s.getAllGridColumns(), c = l.filter((w) => yi(t, w)), d = l.filter((w) => !yi(t, w)), h = u.filter((w) => !yi(t, w));
    let p = 0, g = i;
    if (r) {
      let w = 0;
      c.forEach((E) => w += E.getActualWidth()), g -= w;
    }
    if (g > 0) {
      for (let w = 0; w < d.length; w++) {
        const E = d[w];
        if (g -= E.getActualWidth(), g < 0)
          break;
        p++;
      }
      r && p++;
    }
    let m;
    if (p > 0) {
      const w = d[p - 1];
      m = h.indexOf(w) + 1;
    } else
      m = h.indexOf(d[0]), m === -1 && (m = 0);
    const f = [m], C = (w, E) => w - E;
    if (r) {
      let w = m + 1;
      const E = u.length - 1;
      for (; w <= E; )
        f.push(w), w++;
      f.sort(C);
    } else {
      let w = m;
      const E = u.length - 1;
      let b = u[w];
      for (; w <= E && l.indexOf(b) < 0; )
        w++, f.push(w), b = u[w];
      w = m - 1;
      const y = 0;
      for (; w >= y; )
        f.push(w), w--;
      f.sort(C).reverse();
    }
    return f;
  }
  static normaliseX(e, t, r, i, n) {
    const o = n.getHeaderRowContainerCtrl(t).getViewport();
    return r && (e -= o.getBoundingClientRect().left), i.get("enableRtl") && (e = o.clientWidth - e), t == null && (e += n.get("center").getCenterViewportScrollLeft()), e;
  }
}, $u = class {
  constructor(e) {
    this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !q(e);
  }
  init() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    return this.pinned ? _e.ICON_PINNED : _e.ICON_MOVE;
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(t, !0, "uiColumnDragged");
    else {
      const i = e.dragItem.visibleState, n = (t || []).filter((o) => i[o.getId()]);
      this.setColumnsVisible(n, !0, "uiColumnDragged");
    }
    this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0, !0);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, r) {
    if (e) {
      const i = e.filter((n) => !n.getColDef().lockVisible);
      this.columnModel.setColumnsVisible(i, t, r);
    }
  }
  setColumnsPinned(e, t, r) {
    if (e) {
      const i = e.filter((n) => !n.getColDef().lockPinned);
      this.columnModel.setColumnsPinned(i, t, r);
    }
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  checkCenterForScrolling(e) {
    if (this.isCenterContainer) {
      const t = this.ctrlsService.get("center"), r = t.getCenterViewportScrollLeft(), i = r + t.getCenterWidth();
      this.gos.get("enableRtl") ? (this.needToMoveRight = e < r + 50, this.needToMoveLeft = e > i - 50) : (this.needToMoveLeft = e < r + 50, this.needToMoveRight = e > i - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
    }
  }
  onDragging(e = this.lastDraggingEvent, t = !1, r = !1, i = !1) {
    var n;
    if (i) {
      if (this.lastMovedInfo) {
        const { columns: c, toIndex: d } = this.lastMovedInfo;
        qs.moveColumns(c, d, "uiColumnMoved", !0, this.columnModel);
      }
      return;
    }
    if (this.lastDraggingEvent = e, Re(e.hDirection))
      return;
    const o = qs.normaliseX(
      e.x,
      this.pinned,
      !1,
      this.gos,
      this.ctrlsService
    );
    t || this.checkCenterForScrolling(o);
    const s = this.normaliseDirection(e.hDirection), a = e.dragSource.type, l = ((n = e.dragSource.getDragItem().columns) == null ? void 0 : n.filter((c) => c.getColDef().lockPinned ? c.getPinned() == this.pinned : !0)) || [], u = qs.attemptMoveColumns({
      allMovingColumns: l,
      isFromHeader: a === 1,
      hDirection: s,
      xPosition: o,
      pinned: this.pinned,
      fromEnter: t,
      fakeEvent: r,
      gos: this.gos,
      columnModel: this.columnModel
    });
    u && (this.lastMovedInfo = u);
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case 0:
          return 1;
        case 1:
          return 0;
        default:
          console.error(`AG Grid: Unknown direction ${e}`);
      }
    else
      return e;
  }
  ensureIntervalStarted() {
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.needToMoveLeft ? this.dragAndDropService.setGhostIcon(_e.ICON_LEFT, !0) : this.dragAndDropService.setGhostIcon(_e.ICON_RIGHT, !0));
  }
  ensureIntervalCleared() {
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon(_e.ICON_MOVE));
  }
  moveInterval() {
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
    let t = null;
    const r = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = r.scrollHorizontally(-e) : this.needToMoveRight && (t = r.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const n = this.lastDraggingEvent.dragItem.columns.filter((o) => !o.getColDef().lockPinned);
      if (n.length > 0 && (this.dragAndDropService.setGhostIcon(_e.ICON_PINNED), this.failedMoveAttempts > 7)) {
        const o = this.needToMoveLeft ? "left" : "right";
        this.setColumnsPinned(n, o, "uiColumnDragged"), this.dragAndDropService.nudge();
      }
    }
  }
};
v([
  T("columnModel")
], $u.prototype, "columnModel", 2);
v([
  T("dragAndDropService")
], $u.prototype, "dragAndDropService", 2);
v([
  T("gridOptionsService")
], $u.prototype, "gos", 2);
v([
  T("ctrlsService")
], $u.prototype, "ctrlsService", 2);
v([
  te
], $u.prototype, "init", 1);
var ju = class extends Q {
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()],
            [e.bottomLeft.getContainerElement()],
            [e.topLeft.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()],
            [e.bottomRight.getContainerElement()],
            [e.topRight.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()],
            [e.bottomCenter.getViewportElement()],
            [e.topCenter.getViewportElement()]
          ];
          break;
      }
    });
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  init() {
    this.moveColumnFeature = this.createManagedBean(new $u(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new AE(this.pinned)), this.dragAndDropService.addDropTarget(this);
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
};
v([
  T("dragAndDropService")
], ju.prototype, "dragAndDropService", 2);
v([
  T("columnModel")
], ju.prototype, "columnModel", 2);
v([
  T("ctrlsService")
], ju.prototype, "ctrlsService", 2);
v([
  te
], ju.prototype, "postConstruct", 1);
v([
  te
], ju.prototype, "init", 1);
var zu = class BN extends wE {
  constructor(t) {
    super(BN.TEMPLATE, t), this.headerCompVersion = 0, this.column = t.getColumnGroupChild(), this.pinned = t.getPinned();
  }
  postConstruct() {
    const t = this.getGui();
    ((o, s) => {
      s != null && s != "" ? t.setAttribute(o, s) : t.removeAttribute(o);
    })("col-id", this.column.getColId());
    const i = {
      setWidth: (o) => t.style.width = o,
      addOrRemoveCssClass: (o, s) => this.addOrRemoveCssClass(o, s),
      setAriaSort: (o) => o ? p_(t, o) : f_(t),
      setUserCompDetails: (o) => this.setUserCompDetails(o),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(i, this.getGui(), this.eResize, this.eHeaderCompWrapper);
    const n = this.ctrl.getSelectAllGui();
    this.eResize.insertAdjacentElement("afterend", n);
  }
  destroyHeaderComp() {
    this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
  }
  setUserCompDetails(t) {
    this.headerCompVersion++;
    const r = this.headerCompVersion;
    t.newAgStackInstance().then((i) => this.afterCompCreated(r, i));
  }
  afterCompCreated(t, r) {
    if (t != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(r);
      return;
    }
    this.destroyHeaderComp(), this.headerComp = r, this.headerCompGui = r.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui());
  }
};
zu.TEMPLATE = /* html */
`<div class="ag-header-cell" role="columnheader">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`;
v([
  ne("eResize")
], zu.prototype, "eResize", 2);
v([
  ne("eHeaderCompWrapper")
], zu.prototype, "eHeaderCompWrapper", 2);
v([
  te
], zu.prototype, "postConstruct", 1);
v([
  jr
], zu.prototype, "destroyHeaderComp", 1);
var _se = zu, ev = class WN extends wE {
  constructor(t) {
    super(WN.TEMPLATE, t);
  }
  postConstruct() {
    const t = this.getGui(), r = (n, o) => o != null ? t.setAttribute(n, o) : t.removeAttribute(n);
    t.setAttribute("col-id", this.ctrl.getColId());
    const i = {
      addOrRemoveCssClass: (n, o) => this.addOrRemoveCssClass(n, o),
      setResizableDisplayed: (n) => We(this.eResize, n),
      setWidth: (n) => t.style.width = n,
      setAriaExpanded: (n) => r("aria-expanded", n),
      setUserCompDetails: (n) => this.setUserCompDetails(n),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(i, t, this.eResize);
  }
  setUserCompDetails(t) {
    t.newAgStackInstance().then((r) => this.afterHeaderCompCreated(r));
  }
  afterHeaderCompCreated(t) {
    const r = () => this.destroyBean(t);
    if (!this.isAlive()) {
      r();
      return;
    }
    const i = this.getGui(), n = t.getGui();
    i.appendChild(n), this.addDestroyFunc(r), this.headerGroupComp = t, this.ctrl.setDragSource(i);
  }
};
ev.TEMPLATE = /* html */
`<div class="ag-header-group-cell" role="columnheader">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`;
v([
  ne("eResize")
], ev.prototype, "eResize", 2);
v([
  te
], ev.prototype, "postConstruct", 1);
var Nse = ev, zb = /* @__PURE__ */ ((e) => (e.COLUMN_GROUP = "group", e.COLUMN = "column", e.FLOATING_FILTER = "filter", e))(zb || {}), DE = class extends Oe {
  constructor(t) {
    super(), this.headerComps = {}, this.ctrl = t, this.setTemplate(
      /* html */
      `<div class="${this.ctrl.getHeaderRowClass()}" role="row"></div>`
    );
  }
  init() {
    $S(this.getGui(), this.ctrl.getAriaRowIndex());
    const t = {
      setHeight: (r) => this.getGui().style.height = r,
      setTop: (r) => this.getGui().style.top = r,
      setHeaderCtrls: (r, i) => this.setHeaderCtrls(r, i),
      setWidth: (r) => this.getGui().style.width = r
    };
    this.ctrl.setComp(t);
  }
  destroyHeaderCtrls() {
    this.setHeaderCtrls([], !1);
  }
  setHeaderCtrls(t, r) {
    if (!this.isAlive())
      return;
    const i = this.headerComps;
    if (this.headerComps = {}, t.forEach((n) => {
      const o = n.getInstanceId();
      let s = i[o];
      delete i[o], s == null && (s = this.createHeaderComp(n), this.getGui().appendChild(s.getGui())), this.headerComps[o] = s;
    }), Tr(i, (n, o) => {
      this.getGui().removeChild(o.getGui()), this.destroyBean(o);
    }), r) {
      const n = qo(this.headerComps);
      n.sort((s, a) => {
        const l = s.getCtrl().getColumnGroupChild().getLeft(), u = a.getCtrl().getColumnGroupChild().getLeft();
        return l - u;
      });
      const o = n.map((s) => s.getGui());
      nE(this.getGui(), o);
    }
  }
  createHeaderComp(t) {
    let r;
    switch (this.ctrl.getType()) {
      case "group":
        r = new Nse(t);
        break;
      case "filter":
        r = new Qoe(t);
        break;
      default:
        r = new _se(t);
        break;
    }
    return this.createBean(r), r.setParentComponent(this), r;
  }
};
v([
  te
], DE.prototype, "init", 1);
v([
  jr
], DE.prototype, "destroyHeaderCtrls", 1);
var Lse = 0, No = class $N extends Q {
  constructor(t, r, i) {
    super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = t, this.parentRowCtrl = i, this.beans = r, this.instanceId = t.getUniqueId() + "-" + Lse++;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["suppressHeaderFocus"], () => this.refreshTabIndex());
  }
  shouldStopEventPropagation(t) {
    const { headerRowIndex: r, column: i } = this.focusService.getFocusedHeader();
    return G_(
      this.gos,
      t,
      r,
      i
    );
  }
  getWrapperHasFocus() {
    return this.gos.getActiveDomElement() === this.eGui;
  }
  setGui(t) {
    this.eGui = t, this.addDomData(), this.addManagedListener(this.beans.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onDisplayedColumnsChanged() {
    !this.comp || !this.column || (this.refreshFirstAndLastStyles(), this.refreshAriaColIndex());
  }
  refreshFirstAndLastStyles() {
    const { comp: t, column: r, beans: i } = this;
    Zm.refreshFirstAndLastStyles(t, r, i.columnModel);
  }
  refreshAriaColIndex() {
    const { beans: t, column: r } = this, i = t.columnModel.getAriaColumnIndex(r);
    jS(this.eGui, i);
  }
  addResizeAndMoveKeyboardListeners() {
    this.resizeFeature && (this.addManagedListener(this.eGui, "keydown", this.onGuiKeyDown.bind(this)), this.addManagedListener(this.eGui, "keyup", this.onGuiKeyUp.bind(this)));
  }
  refreshTabIndex() {
    this.gos.get("suppressHeaderFocus") ? this.eGui.removeAttribute("tabindex") : this.eGui.setAttribute("tabindex", "-1");
  }
  onGuiKeyDown(t) {
    var r;
    const i = this.gos.getActiveDomElement(), n = t.key === k.LEFT || t.key === k.RIGHT;
    if (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    i !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !t.shiftKey && !t.altKey || ((this.isResizing || n) && (t.preventDefault(), t.stopImmediatePropagation()), !n))
      return;
    const o = t.key === k.LEFT !== this.gos.get("enableRtl"), s = fN[o ? "Left" : "Right"];
    if (t.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const a = this.getViewportAdjustedResizeDiff(t);
      this.resizeHeader(a, t.shiftKey), (r = this.resizeFeature) == null || r.toggleColumnResizing(!0);
    } else
      this.moveHeader(s);
  }
  getViewportAdjustedResizeDiff(t) {
    let r = this.getResizeDiff(t);
    if (this.column.getPinned()) {
      const n = this.pinnedWidthService.getPinnedLeftWidth(), o = this.pinnedWidthService.getPinnedRightWidth(), s = Ma(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (n + o + r > s)
        if (s > n + o)
          r = s - n - o;
        else
          return 0;
    }
    return r;
  }
  getResizeDiff(t) {
    let r = t.key === k.LEFT !== this.gos.get("enableRtl");
    const i = this.column.getPinned(), n = this.gos.get("enableRtl");
    return i && n !== (i === "right") && (r = !r), (r ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = setTimeout(() => {
      var t;
      (t = this.resizeFeature) == null || t.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(t) {
    const r = this.getWrapperHasFocus();
    switch (t.key) {
      case k.PAGE_DOWN:
      case k.PAGE_UP:
      case k.PAGE_HOME:
      case k.PAGE_END:
        r && t.preventDefault();
    }
  }
  addDomData() {
    const t = $N.DOM_DATA_KEY_HEADER_CTRL;
    this.gos.setDomData(this.eGui, t, this), this.addDestroyFunc(() => this.gos.setDomData(this.eGui, t, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(t) {
    return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
  removeDragSource() {
    this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(t, r, i) {
    const n = t ?? r;
    this.gos.get("preventDefaultOnContextMenu") && n.preventDefault();
    const o = i instanceof ct ? i : void 0;
    this.menuService.isHeaderContextMenuEnabled(o) && this.menuService.showHeaderContextMenu(o, t, r), this.dispatchColumnMouseEvent(A.EVENT_COLUMN_HEADER_CONTEXT_MENU, i);
  }
  dispatchColumnMouseEvent(t, r) {
    const i = {
      type: t,
      column: r
    };
    this.eventService.dispatchEvent(i);
  }
  destroy() {
    super.destroy(), this.removeDragSource(), this.comp = null, this.column = null, this.resizeFeature = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null, this.eGui = null;
  }
};
No.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
v([
  T("pinnedWidthService")
], No.prototype, "pinnedWidthService", 2);
v([
  T("focusService")
], No.prototype, "focusService", 2);
v([
  T("userComponentFactory")
], No.prototype, "userComponentFactory", 2);
v([
  T("ctrlsService")
], No.prototype, "ctrlsService", 2);
v([
  T("dragAndDropService")
], No.prototype, "dragAndDropService", 2);
v([
  T("menuService")
], No.prototype, "menuService", 2);
v([
  te
], No.prototype, "postConstruct", 1);
var tv = No, rv = class extends Q {
  constructor(e, t, r, i) {
    super(), this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = i, this.beans = r;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? ze(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    this.addManagedListener(this.columnOrGroup, ct.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this)), this.setLeftFirstTime(), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onLeftChanged.bind(this));
  }
  setLeftFirstTime() {
    const e = this.beans.gos.get("suppressColumnMoveAnimation"), t = q(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), r = e.getOldLeft(), i = this.modifyLeftForPrintLayout(e, r), n = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(i), this.actualLeft = n, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === n && this.setLeft(n);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!this.beans.gos.isDomLayout("print") || e.getPinned() === "left")
      return t;
    const i = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (e.getPinned() === "right") {
      const n = this.beans.columnModel.getBodyContainerWidth();
      return i + n + t;
    }
    return i + t;
  }
  setLeft(e) {
    if (q(e) && (this.eCell.style.left = `${e}px`), this.columnOrGroup instanceof ct)
      this.columnOrGroup;
    else {
      const r = this.columnOrGroup.getLeafColumns();
      if (!r.length)
        return;
      r.length > 1 && h_(this.ariaEl, r.length), r[0];
    }
  }
};
v([
  te
], rv.prototype, "postConstruct", 1);
var Rh = class extends Q {
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this)), this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
};
v([
  T("columnHoverService")
], Rh.prototype, "columnHoverService", 2);
v([
  te
], Rh.prototype, "postConstruct", 1);
var Gse = class extends tv {
  constructor(e, t, r) {
    super(e, t, r), this.iconCreated = !1, this.column = e;
  }
  setComp(e, t, r, i) {
    this.comp = e, this.eButtonShowMainFilter = r, this.eFloatingFilterBody = i, this.setGui(t), this.setupActive(), this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this)), this.setupFilterChangedListener(), this.addManagedListener(this.column, ct.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
  }
  // empty abstract method
  resizeHeader() {
  }
  // empty abstract method
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, r = !!e.floatingFilter;
    this.active = t && r;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = It("filter", this.gos, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus() {
    this.createManagedBean(new cs(
      this.eGui,
      {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }
    ));
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    Si(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (this.gos.getActiveDomElement() === this.eGui)
      return;
    const i = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (i) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), i.focus();
      return;
    }
    const n = this.findNextColumnWithFloatingFilter(e.shiftKey);
    n && this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: n
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.columnModel;
    let r = this.column;
    do
      if (r = e ? t.getDisplayedColBefore(r) : t.getDisplayedColAfter(r), !r)
        break;
    while (!r.getColDef().filter || !r.getColDef().floatingFilter);
    return r;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case k.UP:
      case k.DOWN:
        t || e.preventDefault();
      case k.LEFT:
      case k.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case k.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case k.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const r = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), i = !!e.relatedTarget && Us(e.relatedTarget, "ag-floating-filter");
    if (r && i && e.target === this.eGui) {
      const o = this.lastFocusEvent, s = !!(o && o.key === k.TAB);
      if (o && s) {
        const a = o.shiftKey;
        this.focusService.focusInto(this.eGui, a);
      }
    }
    const n = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(n, this.column);
  }
  setupHover() {
    this.createManagedBean(new Rh([this.column], this.eGui));
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_HOVER_CHANGED, e), e();
  }
  setupLeft() {
    const e = new rv(this.column, this.eGui, this.beans);
    this.createManagedBean(e);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
  }
  setupUserComp() {
    if (!this.active)
      return;
    const e = this.beans.filterManager.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuService.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter() {
    if (!this.active)
      return;
    const { filterManager: e } = this.beans, t = (r) => {
      if ((r == null ? void 0 : r.source) === "filterDestroyed" && this.context.isDestroyed())
        return;
      const i = this.comp.getFloatingFilterComp();
      i && i.then((n) => {
        var o;
        if (n) {
          const s = e.getCurrentFloatingFilterParentModel(this.column);
          n.onParentModelChanged(s, r ? this.gos.addGridCommonParams({
            columns: (o = r.columns) != null ? o : [],
            type: A.EVENT_FILTER_CHANGED,
            source: r.source === "api" ? "api" : "columnFilter"
          }) : null);
        }
      });
    };
    this.destroySyncListener = this.addManagedListener(this.column, ct.EVENT_FILTER_CHANGED, t), e.isFilterActive(this.column) && t(null);
  }
  setupWidth() {
    const e = () => {
      const t = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(t);
    };
    this.addManagedListener(this.column, ct.EVENT_WIDTH_CHANGED, e), e();
  }
  setupFilterChangedListener() {
    this.active && (this.destroyFilterChangedListener = this.addManagedListener(this.column, ct.EVENT_FILTER_CHANGED, this.updateFilterButton.bind(this)), this.updateFilterButton());
  }
  updateFilterButton() {
    if (!this.suppressFilterButton && this.comp) {
      const e = this.beans.filterManager.isFilterAllowed(this.column);
      this.comp.setButtonWrapperDisplayed(e), this.highlightFilterButtonWhenActive && e && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged() {
    var e, t;
    const r = this.active;
    this.setupActive();
    const i = !r && this.active;
    r && !this.active && ((e = this.destroySyncListener) == null || e.call(this), (t = this.destroyFilterChangedListener) == null || t.call(this));
    const n = this.active ? this.beans.filterManager.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    ) : null, o = this.comp.getFloatingFilterComp();
    !o || !n ? this.updateCompDetails(n, i) : o.then((s) => {
      var a;
      !s || this.beans.filterManager.areFilterCompsDifferent((a = this.userCompDetails) != null ? a : null, n) ? this.updateCompDetails(n, i) : this.updateFloatingFilterParams(n);
    });
  }
  updateCompDetails(e, t) {
    this.isAlive() && (this.setCompDetails(e), this.setupFilterButton(), this.setupUi(), t && (this.setupSyncWithFilter(), this.setupFilterChangedListener()));
  }
  updateFloatingFilterParams(e) {
    var t;
    if (!e)
      return;
    const r = e.params;
    (t = this.comp.getFloatingFilterComp()) == null || t.then((i) => {
      let n = !1;
      i != null && i.refresh && typeof i.refresh == "function" && i.refresh(r) !== null && (n = !0), !n && (i != null && i.onParamsUpdated) && typeof i.onParamsUpdated == "function" && i.onParamsUpdated(r) !== null && we("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
    });
  }
  destroy() {
    super.destroy(), this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
}, Uu = class extends Q {
  constructor(e, t, r, i, n) {
    super(), this.pinned = e, this.column = t, this.eResize = r, this.comp = i, this.ctrl = n;
  }
  postConstruct() {
    const e = [];
    let t, r;
    const i = () => {
      if (We(this.eResize, t), !t)
        return;
      const s = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (e.push(s), r) {
        const a = this.gos.get("skipHeaderOnAutoSize"), l = () => {
          this.columnModel.autoSizeColumn(this.column, "uiColumnResized", a);
        };
        this.eResize.addEventListener("dblclick", l);
        const u = new mr(this.eResize);
        u.addEventListener(mr.EVENT_DOUBLE_TAP, l), e.push(() => {
          this.eResize.removeEventListener("dblclick", l), u.removeEventListener(mr.EVENT_DOUBLE_TAP, l), u.destroy();
        });
      }
    }, n = () => {
      e.forEach((s) => s()), e.length = 0;
    }, o = () => {
      const s = this.column.isResizable(), a = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (s !== t || a !== r) && (t = s, r = a, n(), i());
    };
    o(), this.addDestroyFunc(n), this.ctrl.addRefreshFunction(o);
  }
  onResizing(e, t) {
    const { column: r, lastResizeAmount: i, resizeStartWidth: n } = this, o = this.normaliseResizeAmount(t), s = n + o, a = [{ key: r, newWidth: s }];
    if (this.column.getPinned()) {
      const l = this.pinnedWidthService.getPinnedLeftWidth(), u = this.pinnedWidthService.getPinnedRightWidth(), c = Ma(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (l + u + (o - i) > c)
        return;
    }
    this.lastResizeAmount = o, this.columnModel.setColumnWidths(a, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const r = this.pinned !== "left", i = this.pinned === "right";
    return this.gos.get("enableRtl") ? r && (t *= -1) : i && (t *= -1), t;
  }
};
v([
  T("horizontalResizeService")
], Uu.prototype, "horizontalResizeService", 2);
v([
  T("pinnedWidthService")
], Uu.prototype, "pinnedWidthService", 2);
v([
  T("ctrlsService")
], Uu.prototype, "ctrlsService", 2);
v([
  T("columnModel")
], Uu.prototype, "columnModel", 2);
v([
  te
], Uu.prototype, "postConstruct", 1);
var TE = class extends Q {
  constructor(e) {
    super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(this.gos.getActiveDomElement()) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new jm()), this.cbSelectAll.addCssClass("ag-header-select-all"), Nt(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_PAGINATION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this)), this.addManagedListener(this.cbSelectAll, A.EVENT_FIELD_VALUE_CHANGED, this.onCbSelectAll.bind(this)), Ch(this.cbSelectAll.getGui(), !0), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onNewColumnsLoaded() {
    this.showOrHideSelectAll();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: !0 }), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.selectionService.getSelectAllState(
      this.isFilteredOnly(),
      this.isCurrentPageOnly()
    );
    this.cbSelectAll.setValue(e);
    const t = this.selectionService.hasNodesToSelect(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), r = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), i = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${i} (${r})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(`${i} (${r})`), this.headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(e) {
    return this.gos.get("rowSelection") === "multiple" ? !0 : (console.warn(`AG Grid: ${e} is only available if using 'multiple' rowSelection.`), !1);
  }
  checkRightRowModelType(e) {
    const t = this.rowModel.getType();
    return t === "clientSide" || t === "serverSide" ? !0 : (console.warn(`AG Grid: ${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.isFilteredOnly(), r = this.isCurrentPageOnly();
    let i = "uiSelectAll";
    r ? i = "uiSelectAllCurrentPage" : t && (i = "uiSelectAllFiltered");
    const n = {
      source: i,
      justFiltered: t,
      justCurrentPage: r
    };
    e ? this.selectionService.selectAllRowNodes(n) : this.selectionService.deselectAllRowNodes(n);
  }
  isCheckboxSelection() {
    let e = this.column.getColDef().headerCheckboxSelection;
    if (typeof e == "function") {
      const t = e, r = this.gos.addGridCommonParams({
        column: this.column,
        colDef: this.column.getColDef()
      });
      e = t(r);
    }
    return e ? this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection") : !1;
  }
  isFilteredOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
  }
  isCurrentPageOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
  }
};
v([
  T("rowModel")
], TE.prototype, "rowModel", 2);
v([
  T("selectionService")
], TE.prototype, "selectionService", 2);
var kse = class extends tv {
  constructor(e, t, r) {
    super(e, t, r), this.refreshFunctions = [], this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, r, i) {
    this.comp = e, this.setGui(t), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight(i), this.addColumnHoverListener(), this.setupFilterClass(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.refreshAria(), this.resizeFeature = this.createManagedBean(new Uu(this.getPinned(), this.column, r, e, this)), this.createManagedBean(new Rh([this.column], t)), this.createManagedBean(new rv(this.column, t, this.beans)), this.createManagedBean(new cs(
      t,
      {
        shouldStopEventPropagation: (n) => this.shouldStopEventPropagation(n),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      }
    )), this.addResizeAndMoveKeyboardListeners(), this.addManagedPropertyListeners(["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"], this.refresh.bind(this)), this.addManagedListener(this.column, ct.EVENT_COL_DEF_CHANGED, this.refresh.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  resizeHeader(e, t) {
    var r, i;
    if (!this.column.isResizable())
      return;
    const n = this.column.getActualWidth(), o = (r = this.column.getMinWidth()) != null ? r : 0, s = (i = this.column.getMaxWidth()) != null ? i : Number.MAX_SAFE_INTEGER, a = Math.min(Math.max(n + e, o), s);
    this.beans.columnModel.setColumnWidths([{ key: this.column, newWidth: a }], t, !0, "uiColumnResized");
  }
  moveHeader(e) {
    const { eGui: t, column: r, gos: i, ctrlsService: n } = this, o = this.getPinned(), s = t.getBoundingClientRect().left, a = r.getActualWidth(), l = i.get("enableRtl"), u = e === 0 !== l, c = qs.normaliseX(
      u ? s - 20 : s + a + 20,
      o,
      !0,
      i,
      n
    );
    qs.attemptMoveColumns({
      allMovingColumns: [r],
      isFromHeader: !0,
      hDirection: e,
      xPosition: c,
      pinned: o,
      fromEnter: !1,
      fakeEvent: !1,
      gos: i,
      columnModel: this.beans.columnModel
    }), n.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(r, "auto");
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(t, e);
  }
  createParams() {
    return this.gos.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
      enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
      showColumnMenu: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          buttonElement: t,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          mouseEvent: t,
          positionBy: "mouse"
        });
      },
      showFilter: (t) => {
        this.menuService.showFilterMenu({
          column: this.column,
          buttonElement: t,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (t) => {
        this.beans.sortController.progressSort(this.column, !!t, "uiColumnSorted");
      },
      setSort: (t, r) => {
        this.beans.sortController.setSortForColumn(this.column, t, !!r, "uiColumnSorted");
      },
      eGridHeader: this.getGui(),
      setTooltip: (t, r) => {
        this.setupTooltip(t, r);
      }
    });
  }
  setupSelectAll() {
    this.selectAllFeature = this.createManagedBean(new TE(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === k.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === k.ENTER && this.onEnterKeyDown(e), e.key === k.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey)
      this.showMenuOnKeyPress(e, !0);
    else if (this.sortable) {
      const t = e.shiftKey;
      this.beans.sortController.progressSort(this.column, t, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, t) {
    const r = this.comp.getUserCompInstance();
    !r || !(r instanceof Bb) || r.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column), this.announceAriaDescription();
    }
    this.focusService.isKeyboardMode() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.gos.get("tooltipShowMode") === "whenTruncated", i = this.eGui, n = this.column.getColDef();
    !t && r && !n.headerComponent && (t = () => {
      const a = i.querySelector(".ag-header-cell-text");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => i,
      getLocation: () => "header",
      getTooltipValue: () => e ?? this.column.getColDef().headerTooltip,
      shouldDisplayTooltip: t
    }, s = this.createManagedBean(new Mo(o));
    this.refreshFunctions.push(() => s.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), r = Zm.getHeaderClassesFromColDef(t, this.gos, this.column, null), i = this.userHeaderClasses;
      this.userHeaderClasses = new Set(r), r.forEach((n) => {
        i.has(n) ? i.delete(n) : this.comp.addOrRemoveCssClass(n, !0);
      }), i.forEach((n) => this.comp.addOrRemoveCssClass(n, !1));
    };
    this.refreshFunctions.push(e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable)
      return;
    const { column: t, beans: r, displayName: i, dragAndDropService: n, gos: o } = this, { columnModel: s } = r;
    let a = !this.gos.get("suppressDragLeaveHidesColumns");
    const l = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => a ? _e.ICON_HIDE : _e.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(t),
      dragItemName: i,
      onDragStarted: () => {
        a = !o.get("suppressDragLeaveHidesColumns"), t.setMoving(!0, "uiColumnMoved");
      },
      onDragStopped: () => t.setMoving(!1, "uiColumnMoved"),
      onGridEnter: (u) => {
        var c;
        if (a) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          s.setColumnsVisible(d, !0, "uiColumnMoved");
        }
      },
      onGridExit: (u) => {
        var c;
        if (a) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          s.setColumnsVisible(d, !1, "uiColumnMoved");
        }
      }
    };
    n.addDragSource(l, !0);
  }
  createDragItem(e) {
    const t = {};
    return t[e.getId()] = e.isVisible(), {
      columns: [e],
      visibleState: t
    };
  }
  updateState() {
    this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  addRefreshFunction(e) {
    this.refreshFunctions.push(e);
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), this.refreshFunctions.forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.columnModel.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  onColumnRowGroupChanged() {
    this.checkDisplayName();
  }
  onColumnPivotChanged() {
    this.checkDisplayName();
  }
  onColumnValueChanged() {
    this.checkDisplayName();
  }
  setupWidth() {
    const e = () => {
      const t = this.column.getActualWidth();
      this.comp.setWidth(`${t}px`);
    };
    this.addManagedListener(this.column, ct.EVENT_WIDTH_CHANGED, e), e();
  }
  setupMovingCss() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    this.addManagedListener(this.column, ct.EVENT_MOVING_CHANGED, e), e();
  }
  setupMenuClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    this.addManagedListener(this.column, ct.EVENT_MENU_VISIBLE_CHANGED, e), e();
  }
  setupSortableClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    e(), this.addRefreshFunction(e), this.addManagedListener(this.eventService, ct.EVENT_SORT_CHANGED, this.refreshAriaSort.bind(this));
  }
  setupFilterClass() {
    const e = () => {
      const t = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", t), this.refreshAria();
    };
    this.addManagedListener(this.column, ct.EVENT_FILTER_ACTIVE_CHANGED, e), e();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.addRefreshFunction(e);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: r, beans: i } = this;
    if (!t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), r.addOrRemoveCssClass("ag-header-span-height", !1), r.addOrRemoveCssClass("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: n, isSpanningTotal: o } = this.column.getColumnGroupPaddingInfo();
    r.addOrRemoveCssClass("ag-header-span-height", n > 0);
    const { columnModel: s } = i, a = s.getColumnHeaderRowHeight();
    if (n === 0) {
      r.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${a}px`);
      return;
    }
    r.addOrRemoveCssClass("ag-header-span-total", o);
    const u = s.isPivotMode() ? s.getPivotGroupHeaderHeight() : s.getGroupHeaderHeight(), c = n * u;
    e.style.setProperty("top", `${-c}px`), e.style.setProperty("height", `${a + c}px`);
  }
  setupAutoHeight(e) {
    const { columnModel: t, resizeObserverService: r } = this.beans, i = (u) => {
      if (!this.isAlive())
        return;
      const { paddingTop: c, paddingBottom: d, borderBottomWidth: h, borderTopWidth: p } = us(this.getGui()), g = c + d + h + p, f = e.offsetHeight + g;
      if (u < 5) {
        const C = this.beans.gos.getDocument(), w = !C || !C.contains(e), E = f == 0;
        if (w || E) {
          window.setTimeout(() => i(u + 1), 0);
          return;
        }
      }
      t.setColumnHeaderHeight(this.column, f);
    };
    let n = !1, o;
    const s = () => {
      const u = this.column.isAutoHeaderHeight();
      u && !n && a(), !u && n && l();
    }, a = () => {
      n = !0, i(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), o = r.observeResize(e, () => i(0));
    }, l = () => {
      n = !1, o && o(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), o = void 0;
    };
    s(), this.addDestroyFunc(() => l()), this.addManagedListener(this.column, ct.EVENT_WIDTH_CHANGED, () => n && i(0)), this.addManagedListener(this.eventService, ct.EVENT_SORT_CHANGED, () => {
      n && window.setTimeout(() => i(0));
    }), this.addRefreshFunction(s);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(r_(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("filterButton", e("ariaFilterColumn", "Press CTRL ENTER to open filter"));
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.localeService.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    if (!this.eGui.contains(this.beans.gos.getActiveDomElement()))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((t, r) => t === "filter" ? -1 : r.charCodeAt(0) - t.charCodeAt(0)).map((t) => this.ariaDescriptionProperties.get(t)).join(". ");
    this.beans.ariaAnnouncementService.announceValue(e);
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener() {
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_HOVER_CHANGED, e), e();
  }
  getColId() {
    return this.column.getColId();
  }
  addActiveHeaderMouseListeners() {
    const e = (i) => this.handleMouseOverChange(i.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent(A.EVENT_COLUMN_HEADER_CLICKED, this.column), r = (i) => this.handleContextMenuMouseEvent(i, void 0, this.column);
    this.addManagedListener(this.getGui(), "mouseenter", e), this.addManagedListener(this.getGui(), "mouseleave", e), this.addManagedListener(this.getGui(), "click", t), this.addManagedListener(this.getGui(), "contextmenu", r);
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e);
    const r = {
      type: e ? A.EVENT_COLUMN_HEADER_MOUSE_OVER : A.EVENT_COLUMN_HEADER_MOUSE_LEAVE,
      column: this.column
    };
    this.eventService.dispatchEvent(r);
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return t instanceof Bb ? t.getAnchorElementForMenu(e) : this.getGui();
  }
  destroy() {
    super.destroy(), this.refreshFunctions = null, this.selectAllFeature = null, this.dragSourceElement = null, this.userCompDetails = null, this.userHeaderClasses = null, this.ariaDescriptionProperties = null;
  }
}, Ph = class extends Q {
  constructor(e, t, r, i) {
    super(), this.eResize = t, this.comp = e, this.pinned = r, this.columnGroup = i;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
      const t = this.gos.get("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const r = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((n) => {
          n.getColDef().suppressAutoSize || r.push(n.getColId());
        }), r.length > 0 && this.columnModel.autoSizeColumns({
          columns: r,
          skipHeader: t,
          stopAtGroup: this.columnGroup,
          source: "uiColumnResized"
        }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    const t = this.getInitialValues(e);
    this.storeLocalValues(t), this.toggleColumnResizing(!0);
  }
  onResizing(e, t, r = "uiColumnResized") {
    const i = this.normaliseDragChange(t), n = this.resizeStartWidth + i;
    this.resizeColumnsFromLocalValues(n, r, e);
  }
  getInitialValues(e) {
    const t = this.getColumnsToResize(), r = this.getInitialSizeOfColumns(t), i = this.getSizeRatiosOfColumns(t, r), n = {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: i
    };
    let o = null;
    if (e && (o = this.columnModel.getDisplayedGroupAtDirection(this.columnGroup, "After")), o) {
      const s = o.getDisplayedLeafColumns(), a = n.groupAfterColumns = s.filter((u) => u.isResizable()), l = n.groupAfterStartWidth = this.getInitialSizeOfColumns(a);
      n.groupAfterRatios = this.getSizeRatiosOfColumns(a, l);
    } else
      n.groupAfterColumns = void 0, n.groupAfterStartWidth = void 0, n.groupAfterRatios = void 0;
    return n;
  }
  storeLocalValues(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: i,
      groupAfterColumns: n,
      groupAfterStartWidth: o,
      groupAfterRatios: s
    } = e;
    this.resizeCols = t, this.resizeStartWidth = r, this.resizeRatios = i, this.resizeTakeFromCols = n, this.resizeTakeFromStartWidth = o, this.resizeTakeFromRatios = s;
  }
  clearLocalValues() {
    this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup), r = this.getInitialValues();
    t > r.resizeStartWidth && this.resizeColumns(r, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, r = !0) {
    var i, n, o;
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const s = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: (i = this.resizeTakeFromCols) != null ? i : void 0,
      groupAfterStartWidth: (n = this.resizeTakeFromStartWidth) != null ? n : void 0,
      groupAfterRatios: (o = this.resizeTakeFromRatios) != null ? o : void 0
    };
    this.resizeColumns(s, e, t, r);
  }
  resizeColumns(e, t, r, i = !0) {
    const {
      columnsToResize: n,
      resizeStartWidth: o,
      resizeRatios: s,
      groupAfterColumns: a,
      groupAfterStartWidth: l,
      groupAfterRatios: u
    } = e, c = [];
    if (c.push({
      columns: n,
      ratios: s,
      width: t
    }), a) {
      const d = t - o;
      c.push({
        columns: a,
        ratios: u,
        width: l - d
      });
    }
    this.columnModel.resizeColumnSets({
      resizeSets: c,
      finished: i,
      source: r
    }), i && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  getInitialSizeOfColumns(e) {
    return e.reduce(
      (t, r) => t + r.getActualWidth(),
      0
    );
  }
  getSizeRatiosOfColumns(e, t) {
    return e.map((r) => r.getActualWidth() / t);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.clearLocalValues();
  }
};
v([
  T("horizontalResizeService")
], Ph.prototype, "horizontalResizeService", 2);
v([
  T("autoWidthCalculator")
], Ph.prototype, "autoWidthCalculator", 2);
v([
  T("columnModel")
], Ph.prototype, "columnModel", 2);
v([
  te
], Ph.prototype, "postConstruct", 1);
var jN = class extends Q {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListener(this.columnGroup, ur.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this)), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
};
v([
  te
], jN.prototype, "postConstruct", 1);
var Vse = class extends tv {
  constructor(e, t, r) {
    super(e, t, r), this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving())
        this.removeDragSource();
      else if (!this.dragSource) {
        const i = this.getGui();
        this.setDragSource(i);
      }
    }, this.column = e;
  }
  setComp(e, t, r) {
    this.comp = e, this.setGui(t), this.displayName = this.beans.columnModel.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.addDestroyFunc(() => {
      this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    }), this.setupUserComp(), this.addHeaderMouseListeners();
    const i = this.getParentRowCtrl().getPinned(), n = this.column.getProvidedColumnGroup().getLeafColumns();
    this.createManagedBean(new Rh(n, t)), this.createManagedBean(new rv(this.column, t, this.beans)), this.createManagedBean(new jN(e, this.column)), this.resizeFeature = this.createManagedBean(new Ph(e, r, i, this.column)), this.createManagedBean(new cs(
      t,
      {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }
    )), this.addManagedPropertyListener(A.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED, this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners();
  }
  resizeHeader(e, t) {
    if (!this.resizeFeature)
      return;
    const r = this.resizeFeature.getInitialValues(t);
    this.resizeFeature.resizeColumns(r, r.resizeStartWidth + e, "uiColumnResized", !0);
  }
  moveHeader(e) {
    const { beans: t, eGui: r, column: i, gos: n, ctrlsService: o } = this, s = n.get("enableRtl"), a = e === 0, l = this.getPinned(), u = r.getBoundingClientRect(), c = u.left, d = u.width, h = qs.normaliseX(
      a !== s ? c - 20 : c + d + 20,
      l,
      !0,
      n,
      o
    ), p = i.getGroupId(), g = this.focusService.getFocusedHeader();
    qs.attemptMoveColumns({
      allMovingColumns: this.column.getLeafColumns(),
      isFromHeader: !0,
      hDirection: e,
      xPosition: h,
      pinned: l,
      fromEnter: !1,
      fakeEvent: !1,
      gos: n,
      columnModel: t.columnModel
    });
    const m = i.getDisplayedLeafColumns(), f = a ? m[0] : ze(m);
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(f, "auto"), !this.isAlive() && g && this.restoreFocus(p, i, g);
  }
  restoreFocus(e, t, r) {
    const i = t.getLeafColumns();
    if (!i.length)
      return;
    const n = i[0].getParent();
    if (!n)
      return;
    const o = this.findGroupWidthId(n, e);
    o && this.focusService.focusHeaderPosition({
      headerPosition: Dt(Ce({}, r), {
        column: o
      })
    });
  }
  findGroupWidthId(e, t) {
    for (; e; ) {
      if (e.getGroupId() === t)
        return e;
      e = e.getParent();
    }
    return null;
  }
  resizeLeafColumnsToFit(e) {
    this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const e = this.gos.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (r) => {
        this.beans.columnModel.setColumnGroupOpened(this.column.getProvidedColumnGroup(), r, "gridInitializing");
      },
      setTooltip: (r, i) => {
        this.setupTooltip(r, i);
      }
    }), t = this.userComponentFactory.getHeaderGroupCompDetails(e);
    this.comp.setUserCompDetails(t);
  }
  addHeaderMouseListeners() {
    const e = (i) => this.handleMouseOverChange(i.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent(A.EVENT_COLUMN_HEADER_CLICKED, this.column.getProvidedColumnGroup()), r = (i) => this.handleContextMenuMouseEvent(i, void 0, this.column.getProvidedColumnGroup());
    this.addManagedListener(this.getGui(), "mouseenter", e), this.addManagedListener(this.getGui(), "mouseleave", e), this.addManagedListener(this.getGui(), "click", t), this.addManagedListener(this.getGui(), "contextmenu", r);
  }
  handleMouseOverChange(e) {
    const r = {
      type: e ? A.EVENT_COLUMN_HEADER_MOUSE_OVER : A.EVENT_COLUMN_HEADER_MOUSE_LEAVE,
      column: this.column.getProvidedColumnGroup()
    };
    this.eventService.dispatchEvent(r);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.column.getColGroupDef(), i = this.gos.get("tooltipShowMode") === "whenTruncated", n = this.eGui;
    !t && i && !(r != null && r.headerGroupComponent) && (t = () => {
      const s = n.querySelector(".ag-header-group-text");
      return s ? s.scrollWidth > s.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getGui: () => n,
      getLocation: () => "headerGroup",
      getTooltipValue: () => e ?? (r && r.headerTooltip),
      shouldDisplayTooltip: t
    };
    r && (o.getColDef = () => r), this.createBean(new Mo(o));
  }
  setupExpandable() {
    const e = this.column.getProvidedColumnGroup();
    this.refreshExpanded(), this.addManagedListener(e, Ut.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this)), this.addManagedListener(e, Ut.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
  }
  refreshExpanded() {
    const e = this.column;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  getColId() {
    return this.column.getUniqueId();
  }
  addClasses() {
    const e = this.column.getColGroupDef(), t = Zm.getHeaderClassesFromColDef(e, this.gos, null, this.column);
    this.column.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.column.getLeafColumns().every((i) => i.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : t.push("ag-header-group-cell-with-group"), t.forEach((r) => this.comp.addOrRemoveCssClass(r, !0));
  }
  setupMovingCss() {
    const t = this.column.getProvidedColumnGroup().getLeafColumns(), r = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    t.forEach((i) => {
      this.addManagedListener(i, ct.EVENT_MOVING_CHANGED, r);
    }), r();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.column);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === k.ENTER) {
      const r = this.column, i = !r.isExpanded();
      this.beans.columnModel.setColumnGroupOpened(r.getProvidedColumnGroup(), i, "uiColumnExpanded");
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    if (!this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), !e))
      return;
    const { beans: t, column: r, displayName: i, gos: n, dragAndDropService: o } = this, { columnModel: s } = t, a = r.getProvidedColumnGroup().getLeafColumns();
    let l = !n.get("suppressDragLeaveHidesColumns");
    const u = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => l ? _e.ICON_HIDE : _e.ICON_NOT_ALLOWED,
      dragItemName: i,
      // we add in the original group leaf columns, so we move both visible and non-visible items
      getDragItem: () => this.getDragItemForGroup(r),
      onDragStarted: () => {
        l = !n.get("suppressDragLeaveHidesColumns"), a.forEach((c) => c.setMoving(!0, "uiColumnDragged"));
      },
      onDragStopped: () => a.forEach((c) => c.setMoving(!1, "uiColumnDragged")),
      onGridEnter: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((p) => !p.getColDef().lockVisible)) || [];
          s.setColumnsVisible(h, !0, "uiColumnMoved");
        }
      },
      onGridExit: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((p) => !p.getColDef().lockVisible)) || [];
          s.setColumnsVisible(h, !1, "uiColumnMoved");
        }
      }
    };
    o.addDragSource(u, !0);
  }
  // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
  // and in the order they are currently in the screen.
  getDragItemForGroup(e) {
    const t = e.getProvidedColumnGroup().getLeafColumns(), r = {};
    t.forEach((n) => r[n.getId()] = n.isVisible());
    const i = [];
    return this.beans.columnModel.getAllDisplayedColumns().forEach((n) => {
      t.indexOf(n) >= 0 && (i.push(n), Xr(t, n));
    }), t.forEach((n) => i.push(n)), {
      columns: i,
      visibleState: r
    };
  }
  isSuppressMoving() {
    let e = !1;
    return this.column.getLeafColumns().forEach((r) => {
      (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (e = !0);
    }), e || this.gos.get("suppressMovableColumns");
  }
}, Hse = 0, Hc = class extends Q {
  constructor(e, t, r) {
    super(), this.instanceId = Hse++, this.rowIndex = e, this.pinned = t, this.type = r;
    const i = r == "group" ? "ag-header-row-column-group" : r == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${i}`;
  }
  postConstruct() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  getInstanceId() {
    return this.instanceId;
  }
  /**
   * 
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t = !0) {
    this.comp = e, t && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners();
  }
  getHeaderRowClass() {
    return this.headerRowClass;
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_VIRTUAL_COLUMNS_CHANGED, (e) => this.onVirtualColumnsChanged(e.afterScroll)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_GRID_STYLES_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), this.addManagedPropertyListener("ensureDomOrder", (e) => this.isEnsureDomOrder = e.currentValue), this.addManagedPropertyListener("headerHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("groupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotGroupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("floatingFiltersHeight", this.onRowHeightChanged.bind(this));
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls)
      return zs(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { columnModel: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    var { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { columnModel: e, filterManager: t } = this.beans;
    let r = e.getHeaderRowCount();
    const i = [];
    let n = 0;
    t.hasFloatingFilters() && (r++, n = 1);
    const o = e.getColumnGroupHeaderRowHeight(), s = e.getColumnHeaderRowHeight(), a = 1 + n, l = r - a;
    for (let d = 0; d < l; d++)
      i.push(o);
    i.push(s);
    for (let d = 0; d < n; d++)
      i.push(e.getFloatingFiltersHeight());
    let u = 0;
    for (let d = 0; d < this.rowIndex; d++)
      u += i[d];
    const c = i[this.rowIndex];
    return { topOffset: u, rowHeight: c };
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getHeaderCtrls(), r = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, r, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const n of t)
      this.recycleAndCreateHeaderCtrls(n, e);
    const r = (n) => {
      const { focusService: o, columnModel: s } = this.beans;
      return o.isHeaderWrapperFocused(n) ? s.isDisplayed(n.getColumnGroupChild()) : !1;
    };
    if (e)
      for (const [n, o] of e)
        r(o) ? this.headerCellCtrls.set(n, o) : this.destroyBean(o);
    return Array.from(this.headerCellCtrls.values());
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup())
      return;
    const r = e.getUniqueId();
    let i;
    if (t && (i = t.get(r), t.delete(r)), i && i.getColumnGroupChild() != e && (this.destroyBean(i), i = void 0), i == null)
      switch (this.type) {
        case "filter":
          i = this.createBean(new Gse(e, this.beans, this));
          break;
        case "group":
          i = this.createBean(new Vse(e, this.beans, this));
          break;
        default:
          i = this.createBean(new kse(e, this.beans, this));
          break;
      }
    this.headerCellCtrls.set(r, i);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { columnModel: r } = this.beans;
    return ["left", null, "right"].forEach((i) => {
      const n = r.getVirtualHeaderGroupRow(i, t);
      e = e.concat(n);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
  }
  focusHeader(e, t) {
    if (!this.headerCellCtrls)
      return !1;
    const i = Array.from(this.headerCellCtrls.values()).find((n) => n.getColumnGroupChild() == e);
    return i ? i.focus(t) : !1;
  }
  destroy() {
    this.headerCellCtrls && this.headerCellCtrls.forEach((e) => {
      this.destroyBean(e);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
};
v([
  T("beans")
], Hc.prototype, "beans", 2);
v([
  te
], Hc.prototype, "postConstruct", 1);
var ds = class extends Q {
  constructor(e) {
    super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport), this.addManagedListener(this.eventService, A.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
  }
  setupDragAndDrop(e) {
    const t = new ju(this.pinned, e);
    this.createManagedBean(t);
  }
  refresh(e = !1) {
    const t = new Ql(), r = this.focusService.getFocusHeaderToUseAfterRefresh(), i = () => {
      const a = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let l = 0; l < a; l++) {
        const u = this.createBean(new Hc(
          t.next(),
          this.pinned,
          "group"
          /* COLUMN_GROUP */
        ));
        this.groupsRowCtrls.push(u);
      }
    }, n = () => {
      const a = t.next(), l = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== a);
      (l || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), l && (this.columnsRowCtrl = this.createBean(new Hc(
        a,
        this.pinned,
        "column"
        /* COLUMN */
      )));
    }, o = () => {
      this.includeFloatingFilter = this.filterManager.hasFloatingFilters() && !this.hidden;
      const a = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        a();
        return;
      }
      const l = t.next();
      if (this.filtersRowCtrl) {
        const u = this.filtersRowCtrl.getRowIndex() !== l;
        (!e || u) && a();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new Hc(
        l,
        this.pinned,
        "filter"
        /* FLOATING_FILTER */
      )));
    };
    i(), n(), o();
    const s = this.getAllCtrls();
    this.comp.setCtrls(s), this.restoreFocusOnHeader(r);
  }
  restoreFocusOnHeader(e) {
    e == null || e.column.getPinned() != this.pinned || this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged() {
    const e = this.filterManager.hasFloatingFilters() && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new Bu((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  setupPinnedWidth() {
    if (this.pinned == null)
      return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = !0;
    const r = () => {
      const i = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (i == null)
        return;
      const n = i == 0, o = this.hidden !== n, s = this.gos.get("enableRtl"), a = this.gos.getScrollbarWidth(), u = this.scrollVisibleService.isVerticalScrollShowing() && (s && e || !s && t) ? i + a : i;
      this.comp.setPinnedContainerWidth(`${u}px`), this.comp.setDisplayed(!n), o && (this.hidden = n, this.refresh());
    };
    this.addManagedListener(this.eventService, A.EVENT_LEFT_PINNED_WIDTH_CHANGED, r), this.addManagedListener(this.eventService, A.EVENT_RIGHT_PINNED_WIDTH_CHANGED, r), this.addManagedListener(this.eventService, A.EVENT_SCROLL_VISIBILITY_CHANGED, r), this.addManagedListener(this.eventService, A.EVENT_SCROLLBAR_WIDTH_CHANGED, r);
  }
  getHeaderCtrlForColumn(e) {
    if (e instanceof ct)
      return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(e) : void 0;
    if (this.groupsRowCtrls.length !== 0)
      for (let t = 0; t < this.groupsRowCtrls.length; t++) {
        const r = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
        if (r)
          return r;
      }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const r = this.getAllCtrls()[e];
    return r ? r.getType() : void 0;
  }
  focusHeader(e, t, r) {
    const n = this.getAllCtrls()[e];
    return n ? n.focusHeader(t, r) : !1;
  }
  getViewport() {
    return this.eViewport;
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
};
v([
  T("ctrlsService")
], ds.prototype, "ctrlsService", 2);
v([
  T("scrollVisibleService")
], ds.prototype, "scrollVisibleService", 2);
v([
  T("pinnedWidthService")
], ds.prototype, "pinnedWidthService", 2);
v([
  T("columnModel")
], ds.prototype, "columnModel", 2);
v([
  T("focusService")
], ds.prototype, "focusService", 2);
v([
  T("filterManager")
], ds.prototype, "filterManager", 2);
var Ha = class Fp extends Oe {
  constructor(t) {
    super(), this.headerRowComps = {}, this.rowCompsList = [], this.pinned = t;
  }
  init() {
    this.selectAndSetTemplate();
    const t = {
      setDisplayed: (i) => this.setDisplayed(i),
      setCtrls: (i) => this.setCtrls(i),
      // only gets called for center section
      setCenterWidth: (i) => this.eCenterContainer.style.width = i,
      setViewportScrollLeft: (i) => this.getGui().scrollLeft = i,
      // only gets called for pinned sections
      setPinnedContainerWidth: (i) => {
        const n = this.getGui();
        n.style.width = i, n.style.maxWidth = i, n.style.minWidth = i;
      }
    };
    this.createManagedBean(new ds(this.pinned)).setComp(t, this.getGui());
  }
  selectAndSetTemplate() {
    const t = this.pinned == "left", r = this.pinned == "right", i = t ? Fp.PINNED_LEFT_TEMPLATE : r ? Fp.PINNED_RIGHT_TEMPLATE : Fp.CENTER_TEMPLATE;
    this.setTemplate(i), this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
  }
  destroyRowComps() {
    this.setCtrls([]);
  }
  destroyRowComp(t) {
    this.destroyBean(t), this.eRowContainer.removeChild(t.getGui());
  }
  setCtrls(t) {
    const r = this.headerRowComps;
    this.headerRowComps = {}, this.rowCompsList = [];
    let i;
    const n = (o) => {
      const s = o.getGui();
      s.parentElement != this.eRowContainer && this.eRowContainer.appendChild(s), i && iE(this.eRowContainer, s, i), i = s;
    };
    t.forEach((o) => {
      const s = o.getInstanceId(), a = r[s];
      delete r[s];
      const l = a || this.createBean(new DE(o));
      this.headerRowComps[s] = l, this.rowCompsList.push(l), n(l);
    }), qo(r).forEach((o) => this.destroyRowComp(o));
  }
};
Ha.PINNED_LEFT_TEMPLATE = /* html */
'<div class="ag-pinned-left-header" role="rowgroup"></div>';
Ha.PINNED_RIGHT_TEMPLATE = /* html */
'<div class="ag-pinned-right-header" role="rowgroup"></div>';
Ha.CENTER_TEMPLATE = /* html */
`<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`;
v([
  ne("eCenterContainer")
], Ha.prototype, "eCenterContainer", 2);
v([
  te
], Ha.prototype, "init", 1);
v([
  jr
], Ha.prototype, "destroyRowComps", 1);
var vC = Ha, ca = class extends Q {
  constructor() {
    super(...arguments), this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    this.ctrlsService.whenReady((t) => {
      this.gridBodyCon = t.gridBodyCtrl;
    });
    const e = this.gos.getDocument();
    this.addManagedListener(e, "mousedown", () => this.setCurrentHeaderRowWithoutSpan(-1));
  }
  getHeaderRowCount() {
    const e = this.ctrlsService.getHeaderRowContainerCtrl();
    return e ? e.getRowCount() : 0;
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, r) {
    if (t || (t = this.focusService.getFocusedHeader()), !t)
      return !1;
    const { headerRowIndex: i, column: n } = t, o = this.getHeaderRowCount(), s = e === 0;
    let { headerRowIndex: a, column: l, headerRowIndexWithoutSpan: u } = s ? this.headerPositionUtils.getColumnVisibleParent(n, i) : this.headerPositionUtils.getColumnVisibleChild(n, i), c = !1;
    return a < 0 && (a = 0, l = n, c = !0), a >= o ? (a = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : u !== void 0 && (this.currentHeaderRowWithoutSpan = u), !c && !l ? !1 : this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: a, column: l },
      allowUserOverride: !0,
      event: r
    });
  }
  setCurrentHeaderRowWithoutSpan(e) {
    this.currentHeaderRowWithoutSpan = e;
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, r) {
    const i = this.focusService.getFocusedHeader(), n = e === 2, o = this.gos.get("enableRtl");
    let s, a;
    if (this.currentHeaderRowWithoutSpan !== -1 ? i.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = i.headerRowIndex, n !== o ? (a = "Before", s = this.headerPositionUtils.findHeader(i, a)) : (a = "After", s = this.headerPositionUtils.findHeader(i, a)), s || !t)
      return this.focusService.focusHeaderPosition({
        headerPosition: s,
        direction: a,
        fromTab: t,
        allowUserOverride: !0,
        event: r
      });
    if (t) {
      const l = this.gos.getCallback("tabToNextHeader");
      if (l)
        return this.focusService.focusHeaderPositionFromUserFunc({
          userFunc: l,
          headerPosition: s,
          direction: a
        });
    }
    return this.focusNextHeaderRow(i, a, r);
  }
  focusNextHeaderRow(e, t, r) {
    const i = e.headerRowIndex;
    let n = null, o;
    if (t === "Before" ? i > 0 && (o = i - 1, this.currentHeaderRowWithoutSpan -= 1, n = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "end")) : (o = i + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), n = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "start")), !n)
      return !1;
    const { column: s, headerRowIndex: a } = this.headerPositionUtils.getHeaderIndexToFocus(n.column, n == null ? void 0 : n.headerRowIndex);
    return this.focusService.focusHeaderPosition({
      headerPosition: { column: s, headerRowIndex: a },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: r
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let r;
    if (e instanceof ur) {
      const i = e.getDisplayedLeafColumns();
      r = t === "Before" ? ze(i) : i[0];
    } else
      r = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(r);
  }
};
v([
  T("focusService")
], ca.prototype, "focusService", 2);
v([
  T("headerPositionUtils")
], ca.prototype, "headerPositionUtils", 2);
v([
  T("ctrlsService")
], ca.prototype, "ctrlsService", 2);
v([
  te
], ca.prototype, "postConstruct", 1);
ca = v([
  de("headerNavigationService")
], ca);
var hs = class extends Q {
  setComp(e, t, r) {
    this.comp = e, this.eGui = t, this.createManagedBean(new cs(
      r,
      {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      }
    )), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.onPivotModeChanged(), this.setupHeaderHeight();
    const i = this.onHeaderContextMenu.bind(this);
    this.addManagedListener(this.eGui, "contextmenu", i), this.mockContextMenuForIPad(i), this.ctrlsService.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("pivotHeaderHeight", e), this.addManagedPropertyListener("groupHeaderHeight", e), this.addManagedPropertyListener("pivotGroupHeaderHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_GRID_STYLES_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, e);
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    const { columnModel: e } = this;
    let t = 0, r = e.getHeaderRowCount(), i;
    this.filterManager.hasFloatingFilters() && (r++, t = 1);
    const o = this.columnModel.getColumnGroupHeaderRowHeight(), s = this.columnModel.getColumnHeaderRowHeight(), a = 1 + t, l = r - a;
    if (i = t * e.getFloatingFiltersHeight(), i += l * o, i += s, this.headerHeight === i)
      return;
    this.headerHeight = i;
    const u = `${i + 1}px`;
    this.comp.setHeightAndMinHeight(u), this.eventService.dispatchEvent({
      type: A.EVENT_HEADER_HEIGHT_CHANGED
    });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.columnModel.getAllDisplayedColumns().some((r) => r.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), r = e.shiftKey !== t ? 2 : 3;
    (this.headerNavigationService.navigateHorizontally(r, !0, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case k.LEFT:
        t = 2;
      case k.RIGHT:
        q(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, !1, e);
        break;
      case k.UP:
        t = 0;
      case k.DOWN:
        q(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e;
    !t && this.eGui.contains(this.gos.getActiveDomElement()) || this.eGui.contains(t) || this.focusService.clearFocusedHeader();
  }
  onHeaderContextMenu(e, t, r) {
    if (!e && !r || !this.menuService.isHeaderContextMenuEnabled())
      return;
    const { target: i } = e ?? t;
    (i === this.eGui || i === this.ctrlsService.getHeaderRowContainerCtrl().getViewport()) && this.menuService.showHeaderContextMenu(void 0, e, r);
  }
  mockContextMenuForIPad(e) {
    if (!Oo())
      return;
    const t = new mr(this.eGui), r = (i) => {
      e(void 0, i.touchStart, i.touchEvent);
    };
    this.addManagedListener(t, mr.EVENT_LONG_TAP, r), this.addDestroyFunc(() => t.destroy());
  }
};
v([
  T("headerNavigationService")
], hs.prototype, "headerNavigationService", 2);
v([
  T("focusService")
], hs.prototype, "focusService", 2);
v([
  T("columnModel")
], hs.prototype, "columnModel", 2);
v([
  T("ctrlsService")
], hs.prototype, "ctrlsService", 2);
v([
  T("filterManager")
], hs.prototype, "filterManager", 2);
v([
  T("menuService")
], hs.prototype, "menuService", 2);
var RE = class zN extends Oe {
  constructor() {
    super(zN.TEMPLATE);
  }
  postConstruct() {
    const t = {
      addOrRemoveCssClass: (n, o) => this.addOrRemoveCssClass(n, o),
      setHeightAndMinHeight: (n) => {
        this.getGui().style.height = n, this.getGui().style.minHeight = n;
      }
    };
    this.createManagedBean(new hs()).setComp(t, this.getGui(), this.getFocusableElement());
    const i = (n) => {
      this.createManagedBean(n), this.appendChild(n);
    };
    i(new vC("left")), i(new vC(null)), i(new vC("right"));
  }
};
RE.TEMPLATE = /* html */
'<div class="ag-header" role="presentation"/>';
v([
  te
], RE.prototype, "postConstruct", 1);
var Bse = RE, Gd = class extends Q {
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const r = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(r);
  }
  setResizeIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e, t) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
};
v([
  T("dragService")
], Gd.prototype, "dragService", 2);
v([
  T("ctrlsService")
], Gd.prototype, "ctrlsService", 2);
Gd = v([
  de("horizontalResizeService")
], Gd);
var Jo = class extends Q {
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t, r) {
    this.showPopup(e, (i) => {
      this.popupService.positionPopupUnderMouseEvent({
        column: e,
        type: r,
        mouseEvent: t,
        ePopup: i
      });
    }, r, t.target, this.menuService.isLegacyMenuEnabled());
  }
  showMenuAfterButtonClick(e, t, r) {
    let i = -1, n = "left";
    const o = this.menuService.isLegacyMenuEnabled();
    !o && this.gos.get("enableRtl") && (i = 1, n = "right");
    let s = o ? void 0 : 4 * i, a = o ? void 0 : 4;
    this.showPopup(e, (l) => {
      this.popupService.positionPopupByComponent({
        type: r,
        eventSource: t,
        ePopup: l,
        nudgeX: s,
        nudgeY: a,
        alignSide: n,
        keepWithinBounds: !0,
        position: "under",
        column: e
      });
    }, r, t, o);
  }
  showPopup(e, t, r, i, n) {
    const o = e ? this.createBean(new Km(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = o, !(o != null && o.hasFilter()) || !e)
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const s = document.createElement("div");
    Nt(s, "presentation"), s.classList.add("ag-menu"), n || s.classList.add("ag-filter-menu"), this.tabListener = this.addManagedListener(s, "keydown", (g) => this.trapFocusWithin(g, s)), s.appendChild(o == null ? void 0 : o.getGui());
    let a;
    const l = () => o == null ? void 0 : o.afterGuiDetached(), u = this.menuService.isColumnMenuAnchoringEnabled() ? i ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0, c = (g) => {
      e.setMenuVisible(!1, "contextMenu");
      const m = g instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), m && i && ii(i)) {
        const f = this.focusService.findTabbableParent(i);
        f && f.focus();
      }
      l(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, r, e);
    }, d = this.localeService.getLocaleTextFunc(), h = n && r !== "columnFilter" ? d("ariaLabelColumnMenu", "Column Menu") : d("ariaLabelColumnFilter", "Column Filter"), p = this.popupService.addPopup({
      modal: !0,
      eChild: s,
      closeOnEsc: !0,
      closedCallback: c,
      positionCallback: () => t(s),
      anchorToElement: u,
      ariaLabel: h
    });
    p && (this.hidePopup = a = p.hideFunc), o.afterInit().then(() => {
      t(s), o.afterGuiAttached({ container: r, hidePopup: a });
    }), e.setMenuVisible(!0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, r, e);
  }
  trapFocusWithin(e, t) {
    e.key !== k.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, r) {
    const i = {
      type: A.EVENT_COLUMN_MENU_VISIBLE_CHANGED,
      visible: e,
      switchingTab: !1,
      key: t,
      column: r ?? null
    };
    this.eventService.dispatchEvent(i);
  }
  isMenuEnabled(e) {
    var t;
    return e.isFilterAllowed() && ((t = e.getColDef().menuTabs) != null ? t : ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
};
v([
  T("filterManager")
], Jo.prototype, "filterManager", 2);
v([
  T("popupService")
], Jo.prototype, "popupService", 2);
v([
  T("focusService")
], Jo.prototype, "focusService", 2);
v([
  T("ctrlsService")
], Jo.prototype, "ctrlsService", 2);
v([
  T("menuService")
], Jo.prototype, "menuService", 2);
Jo = v([
  de("filterMenuFactory")
], Jo);
var _p = /* @__PURE__ */ ((e) => (e.TAB_GUARD = "ag-tab-guard", e.TAB_GUARD_TOP = "ag-tab-guard-top", e.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom", e))(_p || {}), iv = class extends Q {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1;
    const {
      comp: t,
      eTopGuard: r,
      eBottomGuard: i,
      focusTrapActive: n,
      forceFocusOutWhenTabGuardsAreEmpty: o,
      focusInnerElement: s,
      onFocusIn: a,
      onFocusOut: l,
      shouldStopEventPropagation: u,
      onTabKeyDown: c,
      handleKeyDown: d,
      eFocusableElement: h
    } = e;
    this.comp = t, this.eTopGuard = r, this.eBottomGuard = i, this.providedFocusInnerElement = s, this.eFocusableElement = h, this.focusTrapActive = !!n, this.forceFocusOutWhenTabGuardsAreEmpty = !!o, this.providedFocusIn = a, this.providedFocusOut = l, this.providedShouldStopEventPropagation = u, this.providedOnTabKeyDown = c, this.providedHandleKeyDown = d;
  }
  postConstruct() {
    this.createManagedBean(new cs(
      this.eFocusableElement,
      {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      }
    )), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedListener(e, "focus", this.onFocus.bind(this))
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    const t = this.gos.getDocument(), r = this.focusService.findFocusableElements(t.body, null, !0), i = r.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (i === -1)
      return;
    let n, o;
    e ? (n = 0, o = i) : (n = i + 1, o = r.length);
    const s = r.slice(n, o), a = this.gos.get("tabIndex");
    s.sort((l, u) => {
      const c = parseInt(l.getAttribute("tabindex") || "0"), d = parseInt(u.getAttribute("tabindex") || "0");
      return d === a ? 1 : c === a ? -1 : c === 0 ? 1 : d === 0 ? -1 : c - d;
    }), s[e ? s.length - 1 : 0].focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || (this.providedFocusIn && this.providedFocusIn(e), this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const r = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), r && (r.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e) {
    return e === this.eTopGuard || e === this.eBottomGuard;
  }
};
v([
  T("focusService")
], iv.prototype, "focusService", 2);
v([
  te
], iv.prototype, "postConstruct", 1);
var Ih = class extends Oe {
  initialiseTabGuard(t) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.getFocusableElement();
    const r = [this.eTopGuard, this.eBottomGuard], i = {
      setTabIndex: (n) => {
        r.forEach((o) => n != null ? o.setAttribute("tabindex", n) : o.removeAttribute("tabindex"));
      }
    };
    this.addTabGuards(this.eTopGuard, this.eBottomGuard), this.tabGuardCtrl = this.createManagedBean(new iv({
      comp: i,
      focusTrapActive: !!t.focusTrapActive,
      eTopGuard: this.eTopGuard,
      eBottomGuard: this.eBottomGuard,
      eFocusableElement: this.eFocusableElement,
      onFocusIn: t.onFocusIn,
      onFocusOut: t.onFocusOut,
      focusInnerElement: t.focusInnerElement,
      handleKeyDown: t.handleKeyDown,
      onTabKeyDown: t.onTabKeyDown,
      shouldStopEventPropagation: t.shouldStopEventPropagation,
      forceFocusOutWhenTabGuardsAreEmpty: t.forceFocusOutWhenTabGuardsAreEmpty
    }));
  }
  createTabGuard(t) {
    const r = document.createElement("div"), i = t === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
    return r.classList.add("ag-tab-guard", i), Nt(r, "presentation"), r;
  }
  addTabGuards(t, r) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", t), this.eFocusableElement.insertAdjacentElement("beforeend", r);
  }
  removeAllChildrenExceptTabGuards() {
    const t = [this.eTopGuard, this.eBottomGuard];
    Ht(this.getFocusableElement()), this.addTabGuards(...t);
  }
  forceFocusOutOfContainer(t = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(t);
  }
  appendChild(t, r) {
    bh(t) || (t = t.getGui());
    const { eBottomGuard: i } = this;
    i ? i.insertAdjacentElement("beforebegin", t) : super.appendChild(t, r);
  }
}, nv = class UN extends Ih {
  constructor(t) {
    super(UN.getTemplate(t.cssClass)), this.items = [], this.tabbedItemScrollMap = /* @__PURE__ */ new Map(), this.params = t;
  }
  postConstruct() {
    this.setupHeader(), this.params.items && this.params.items.forEach((t) => this.addItem(t)), this.initialiseTabGuard({
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      focusInnerElement: this.focusInnerElement.bind(this),
      focusTrapActive: !0
    }), this.addDestroyFunc(() => {
      var t, r, i;
      return (i = (r = (t = this.activeItem) == null ? void 0 : t.tabbedItem) == null ? void 0 : r.afterDetachedCallback) == null ? void 0 : i.call(r);
    });
  }
  static getTemplate(t) {
    return (
      /* html */
      `<div class="ag-tabs ${t}">
            <div ref="eHeader"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ${t ? `${t}-body` : ""}"></div>
        </div>`
    );
  }
  setupHeader() {
    const { enableCloseButton: t, cssClass: r } = this.params, i = (n, o) => {
      n.classList.add(`ag-tabs-${o}`), r && n.classList.add(`${r}-${o}`);
    };
    t ? (this.setupCloseButton(i), this.eTabHeader = this.gos.getDocument().createElement("div"), i(this.eHeader, "header-wrapper"), Nt(this.eHeader, "presentation"), this.eHeader.appendChild(this.eTabHeader)) : this.eTabHeader = this.eHeader, Nt(this.eTabHeader, "tablist"), i(this.eTabHeader, "header");
  }
  setupCloseButton(t) {
    const r = this.gos.getDocument(), i = r.createElement("button");
    t(i, "close-button");
    const n = It(
      "close",
      this.gos,
      void 0,
      !0
    );
    Si(i, this.params.closeButtonAriaLabel), i.appendChild(n), this.addManagedListener(i, "click", () => {
      var s, a;
      return (a = (s = this.params).onCloseClicked) == null ? void 0 : a.call(s);
    });
    const o = r.createElement("div");
    t(o, "close-button-wrapper"), Nt(o, "presentation"), o.appendChild(i), this.eHeader.appendChild(o), this.eCloseButton = i;
  }
  handleKeyDown(t) {
    switch (t.key) {
      case k.RIGHT:
      case k.LEFT:
        if (!this.eTabHeader.contains(this.gos.getActiveDomElement()))
          return;
        const r = t.key === k.RIGHT, i = this.gos.get("enableRtl"), n = this.items.indexOf(this.activeItem), o = r !== i ? Math.min(n + 1, this.items.length - 1) : Math.max(n - 1, 0);
        if (n === o)
          return;
        t.preventDefault();
        const s = this.items[o];
        this.showItemWrapper(s), s.eHeaderButton.focus();
        break;
      case k.UP:
      case k.DOWN:
        t.stopPropagation();
        break;
    }
  }
  onTabKeyDown(t) {
    var r, i, n, o;
    if (t.defaultPrevented)
      return;
    const { focusService: s, eHeader: a, eBody: l, activeItem: u, params: c } = this, { suppressTrapFocus: d, enableCloseButton: h } = c, p = this.gos.getActiveDomElement(), g = t.target, m = t.shiftKey;
    if (a.contains(p)) {
      t.preventDefault(), h && m && !((r = this.eCloseButton) != null && r.contains(p)) ? (i = this.eCloseButton) == null || i.focus() : d && m ? (n = this.focusService.findFocusableElementBeforeTabGuard(this.gos.getDocument().body, g)) == null || n.focus() : this.focusBody(t.shiftKey);
      return;
    }
    let f = null;
    if (s.isTargetUnderManagedComponent(l, g) && (m && (f = this.focusService.findFocusableElementBeforeTabGuard(l, g)), !f && !d && (f = u.eHeaderButton)), !f && l.contains(p) && (f = s.findNextFocusableElement(l, !1, m), !f)) {
      t.preventDefault(), d && !m ? this.forceFocusOutOfContainer(m) : h && !m ? (o = this.eCloseButton) == null || o.focus() : this.focusHeader();
      return;
    }
    f && (t.preventDefault(), f.focus());
  }
  focusInnerElement(t) {
    t ? this.focusHeader() : this.focusBody(!0);
  }
  focusHeader(t) {
    this.activeItem.eHeaderButton.focus({ preventScroll: t });
  }
  focusBody(t) {
    this.focusService.focusInto(this.eBody, t);
  }
  setAfterAttachedParams(t) {
    this.afterAttachedParams = t;
  }
  showFirstItem() {
    this.items.length > 0 && this.showItemWrapper(this.items[0]);
  }
  addItem(t) {
    const r = document.createElement("span");
    Nt(r, "tab"), r.setAttribute("tabindex", "-1"), r.appendChild(t.title), r.classList.add("ag-tab"), this.eTabHeader.appendChild(r), Si(r, t.titleLabel);
    const i = {
      tabbedItem: t,
      eHeaderButton: r
    };
    this.items.push(i), r.addEventListener("click", this.showItemWrapper.bind(this, i));
  }
  showItem(t) {
    const r = this.items.find((i) => i.tabbedItem === t);
    r && this.showItemWrapper(r);
  }
  showItemWrapper(t) {
    var r, i, n, o, s, a;
    const { tabbedItem: l, eHeaderButton: u } = t;
    if ((i = (r = this.params).onItemClicked) == null || i.call(r, { item: l }), this.activeItem === t) {
      (o = (n = this.params).onActiveItemClicked) == null || o.call(n);
      return;
    }
    this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), Ht(this.eBody), l.bodyPromise.then((c) => {
      this.eBody.appendChild(c);
      const d = !this.focusService.isKeyboardMode();
      if (this.params.suppressFocusBodyOnOpen || this.focusService.focusInto(this.eBody, !1, d), l.afterAttachedCallback && l.afterAttachedCallback(this.afterAttachedParams), this.params.keepScrollPosition) {
        const h = l.getScrollableContainer && l.getScrollableContainer() || c;
        this.lastScrollListener = this.addManagedListener(h, "scroll", () => {
          this.tabbedItemScrollMap.set(l.name, h.scrollTop);
        });
        const p = this.tabbedItemScrollMap.get(l.name);
        p !== void 0 && setTimeout(() => {
          h.scrollTop = p;
        }, 0);
      }
    }), this.activeItem && (this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), (a = (s = this.activeItem.tabbedItem).afterDetachedCallback) == null || a.call(s)), u.classList.add("ag-tab-selected"), this.activeItem = t;
  }
};
v([
  T("focusService")
], nv.prototype, "focusService", 2);
v([
  ne("eHeader")
], nv.prototype, "eHeader", 2);
v([
  ne("eBody")
], nv.prototype, "eBody", 2);
v([
  te
], nv.prototype, "postConstruct", 1);
var Wse = 50, Ub = class extends Q {
  constructor() {
    super(...arguments), this.polyfillFunctions = [];
  }
  observeResize(e, t) {
    const r = this.gos.getWindow(), i = () => {
      const a = new r.ResizeObserver(t);
      return a.observe(e), () => a.disconnect();
    }, n = () => {
      var a, l;
      let u = (a = e == null ? void 0 : e.clientWidth) != null ? a : 0, c = (l = e == null ? void 0 : e.clientHeight) != null ? l : 0, d = !0;
      const h = () => {
        var p, g;
        if (d) {
          const m = (p = e == null ? void 0 : e.clientWidth) != null ? p : 0, f = (g = e == null ? void 0 : e.clientHeight) != null ? g : 0;
          (m !== u || f !== c) && (u = m, c = f, t()), this.doNextPolyfillTurn(h);
        }
      };
      return h(), () => d = !1;
    }, o = this.gos.get("suppressBrowserResizeObserver");
    return !!r.ResizeObserver && !o ? i() : this.getFrameworkOverrides().wrapIncoming(() => n(), "resize-observer");
  }
  doNextPolyfillTurn(e) {
    this.polyfillFunctions.push(e), this.schedulePolyfill();
  }
  schedulePolyfill() {
    if (this.polyfillScheduled)
      return;
    const e = () => {
      const t = this.polyfillFunctions;
      this.polyfillScheduled = !1, this.polyfillFunctions = [], t.forEach((r) => r());
    };
    this.polyfillScheduled = !0, window.setTimeout(e, Wse);
  }
};
Ub = v([
  de("resizeObserverService")
], Ub);
var tu = class extends Q {
  constructor() {
    super(...arguments), this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  setScrollTop(e) {
    const t = this.gos.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const r = this.paginationProxy.getCurrentPage();
      r !== this.lastPage && (this.lastPage = r, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  init() {
    this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === !1 && console.warn(`AG Grid: AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, r) {
    this.verifyAnimationFrameOn(r);
    const i = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[r], i), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort((r, i) => r.index !== i.index ? t * (i.index - r.index) : i.createOrder - r.createOrder), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, r = t.list, i = this.createTasksP2, n = i.list, o = this.destroyTasks, s = (/* @__PURE__ */ new Date()).getTime();
    let a = (/* @__PURE__ */ new Date()).getTime() - s;
    const l = e <= 0, u = this.ctrlsService.getGridBodyCtrl();
    for (; l || a < e; ) {
      if (!u.getScrollFeature().scrollGridIfNeeded()) {
        let d;
        if (r.length)
          this.sortTaskList(t), d = r.pop().task;
        else if (n.length)
          this.sortTaskList(i), d = n.pop().task;
        else if (o.length)
          d = o.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(d) || d();
      }
      a = (/* @__PURE__ */ new Date()).getTime() - s;
    }
    r.length || n.length || o.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = !1;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = this.gos.getWindow();
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  // a debounce utility used for parts of the app involved with rendering.
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    let t = !1;
    return () => {
      if (!this.isOn()) {
        window.setTimeout(e, 0);
        return;
      }
      t || (t = !0, this.addDestroyTask(() => {
        t = !1, e();
      }));
    };
  }
};
v([
  T("ctrlsService")
], tu.prototype, "ctrlsService", 2);
v([
  T("paginationProxy")
], tu.prototype, "paginationProxy", 2);
v([
  te
], tu.prototype, "init", 1);
tu = v([
  de("animationFrameService")
], tu);
var kd = class extends Q {
  postConstruct() {
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
  }
  expandRows(e) {
    if (!this.isClientSideRowModel)
      return;
    const t = new Set(e);
    this.rowModel.forEachNode((r) => {
      r.id && t.has(r.id) && (r.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  getExpandedRows() {
    const e = [];
    return this.rowModel.forEachNode(({ expanded: t, id: r }) => {
      t && r && e.push(r);
    }), e;
  }
  expandAll(e) {
    this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e);
  }
  setRowNodeExpanded(e, t, r, i) {
    e && (r && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, r, i), e.setExpanded(t, void 0, i));
  }
  onGroupExpandedOrCollapsed() {
    this.isClientSideRowModel && this.rowModel.refreshModel({
      step: "map"
      /* MAP */
    });
  }
};
v([
  T("rowModel")
], kd.prototype, "rowModel", 2);
v([
  te
], kd.prototype, "postConstruct", 1);
kd = v([
  de("expansionService")
], kd);
var Ui = class extends Q {
  postConstruct() {
    var e;
    this.activeMenuFactory = (e = this.enterpriseMenuFactory) != null ? e : this.filterMenuFactory;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
    this.showColumnMenuCommon(t, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, r) {
    this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, r);
  }
  getContextMenuPosition(e, t) {
    const r = this.getRowCtrl(e), i = this.getCellGui(r, t);
    if (!i)
      return r ? { x: 0, y: r.getRowYPosition() } : { x: 0, y: 0 };
    const n = i.getBoundingClientRect();
    return {
      x: n.x + n.width / 2,
      y: n.y + n.height / 2
    };
  }
  showContextMenu(e) {
    var t, r, i;
    const { column: n, rowNode: o } = e;
    let { anchorToElement: s, value: a } = e;
    o && n && a == null && (a = o.getValueFromValueService(n)), s == null && (s = this.getContextMenuAnchorElement(o, n)), (i = this.contextMenuFactory) == null || i.onContextMenu(
      (t = e.mouseEvent) != null ? t : null,
      (r = e.touchEvent) != null ? r : null,
      o ?? null,
      n ?? null,
      a,
      s
    );
  }
  showColumnChooser(e) {
    var t;
    (t = this.columnChooserFactory) == null || t.showColumnChooser(e);
  }
  hidePopupMenu() {
    var e;
    (e = this.contextMenuFactory) == null || e.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu();
  }
  hideColumnChooser() {
    var e;
    (e = this.columnChooserFactory) == null || e.hideActiveColumnChooser();
  }
  isColumnMenuInHeaderEnabled(e) {
    const { suppressMenu: t, suppressHeaderMenuButton: r } = e.getColDef();
    return !(r ?? t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    return !e.getColDef().suppressHeaderFilterButton && this.filterManager.isFilterAllowed(e);
  }
  isHeaderContextMenuEnabled(e) {
    return !(e != null && e.getColDef().suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(Oo() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    return this.filterManager.isFilterAllowed(e) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isColumnMenuAnchoringEnabled() {
    return !this.isLegacyMenuEnabled();
  }
  areAdditionalColumnMenuItemsEnabled() {
    return this.getColumnMenuType() === "new";
  }
  isLegacyMenuEnabled() {
    return this.getColumnMenuType() === "legacy";
  }
  isFloatingFilterButtonEnabled(e) {
    var t;
    const r = e.getColDef(), i = (t = r.floatingFilterComponentParams) == null ? void 0 : t.suppressFilterButton;
    return i != null && we("As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."), r.suppressFloatingFilterButton == null ? !i : !r.suppressFloatingFilterButton;
  }
  getColumnMenuType() {
    var e;
    return (e = this.gos.get("columnMenu")) != null ? e : "legacy";
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos.get("suppressMenuHide");
    return this.isLegacyMenuEnabled() || this.gos.exists("suppressMenuHide") ? e : !0;
  }
  showColumnMenuCommon(e, t, r, i) {
    const { column: n, positionBy: o } = t;
    if (o === "button") {
      const { buttonElement: s } = t;
      e.showMenuAfterButtonClick(n, s, r, i);
    } else if (o === "mouse") {
      const { mouseEvent: s } = t;
      e.showMenuAfterMouseEvent(n, s, r, i);
    } else n && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(n, "auto"), this.animationFrameService.requestAnimationFrame(() => {
      const s = this.ctrlsService.getHeaderRowContainerCtrl(n.getPinned()).getHeaderCtrlForColumn(n);
      e.showMenuAfterButtonClick(n, s.getAnchorElementForMenu(i), r, !0);
    }));
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: r } = e || {};
    if (t != null)
      return this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const r = e.getCellCtrl(t);
    return (r == null ? void 0 : r.getGui()) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const r = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(), i = this.getRowCtrl(e);
    if (!i)
      return r;
    const n = this.getCellGui(i, t);
    return n || (i.isFullWidth() ? i.getFullWidthElement() : r);
  }
};
v([
  T("filterMenuFactory")
], Ui.prototype, "filterMenuFactory", 2);
v([
  T("ctrlsService")
], Ui.prototype, "ctrlsService", 2);
v([
  T("animationFrameService")
], Ui.prototype, "animationFrameService", 2);
v([
  T("filterManager")
], Ui.prototype, "filterManager", 2);
v([
  T("rowRenderer")
], Ui.prototype, "rowRenderer", 2);
v([
  Qe("columnChooserFactory")
], Ui.prototype, "columnChooserFactory", 2);
v([
  Qe("contextMenuFactory")
], Ui.prototype, "contextMenuFactory", 2);
v([
  Qe("enterpriseMenuFactory")
], Ui.prototype, "enterpriseMenuFactory", 2);
v([
  te
], Ui.prototype, "postConstruct", 1);
Ui = v([
  de("menuService")
], Ui);
var da = class extends Q {
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const r = this.getHeaderCellForColumn(e);
    if (!r)
      return -1;
    const i = this.rowRenderer.getAllCellsForColumn(e);
    return t || i.push(r), this.addElementsToContainerAndGetWidth(i);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const r = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((o) => this.cloneItemIntoDummy(o, t)), r.appendChild(t);
    const i = t.offsetWidth;
    r.removeChild(t);
    const n = this.getAutoSizePadding();
    return i + n;
  }
  getAutoSizePadding() {
    return this.gos.get("autoSizePadding");
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach(
      (r) => {
        const i = r.getHtmlElementForColumnHeader(e);
        i != null && (t = i);
      }
    ), t;
  }
  cloneItemIntoDummy(e, t) {
    const r = e.cloneNode(!0);
    r.style.width = "", r.style.position = "static", r.style.left = "";
    const i = document.createElement("div"), n = i.classList;
    ["ag-header-cell", "ag-header-group-cell"].some(
      (a) => r.classList.contains(a)
    ) ? (n.add("ag-header", "ag-header-row"), i.style.position = "static") : n.add("ag-row");
    let s = e.parentElement;
    for (; s; ) {
      if (["ag-header-row", "ag-row"].some(
        (l) => s.classList.contains(l)
      )) {
        for (let l = 0; l < s.classList.length; l++) {
          const u = s.classList[l];
          u != "ag-row-position-absolute" && n.add(u);
        }
        break;
      }
      s = s.parentElement;
    }
    i.appendChild(r), t.appendChild(i);
  }
};
v([
  T("rowRenderer")
], da.prototype, "rowRenderer", 2);
v([
  T("ctrlsService")
], da.prototype, "ctrlsService", 2);
v([
  T("rowCssClassCalculator")
], da.prototype, "rowCssClassCalculator", 2);
v([
  te
], da.prototype, "postConstruct", 1);
da = v([
  de("autoWidthCalculator")
], da);
var Oh = class extends Q {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.topContainerHeight = 0, this.bottomContainerHeight = 0;
  }
  postConstruct() {
    this.isClientSide = this.rowModel.getType() === "clientSide", this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    });
  }
  getStickyTopRowCtrls() {
    return this.stickyTopRowCtrls;
  }
  getStickyBottomRowCtrls() {
    return this.stickyBottomRowCtrls;
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  getServerSideLastPixelOfGroup(e) {
    var t, r, i, n;
    if (this.isClientSide)
      throw new Error("This func should only be called in server side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.master)
        return e.detailNode.rowTop + e.detailNode.rowHeight;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let s = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
        return e.footer && (s = (r = e.sibling.childStore) == null ? void 0 : r.getStoreBounds()), ((i = s == null ? void 0 : s.heightPx) != null ? i : 0) + ((n = s == null ? void 0 : s.topPx) != null ? n : 0);
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  getClientSideLastPixelOfGroup(e) {
    if (!this.isClientSide)
      throw new Error("This func should only be called in client side row model.");
    if (e.isExpandable() || e.footer) {
      const t = e.footer && e.rowIndex === 0, r = !e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1;
      if (t || r) {
        let i = e.footer ? e.sibling : e;
        for (; i.isExpandable() && i.expanded; )
          if (i.master)
            i = i.detailNode;
          else if (i.childrenAfterSort) {
            if (i.childrenAfterSort.length === 0)
              break;
            i = ze(i.childrenAfterSort);
          }
        return i.rowTop + i.rowHeight;
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let r = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), r);
    const i = t ? this.rowRenderer.getFirstVisibleVerticalPixel() : this.rowRenderer.getLastVisibleVerticalPixel(), n = /* @__PURE__ */ new Set(), o = (u) => {
      if (n.add(u), t) {
        const c = this.getLastPixelOfGroup(u), d = i + r + u.rowHeight;
        c < d ? u.stickyRowTop = r + (c - d) : u.stickyRowTop = r;
      } else {
        const c = this.getFirstPixelOfGroup(u), d = i - (r + u.rowHeight);
        c > d ? u.stickyRowTop = r - (c - d) : u.stickyRowTop = r;
      }
      r = 0, n.forEach((c) => {
        const d = c.stickyRowTop + c.rowHeight;
        r < d && (r = d);
      });
    }, s = this.areFooterRowsStickySuppressed(), a = this.gos.get("suppressGroupRowsSticky"), l = (u) => u.displayed ? u.footer ? s === !0 || s === "grand" && u.level === -1 || s === "group" && u.level > -1 ? !1 : !n.has(u) : u.isExpandable() ? a === !0 ? !1 : !n.has(u) && u.expanded : !1 : !1;
    for (let u = 0; u < 100; u++) {
      let c = i + r;
      t || (c = i - r);
      const d = this.rowModel.getRowIndexAtPixel(c), h = this.rowModel.getRow(d);
      if (h == null)
        break;
      const g = this.getStickyAncestors(h).find(
        (f) => (t ? f.rowIndex < d : f.rowIndex > d) && l(f)
      );
      if (g) {
        o(g);
        continue;
      }
      if ((t ? h.rowTop < c : h.rowTop + h.rowHeight > c) && l(h)) {
        o(h);
        continue;
      }
      break;
    }
    return t || n.forEach((u) => {
      u.stickyRowTop = r - (u.stickyRowTop + u.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, n, r);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = !!this.gos.get("groupIncludeFooter") || e === "group", r = !!this.gos.get("groupIncludeTotalFooter") || e === "grand";
    return t && r ? !0 : r ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = this.gos.isGroupRowsSticky(), t = this.areFooterRowsStickySuppressed(), r = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !r);
  }
  getStickyAncestors(e) {
    const t = [];
    let r = e.footer ? e.sibling : e.parent;
    for (; r; )
      r.sibling && t.push(r.sibling), t.push(r), r = r.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((r) => r.getRowNode() === e)) {
      for (let r = 0; r < this.stickyTopRowCtrls.length; r++) {
        const i = this.stickyTopRowCtrls[r].getRowNode();
        i !== e && t.add(i);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let r = 0; r < this.stickyBottomRowCtrls.length; r++) {
      const i = this.stickyBottomRowCtrls[r].getRowNode();
      i !== e && t.add(i);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, r) {
    const i = e === "top", n = i ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, o = {}, s = [];
    for (let d = 0; d < n.length; d++) {
      const h = n[d].getRowNode();
      if (!t.has(h)) {
        o[h.id] = n[d], h.sticky = !1;
        continue;
      }
      s.push(n[d]);
    }
    const a = /* @__PURE__ */ new Set();
    for (let d = 0; d < s.length; d++)
      a.add(s[d].getRowNode());
    const l = [];
    t.forEach((d) => {
      a.has(d) || (d.sticky = !0, l.push(this.createRowCon(d, !1, !1)));
    });
    let u = !!l.length || s.length !== n.length;
    i ? this.topContainerHeight !== r && (this.topContainerHeight = r, this.gridBodyCtrl.setStickyTopHeight(r), u = !0) : this.bottomContainerHeight !== r && (this.bottomContainerHeight = r, this.gridBodyCtrl.setStickyBottomHeight(r), u = !0), this.destroyRowCtrls(o, !1);
    const c = [...s, ...l];
    return c.sort((d, h) => h.getRowNode().rowIndex - d.getRowNode().rowIndex), i || c.reverse(), c.forEach((d) => d.setRowTop(d.getRowNode().stickyRowTop)), u ? (i ? this.stickyTopRowCtrls = c : this.stickyBottomRowCtrls = c, !0) : !1;
  }
};
v([
  T("rowModel")
], Oh.prototype, "rowModel", 2);
v([
  T("rowRenderer")
], Oh.prototype, "rowRenderer", 2);
v([
  T("ctrlsService")
], Oh.prototype, "ctrlsService", 2);
v([
  te
], Oh.prototype, "postConstruct", 1);
var Ei = class extends Q {
  constructor() {
    super(...arguments), this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((o) => o.onRangeSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((o) => o.updateRangeBordersIfRangeCount());
      }, r = () => {
        this.eventService.addEventListener(A.EVENT_RANGE_SELECTION_CHANGED, e), this.eventService.addEventListener(A.EVENT_COLUMN_MOVED, t), this.eventService.addEventListener(A.EVENT_COLUMN_PINNED, t), this.eventService.addEventListener(A.EVENT_COLUMN_VISIBLE, t);
      }, i = () => {
        this.eventService.removeEventListener(A.EVENT_RANGE_SELECTION_CHANGED, e), this.eventService.removeEventListener(A.EVENT_COLUMN_MOVED, t), this.eventService.removeEventListener(A.EVENT_COLUMN_PINNED, t), this.eventService.removeEventListener(A.EVENT_COLUMN_VISIBLE, t);
      };
      this.addDestroyFunc(() => i()), this.addManagedPropertyListener("enableRangeSelection", (o) => {
        o.currentValue ? r() : i();
      }), this.gos.get("enableRangeSelection") && r();
    };
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    if (this.addManagedListener(this.eventService, A.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this)), this.addManagedListener(this.eventService, A.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL, this.onBodyScroll.bind(this)), this.addManagedListener(this.eventService, A.EVENT_BODY_HEIGHT_CHANGED, this.redraw.bind(this)), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListeners([
      "suppressCellFocus",
      "getBusinessKeyForNode",
      "fullWidthCellRenderer",
      "fullWidthCellRendererParams",
      "rowStyle",
      "getRowStyle",
      "rowClass",
      "getRowClass",
      "rowClassRules",
      "suppressStickyTotalRow",
      "groupRowRenderer",
      "groupRowRendererParams",
      // maybe only needs to refresh FW rows...
      "loadingCellRenderer",
      "loadingCellRendererParams",
      "detailCellRenderer",
      "detailCellRendererParams",
      "enableRangeSelection",
      "enableCellTextSelection"
    ], () => this.redrawRows()), this.gos.isGroupRowsSticky()) {
      const e = this.rowModel.getType();
      (e === "clientSide" || e === "serverSide") && (this.stickyRowFeature = this.createManagedBean(new Oh(
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      )));
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gos.isDomLayout("print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new $se(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = qo(this.rowCtrlsByRowIndex), t = qo(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    t.length > 0 || r.length > 0 ? this.allRowCtrls = [...e, ...t, ...r] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedListener(this.eventService, A.EVENT_CELL_FOCUSED, (e) => {
      this.onCellFocusChanged(e);
    }), this.addManagedListener(this.eventService, A.EVENT_CELL_FOCUS_CLEARED, () => {
      this.onCellFocusChanged();
    }), this.addManagedListener(this.eventService, A.EVENT_FLASH_CELLS, (e) => {
      this.getAllCellCtrls().forEach((t) => t.onFlashCells(e));
    }), this.addManagedListener(this.eventService, A.EVENT_COLUMN_HOVER_CHANGED, () => {
      this.getAllCellCtrls().forEach((e) => e.onColumnHover());
    }), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, () => {
      this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
    }), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {
      this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedListener(this.eventService, A.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this)), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.columnModel.getAllGridColumns().forEach((t) => {
      const r = (l) => {
        this.getAllCellCtrls().forEach((u) => {
          u.getColumn() === t && l(u);
        });
      }, i = () => {
        r((l) => l.onLeftChanged());
      }, n = () => {
        r((l) => l.onWidthChanged());
      }, o = () => {
        r((l) => l.onFirstRightPinnedChanged());
      }, s = () => {
        r((l) => l.onLastLeftPinnedChanged());
      }, a = () => {
        r((l) => l.onColDefChanged());
      };
      t.addEventListener("leftChanged", i), t.addEventListener("widthChanged", n), t.addEventListener("firstRightPinnedChanged", o), t.addEventListener("lastLeftPinnedChanged", s), t.addEventListener("colDefChanged", a), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", i), t.removeEventListener("widthChanged", n), t.removeEventListener("firstRightPinnedChanged", o), t.removeEventListener("lastLeftPinnedChanged", s), t.removeEventListener("colDefChanged", a);
      });
    });
  }
  onDomLayoutChanged() {
    const e = this.gos.isDomLayout("print"), t = e || this.gos.get("embedFullWidthRows"), r = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, r && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((r) => {
      const i = r.getCellElement(e);
      i && t.push(i);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(
      this.topRowCtrls,
      this.pinnedRowModel.getPinnedTopRowData()
    ), this.refreshFloatingRows(
      this.bottomRowCtrls,
      this.pinnedRowModel.getPinnedBottomRowData()
    );
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getCentreRowCtrls() {
    return this.allRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  refreshFloatingRows(e, t) {
    e.forEach((r) => {
      r.destroyFirstPass(), r.destroySecondPass();
    }), e.length = 0, t && t.forEach((r) => {
      const i = new Ks(
        r,
        this.beans,
        !1,
        !1,
        this.printLayout
      );
      e.push(i);
    });
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = !1) {
    var r;
    if (e.sticky)
      this.stickyRowFeature.refreshStickyNode(e);
    else if ((r = this.cachedRowCtrls) != null && r.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const i = (n) => {
        const o = n[e.rowIndex];
        o && o.getRowNode() === e && (o.destroyFirstPass(), o.destroySecondPass(), n[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          i(this.topRowCtrls);
          break;
        case "bottom":
          i(this.bottomRowCtrls);
          break;
        default:
          i(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((r) => this.redrawRow(r, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const r = this.gos.getActiveDomElement(), i = this.gos.getDomData(r, Xs.DOM_DATA_KEY_CELL_CTRL), n = this.gos.getDomData(r, Ks.DOM_DATA_KEY_ROW_CTRL);
    return i || n ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const r = !e.domLayoutChanged && !!e.recycleRows, i = e.animate && this.gos.isAnimateRows(), n = r ? this.getRowsToRecycle() : null;
    r || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature && this.stickyRowFeature.checkStickyRows(), this.recycleRows(n, i), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    const t = e.newData || e.newPage, r = this.gos.get("suppressScrollOnNewData");
    t && !r && this.gridBodyCtrl.getScrollFeature().scrollToTop();
  }
  updateContainerHeights() {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let e = this.paginationProxy.getCurrentPageHeight();
    e === 0 && (e = 1), this.rowContainerHeightService.setModelHeight(e);
  }
  getLockOnRefresh() {
    if (this.refreshInProgress)
      throw new Error(
        "AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace."
      );
    this.refreshInProgress = !0;
  }
  releaseLockOnRefresh() {
    this.refreshInProgress = !1;
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && (this.focusService.setRestoreFocusedCell(e), this.onCellFocusChanged(this.beans.gos.addGridCommonParams({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0,
      type: "mock"
    })));
  }
  stopEditing(e = !1) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), r = t.length;
    for (let i = 0; i < r; i++) {
      const n = t[i].getAllCellCtrls(), o = n.length;
      for (let s = 0; s < o; s++)
        e.push(n[s]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [], t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [], r = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
    for (const i in this.rowCtrlsByRowIndex)
      r.push(this.rowCtrlsByRowIndex[i]);
    return r;
  }
  addRenderedRowListener(e, t, r) {
    const i = this.rowCtrlsByRowIndex[t];
    i && i.addEventListener(e, r);
  }
  flashCells(e = {}) {
    this.getCellCtrls(e.rowNodes, e.columns).forEach((t) => t.flashCell(e));
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => r.refreshOrDestroyCell(t)), e.rowNodes && (this.getRowCtrls(e.rowNodes).forEach((r) => {
      if (!r.isFullWidth())
        return;
      r.refreshFullWidth() || this.redrawRow(r.getRowNode(), !0);
    }), this.dispatchDisplayedRowsChanged(!1));
  }
  getCellRendererInstances(e) {
    var t;
    const r = this.getCellCtrls(e.rowNodes, e.columns).map((o) => o.getCellRenderer()).filter((o) => o != null);
    if ((t = e.columns) != null && t.length)
      return r;
    const i = [], n = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((o) => {
      if (n && !this.isRowInMap(o.getRowNode(), n) || !o.isFullWidth())
        return;
      const s = o.getFullWidthCellRenderers();
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        l != null && i.push(l);
      }
    }), [...i, ...r];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => {
      const i = r.getCellEditor();
      i && t.push(i);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const r = t.getCellPosition();
        e.push(r);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e)
      return;
    const t = {
      top: {},
      bottom: {},
      normal: {}
    };
    return e.forEach((r) => {
      const i = r.id;
      switch (r.rowPinned) {
        case "top":
          t.top[i] = r;
          break;
        case "bottom":
          t.bottom[i] = r;
          break;
        default:
          t.normal[i] = r;
          break;
      }
    }), t;
  }
  isRowInMap(e, t) {
    const r = e.id;
    switch (e.rowPinned) {
      case "top":
        return t.top[r] != null;
      case "bottom":
        return t.bottom[r] != null;
      default:
        return t.normal[r] != null;
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = this.mapRowNodes(e), r = this.getAllRowCtrls();
    return !e || !t ? r : r.filter((i) => {
      const n = i.getRowNode();
      return this.isRowInMap(n, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let r;
    q(t) && (r = {}, t.forEach((n) => {
      const o = this.columnModel.getGridColumn(n);
      q(o) && (r[o.getId()] = !0);
    }));
    const i = [];
    return this.getRowCtrls(e).forEach((n) => {
      n.getAllCellCtrls().forEach((o) => {
        const s = o.getColumn().getId();
        r && !r[s] || i.push(o);
      });
    }), i;
  }
  destroy() {
    this.removeAllRowComps(), super.destroy();
  }
  removeAllRowComps() {
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    Tr(this.rowCtrlsByRowIndex, (r, i) => {
      i.getRowNode().id == null && e.push(r);
    }), this.removeRowCtrls(e);
    const t = {};
    return Tr(this.rowCtrlsByRowIndex, (r, i) => {
      const n = i.getRowNode();
      t[n.id] = i;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((r) => {
      const i = this.rowCtrlsByRowIndex[r];
      i && (i.destroyFirstPass(t), i.destroySecondPass()), delete this.rowCtrlsByRowIndex[r];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { afterScroll: t } = e;
    let r;
    this.stickyRowFeature && KS() && (r = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const i = this.firstRenderedRow, n = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let o = !1;
    this.stickyRowFeature && (o = this.stickyRowFeature.checkStickyRows());
    const s = this.firstRenderedRow !== i || this.lastRenderedRow !== n;
    if (!(t && !o && !s) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !o), r != null)) {
      const a = this.getCellToRestoreFocusToAfterRefresh();
      r != null && a == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(r));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const r = {};
    e.forEach((o) => r[o] = !0);
    const n = Object.keys(this.rowCtrlsByRowIndex).filter((o) => !r[o]);
    this.removeRowCtrls(n, t);
  }
  calculateIndexesToDraw(e) {
    let t = E_(this.firstRenderedRow, this.lastRenderedRow);
    const r = (n, o) => {
      const s = o.getRowNode().rowIndex;
      s != null && (s < this.firstRenderedRow || s > this.lastRenderedRow) && this.doNotUnVirtualiseRow(o) && t.push(s);
    };
    Tr(this.rowCtrlsByRowIndex, r), Tr(e, r), t.sort((n, o) => n - o);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const o = t[n], s = this.paginationProxy.getRow(o);
      s && !s.sticky && i.push(o);
    }
    return i;
  }
  recycleRows(e, t = !1, r = !1) {
    const i = this.calculateIndexesToDraw(e);
    (this.printLayout || r) && (t = !1), this.removeRowCompsNotToDraw(i, !t), i.forEach((n) => {
      this.createOrUpdateRowCtrl(n, e, t, r);
    }), e && (r && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    const t = { type: A.EVENT_DISPLAYED_ROWS_CHANGED, afterScroll: e };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    const e = this.columnModel.isPinningLeft(), t = this.columnModel.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const r = t.getRowNode().rowIndex;
      e.push(r.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((r) => {
      if (!r.isFullWidth())
        return !1;
      const i = r.getRowNode();
      return !(t != null && !this.isRowInMap(i, t));
    });
  }
  createOrUpdateRowCtrl(e, t, r, i) {
    let n, o = this.rowCtrlsByRowIndex[e];
    if (o || (n = this.paginationProxy.getRow(e), q(n) && q(t) && t[n.id] && n.alreadyRendered && (o = t[n.id], t[n.id] = null)), !o)
      if (n || (n = this.paginationProxy.getRow(e)), q(n))
        o = this.createRowCon(n, r, i);
      else
        return;
    return n && (n.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = o, o;
  }
  destroyRowCtrls(e, t) {
    const r = [];
    Tr(e, (i, n) => {
      if (n) {
        if (this.cachedRowCtrls && n.isCacheable()) {
          this.cachedRowCtrls.addRow(n);
          return;
        }
        n.destroyFirstPass(!t), t ? (this.zombieRowCtrls[n.getInstanceId()] = n, r.push(() => {
          n.destroySecondPass(), delete this.zombieRowCtrls[n.getInstanceId()];
        })) : n.destroySecondPass();
      }
    }), t && (r.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), IF(r));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = this.gos.getRowHeightAsNumber();
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    this.rowContainerHeightService.updateOffset();
    let e, t;
    if (!this.paginationProxy.isRowsToRender())
      e = 0, t = -1;
    else if (this.printLayout)
      this.environment.refreshRowHeightVariable(), e = this.paginationProxy.getPageFirstRow(), t = this.paginationProxy.getPageLastRow();
    else {
      const a = this.getRowBufferInPixels(), l = this.ctrlsService.getGridBodyCtrl(), u = this.gos.get("suppressRowVirtualisation");
      let c = !1, d, h;
      do {
        const C = this.paginationProxy.getPixelOffset(), { pageFirstPixel: w, pageLastPixel: E } = this.paginationProxy.getCurrentPagePixelRange(), b = this.rowContainerHeightService.getDivStretchOffset(), y = l.getScrollFeature().getVScrollPosition(), S = y.top, x = y.bottom;
        u ? (d = w + b, h = E + b) : (d = Math.max(S + C - a, w) + b, h = Math.min(x + C + a, E) + b), this.firstVisibleVPixel = Math.max(S + C, w) + b, this.lastVisibleVPixel = Math.min(x + C, E) + b, c = this.ensureAllRowsInRangeHaveHeightsCalculated(d, h);
      } while (c);
      let p = this.paginationProxy.getRowIndexAtPixel(d), g = this.paginationProxy.getRowIndexAtPixel(h);
      const m = this.paginationProxy.getPageFirstRow(), f = this.paginationProxy.getPageLastRow();
      p < m && (p = m), g > f && (g = f), e = p, t = g;
    }
    const r = this.gos.isDomLayout("normal"), i = this.gos.get("suppressMaxRenderedRowRestriction"), n = Math.max(this.getRowBuffer(), 500);
    r && !i && t - e > n && (t = e + n);
    const o = e !== this.firstRenderedRow, s = t !== this.lastRenderedRow;
    if (o || s) {
      this.firstRenderedRow = e, this.lastRenderedRow = t;
      const a = {
        type: A.EVENT_VIEWPORT_CHANGED,
        firstRow: e,
        lastRow: t
      };
      this.eventService.dispatchEvent(a);
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired)
      return;
    this.dataFirstRenderedFired = !0;
    const e = {
      type: A.EVENT_FIRST_DATA_RENDERED,
      firstRow: this.firstRenderedRow,
      lastRow: this.lastRenderedRow
    };
    window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent(e);
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    const r = this.paginationProxy.ensureRowHeightsValid(e, t, -1, -1);
    return r && this.updateContainerHeights(), r;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getLastVisibleVerticalPixel() {
    return this.lastVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const i = e.getRowNode(), n = this.focusService.isRowNodeFocused(i), o = e.isEditing(), s = i.detail;
    return n || o || s ? !!this.paginationProxy.isRowPresent(i) : !1;
  }
  createRowCon(e, t, r) {
    const i = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (i)
      return i;
    const n = this.gos.get("suppressAnimationFrame"), o = r && !n && !this.printLayout;
    return new Ks(
      e,
      this.beans,
      t,
      o,
      this.printLayout
    );
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: r } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[r];
        break;
      case "bottom":
        t = this.bottomRowCtrls[r];
        break;
      default:
        t = this.rowCtrlsByRowIndex[r], t || (t = this.getStickyTopRowCtrls().find((i) => i.getRowNode().rowIndex === r) || null, t || (t = this.getStickyBottomRowCtrls().find((i) => i.getRowNode().rowIndex === r) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const i = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !i;
  }
};
v([
  T("animationFrameService")
], Ei.prototype, "animationFrameService", 2);
v([
  T("paginationProxy")
], Ei.prototype, "paginationProxy", 2);
v([
  T("columnModel")
], Ei.prototype, "columnModel", 2);
v([
  T("pinnedRowModel")
], Ei.prototype, "pinnedRowModel", 2);
v([
  T("rowModel")
], Ei.prototype, "rowModel", 2);
v([
  T("focusService")
], Ei.prototype, "focusService", 2);
v([
  T("beans")
], Ei.prototype, "beans", 2);
v([
  T("rowContainerHeightService")
], Ei.prototype, "rowContainerHeightService", 2);
v([
  T("ctrlsService")
], Ei.prototype, "ctrlsService", 2);
v([
  te
], Ei.prototype, "postConstruct", 1);
Ei = v([
  de("rowRenderer")
], Ei);
var $se = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.getRowNode() != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, r = this.entriesMap[t];
    delete this.entriesMap[t], Xr(this.entriesList, r);
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], Xr(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}, Vd = class extends Q {
  init() {
    this.setPinnedTopRowData(), this.setPinnedBottomRowData(), this.addManagedPropertyListener("pinnedTopRowData", () => this.setPinnedTopRowData()), this.addManagedPropertyListener("pinnedBottomRowData", () => this.setPinnedBottomRowData());
  }
  isEmpty(e) {
    const t = e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    return Ni(t);
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  getRowAtPixel(e, t) {
    const r = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (Ni(r))
      return 0;
    for (let i = 0; i < r.length; i++) {
      const n = r[i];
      if (n.rowTop + n.rowHeight - 1 >= e)
        return i;
    }
    return r.length - 1;
  }
  setPinnedTopRowData() {
    const e = this.gos.get("pinnedTopRowData");
    this.pinnedTopRows = this.createNodesFromData(e, !0);
    const t = {
      type: A.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  setPinnedBottomRowData() {
    const e = this.gos.get("pinnedBottomRowData");
    this.pinnedBottomRows = this.createNodesFromData(e, !1);
    const t = {
      type: A.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  createNodesFromData(e, t) {
    const r = [];
    if (e) {
      let i = 0;
      e.forEach((n, o) => {
        const s = new Ve(this.beans);
        s.data = n;
        const a = t ? Ve.ID_PREFIX_TOP_PINNED : Ve.ID_PREFIX_BOTTOM_PINNED;
        s.id = a + o, s.rowPinned = t ? "top" : "bottom", s.setRowTop(i), s.setRowHeight(this.gos.getRowHeightForNode(s).height), s.setRowIndex(o), i += s.rowHeight, r.push(s);
      });
    }
    return r;
  }
  getPinnedTopRowData() {
    return this.pinnedTopRows;
  }
  getPinnedBottomRowData() {
    return this.pinnedBottomRows;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows[e];
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows[e];
  }
  forEachPinnedTopRow(e) {
    Ni(this.pinnedTopRows) || this.pinnedTopRows.forEach(e);
  }
  forEachPinnedBottomRow(e) {
    Ni(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(e);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getTotalHeight(e) {
    if (!e || e.length === 0)
      return 0;
    const t = ze(e);
    return t.rowTop + t.rowHeight;
  }
};
v([
  T("beans")
], Vd.prototype, "beans", 2);
v([
  te
], Vd.prototype, "init", 1);
Vd = v([
  de("pinnedRowModel")
], Vd);
var ov = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  // can be set inactive by:
  // a) ClientSideRowModel, if no transactions or
  // b) PivotService, if secondary columns changed
  setInactive() {
    this.active = !1;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children)
      for (let r = 0; r < e.children.length; r++)
        this.depthFirstSearchChangedPath(e.children[r], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, r) {
    if (e.childrenAfterGroup)
      for (let i = 0; i < e.childrenAfterGroup.length; i++) {
        const n = e.childrenAfterGroup[i];
        n.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[i], t, r) : r && t(n);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, r = !1) {
    this.active && !r ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, r = 0;
    for (; !this.mapToItems[t.id]; ) {
      const i = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = i, r++, t = t.parent;
    }
    return r;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let r = e;
    for (; r; )
      this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach((i) => this.nodeIdsToColumns[r.id][i.getId()] = !0), r = r.parent;
  }
  linkPathItems(e, t) {
    let r = e;
    for (let i = 0; i < t; i++) {
      const n = this.mapToItems[r.id], o = this.mapToItems[r.parent.id];
      o.children || (o.children = []), o.children.push(n), r = r.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const r = this.createPathItems(e);
    this.linkPathItems(e, r), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((n) => r[n.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((n) => !r[n.getId()]);
  }
}, Yu = class Ps extends Q {
  constructor(t) {
    super(), this.state = Ps.STATE_WAITING_TO_LOAD, this.version = 0, this.id = t;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = Ps.STATE_LOADING, this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++, this.state = Ps.STATE_WAITING_TO_LOAD;
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(t) {
    this.isRequestMostRecentAndLive(t) && (this.state = Ps.STATE_FAILED, this.processServerFail()), this.dispatchLoadCompleted(!1);
  }
  success(t, r) {
    this.successCommon(t, r);
  }
  pageLoaded(t, r, i) {
    this.successCommon(t, { rowData: r, rowCount: i });
  }
  isRequestMostRecentAndLive(t) {
    const r = t === this.version, i = this.isAlive();
    return r && i;
  }
  successCommon(t, r) {
    this.dispatchLoadCompleted(), this.isRequestMostRecentAndLive(t) && (this.state = Ps.STATE_LOADED, this.processServerResult(r));
  }
  dispatchLoadCompleted(t = !0) {
    const r = {
      type: Ps.EVENT_LOAD_COMPLETE,
      success: t,
      block: this
    };
    this.dispatchEvent(r);
  }
};
Yu.EVENT_LOAD_COMPLETE = "loadComplete";
Yu.STATE_WAITING_TO_LOAD = "needsLoading";
Yu.STATE_LOADING = "loading";
Yu.STATE_LOADED = "loaded";
Yu.STATE_FAILED = "failed";
var Yb = Yu, zn = class extends Q {
  constructor() {
    super(...arguments), this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = Ae.debounce(this.performCheckBlocksToLoad.bind(this), e));
  }
  setBeans(e) {
    this.logger = e.create("RowNodeBlockLoader");
  }
  getMaxConcurrentDatasourceRequests() {
    const e = this.gos.get("maxConcurrentDatasourceRequests");
    if (e == null)
      return 2;
    if (!(e <= 0))
      return e;
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener(Yb.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    Ae.removeFromArray(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchEvent({ type: zn.BLOCK_LOADED_EVENT }), this.activeBlockLoadsCount == 0 && this.dispatchEvent({ type: zn.BLOCK_LOADER_FINISHED_EVENT });
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.logger.log("checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.getAvailableLoadingCount(), t = this.blocks.filter((r) => r.getState() === Yb.STATE_WAITING_TO_LOAD).slice(0, e);
    this.registerLoads(t.length), t.forEach((r) => r.load()), this.printCacheStatus();
  }
  getBlockState() {
    if (this.gos.isRowModelType("serverSide"))
      return this.rowModel.getBlockStates();
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: r, state: i } = t.getBlockStateJson();
      e[r] = i;
    }), e;
  }
  printCacheStatus() {
    this.logger.isLogging() && this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`);
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(e) {
    this.activeBlockLoadsCount += e;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
};
zn.BLOCK_LOADED_EVENT = "blockLoaded";
zn.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished";
v([
  T("rowModel")
], zn.prototype, "rowModel", 2);
v([
  te
], zn.prototype, "postConstruct", 1);
v([
  an(0, Gi("loggerFactory"))
], zn.prototype, "setBeans", 1);
zn = v([
  de("rowNodeBlockLoader")
], zn);
var Hd = class extends Q {
  constructor() {
    super(...arguments), this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.pixelOffset = 0, this.masterRowCount = 0;
  }
  postConstruct() {
    this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedListener(this.eventService, A.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this)), this.onModelUpdated();
  }
  ensureRowHeightsValid(e, t, r, i) {
    const n = this.rowModel.ensureRowHeightsValid(e, t, this.getPageFirstRow(), this.getPageLastRow());
    return n && this.calculatePages(), n;
  }
  isPaginateChildRows() {
    return this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren") ? !0 : this.gos.get("paginateChildRows");
  }
  onModelUpdated(e) {
    this.calculatePages();
    const t = {
      type: A.EVENT_PAGINATION_CHANGED,
      animate: e ? e.animate : !1,
      newData: e ? e.newData : !1,
      newPage: e ? e.newPage : !1,
      newPageSize: e ? e.newPageSize : !1,
      keepRenderedRows: e ? e.keepRenderedRows : !1
    };
    this.eventService.dispatchEvent(t);
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages();
    const e = {
      type: A.EVENT_PAGINATION_CHANGED,
      animate: !1,
      newData: !1,
      newPage: !1,
      newPageSize: !1,
      // important to keep rendered rows, otherwise every time grid is resized,
      // we would destroy all the rows.
      keepRenderedRows: !0
    };
    this.eventService.dispatchEvent(e);
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    if (!this.active || this.currentPage === e || typeof this.currentPage != "number")
      return;
    this.currentPage = e, this.calculatePages();
    const t = {
      type: A.EVENT_PAGINATION_CHANGED,
      animate: !1,
      newData: !1,
      newPage: !0,
      newPageSize: !1,
      keepRenderedRows: !1
    };
    this.eventService.dispatchEvent(t);
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  getRow(e) {
    return this.rowModel.getRow(e);
  }
  getRowNode(e) {
    return this.rowModel.getRowNode(e);
  }
  getRowIndexAtPixel(e) {
    return this.rowModel.getRowIndexAtPixel(e);
  }
  getCurrentPageHeight() {
    return Re(this.topRowBounds) || Re(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex : !1;
  }
  isEmpty() {
    return this.rowModel.isEmpty();
  }
  isRowsToRender() {
    return this.rowModel.isRowsToRender();
  }
  forEachNode(e) {
    return this.rowModel.forEachNode(e);
  }
  forEachNodeOnPage(e) {
    const t = this.getPageFirstRow(), r = this.getPageLastRow();
    for (let i = t; i <= r; i++) {
      const n = this.getRow(i);
      n && e(n);
    }
  }
  getType() {
    return this.rowModel.getType();
  }
  getRowBounds(e) {
    const t = this.rowModel.getRowBounds(e);
    return t.rowIndex = e, t;
  }
  getPageFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getPageLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getRowCount() {
    return this.rowModel.getRowCount();
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  isLastPageFound() {
    return this.rowModel.isLastRowIndexKnown();
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return q(this.pageSizeAutoCalculated) ? this.pageSizeAutoCalculated : q(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : q(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : q(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    if (this.pageSizeAutoCalculated = void 0, this.pageSize === e)
      return;
    this.calculatePages();
    const t = {
      type: A.EVENT_PAGINATION_CHANGED,
      animate: !1,
      newData: !1,
      newPage: !1,
      newPageSize: !0,
      keepRenderedRows: !1
    };
    this.eventService.dispatchEvent(t);
  }
  setPageSize(e, t) {
    const r = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    if (r !== this.pageSize) {
      this.calculatePages();
      const i = {
        type: A.EVENT_PAGINATION_CHANGED,
        animate: !1,
        newData: !1,
        newPage: !1,
        newPageSize: !0,
        keepRenderedRows: !0
      };
      this.eventService.dispatchEvent(i);
    }
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex), this.topRowBounds && (this.topRowBounds.rowIndex = this.topDisplayedRowIndex), this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex), this.setPixelOffset(q(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
  }
  setPixelOffset(e) {
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: A.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let r = this.pageSize * (this.currentPage + 1) - 1;
    if (r > e && (r = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), r === e)
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const i = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
      this.bottomDisplayedRowIndex = i - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
};
v([
  T("rowModel")
], Hd.prototype, "rowModel", 2);
v([
  te
], Hd.prototype, "postConstruct", 1);
Hd = v([
  de("paginationProxy")
], Hd);
var pg = class extends Q {
  processAllCellClasses(e, t, r, i) {
    this.processClassRules(void 0, e.cellClassRules, t, r, i), this.processStaticCellClasses(e, t, r);
  }
  processClassRules(e, t, r, i, n) {
    if (t == null && e == null)
      return;
    const o = {}, s = {}, a = (l, u) => {
      l.split(" ").forEach((c) => {
        c.trim() != "" && u(c);
      });
    };
    if (t) {
      const l = Object.keys(t);
      for (let u = 0; u < l.length; u++) {
        const c = l[u], d = t[c];
        let h;
        typeof d == "string" ? h = this.expressionService.evaluate(d, r) : typeof d == "function" && (h = d(r)), a(c, (p) => {
          h ? o[p] = !0 : s[p] = !0;
        });
      }
    }
    e && n && Object.keys(e).forEach((l) => a(l, (u) => {
      o[u] || (s[u] = !0);
    })), n && Object.keys(s).forEach(n), Object.keys(o).forEach(i);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: r } = e;
    if (!r)
      return [];
    let i;
    return typeof r == "function" ? i = r(t) : i = r, typeof i == "string" && (i = [i]), i || [];
  }
  processStaticCellClasses(e, t, r) {
    this.getStaticCellClasses(e, t).forEach((n) => {
      r(n);
    });
  }
};
v([
  T("expressionService")
], pg.prototype, "expressionService", 2);
pg = v([
  de("stylingService")
], pg);
var YN = class extends jm {
  constructor(e) {
    super(e, "ag-toggle-button");
  }
  setValue(e, t) {
    return super.setValue(e, t), this.addOrRemoveCssClass("ag-selected", this.getValue()), this;
  }
}, jse = class extends un {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const r = super.setValue(e, t);
    return this.eInput.value = e, r;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, zse = class extends _a {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
    const e = jn();
    this.addManagedListener(this.eInput, "mousedown", () => {
      this.isDisabled() || e || this.eInput.focus();
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  setMin(e) {
    var t;
    const r = e instanceof Date ? (t = Bi(e ?? null, !1)) != null ? t : void 0 : e;
    return this.min === r ? this : (this.min = r, Ln(this.eInput, "min", r), this);
  }
  setMax(e) {
    var t;
    const r = e instanceof Date ? (t = Bi(e ?? null, !1)) != null ? t : void 0 : e;
    return this.max === r ? this : (this.max = r, Ln(this.eInput, "max", r), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ln(this.eInput, "step", e), this);
  }
  getDate() {
    var e;
    if (this.eInput.validity.valid)
      return (e = Jr(this.getValue())) != null ? e : void 0;
  }
  setDate(e, t) {
    this.setValue(Bi(e ?? null, !1), t);
  }
}, Use = class extends un {
  constructor(e) {
    super(e, "ag-range-field", "range");
  }
  postConstruct() {
    super.postConstruct();
    const { min: e, max: t, step: r } = this.config;
    e != null && this.setMinValue(e), t != null && this.setMaxValue(t), this.setStep(r || 1);
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => {
      const t = e.target.value;
      this.setValue(t);
    });
  }
  setMinValue(e) {
    return this.min = e, this.eInput.setAttribute("min", e.toString()), this;
  }
  setMaxValue(e) {
    return this.max = e, this.eInput.setAttribute("max", e.toString()), this;
  }
  setStep(e) {
    return this.eInput.setAttribute("step", e.toString()), this;
  }
  setValue(e, t) {
    this.min != null && (e = Math.max(parseFloat(e), this.min).toString()), this.max != null && (e = Math.min(parseFloat(e), this.max).toString());
    const r = super.setValue(e, t);
    return this.eInput.value = e, r;
  }
}, PE = class extends Oe {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-rich-select-row" role="presentation"></div>'
    ), this.params = e, this.wrapperEl = t;
  }
  postConstruct() {
    this.addManagedListener(this.getGui(), "click", this.onClick.bind(this));
  }
  setState(e) {
    let t = "";
    this.params.valueFormatter && (t = this.params.valueFormatter(e)), this.populateWithRenderer(e, t) || this.populateWithoutRenderer(e, t), this.value = e;
  }
  highlightString(e) {
    const { parsedValue: t } = this;
    if (this.params.cellRenderer || !q(t))
      return;
    let r = q(e);
    if (r) {
      const i = t == null ? void 0 : t.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
      if (i >= 0) {
        const n = i + e.length, o = Yt(t.slice(0, i), !0), s = Yt(t.slice(i, n), !0), a = Yt(t.slice(n));
        this.renderValueWithoutRenderer(`${o}<span class="ag-rich-select-row-text-highlight">${s}</span>${a}`);
      } else
        r = !1;
    }
    r || this.renderValueWithoutRenderer(t);
  }
  updateHighlighted(e) {
    var t;
    const r = this.getGui(), i = `ag-rich-select-row-${this.getCompId()}`;
    if ((t = r.parentElement) == null || t.setAttribute("id", i), e) {
      const n = this.getParentComponent().getAriaElement();
      WS(n, i), this.wrapperEl.setAttribute("data-active-option", i);
    }
    Zl(r.parentElement, e), this.addOrRemoveCssClass("ag-rich-select-row-selected", e);
  }
  populateWithoutRenderer(e, t) {
    const r = this.gos.getDocument(), i = this.getGui(), n = r.createElement("span");
    n.style.overflow = "hidden", n.style.textOverflow = "ellipsis";
    const o = Yt(q(t) ? t : e, !0);
    this.parsedValue = q(o) ? o : null, i.appendChild(n), this.renderValueWithoutRenderer(o), this.setTooltip({
      newTooltipText: this.parsedValue,
      shouldDisplayTooltip: () => n.scrollWidth > n.clientWidth
    });
  }
  renderValueWithoutRenderer(e) {
    const t = this.getGui().querySelector("span");
    t && (t.innerHTML = q(e) ? e : "&nbsp;");
  }
  populateWithRenderer(e, t) {
    let r, i;
    return this.params.cellRenderer && (i = this.userComponentFactory.getCellRendererDetails(this.params, {
      value: e,
      valueFormatted: t,
      setTooltip: (n, o) => {
        this.setTooltip({ newTooltipText: n, shouldDisplayTooltip: o });
      }
    })), i && (r = i.newAgStackInstance()), r && aE(r, this.getGui()), r ? (r.then((n) => {
      this.addDestroyFunc(() => {
        this.getContext().destroyBean(n);
      });
    }), !0) : !1;
  }
  onClick() {
    const e = this.getParentComponent(), t = {
      type: A.EVENT_FIELD_PICKER_VALUE_SELECTED,
      fromEnterKey: !1,
      value: this.value
    };
    e == null || e.dispatchEvent(t);
  }
};
v([
  T("userComponentFactory")
], PE.prototype, "userComponentFactory", 2);
v([
  te
], PE.prototype, "postConstruct", 1);
var Mh = class XN extends Ih {
  constructor(t) {
    super(XN.getTemplate((t == null ? void 0 : t.cssIdentifier) || "default")), this.renderedRows = /* @__PURE__ */ new Map(), this.rowHeight = 20, this.pageSize = -1, this.isScrolling = !1, this.isHeightFromTheme = !0;
    const { cssIdentifier: r = "default", ariaRole: i = "listbox", listName: n } = t || {};
    this.cssIdentifier = r, this.ariaRole = i, this.listName = n;
  }
  postConstruct() {
    this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
      onFocusIn: (t) => this.onFocusIn(t),
      onFocusOut: (t) => this.onFocusOut(t),
      focusInnerElement: (t) => this.focusInnerElement(t),
      onTabKeyDown: (t) => this.onTabKeyDown(t),
      handleKeyDown: (t) => this.handleKeyDown(t)
    }), this.setAriaProperties(), this.addManagedListener(this.eventService, A.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanged.bind(this));
  }
  onGridStylesChanged() {
    this.rowHeight = this.getItemHeight(), this.refresh();
  }
  setAriaProperties() {
    const r = this.localeService.getLocaleTextFunc()("ariaDefaultListName", this.listName || "List"), i = this.eContainer;
    Nt(i, this.ariaRole), Si(i, r);
  }
  addResizeObserver() {
    const t = () => this.animationFrameService.requestAnimationFrame(() => this.drawVirtualRows()), r = this.resizeObserverService.observeResize(this.getGui(), t);
    this.addDestroyFunc(r);
  }
  focusInnerElement(t) {
    this.focusRow(t ? this.model.getRowCount() - 1 : 0);
  }
  onFocusIn(t) {
    const r = t.target;
    r.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = i_(r) - 1);
  }
  onFocusOut(t) {
    this.getFocusableElement().contains(t.relatedTarget) || (this.lastFocusedRowIndex = null);
  }
  handleKeyDown(t) {
    switch (t.key) {
      case k.UP:
      case k.DOWN:
        this.navigate(t.key === k.UP) && t.preventDefault();
        break;
      case k.PAGE_HOME:
      case k.PAGE_END:
      case k.PAGE_UP:
      case k.PAGE_DOWN:
        this.navigateToPage(t.key) !== null && t.preventDefault();
        break;
    }
  }
  onTabKeyDown(t) {
    this.navigate(t.shiftKey) ? t.preventDefault() : (gn(t), this.forceFocusOutOfContainer(t.shiftKey));
  }
  navigate(t) {
    if (this.lastFocusedRowIndex == null)
      return !1;
    const r = this.lastFocusedRowIndex + (t ? -1 : 1);
    return r < 0 || r >= this.model.getRowCount() ? !1 : (this.focusRow(r), !0);
  }
  navigateToPage(t, r = "focused") {
    let i = !1;
    r === "focused" && (r = this.getLastFocusedRow(), i = !0);
    const n = this.model.getRowCount() - 1;
    let o = -1;
    return t === k.PAGE_HOME ? o = 0 : t === k.PAGE_END ? o = n : t === k.PAGE_DOWN ? o = Math.min(r + this.pageSize, n) : t === k.PAGE_UP && (o = Math.max(r - this.pageSize, 0)), o === -1 ? null : (i ? this.focusRow(o) : this.ensureIndexVisible(o), o);
  }
  getLastFocusedRow() {
    return this.lastFocusedRowIndex;
  }
  focusRow(t) {
    this.isScrolling || (this.isScrolling = !0, this.ensureIndexVisible(t), this.animationFrameService.requestAnimationFrame(() => {
      if (this.isScrolling = !1, !this.isAlive())
        return;
      const r = this.renderedRows.get(t);
      r && r.eDiv.focus();
    }));
  }
  getComponentAt(t) {
    const r = this.renderedRows.get(t);
    return r && r.rowComponent;
  }
  forEachRenderedRow(t) {
    this.renderedRows.forEach((r, i) => t(r.rowComponent, i));
  }
  static getTemplate(t) {
    return (
      /* html */
      `<div class="ag-virtual-list-viewport ag-${t}-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-${t}-virtual-list-container" ref="eContainer"></div>
            </div>`
    );
  }
  getItemHeight() {
    return this.isHeightFromTheme ? this.environment.getListItemHeight() : this.rowHeight;
  }
  /**
   * Returns true if the view had to be scrolled, otherwise, false.
   */
  ensureIndexVisible(t, r = !0) {
    const i = this.model.getRowCount();
    if (typeof t != "number" || t < 0 || t >= i)
      return console.warn("AG Grid: invalid row index for ensureIndexVisible: " + t), !1;
    const n = t * this.rowHeight, o = n + this.rowHeight, s = this.getGui(), a = s.scrollTop, l = s.offsetHeight, u = a + l, c = r ? 0 : this.rowHeight, d = a > n + c, h = u < o - c;
    if (d)
      return s.scrollTop = n, !0;
    if (h) {
      const p = o - l;
      return s.scrollTop = p, !0;
    }
    return !1;
  }
  setComponentCreator(t) {
    this.componentCreator = t;
  }
  setComponentUpdater(t) {
    this.componentUpdater = t;
  }
  getRowHeight() {
    return this.rowHeight;
  }
  getScrollTop() {
    return this.getGui().scrollTop;
  }
  setRowHeight(t) {
    this.isHeightFromTheme = !1, this.rowHeight = t, this.refresh();
  }
  refresh(t) {
    if (this.model == null || !this.isAlive())
      return;
    const r = this.model.getRowCount();
    this.eContainer.style.height = `${r * this.rowHeight}px`, NS(
      () => this.eContainer.clientHeight >= r * this.rowHeight,
      () => {
        this.isAlive() && (this.canSoftRefresh(t) ? this.drawVirtualRows(!0) : (this.clearVirtualRows(), this.drawVirtualRows()));
      }
    );
  }
  canSoftRefresh(t) {
    return !!(t && this.renderedRows.size && typeof this.model.areRowsEqual == "function" && this.componentUpdater);
  }
  clearVirtualRows() {
    this.renderedRows.forEach((t, r) => this.removeRow(r));
  }
  drawVirtualRows(t) {
    if (!this.isAlive() || !this.model)
      return;
    const r = this.getGui(), i = r.scrollTop, n = i + r.offsetHeight, o = Math.floor(i / this.rowHeight), s = Math.floor(n / this.rowHeight);
    this.pageSize = Math.floor((n - i) / this.rowHeight), this.ensureRowsRendered(o, s, t);
  }
  ensureRowsRendered(t, r, i) {
    this.renderedRows.forEach((n, o) => {
      (o < t || o > r) && o !== this.lastFocusedRowIndex && this.removeRow(o);
    }), i && this.refreshRows();
    for (let n = t; n <= r; n++)
      this.renderedRows.has(n) || n < this.model.getRowCount() && this.insertRow(n);
  }
  insertRow(t) {
    const r = this.model.getRow(t), i = document.createElement("div");
    i.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`), Nt(i, this.ariaRole === "tree" ? "treeitem" : "option"), _m(i, this.model.getRowCount()), Nm(i, t + 1), i.setAttribute("tabindex", "-1"), i.style.height = `${this.rowHeight}px`, i.style.top = `${this.rowHeight * t}px`;
    const n = this.componentCreator(r, i);
    n.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = t), i.appendChild(n.getGui()), this.renderedRows.has(t - 1) ? this.renderedRows.get(t - 1).eDiv.insertAdjacentElement("afterend", i) : this.renderedRows.has(t + 1) ? this.renderedRows.get(t + 1).eDiv.insertAdjacentElement("beforebegin", i) : this.eContainer.appendChild(i), this.renderedRows.set(t, { rowComponent: n, eDiv: i, value: r });
  }
  removeRow(t) {
    const r = this.renderedRows.get(t);
    this.eContainer.removeChild(r.eDiv), this.destroyBean(r.rowComponent), this.renderedRows.delete(t);
  }
  refreshRows() {
    const t = this.model.getRowCount();
    this.renderedRows.forEach((r, i) => {
      var n, o;
      if (i >= t)
        this.removeRow(i);
      else {
        const s = this.model.getRow(i);
        (o = (n = this.model).areRowsEqual) != null && o.call(n, r.value, s) ? this.componentUpdater(s, r.rowComponent) : this.removeRow(i);
      }
    });
  }
  addScrollListener() {
    this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: !0 });
  }
  setModel(t) {
    this.model = t;
  }
  getAriaElement() {
    return this.eContainer;
  }
  destroy() {
    this.isAlive() && (this.clearVirtualRows(), super.destroy());
  }
};
v([
  T("resizeObserverService")
], Mh.prototype, "resizeObserverService", 2);
v([
  T("animationFrameService")
], Mh.prototype, "animationFrameService", 2);
v([
  ne("eContainer")
], Mh.prototype, "eContainer", 2);
v([
  te
], Mh.prototype, "postConstruct", 1);
var KN = Mh, Yse = (
  /* html */
  `
    <div class="ag-picker-field" role="presentation">
        <div ref="eLabel"></div>
            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-rich-select-value ag-picker-collapsed">
            <div ref="eDisplayField" class="ag-picker-field-display"></div>
            <ag-input-text-field ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
        </div>
    </div>`
), sv = class extends Fa {
  constructor(e) {
    var t, r;
    super(Dt(Ce({
      pickerAriaLabelKey: "ariaLabelRichSelectField",
      pickerAriaLabelValue: "Rich Select Field",
      pickerType: "ag-list",
      className: "ag-rich-select",
      pickerIcon: "smallDown",
      ariaRole: "combobox",
      template: (t = e == null ? void 0 : e.template) != null ? t : Yse,
      modalPicker: !1
    }, e), {
      // maxPickerHeight needs to be set after expanding `config`
      maxPickerHeight: (r = e == null ? void 0 : e.maxPickerHeight) != null ? r : "calc(var(--ag-row-height) * 6.5)"
    })), this.searchString = "", this.highlightedItem = -1, this.lastRowHovered = -1, this.searchStringCreator = null;
    const { cellRowHeight: i, value: n, valueList: o, searchStringCreator: s } = e || {};
    i != null && (this.cellRowHeight = i), n !== void 0 && (this.value = n), o != null && (this.values = o), s && (this.searchStringCreator = s);
  }
  postConstruct() {
    super.postConstruct(), this.createLoadingElement(), this.createListComponent();
    const { allowTyping: e, placeholder: t } = this.config;
    e ? (this.eInput.setAutoComplete(!1).setInputPlaceholder(t), this.eDisplayField.classList.add("ag-hidden")) : this.eInput.setDisplayed(!1), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { searchDebounceDelay: r = 300 } = this.config;
    this.clearSearchString = kr(this.clearSearchString, r), this.renderSelectedValue(), e && (this.eInput.onValueChange((i) => this.searchTextFromString(i)), this.addManagedListener(this.eWrapper, "focus", this.onWrapperFocus.bind(this))), this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this));
  }
  createLoadingElement() {
    const e = this.gos.getDocument(), t = this.localeService.getLocaleTextFunc(), r = e.createElement("div");
    r.classList.add("ag-loading-text"), r.innerText = t("loadingOoo", "Loading..."), this.eLoading = r;
  }
  createListComponent() {
    this.listComponent = this.createBean(new KN({ cssIdentifier: "rich-select" })), this.listComponent.setComponentCreator(this.createRowComponent.bind(this));
    const e = (a, l) => {
    };
    this.listComponent.setComponentUpdater(e), this.listComponent.setParentComponent(this), this.addManagedListener(this.listComponent, A.EVENT_FIELD_PICKER_VALUE_SELECTED, (a) => {
      this.onListValueSelected(a.value, a.fromEnterKey);
    });
    const { cellRowHeight: t } = this;
    t && this.listComponent.setRowHeight(t);
    const r = this.listComponent.getGui(), i = this.listComponent.getAriaElement();
    this.addManagedListener(r, "mousemove", this.onPickerMouseMove.bind(this)), this.addManagedListener(r, "mousedown", (a) => a.preventDefault()), r.classList.add("ag-rich-select-list");
    const n = `ag-rich-select-list-${this.listComponent.getCompId()}`;
    i.setAttribute("id", n);
    const s = this.localeService.getLocaleTextFunc()(this.config.pickerAriaLabelKey, this.config.pickerAriaLabelValue);
    Si(i, s), zS(this.eWrapper, i);
  }
  renderSelectedValue() {
    const { value: e, eDisplayField: t, config: r } = this, { allowTyping: i, initialInputValue: n } = this.config, o = this.config.valueFormatter ? this.config.valueFormatter(e) : e;
    if (i) {
      this.eInput.setValue(n ?? o);
      return;
    }
    let s;
    r.cellRenderer && (s = this.userComponentFactory.getCellRendererDetails(this.config, {
      value: e,
      valueFormatted: o
    }));
    let a;
    if (s && (a = s.newAgStackInstance()), a)
      Ht(t), aE(a, t), a.then((l) => {
        this.addDestroyFunc(() => this.getContext().destroyBean(l));
      });
    else {
      if (q(this.value))
        t.innerText = o, t.classList.remove("ag-display-as-placeholder");
      else {
        const { placeholder: l } = r;
        q(l) ? (t.innerHTML = `${Yt(l)}`, t.classList.add("ag-display-as-placeholder")) : Ht(t);
      }
      this.setTooltip({
        newTooltipText: o ?? null,
        shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
      });
    }
  }
  getCurrentValueIndex() {
    const { currentList: e, value: t } = this;
    if (t == null || !e)
      return -1;
    for (let r = 0; r < e.length; r++)
      if (e[r] === t)
        return r;
    return -1;
  }
  highlightFilterMatch() {
    var e;
    (e = this.listComponent) == null || e.forEachRenderedRow((t, r) => {
      t.highlightString(this.searchString);
    });
  }
  highlightSelectedValue(e) {
    var t;
    e == null && (e = this.getCurrentValueIndex()), this.highlightedItem = e, (t = this.listComponent) == null || t.forEachRenderedRow((r, i) => {
      const n = e === -1 ? !1 : this.highlightedItem === i;
      r.updateHighlighted(n);
    });
  }
  setRowHeight(e) {
    e !== this.cellRowHeight && (this.cellRowHeight = e), this.listComponent && this.listComponent.setRowHeight(e);
  }
  createPickerComponent() {
    const { values: e } = this;
    return e && this.setValueList({ valueList: e }), this.listComponent;
  }
  setSearchStringCreator(e) {
    this.searchStringCreator = e;
  }
  setValueList(e) {
    const { valueList: t, refresh: r } = e;
    this.listComponent && this.currentList !== t && (this.currentList = t, this.listComponent.setModel({
      getRowCount: () => t.length,
      getRow: (i) => t[i],
      areRowsEqual: (i, n) => i === n
    }), r && (this.values ? this.listComponent.refresh(!0) : (this.values = t, this.isPickerDisplayed && this.showCurrentValueInPicker())));
  }
  showPicker() {
    super.showPicker(), this.showCurrentValueInPicker(), this.displayOrHidePicker();
  }
  showCurrentValueInPicker() {
    var e, t;
    if (!this.listComponent)
      return;
    if (!this.currentList) {
      this.isPickerDisplayed && this.eLoading && this.listComponent.appendChild(this.eLoading);
      return;
    }
    (e = this.eLoading) != null && e.offsetParent && ((t = this.eLoading.parentElement) == null || t.removeChild(this.eLoading));
    const r = this.getCurrentValueIndex();
    r !== -1 ? (this.listComponent.refresh(), this.listComponent.ensureIndexVisible(r), this.listComponent.refresh(!0), this.highlightSelectedValue(r)) : this.listComponent.refresh();
  }
  beforeHidePicker() {
    this.highlightedItem = -1, super.beforeHidePicker();
  }
  onWrapperFocus() {
    if (!this.eInput)
      return;
    const e = this.eInput.getFocusableElement();
    e.focus(), e.select();
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  buildSearchStringFromKeyboardEvent(e) {
    let { key: t } = e;
    if (t === k.BACKSPACE)
      this.searchString = this.searchString.slice(0, -1), t = "";
    else if (!Vm(e))
      return;
    e.preventDefault(), this.searchTextFromCharacter(t);
  }
  searchTextFromCharacter(e) {
    this.searchString += e, this.runSearch(), this.clearSearchString();
  }
  searchTextFromString(e) {
    e == null && (e = ""), this.searchString = e, this.runSearch();
  }
  buildSearchStrings(e) {
    const { valueFormatter: t = (i) => i } = this.config;
    let r;
    return typeof e[0] == "number" || typeof e[0] == "string" ? r = e.map((i) => t(i)) : typeof e[0] == "object" && this.searchStringCreator && (r = this.searchStringCreator(e)), r;
  }
  getSuggestionsAndFilteredValues(e, t) {
    let r = [], i = [];
    if (!e.length)
      return { suggestions: r, filteredValues: i };
    const { searchType: n = "fuzzy", filterList: o } = this.config;
    if (n === "fuzzy") {
      const s = wh(this.searchString, t, !0);
      r = s.values;
      const a = s.indices;
      if (o && a.length)
        for (let l = 0; l < a.length; l++)
          i.push(this.values[a[l]]);
    } else
      r = t.filter((s, a) => {
        const l = s.toLocaleLowerCase(), u = this.searchString.toLocaleLowerCase(), c = n === "match" ? l.startsWith(u) : l.indexOf(u) !== -1;
        return o && c && i.push(this.values[a]), c;
      });
    return { suggestions: r, filteredValues: i };
  }
  filterListModel(e) {
    const { filterList: t } = this.config;
    t && (this.setValueList({ valueList: e, refresh: !0 }), this.alignPickerToComponent());
  }
  runSearch() {
    var e, t;
    const { values: r } = this, i = this.buildSearchStrings(r);
    if (!i) {
      this.highlightSelectedValue(-1);
      return;
    }
    const { suggestions: n, filteredValues: o } = this.getSuggestionsAndFilteredValues(this.searchString, i), { filterList: s, highlightMatch: a, searchType: l = "fuzzy" } = this.config, u = o.length, c = !!(s && this.searchString !== "");
    if (this.filterListModel(c ? o : r), n.length) {
      const d = c ? 0 : i.indexOf(n[0]);
      this.selectListItem(d);
    } else if (this.highlightSelectedValue(-1), !c || u)
      (e = this.listComponent) == null || e.ensureIndexVisible(0);
    else if (c) {
      this.getAriaElement().removeAttribute("data-active-option");
      const d = (t = this.listComponent) == null ? void 0 : t.getAriaElement();
      d && WS(d, null);
    }
    a && l !== "fuzzy" && this.highlightFilterMatch(), this.displayOrHidePicker();
  }
  displayOrHidePicker() {
    var e;
    const t = (e = this.listComponent) == null ? void 0 : e.getGui(), r = this.currentList ? this.currentList.length === 0 : !1;
    t == null || t.classList.toggle("ag-hidden", r);
  }
  clearSearchString() {
    this.searchString = "";
  }
  selectListItem(e, t) {
    if (!this.isPickerDisplayed || !this.currentList || !this.listComponent || e < 0 || e >= this.currentList.length)
      return;
    this.listComponent.ensureIndexVisible(e, !t) && !t && this.listComponent.refresh(!0), this.highlightSelectedValue(e);
  }
  setValue(e, t, r) {
    const i = this.currentList ? this.currentList.indexOf(e) : -1;
    return i === -1 ? this : (this.value = e, r || this.selectListItem(i), this.renderSelectedValue(), super.setValue(e, t));
  }
  createRowComponent(e) {
    const t = new PE(this.config, this.eWrapper);
    t.setParentComponent(this.listComponent), this.getContext().createBean(t), t.setState(e);
    const { highlightMatch: r, searchType: i = "fuzzy" } = this.config;
    return r && i !== "fuzzy" && t.highlightString(this.searchString), t;
  }
  getRowForMouseEvent(e) {
    const { listComponent: t } = this;
    if (!t)
      return -1;
    const i = (t == null ? void 0 : t.getGui()).getBoundingClientRect(), n = t.getScrollTop(), o = e.clientY - i.top + n;
    return Math.floor(o / t.getRowHeight());
  }
  onPickerMouseMove(e) {
    if (!this.listComponent)
      return;
    const t = this.getRowForMouseEvent(e);
    t !== -1 && t != this.lastRowHovered && (this.lastRowHovered = t, this.selectListItem(t, !0));
  }
  onNavigationKeyDown(e, t) {
    e.preventDefault();
    const r = t === k.DOWN;
    if (!this.isPickerDisplayed && r) {
      this.showPicker();
      return;
    }
    const i = this.highlightedItem, o = i === -1 ? 0 : i + (r ? 1 : -1);
    this.selectListItem(o);
  }
  onPageNavigation(e) {
    var t;
    if (!this.isPickerDisplayed)
      return;
    const r = (t = this.listComponent) == null ? void 0 : t.navigateToPage(e, this.highlightedItem);
    r != null && this.animationFrameService.requestAnimationFrame(() => {
      if (!this.isAlive())
        return null;
      this.highlightSelectedValue(r);
    });
  }
  onEnterKeyDown(e) {
    this.isPickerDisplayed && (e.preventDefault(), this.currentList && this.onListValueSelected(this.currentList[this.highlightedItem], !0));
  }
  onTabKeyDown() {
    !this.isPickerDisplayed || !this.currentList || this.setValue(this.currentList[this.highlightedItem], !1, !0);
  }
  onListValueSelected(e, t) {
    this.setValue(e, !1, !0), this.dispatchPickerEvent(e, t), this.hidePicker();
  }
  dispatchPickerEvent(e, t) {
    const r = {
      type: A.EVENT_FIELD_PICKER_VALUE_SELECTED,
      fromEnterKey: t,
      value: e
    };
    this.dispatchEvent(r);
  }
  getFocusableElement() {
    const { allowTyping: e } = this.config;
    return e ? this.eInput.getFocusableElement() : super.getFocusableElement();
  }
  onKeyDown(e) {
    const t = e.key, { allowTyping: r } = this.config;
    switch (t) {
      case k.LEFT:
      case k.RIGHT:
        r || e.preventDefault();
        break;
      case k.PAGE_HOME:
      case k.PAGE_END:
        if (r) {
          e.preventDefault();
          const i = this.eInput.getInputElement(), n = t === k.PAGE_HOME ? 0 : i.value.length;
          i.setSelectionRange(n, n);
          break;
        }
      case k.PAGE_UP:
      case k.PAGE_DOWN:
        e.preventDefault(), this.onPageNavigation(t);
        break;
      case k.DOWN:
      case k.UP:
        this.onNavigationKeyDown(e, t);
        break;
      case k.ESCAPE:
        this.isPickerDisplayed && (ii(this.listComponent.getGui()) && (e.preventDefault(), gn(e)), this.hidePicker());
        break;
      case k.ENTER:
        this.onEnterKeyDown(e);
        break;
      case k.TAB:
        this.onTabKeyDown();
        break;
      default:
        r || this.buildSearchStringFromKeyboardEvent(e);
    }
  }
  destroy() {
    this.listComponent && (this.destroyBean(this.listComponent), this.listComponent = void 0), this.eLoading = void 0, super.destroy();
  }
};
v([
  T("userComponentFactory")
], sv.prototype, "userComponentFactory", 2);
v([
  T("animationFrameService")
], sv.prototype, "animationFrameService", 2);
v([
  ne("eInput")
], sv.prototype, "eInput", 2);
var Xu = class qN extends dE {
  constructor(t) {
    super(t, qN.TEMPLATE), this.labelAlignment = "top";
  }
  init() {
    this.eSlider.addCssClass("ag-slider-field");
    const { minValue: t, maxValue: r, textFieldWidth: i, step: n, value: o, onValueChange: s } = this.config;
    t != null && this.setMinValue(t), r != null && this.setMaxValue(r), i != null && this.setTextFieldWidth(i), n != null && this.setStep(n), o != null && this.setValue(o), s != null && this.onValueChange(s);
  }
  onValueChange(t) {
    const r = A.EVENT_FIELD_VALUE_CHANGED;
    return this.addManagedListener(this.eText, r, () => {
      const i = parseFloat(this.eText.getValue());
      this.eSlider.setValue(i.toString(), !0), t(i || 0);
    }), this.addManagedListener(this.eSlider, r, () => {
      const i = this.eSlider.getValue();
      this.eText.setValue(i, !0), t(parseFloat(i));
    }), this;
  }
  setSliderWidth(t) {
    return this.eSlider.setWidth(t), this;
  }
  setTextFieldWidth(t) {
    return this.eText.setWidth(t), this;
  }
  setMinValue(t) {
    return this.eSlider.setMinValue(t), this.eText.setMin(t), this;
  }
  setMaxValue(t) {
    return this.eSlider.setMaxValue(t), this.eText.setMax(t), this;
  }
  getValue() {
    return this.eText.getValue();
  }
  setValue(t, r) {
    return this.getValue() === t ? this : (this.eText.setValue(t, !0), this.eSlider.setValue(t, !0), r || this.dispatchEvent({ type: A.EVENT_FIELD_VALUE_CHANGED }), this);
  }
  setStep(t) {
    return this.eSlider.setStep(t), this.eText.setStep(t), this;
  }
};
Xu.TEMPLATE = /* html */
`<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`;
v([
  ne("eLabel")
], Xu.prototype, "eLabel", 2);
v([
  ne("eSlider")
], Xu.prototype, "eSlider", 2);
v([
  ne("eText")
], Xu.prototype, "eText", 2);
v([
  te
], Xu.prototype, "init", 1);
var Xse = Xu, ps = class rl extends Oe {
  constructor(t = {}) {
    super(rl.getTemplate(t)), this.params = t, this.suppressEnabledCheckbox = !0, this.suppressToggleExpandOnEnableChange = !1;
    const {
      enabled: r,
      items: i,
      suppressEnabledCheckbox: n,
      expanded: o,
      suppressToggleExpandOnEnableChange: s,
      useToggle: a
    } = t;
    this.cssIdentifier = t.cssIdentifier || "default", this.enabled = r ?? !0, this.items = i || [], this.useToggle = a ?? !1, this.alignItems = t.alignItems || "center", this.expanded = o ?? !0, n != null && (this.suppressEnabledCheckbox = n), s != null && (this.suppressToggleExpandOnEnableChange = s);
  }
  static getTemplate(t) {
    const r = t.cssIdentifier || "default", i = t.direction || "vertical";
    return (
      /* html */
      `
            <div class="ag-group ag-${r}-group" role="presentation">
                <div ref="eToolbar" class="ag-group-toolbar ag-${r}-group-toolbar">
                    <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
                </div>
                <div ref="eContainer" class="ag-group-container ag-group-container-${i} ag-${r}-group-container"></div>
            </div>
        `
    );
  }
  postConstruct() {
    if (this.setupTitleBar(), this.items.length) {
      const n = this.items;
      this.items = [], this.addItems(n);
    }
    const t = this.localeService.getLocaleTextFunc();
    this.cbGroupEnabled.setLabel(t("enabled", "Enabled")), this.enabled && this.setEnabled(this.enabled, void 0, !0), this.setAlignItems(this.alignItems);
    const { onEnableChange: r, suppressOpenCloseIcons: i } = this.params;
    this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(i ?? !1), this.refreshChildDisplay(), We(this.eContainer, this.expanded), this.cbGroupEnabled.onValueChange((n) => {
      this.setEnabled(n, !0, this.suppressToggleExpandOnEnableChange), this.dispatchEnableChangeEvent(n);
    }), r != null && this.onEnableChange(r);
  }
  refreshChildDisplay() {
    var t;
    We(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), (t = this.eTitleBar) == null || t.refreshOnExpand(this.expanded);
  }
  isExpanded() {
    return this.expanded;
  }
  setAlignItems(t) {
    this.alignItems !== t && this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`), this.alignItems = t;
    const r = `ag-group-item-alignment-${this.alignItems}`;
    return this.addCssClass(r), this;
  }
  toggleGroupExpand(t) {
    var r;
    let i = !1;
    if ((r = this.eTitleBar) != null && r.isSuppressCollapse() && !this.useToggle)
      t = !0, i = !0;
    else if (t = t ?? !this.expanded, this.expanded === t)
      return this;
    return this.expanded = t, this.refreshChildDisplay(), We(this.eContainer, t), i || this.dispatchEvent({ type: t ? rl.EVENT_EXPANDED : rl.EVENT_COLLAPSED }), this;
  }
  addItems(t) {
    t.forEach((r) => this.addItem(r));
  }
  prependItem(t) {
    this.insertItem(t, !0);
  }
  addItem(t) {
    this.insertItem(t, !1);
  }
  insertItem(t, r) {
    const i = this.eContainer, n = t instanceof Oe ? t.getGui() : t;
    n.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`), r ? (i.insertAdjacentElement("afterbegin", n), this.items.unshift(n)) : (i.appendChild(n), this.items.push(n));
  }
  hideItem(t, r) {
    const i = this.items[r];
    We(i, !t);
  }
  getItemIndex(t) {
    const r = t instanceof Oe ? t.getGui() : t;
    return this.items.indexOf(r);
  }
  setTitle(t) {
    var r;
    return (r = this.eTitleBar) == null || r.setTitle(t), this;
  }
  addTitleBarWidget(t) {
    var r;
    return (r = this.eTitleBar) == null || r.addWidget(t), this;
  }
  addCssClassToTitleBar(t) {
    var r;
    (r = this.eTitleBar) == null || r.addCssClass(t);
  }
  dispatchEnableChangeEvent(t) {
    const r = {
      type: rl.EVENT_ENABLE_CHANGE,
      enabled: t
    };
    this.dispatchEvent(r);
  }
  setEnabled(t, r, i) {
    var n;
    return this.enabled = t, this.refreshDisabledStyles(), i || this.toggleGroupExpand(t), r || (this.cbGroupEnabled.setValue(t), (n = this.eToggle) == null || n.setValue(t)), this;
  }
  isEnabled() {
    return this.enabled;
  }
  onEnableChange(t) {
    return this.addManagedListener(this, rl.EVENT_ENABLE_CHANGE, (r) => t(r.enabled)), this;
  }
  hideEnabledCheckbox(t) {
    return this.suppressEnabledCheckbox = t, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
  }
  hideOpenCloseIcons(t) {
    var r;
    return (r = this.eTitleBar) == null || r.hideOpenCloseIcons(t), this;
  }
  refreshDisabledStyles() {
    var t;
    const r = !this.enabled;
    this.eContainer.classList.toggle("ag-disabled", r), (t = this.eTitleBar) == null || t.refreshDisabledStyles(this.suppressEnabledCheckbox && r), this.eContainer.classList.toggle("ag-disabled-group-container", r);
  }
  setupTitleBar() {
    const t = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
    this.eToolbar.insertAdjacentElement("beforebegin", t.getGui());
  }
  createDefaultTitleBar() {
    const t = this.createManagedBean(new $T(this.params));
    return this.eTitleBar = t, t.refreshOnExpand(this.expanded), this.addManagedListener(t, $T.EVENT_EXPAND_CHANGED, (r) => this.toggleGroupExpand(r.expanded)), t;
  }
  createToggleTitleBar() {
    var t;
    const r = this.createManagedBean(new YN({
      value: this.enabled,
      label: this.params.title,
      labelAlignment: "left",
      labelWidth: "flex",
      onValueChange: (i) => {
        this.setEnabled(i, !0), this.dispatchEnableChangeEvent(i);
      }
    }));
    return r.addCssClass("ag-group-title-bar"), r.addCssClass(`ag-${(t = this.params.cssIdentifier) != null ? t : "default"}-group-title-bar ag-unselectable`), this.eToggle = r, this.toggleGroupExpand(this.enabled), r;
  }
};
ps.EVENT_EXPANDED = "expanded";
ps.EVENT_COLLAPSED = "collapsed";
ps.EVENT_ENABLE_CHANGE = "enableChange";
v([
  ne("eToolbar")
], ps.prototype, "eToolbar", 2);
v([
  ne("cbGroupEnabled")
], ps.prototype, "cbGroupEnabled", 2);
v([
  ne("eContainer")
], ps.prototype, "eContainer", 2);
v([
  te
], ps.prototype, "postConstruct", 1);
var Kse = ps, CC = "ag-disabled-group-title-bar", Ku = class Xb extends Oe {
  constructor(t = {}) {
    super(Xb.getTemplate(t)), this.suppressOpenCloseIcons = !1;
    const { title: r, suppressOpenCloseIcons: i } = t;
    r && r.length > 0 && (this.title = r), i != null && (this.suppressOpenCloseIcons = i);
  }
  static getTemplate(t) {
    var r;
    const i = (r = t.cssIdentifier) != null ? r : "default";
    return (
      /* html */
      `
            <div class="ag-group-title-bar ag-${i}-group-title-bar ag-unselectable" role="button">
                <span class="ag-group-title-bar-icon ag-${i}-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-${i}-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-${i}-group-title"></span>
            </div>
        `
    );
  }
  postConstruct() {
    this.setTitle(this.title), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract();
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(Ii("columnSelectClosed", this.gos, null)), this.eGroupOpenedIcon.appendChild(Ii("columnSelectOpen", this.gos, null)), this.addManagedListener(this.getGui(), "click", () => this.dispatchExpandChanged()), this.addManagedListener(this.getGui(), "keydown", (t) => {
      switch (t.key) {
        case k.ENTER:
        case k.SPACE:
          t.preventDefault(), this.dispatchExpandChanged();
          break;
        case k.RIGHT:
        case k.LEFT:
          t.preventDefault(), this.dispatchExpandChanged(t.key === k.RIGHT);
          break;
      }
    });
  }
  refreshOnExpand(t) {
    this.refreshAriaStatus(t), this.refreshOpenCloseIcons(t);
  }
  refreshAriaStatus(t) {
    this.suppressOpenCloseIcons || So(this.getGui(), t);
  }
  refreshOpenCloseIcons(t) {
    const r = !this.suppressOpenCloseIcons;
    We(this.eGroupOpenedIcon, r && t), We(this.eGroupClosedIcon, r && !t);
  }
  isSuppressCollapse() {
    return this.suppressOpenCloseIcons;
  }
  dispatchExpandChanged(t) {
    const r = {
      type: Xb.EVENT_EXPAND_CHANGED,
      expanded: t
    };
    this.dispatchEvent(r);
  }
  setTitle(t) {
    const r = this.getGui(), i = !!t && t.length > 0;
    t = i ? t : void 0, this.eTitle.textContent = t ?? "", We(r, i), t !== this.title && (this.title = t);
    const n = r.classList.contains(CC);
    return this.refreshDisabledStyles(n), this;
  }
  addWidget(t) {
    return this.getGui().appendChild(t), this;
  }
  hideOpenCloseIcons(t) {
    return this.suppressOpenCloseIcons = t, t && this.dispatchExpandChanged(!0), this;
  }
  refreshDisabledStyles(t) {
    const r = this.getGui();
    t ? (r.classList.add(CC), r.removeAttribute("tabindex")) : (r.classList.remove(CC), typeof this.title == "string" ? r.setAttribute("tabindex", "0") : r.removeAttribute("tabindex"));
  }
};
Ku.EVENT_EXPAND_CHANGED = "expandedChanged";
v([
  ne("eGroupOpenedIcon")
], Ku.prototype, "eGroupOpenedIcon", 2);
v([
  ne("eGroupClosedIcon")
], Ku.prototype, "eGroupClosedIcon", 2);
v([
  ne("eTitle")
], Ku.prototype, "eTitle", 2);
v([
  te
], Ku.prototype, "postConstruct", 1);
var $T = Ku, IE = class extends Ih {
  constructor(e = 0, t) {
    super(
      /* html */
      '<div class="ag-menu-list" role="tree"></div>'
    ), this.level = e, this.menuItems = [], this.params = t ?? {
      column: null,
      node: null,
      value: null
    };
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e),
      onFocusIn: (e) => this.handleFocusIn(e),
      onFocusOut: (e) => this.handleFocusOut(e)
    });
  }
  onTabKeyDown(e) {
    const t = this.getParentComponent(), r = t && t.getGui();
    r && r.classList.contains("ag-focus-managed") || e.preventDefault(), e.shiftKey && this.closeIfIsChild(e);
  }
  handleKeyDown(e) {
    switch (e.key) {
      case k.UP:
      case k.RIGHT:
      case k.DOWN:
      case k.LEFT:
        e.preventDefault(), this.handleNavKey(e.key);
        break;
      case k.ESCAPE:
        this.closeIfIsChild() && gn(e);
        break;
    }
  }
  handleFocusIn(e) {
    var t, r;
    const i = e.relatedTarget;
    !this.tabGuardCtrl.isTabGuard(i) && (this.getGui().contains(i) || (r = (t = this.activeMenuItem) == null ? void 0 : t.getSubMenuGui()) != null && r.contains(i)) || (this.activeMenuItem ? this.activeMenuItem.activate() : this.activateFirstItem());
  }
  handleFocusOut(e) {
    var t;
    const r = e.relatedTarget;
    !this.activeMenuItem || this.getGui().contains(r) || (t = this.activeMenuItem.getSubMenuGui()) != null && t.contains(r) || this.activeMenuItem.isSubMenuOpening() || this.activeMenuItem.deactivate();
  }
  clearActiveItem() {
    this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
  }
  addMenuItems(e) {
    e != null && qt.all(e.map((t) => t === "separator" ? qt.resolve({ eGui: this.createSeparator() }) : typeof t == "string" ? (console.warn(`AG Grid: unrecognised menu item ${t}`), qt.resolve({ eGui: null })) : this.addItem(t))).then((t) => {
      t.forEach((r) => {
        r != null && r.eGui && (this.appendChild(r.eGui), r.comp && this.menuItems.push(r.comp));
      });
    });
  }
  addItem(e) {
    const t = this.createManagedBean(new pp());
    return t.init({
      menuItemDef: e,
      isAnotherSubMenuOpen: () => this.menuItems.some((r) => r.isSubMenuOpen()),
      level: this.level,
      contextParams: this.params
    }).then(() => (t.setParentComponent(this), this.addManagedListener(t, pp.EVENT_CLOSE_MENU, (r) => {
      this.dispatchEvent(r);
    }), this.addManagedListener(t, pp.EVENT_MENU_ITEM_ACTIVATED, (r) => {
      this.activeMenuItem && this.activeMenuItem !== r.menuItem && this.activeMenuItem.deactivate(), this.activeMenuItem = r.menuItem;
    }), {
      comp: t,
      eGui: t.getGui()
    }));
  }
  activateFirstItem() {
    const e = this.menuItems.filter((t) => !t.isDisabled())[0];
    e && e.activate();
  }
  createSeparator() {
    return Qr(
      /* html */
      `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
    );
  }
  handleNavKey(e) {
    switch (e) {
      case k.UP:
      case k.DOWN:
        const r = this.findNextItem(e === k.UP);
        r && r !== this.activeMenuItem && r.activate();
        return;
    }
    const t = this.gos.get("enableRtl") ? k.RIGHT : k.LEFT;
    e === t ? this.closeIfIsChild() : this.openChild();
  }
  closeIfIsChild(e) {
    const t = this.getParentComponent();
    return t && t instanceof pp ? (e && e.preventDefault(), t.closeSubMenu(), t.getGui().focus(), !0) : !1;
  }
  openChild() {
    this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
  }
  findNextItem(e) {
    const t = this.menuItems.filter((n) => !n.isDisabled());
    if (!t.length)
      return;
    if (!this.activeMenuItem)
      return e ? ze(t) : t[0];
    e && t.reverse();
    let r, i = !1;
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      if (!i) {
        o === this.activeMenuItem && (i = !0);
        continue;
      }
      r = o;
      break;
    }
    return i && !r ? t[0] : r || this.activeMenuItem;
  }
  destroy() {
    this.clearActiveItem(), super.destroy();
  }
};
v([
  T("focusService")
], IE.prototype, "focusService", 2);
v([
  te
], IE.prototype, "postConstruct", 1);
var ZN = class extends Ih {
  constructor(e) {
    super(), this.wrappedComponent = e, this.setTemplateFromElement(e.getGui());
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  handleKeyDown(e) {
    e.key === k.ESCAPE && this.closePanel();
  }
  onTabKeyDown(e) {
    e.defaultPrevented || (this.closePanel(), e.preventDefault());
  }
  closePanel() {
    const e = this.parentComponent;
    e.closeSubMenu(), setTimeout(() => e.getGui().focus(), 0);
  }
};
v([
  te
], ZN.prototype, "postConstruct", 1);
var qu = class il extends Q {
  constructor() {
    super(...arguments), this.isActive = !1, this.subMenuIsOpen = !1, this.subMenuIsOpening = !1, this.suppressRootStyles = !0, this.suppressAria = !0, this.suppressFocus = !0;
  }
  init(t) {
    var r, i;
    const { menuItemDef: n, isAnotherSubMenuOpen: o, level: s, childComponent: a, contextParams: l } = t;
    return this.params = t.menuItemDef, this.level = s, this.isAnotherSubMenuOpen = o, this.childComponent = a, this.contextParams = l, this.cssClassPrefix = (i = (r = this.params.menuItemParams) == null ? void 0 : r.cssClassPrefix) != null ? i : "ag-menu-option", this.userComponentFactory.getMenuItemCompDetails(this.params, Dt(Ce({}, n), {
      level: s,
      isAnotherSubMenuOpen: o,
      openSubMenu: (c) => this.openSubMenu(c),
      closeSubMenu: () => this.closeSubMenu(),
      closeMenu: (c) => this.closeMenu(c),
      updateTooltip: (c, d) => this.refreshTooltip(c, d),
      onItemActivated: () => this.onItemActivated()
    })).newAgStackInstance().then((c) => {
      var d;
      this.menuItemComp = c;
      const h = (d = c.configureDefaults) == null ? void 0 : d.call(c);
      h && this.configureDefaults(h === !0 ? void 0 : h);
    });
  }
  addListeners(t, r) {
    r != null && r.suppressClick || this.addManagedListener(t, "click", (i) => this.onItemSelected(i)), r != null && r.suppressKeyboardSelect || this.addManagedListener(t, "keydown", (i) => {
      (i.key === k.ENTER || i.key === k.SPACE) && (i.preventDefault(), this.onItemSelected(i));
    }), r != null && r.suppressMouseDown || this.addManagedListener(t, "mousedown", (i) => {
      i.stopPropagation(), i.preventDefault();
    }), r != null && r.suppressMouseOver || (this.addManagedListener(t, "mouseenter", () => this.onMouseEnter()), this.addManagedListener(t, "mouseleave", () => this.onMouseLeave()));
  }
  isDisabled() {
    return !!this.params.disabled;
  }
  openSubMenu(t = !1) {
    var r, i;
    if (this.closeSubMenu(), !this.params.subMenu)
      return;
    this.subMenuIsOpening = !0;
    const n = Qr(
      /* html */
      '<div class="ag-menu" role="presentation"></div>'
    );
    this.eSubMenuGui = n;
    let o, s = () => {
      this.subMenuIsOpening = !1;
    };
    if (this.childComponent) {
      const c = this.createBean(new ZN(this.childComponent));
      c.setParentComponent(this);
      const d = c.getGui(), h = "mouseenter", p = () => this.cancelDeactivate();
      d.addEventListener(h, p), o = () => d.removeEventListener(h, p), n.appendChild(d), this.childComponent.afterGuiAttached && (s = () => {
        this.childComponent.afterGuiAttached(), this.subMenuIsOpening = !1;
      });
    } else if (this.params.subMenu) {
      const c = this.createBean(new IE(this.level + 1, this.contextParams));
      c.setParentComponent(this), c.addMenuItems(this.params.subMenu), n.appendChild(c.getGui()), this.addManagedListener(c, il.EVENT_CLOSE_MENU, (d) => this.dispatchEvent(d)), c.addGuiEventListener("mouseenter", () => this.cancelDeactivate()), o = () => this.destroyBean(c), t && (s = () => {
        c.activateFirstItem(), this.subMenuIsOpening = !1;
      });
    }
    const a = this.popupService.positionPopupForMenu.bind(
      this.popupService,
      { eventSource: this.eGui, ePopup: n }
    ), l = this.localeService.getLocaleTextFunc(), u = this.popupService.addPopup({
      modal: !0,
      eChild: n,
      positionCallback: a,
      anchorToElement: this.eGui,
      ariaLabel: l("ariaLabelSubMenu", "SubMenu"),
      afterGuiAttached: s
    });
    this.subMenuIsOpen = !0, this.setAriaExpanded(!0), this.hideSubMenu = () => {
      var c, d;
      u && u.hideFunc(), this.subMenuIsOpen = !1, this.setAriaExpanded(!1), o(), (d = (c = this.menuItemComp).setExpanded) == null || d.call(c, !1), this.eSubMenuGui = void 0;
    }, (i = (r = this.menuItemComp).setExpanded) == null || i.call(r, !0);
  }
  setAriaExpanded(t) {
    this.suppressAria || So(this.eGui, t);
  }
  closeSubMenu() {
    this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, this.setAriaExpanded(!1));
  }
  isSubMenuOpen() {
    return this.subMenuIsOpen;
  }
  isSubMenuOpening() {
    return this.subMenuIsOpening;
  }
  activate(t) {
    var r, i;
    this.cancelActivate(), !this.params.disabled && (this.isActive = !0, this.suppressRootStyles || this.eGui.classList.add(`${this.cssClassPrefix}-active`), (i = (r = this.menuItemComp).setActive) == null || i.call(r, !0), this.suppressFocus || this.eGui.focus({ preventScroll: !0 }), t && this.params.subMenu && window.setTimeout(() => {
      this.isAlive() && this.isActive && this.openSubMenu();
    }, 300), this.onItemActivated());
  }
  deactivate() {
    var t, r;
    this.cancelDeactivate(), this.suppressRootStyles || this.eGui.classList.remove(`${this.cssClassPrefix}-active`), (r = (t = this.menuItemComp).setActive) == null || r.call(t, !1), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu();
  }
  getGui() {
    return this.menuItemComp.getGui();
  }
  getParentComponent() {
    return this.parentComponent;
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getSubMenuGui() {
    return this.eSubMenuGui;
  }
  onItemSelected(t) {
    var r, i;
    (i = (r = this.menuItemComp).select) == null || i.call(r), this.params.action ? this.getFrameworkOverrides().wrapOutgoing(() => this.params.action(this.gos.addGridCommonParams(Ce({}, this.contextParams)))) : this.openSubMenu(t && t.type === "keydown"), !(this.params.subMenu && !this.params.action || this.params.suppressCloseOnSelect) && this.closeMenu(t);
  }
  closeMenu(t) {
    const r = {
      type: il.EVENT_CLOSE_MENU
    };
    t && (t instanceof MouseEvent ? r.mouseEvent = t : r.keyboardEvent = t), this.dispatchEvent(r);
  }
  onItemActivated() {
    const t = {
      type: il.EVENT_MENU_ITEM_ACTIVATED,
      menuItem: this
    };
    this.dispatchEvent(t);
  }
  cancelActivate() {
    this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
  }
  cancelDeactivate() {
    this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
  }
  onMouseEnter() {
    this.cancelDeactivate(), this.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(() => this.activate(!0), il.ACTIVATION_DELAY) : this.activate(!0);
  }
  onMouseLeave() {
    this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), il.ACTIVATION_DELAY) : this.deactivate();
  }
  configureDefaults(t) {
    var r, i, n;
    if (!this.menuItemComp) {
      setTimeout(() => this.configureDefaults(t));
      return;
    }
    let o = this.menuItemComp.getGui();
    const s = (i = (r = this.menuItemComp).getRootElement) == null ? void 0 : i.call(r);
    s && (t != null && t.suppressRootStyles || o.classList.add("ag-menu-option-custom"), o = s), this.eGui = o, this.suppressRootStyles = !!(t != null && t.suppressRootStyles), this.suppressRootStyles || (o.classList.add(this.cssClassPrefix), (n = this.params.cssClasses) == null || n.forEach((a) => o.classList.add(a)), this.params.disabled && o.classList.add(`${this.cssClassPrefix}-disabled`)), t != null && t.suppressTooltip || this.refreshTooltip(this.params.tooltip), this.suppressAria = !!(t != null && t.suppressAria), this.suppressAria || (Nt(o, "treeitem"), a_(o, this.level + 1), this.params.disabled && BS(o, !0)), t != null && t.suppressTabIndex || o.setAttribute("tabindex", "-1"), this.params.disabled || this.addListeners(o, t), this.suppressFocus = !!(t != null && t.suppressFocus);
  }
  refreshTooltip(t, r) {
    this.tooltip = t, this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), !(!t || !this.menuItemComp) && (this.tooltipFeature = this.createBean(new Mo({
      getGui: () => this.getGui(),
      getTooltipValue: () => this.tooltip,
      getLocation: () => "menu",
      shouldDisplayTooltip: r
    })));
  }
  destroy() {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy();
  }
};
qu.EVENT_CLOSE_MENU = "closeMenu";
qu.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated";
qu.ACTIVATION_DELAY = 80;
v([
  T("popupService")
], qu.prototype, "popupService", 2);
v([
  T("userComponentFactory")
], qu.prototype, "userComponentFactory", 2);
var pp = qu, Ba = class Kb extends Oe {
  constructor(t) {
    super(Kb.getTemplate(t)), this.config = t, this.closable = !0;
  }
  static getTemplate(t) {
    const r = t.cssIdentifier || "default";
    return (
      /* html */
      `<div class="ag-panel ag-${r}-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-${r}-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-${r}-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${r}-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-${r}-panel-content-wrapper"></div>
        </div>`
    );
  }
  postConstruct() {
    const {
      component: t,
      closable: r,
      hideTitleBar: i,
      title: n,
      minWidth: o = 250,
      width: s,
      minHeight: a = 250,
      height: l,
      centered: u,
      popup: c,
      x: d,
      y: h
    } = this.config;
    this.positionableFeature = new Vu(this.getGui(), {
      minWidth: o,
      width: s,
      minHeight: a,
      height: l,
      centered: u,
      x: d,
      y: h,
      popup: c,
      calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
    }), this.createManagedBean(this.positionableFeature);
    const p = this.getGui();
    t && this.setBodyComponent(t), i ? We(this.eTitleBar, !1) : (n && this.setTitle(n), this.setClosable(r ?? this.closable)), this.addManagedListener(this.eTitleBar, "mousedown", (g) => {
      if (p.contains(g.relatedTarget) || p.contains(this.gos.getActiveDomElement()) || this.eTitleBarButtons.contains(g.target)) {
        g.preventDefault();
        return;
      }
      const m = this.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
      m && m.focus();
    }), !(c && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
  }
  renderComponent() {
    const t = this.getGui();
    t.focus(), this.close = () => {
      t.parentElement.removeChild(t), this.destroy();
    };
  }
  getHeight() {
    return this.positionableFeature.getHeight();
  }
  setHeight(t) {
    this.positionableFeature.setHeight(t);
  }
  getWidth() {
    return this.positionableFeature.getWidth();
  }
  setWidth(t) {
    this.positionableFeature.setWidth(t);
  }
  setClosable(t) {
    if (t !== this.closable && (this.closable = t), t) {
      const r = this.closeButtonComp = new Oe(Kb.CLOSE_BTN_TEMPLATE);
      this.getContext().createBean(r);
      const i = r.getGui(), n = It("close", this.gos);
      n.classList.add("ag-panel-title-bar-button-icon"), i.appendChild(n), this.addTitleBarButton(r), r.addManagedListener(i, "click", this.onBtClose.bind(this));
    } else if (this.closeButtonComp) {
      const r = this.closeButtonComp.getGui();
      r.parentElement.removeChild(r), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
  }
  setBodyComponent(t) {
    t.setParentComponent(this), this.eContentWrapper.appendChild(t.getGui());
  }
  addTitleBarButton(t, r) {
    const i = this.eTitleBarButtons, n = i.children, o = n.length;
    r == null && (r = o), r = Math.max(0, Math.min(r, o)), t.addCssClass("ag-panel-title-bar-button");
    const s = t.getGui();
    r === 0 ? i.insertAdjacentElement("afterbegin", s) : r === o ? i.insertAdjacentElement("beforeend", s) : n[r - 1].insertAdjacentElement("afterend", s), t.setParentComponent(this);
  }
  getBodyHeight() {
    return yh(this.eContentWrapper);
  }
  getBodyWidth() {
    return Ma(this.eContentWrapper);
  }
  setTitle(t) {
    this.eTitle.innerText = t;
  }
  // called when user hits the 'x' in the top right
  onBtClose() {
    this.close();
  }
  destroy() {
    this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
    const t = this.getGui();
    t && ii(t) && this.close(), super.destroy();
  }
};
Ba.CLOSE_BTN_TEMPLATE = /* html */
'<div class="ag-button"></div>';
v([
  ne("eContentWrapper")
], Ba.prototype, "eContentWrapper", 2);
v([
  ne("eTitleBar")
], Ba.prototype, "eTitleBar", 2);
v([
  ne("eTitleBarButtons")
], Ba.prototype, "eTitleBarButtons", 2);
v([
  ne("eTitle")
], Ba.prototype, "eTitle", 2);
v([
  te
], Ba.prototype, "postConstruct", 1);
var qse = Ba, Zse = class extends qse {
  constructor(e) {
    super(Dt(Ce({}, e), { popup: !0 })), this.isMaximizable = !1, this.isMaximized = !1, this.maximizeListeners = [], this.resizeListenerDestroy = null, this.lastPosition = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  postConstruct() {
    const e = this.getGui(), { movable: t, resizable: r, maximizable: i } = this.config;
    this.addCssClass("ag-dialog"), super.postConstruct(), this.addManagedListener(e, "focusin", (n) => {
      this.popupService.bringPopupToFront(e);
    }), t && this.setMovable(t), i && this.setMaximizable(i), r && this.setResizable(r);
  }
  renderComponent() {
    const e = this.getGui(), { alwaysOnTop: t, modal: r, title: i, afterGuiAttached: n } = this.config, o = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      modal: r,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: this.onClosed.bind(this),
      alwaysOnTop: t,
      ariaLabel: i || o("ariaLabelDialog", "Dialog"),
      afterGuiAttached: n
    });
    s && (this.close = s.hideFunc);
  }
  onClosed(e) {
    var t, r;
    this.destroy(), (r = (t = this.config).closedCallback) == null || r.call(t, e);
  }
  toggleMaximize() {
    const e = this.positionableFeature.getPosition();
    if (this.isMaximized) {
      const { x: t, y: r, width: i, height: n } = this.lastPosition;
      this.setWidth(i), this.setHeight(n), this.positionableFeature.offsetElement(t, r);
    } else
      this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = e.x, this.lastPosition.y = e.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
    this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
  }
  refreshMaximizeIcon() {
    We(this.maximizeIcon, !this.isMaximized), We(this.minimizeIcon, this.isMaximized);
  }
  clearMaximizebleListeners() {
    this.maximizeListeners.length && (this.maximizeListeners.forEach((e) => e()), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
  }
  destroy() {
    this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), super.destroy();
  }
  setResizable(e) {
    this.positionableFeature.setResizable(e);
  }
  setMovable(e) {
    this.positionableFeature.setMovable(e, this.eTitleBar);
  }
  setMaximizable(e) {
    if (!e) {
      this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
      return;
    }
    const t = this.eTitleBar;
    if (!t || e === this.isMaximizable)
      return;
    const r = this.buildMaximizeAndMinimizeElements();
    this.refreshMaximizeIcon(), r.addManagedListener(r.getGui(), "click", this.toggleMaximize.bind(this)), this.addTitleBarButton(r, 0), this.maximizeListeners.push(
      this.addManagedListener(t, "dblclick", this.toggleMaximize.bind(this))
    ), this.resizeListenerDestroy = this.addManagedListener(this, "resize", () => {
      this.isMaximized = !1, this.refreshMaximizeIcon();
    });
  }
  buildMaximizeAndMinimizeElements() {
    const e = this.maximizeButtonComp = this.createBean(new Oe(
      /* html */
      '<div class="ag-dialog-button"></span>'
    )), t = e.getGui();
    return this.maximizeIcon = It("maximize", this.gos), t.appendChild(this.maximizeIcon), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), this.minimizeIcon = It("minimize", this.gos), t.appendChild(this.minimizeIcon), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon"), e;
  }
};
v([
  T("popupService")
], Zse.prototype, "popupService", 2);
var Jse = 0, Eo = class extends Q {
  constructor() {
    super(...arguments), this.popupList = [];
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedListener(this.eventService, A.EVENT_GRID_STYLES_CHANGED, this.handleThemeChange.bind(this));
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: r } = e, i = this.getPopupIndex(r);
    if (i !== -1) {
      const p = this.popupList[i];
      p.alignedToElement = t;
    }
    const n = t.getBoundingClientRect(), o = this.getParentRect(), s = this.keepXYWithinBounds(
      r,
      n.top - o.top,
      0
      /* vertical */
    ), a = r.clientWidth > 0 ? r.clientWidth : 200;
    r.style.minWidth = `${a}px`;
    const u = o.right - o.left - a;
    let c;
    this.gos.get("enableRtl") ? (c = h(), c < 0 && (c = d(), this.setAlignedStyles(r, "left")), c > u && (c = 0, this.setAlignedStyles(r, "right"))) : (c = d(), c > u && (c = h(), this.setAlignedStyles(r, "right")), c < 0 && (c = 0, this.setAlignedStyles(r, "left"))), r.style.left = `${c}px`, r.style.top = `${s}px`;
    function d() {
      return n.right - o.left - 2;
    }
    function h() {
      return n.left - o.left - a;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: r, nudgeY: i, skipObserver: n } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: i,
      keepWithinBounds: !0,
      skipObserver: n,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(e.type, e.ePopup, null, e.mouseEvent, e.column, e.rowNode)
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const { ePopup: t, nudgeX: r, nudgeY: i, keepWithinBounds: n, eventSource: o, alignSide: s = "left", position: a = "over", column: l, rowNode: u, type: c } = e, d = o.getBoundingClientRect(), h = this.getParentRect(), p = this.getPopupIndex(t);
    if (p !== -1) {
      const m = this.popupList[p];
      m.alignedToElement = o;
    }
    const g = () => {
      let m = d.left - h.left;
      s === "right" && (m -= t.offsetWidth - d.width);
      let f;
      return a === "over" ? (f = d.top - h.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, d, h, e.nudgeY || 0) === "under" ? f = d.top - h.top + d.height : f = d.top - t.offsetHeight - (i || 0) * 2 - h.top), { x: m, y: f };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: i,
      keepWithinBounds: n,
      updatePosition: g,
      postProcessCallback: () => this.callPostProcessPopup(c, t, o, null, l, u)
    });
  }
  shouldRenderUnderOrAbove(e, t, r, i) {
    const n = r.bottom - t.bottom, o = t.top - r.top, s = e.offsetHeight + i;
    return n > s ? "under" : o > s || o > n ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const i = this.popupList[r], { alignedToElement: n } = i;
    !n || (["right", "left", "over", "above", "under"].forEach((s) => {
      n.classList.remove(`ag-has-popup-positioned-${s}`), e.classList.remove(`ag-popup-positioned-${s}`);
    }), !t) || (n.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, r, i, n, o) {
    const s = this.gos.getCallback("postProcessPopup");
    s && s({
      column: n,
      rowNode: o,
      ePopup: t,
      type: e,
      eventSource: r,
      mouseEvent: i
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: r, nudgeX: i, nudgeY: n, skipObserver: o, updatePosition: s } = e, a = { width: 0, height: 0 }, l = (u = !1) => {
      let { x: c, y: d } = s();
      u && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, i && (c += i), n && (d += n), r && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* horizontal */
      ), d = this.keepXYWithinBounds(
        t,
        d,
        0
        /* vertical */
      )), t.style.left = `${c}px`, t.style.top = `${d}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !o) {
      const u = this.resizeObserverService.observeResize(t, () => l(!0));
      setTimeout(() => u(), Eo.WAIT_FOR_POPUP_CONTENT_RESIZE);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = this.gos.getDocument();
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), tE(t);
  }
  keepXYWithinBounds(e, t, r) {
    const i = r === 0, n = i ? "clientHeight" : "clientWidth", o = i ? "top" : "left", s = i ? "offsetHeight" : "offsetWidth", a = i ? "scrollTop" : "scrollLeft", l = this.gos.getDocument(), u = l.documentElement, c = this.getPopupParent(), d = c.getBoundingClientRect(), h = l.documentElement.getBoundingClientRect(), p = c === l.body, g = e[s];
    let f = p ? (i ? eE : Od)(u) + u[a] : c[n];
    p && (f -= Math.abs(h[o] - d[o]));
    const C = f - g;
    return Math.min(Math.max(t, 0), Math.abs(C));
  }
  addPopup(e) {
    const t = this.gos.getDocument(), { eChild: r, ariaLabel: i, alwaysOnTop: n, positionCallback: o, anchorToElement: s } = e;
    if (!t)
      return console.warn("AG Grid: could not find the document, document is empty"), { hideFunc: () => {
      } };
    const a = this.getPopupIndex(r);
    if (a !== -1)
      return { hideFunc: this.popupList[a].hideFunc };
    this.initialisePopupPosition(r);
    const l = this.createPopupWrapper(r, i, !!n), u = this.addEventListenersToPopup(Dt(Ce({}, e), { wrapperEl: l }));
    return o && o(), this.addPopupToPopupList(r, l, u, s), {
      hideFunc: u
    };
  }
  initialisePopupPosition(e) {
    const r = this.getPopupParent().getBoundingClientRect();
    q(e.style.top) || (e.style.top = `${r.top * -1}px`), q(e.style.left) || (e.style.left = `${r.left * -1}px`);
  }
  createPopupWrapper(e, t, r) {
    const i = this.getPopupParent(), n = document.createElement("div"), { allThemes: o } = this.environment.getTheme();
    return o.length && n.classList.add(...o), n.classList.add("ag-popup"), e.classList.add(
      this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr",
      "ag-popup-child"
    ), e.hasAttribute("role") || Nt(e, "dialog"), Si(e, t), n.appendChild(e), i.appendChild(n), r ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), n;
  }
  handleThemeChange() {
    const { allThemes: e } = this.environment.getTheme();
    for (const t of this.popupList) {
      for (const r of Array.from(t.wrapper.classList))
        r.startsWith("ag-theme-") && t.wrapper.classList.remove(r);
      e.length && t.wrapper.classList.add(...e);
    }
  }
  addEventListenersToPopup(e) {
    const t = this.gos.getDocument(), r = this.getPopupParent(), { wrapperEl: i, eChild: n, closedCallback: o, afterGuiAttached: s, closeOnEsc: a, modal: l } = e;
    let u = !1;
    const c = (g) => {
      if (!i.contains(this.gos.getActiveDomElement()))
        return;
      g.key === k.ESCAPE && !hn(g) && p({ keyboardEvent: g });
    }, d = (g) => p({ mouseEvent: g }), h = (g) => p({ touchEvent: g }), p = (g = {}) => {
      const { mouseEvent: m, touchEvent: f, keyboardEvent: C, forceHide: w } = g;
      !w && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: m, touchEvent: f }, n) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u) || (u = !0, r.removeChild(i), t.removeEventListener("keydown", c), t.removeEventListener("mousedown", d), t.removeEventListener("touchstart", h), t.removeEventListener("contextmenu", d), this.eventService.removeEventListener(A.EVENT_DRAG_STARTED, d), o && o(m || f || C), this.removePopupFromPopupList(n));
    };
    return s && s({ hidePopup: p }), window.setTimeout(() => {
      a && t.addEventListener("keydown", c), l && (t.addEventListener("mousedown", d), this.eventService.addEventListener(A.EVENT_DRAG_STARTED, d), t.addEventListener("touchstart", h), t.addEventListener("contextmenu", d));
    }, 0), p;
  }
  addPopupToPopupList(e, t, r, i) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: r,
      instanceId: Jse++,
      isAnchored: !!i
    }), i && this.setPopupPositionRelatedToElement(e, i);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const i = this.popupList[r];
    if (i.stopAnchoringPromise && i.stopAnchoringPromise.then((o) => o && o()), i.stopAnchoringPromise = void 0, i.isAnchored = !1, !t)
      return;
    const n = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: i.hideFunc
    });
    return i.stopAnchoringPromise = n, i.isAnchored = !0, n;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), r = t.getBoundingClientRect(), { element: i, ePopup: n } = e, o = i.getBoundingClientRect(), s = r.top - o.top, a = r.left - o.left;
    let l = s, u = a;
    const c = n.style.top, d = parseInt(c.substring(0, c.length - 1), 10), h = n.style.left, p = parseInt(h.substring(0, h.length - 1), 10);
    return new qt((g) => {
      this.getFrameworkOverrides().setInterval(() => {
        const m = t.getBoundingClientRect(), f = i.getBoundingClientRect();
        if (f.top == 0 && f.left == 0 && f.height == 0 && f.width == 0) {
          e.hidePopup();
          return;
        }
        const w = m.top - f.top;
        if (w != l) {
          const b = this.keepXYWithinBounds(
            n,
            d + s - w,
            0
            /* vertical */
          );
          n.style.top = `${b}px`;
        }
        l = w;
        const E = m.left - f.left;
        if (E != u) {
          const b = this.keepXYWithinBounds(
            n,
            p + a - E,
            1
            /* horizontal */
          );
          n.style.left = `${b}px`;
        }
        u = E;
      }, 200).then((m) => {
        g(() => {
          m != null && window.clearInterval(m);
        });
      });
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: r, touchEvent: i } = e, n = r || i;
    if (!n)
      return !1;
    const o = this.getPopupIndex(t);
    if (o === -1)
      return !1;
    for (let s = o; s < this.popupList.length; s++) {
      const a = this.popupList[s];
      if (sg(a.element, n))
        return !0;
    }
    return this.isElementWithinCustomPopup(n.target);
  }
  isElementWithinCustomPopup(e) {
    const t = this.gos.getDocument();
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const r = this.getWrapper(e);
    r && (r.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(r));
  }
  bringPopupToFront(e) {
    const t = this.getPopupParent(), r = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), i = r.length, n = Array.prototype.slice.call(t.querySelectorAll(".ag-popup.ag-always-on-top")), o = n.length, s = this.getWrapper(e);
    if (!s || i <= 1 || !t.contains(e))
      return;
    const a = r.indexOf(s), l = s.querySelectorAll("div"), u = [];
    for (l.forEach((c) => {
      c.scrollTop !== 0 && u.push([c, c.scrollTop]);
    }), o ? s.classList.contains("ag-always-on-top") ? a !== i - 1 && ze(n).insertAdjacentElement("afterend", s) : a !== i - o - 1 && n[0].insertAdjacentElement("beforebegin", s) : a !== i - 1 && ze(r).insertAdjacentElement("afterend", s); u.length; ) {
      const c = u.pop();
      c[0].scrollTop = c[1];
    }
  }
};
Eo.WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
v([
  T("focusService")
], Eo.prototype, "focusService", 2);
v([
  T("ctrlsService")
], Eo.prototype, "ctrlsService", 2);
v([
  T("resizeObserverService")
], Eo.prototype, "resizeObserverService", 2);
v([
  te
], Eo.prototype, "postConstruct", 1);
Eo = v([
  de("popupService")
], Eo);
var Qse = class extends Oe {
  constructor() {
    super(
      /* html */
      `
        <div class="ag-autocomplete-row" role="presentation">
            <div class="ag-autocomplete-row-label"></div>
        </div>`
    ), this.hasHighlighting = !1;
  }
  setState(e, t) {
    this.value = e, this.render(), this.updateSelected(t);
  }
  updateSelected(e) {
    this.addOrRemoveCssClass("ag-autocomplete-row-selected", e);
  }
  setSearchString(e) {
    var t;
    let r = !1;
    if (q(e)) {
      const i = (t = this.value) == null ? void 0 : t.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
      if (i >= 0) {
        r = !0, this.hasHighlighting = !0;
        const n = i + e.length, o = Yt(this.value.slice(0, i)), s = Yt(this.value.slice(i, n)), a = Yt(this.value.slice(n));
        this.getGui().lastElementChild.innerHTML = `${o}<b>${s}</b>${a}`;
      }
    }
    !r && this.hasHighlighting && (this.hasHighlighting = !1, this.render());
  }
  render() {
    var e;
    this.getGui().lastElementChild.innerHTML = (e = Yt(this.value)) != null ? e : "&nbsp;";
  }
}, av = class JN extends Na {
  constructor(t) {
    super(JN.TEMPLATE), this.params = t, this.searchString = "";
  }
  destroy() {
    super.destroy();
  }
  init() {
    this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList = this.createManagedBean(new KN({ cssIdentifier: "autocomplete" })), this.virtualList.setComponentCreator(this.createRowComponent.bind(this)), this.eList.appendChild(this.virtualList.getGui()), this.virtualList.setModel({
      getRowCount: () => this.autocompleteEntries.length,
      getRow: (r) => this.autocompleteEntries[r]
    });
    const t = this.virtualList.getGui();
    this.addManagedListener(t, "click", () => this.params.onConfirmed()), this.addManagedListener(t, "mousemove", this.onMouseMove.bind(this)), this.addManagedListener(t, "mousedown", (r) => r.preventDefault()), this.setSelectedValue(0);
  }
  onNavigationKeyDown(t, r) {
    t.preventDefault();
    const i = this.autocompleteEntries.indexOf(this.selectedValue), n = r === k.UP ? i - 1 : i + 1;
    this.checkSetSelectedValue(n);
  }
  setSearch(t) {
    this.searchString = t, q(t) ? this.runSearch() : (this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList.refresh(), this.checkSetSelectedValue(0)), this.updateSearchInList();
  }
  runContainsSearch(t, r) {
    let i, n = !1;
    const o = t.toLocaleLowerCase(), s = r.filter((a) => {
      const u = a.toLocaleLowerCase().indexOf(o), c = u === 0, d = u >= 0;
      return d && (!i || !n && c || n === c && a.length < i.length) && (i = a, n = c), d;
    });
    return !i && s.length && (i = s[0]), { topMatch: i, allMatches: s };
  }
  runSearch() {
    var t, r;
    const { autocompleteEntries: i } = this.params, n = i.map((u) => {
      var c;
      return (c = u.displayValue) != null ? c : u.key;
    });
    let o, s;
    if (this.params.useFuzzySearch)
      o = wh(this.searchString, n, !0).values, s = o.length ? o[0] : void 0;
    else {
      const u = this.runContainsSearch(this.searchString, n);
      o = u.allMatches, s = u.topMatch;
    }
    let a = i.filter(({ key: u, displayValue: c }) => o.includes(c ?? u));
    if (!a.length && this.selectedValue && ((r = (t = this.params) == null ? void 0 : t.forceLastSelection) != null && r.call(t, this.selectedValue, this.searchString)) && (a = [this.selectedValue]), this.autocompleteEntries = a, this.virtualList.refresh(), !s)
      return;
    const l = o.indexOf(s);
    this.checkSetSelectedValue(l);
  }
  updateSearchInList() {
    this.virtualList.forEachRenderedRow((t) => t.setSearchString(this.searchString));
  }
  checkSetSelectedValue(t) {
    t >= 0 && t < this.autocompleteEntries.length && this.setSelectedValue(t);
  }
  setSelectedValue(t) {
    const r = this.autocompleteEntries[t];
    this.selectedValue !== r && (this.selectedValue = r, this.virtualList.ensureIndexVisible(t), this.virtualList.forEachRenderedRow((i, n) => {
      i.updateSelected(t === n);
    }));
  }
  createRowComponent(t) {
    var r;
    const i = new Qse();
    return this.getContext().createBean(i), i.setState((r = t.displayValue) != null ? r : t.key, t === this.selectedValue), i;
  }
  onMouseMove(t) {
    const r = this.virtualList.getGui().getBoundingClientRect(), i = this.virtualList.getScrollTop(), n = t.clientY - r.top + i, o = Math.floor(n / this.virtualList.getRowHeight());
    this.checkSetSelectedValue(o);
  }
  afterGuiAttached() {
    this.virtualList.refresh();
  }
  getSelectedValue() {
    var t;
    return this.autocompleteEntries.length && (t = this.selectedValue) != null ? t : null;
  }
};
av.TEMPLATE = /* html */
`<div class="ag-autocomplete-list-popup">
            <div ref="eList" class="ag-autocomplete-list"></div>
        <div>`;
v([
  ne("eList")
], av.prototype, "eList", 2);
v([
  te
], av.prototype, "init", 1);
var eae = av, fs = class Tc extends Oe {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-autocomplete" role="presentation">
                <ag-input-text-field ref="eAutocompleteInput"></ag-input-text-field>
            </div>`
    ), this.isListOpen = !1, this.lastPosition = 0, this.valid = !0;
  }
  postConstruct() {
    this.eAutocompleteInput.onValueChange((t) => this.onValueChanged(t)), this.eAutocompleteInput.getInputElement().setAttribute("autocomplete", "off"), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.addGuiEventListener("click", this.updatePositionAndList.bind(this)), this.addDestroyFunc(() => {
      this.destroyBean(this.autocompleteList);
    }), this.addGuiEventListener("focusout", () => this.onFocusOut());
  }
  onValueChanged(t) {
    const r = Nn(t);
    this.updateValue(r), this.updateAutocompleteList(r);
  }
  updateValue(t) {
    this.updateLastPosition(), this.dispatchEvent({
      type: Tc.EVENT_VALUE_CHANGED,
      value: t
    }), this.validate(t);
  }
  updateAutocompleteList(t) {
    var r, i, n, o;
    const s = (i = (r = this.listGenerator) == null ? void 0 : r.call(this, t, this.lastPosition)) != null ? i : { enabled: !1 };
    if ((!s.type || s.type !== ((n = this.autocompleteListParams) == null ? void 0 : n.type)) && this.isListOpen && this.closeList(), this.autocompleteListParams = s, (o = this.autocompleteListParams) != null && o.enabled) {
      this.isListOpen || this.openList();
      const { searchString: a } = this.autocompleteListParams;
      this.autocompleteList.setSearch(a ?? "");
    } else
      this.isListOpen && this.closeList();
  }
  onKeyDown(t) {
    const r = t.key;
    switch (this.updateLastPosition(), r) {
      case k.ENTER:
        this.onEnterKeyDown(t);
        break;
      case k.TAB:
        this.onTabKeyDown(t);
        break;
      case k.DOWN:
      case k.UP:
        this.onUpDownKeyDown(t, r);
        break;
      case k.LEFT:
      case k.RIGHT:
      case k.PAGE_HOME:
      case k.PAGE_END:
        setTimeout(() => {
          this.updatePositionAndList();
        });
        break;
      case k.ESCAPE:
        this.onEscapeKeyDown(t);
        break;
      case k.SPACE:
        t.ctrlKey && !this.isListOpen && (t.preventDefault(), this.forceOpenList());
        break;
    }
  }
  confirmSelection() {
    var t;
    const r = (t = this.autocompleteList) == null ? void 0 : t.getSelectedValue();
    r && (this.closeList(), this.dispatchEvent({
      type: Tc.EVENT_OPTION_SELECTED,
      value: this.getValue(),
      position: this.lastPosition,
      updateEntry: r,
      autocompleteType: this.autocompleteListParams.type
    }));
  }
  onTabKeyDown(t) {
    this.isListOpen && (t.preventDefault(), t.stopPropagation(), this.confirmSelection());
  }
  onEnterKeyDown(t) {
    t.preventDefault(), this.isListOpen ? this.confirmSelection() : this.onCompleted();
  }
  onUpDownKeyDown(t, r) {
    var i;
    t.preventDefault(), this.isListOpen ? (i = this.autocompleteList) == null || i.onNavigationKeyDown(t, r) : this.forceOpenList();
  }
  onEscapeKeyDown(t) {
    this.isListOpen && (t.preventDefault(), t.stopPropagation(), this.closeList(), this.setCaret(this.lastPosition, !0));
  }
  onFocusOut() {
    this.isListOpen && this.closeList();
  }
  updatePositionAndList() {
    var t;
    this.updateLastPosition(), this.updateAutocompleteList((t = this.eAutocompleteInput.getValue()) != null ? t : null);
  }
  setCaret(t, r) {
    const i = this.gos.getDocument(), n = this.gos.getActiveDomElement();
    r && (!n || n === i.body) && this.eAutocompleteInput.getFocusableElement().focus();
    const o = this.eAutocompleteInput.getInputElement();
    o.setSelectionRange(t, t), t === o.value.length && (o.scrollLeft = o.scrollWidth);
  }
  forceOpenList() {
    this.onValueChanged(this.eAutocompleteInput.getValue());
  }
  updateLastPosition() {
    var t;
    this.lastPosition = (t = this.eAutocompleteInput.getInputElement().selectionStart) != null ? t : 0;
  }
  validate(t) {
    var r;
    this.validator && (this.validationMessage = this.validator(t), this.eAutocompleteInput.getInputElement().setCustomValidity((r = this.validationMessage) != null ? r : ""), this.valid = !this.validationMessage, this.dispatchEvent({
      type: Tc.EVENT_VALID_CHANGED,
      isValid: this.valid,
      validationMessage: this.validationMessage
    }));
  }
  openList() {
    this.isListOpen = !0, this.autocompleteList = this.createBean(new eae({
      autocompleteEntries: this.autocompleteListParams.entries,
      onConfirmed: () => this.confirmSelection(),
      forceLastSelection: this.forceLastSelection
    }));
    const t = this.autocompleteList.getGui(), r = {
      ePopup: t,
      type: "autocomplete",
      eventSource: this.getGui(),
      position: "under",
      alignSide: this.gos.get("enableRtl") ? "right" : "left",
      keepWithinBounds: !0
    }, i = this.popupService.addPopup({
      eChild: t,
      anchorToElement: this.getGui(),
      positionCallback: () => this.popupService.positionPopupByComponent(r),
      ariaLabel: this.listAriaLabel
    });
    this.hidePopup = i.hideFunc, this.autocompleteList.afterGuiAttached();
  }
  closeList() {
    this.isListOpen = !1, this.hidePopup(), this.destroyBean(this.autocompleteList), this.autocompleteList = null;
  }
  onCompleted() {
    this.isListOpen && this.closeList(), this.dispatchEvent({
      type: Tc.EVENT_VALUE_CONFIRMED,
      value: this.getValue(),
      isValid: this.isValid()
    });
  }
  getValue() {
    return Nn(this.eAutocompleteInput.getValue());
  }
  setInputPlaceholder(t) {
    return this.eAutocompleteInput.setInputPlaceholder(t), this;
  }
  setInputAriaLabel(t) {
    return this.eAutocompleteInput.setInputAriaLabel(t), this;
  }
  setListAriaLabel(t) {
    return this.listAriaLabel = t, this;
  }
  setListGenerator(t) {
    return this.listGenerator = t, this;
  }
  setValidator(t) {
    return this.validator = t, this;
  }
  isValid() {
    return this.valid;
  }
  setValue(t) {
    const { value: r, position: i, silent: n, updateListOnlyIfOpen: o, restoreFocus: s } = t;
    this.eAutocompleteInput.setValue(r, !0), this.setCaret(i ?? this.lastPosition, s), n || this.updateValue(r), (!o || this.isListOpen) && this.updateAutocompleteList(r);
  }
  setForceLastSelection(t) {
    return this.forceLastSelection = t, this;
  }
  setInputDisabled(t) {
    return this.eAutocompleteInput.setDisabled(t), this;
  }
};
fs.EVENT_VALUE_CHANGED = "eventValueChanged";
fs.EVENT_VALUE_CONFIRMED = "eventValueConfirmed";
fs.EVENT_OPTION_SELECTED = "eventOptionSelected";
fs.EVENT_VALID_CHANGED = "eventValidChanged";
v([
  T("popupService")
], fs.prototype, "popupService", 2);
v([
  ne("eAutocompleteInput")
], fs.prototype, "eAutocompleteInput", 2);
v([
  te
], fs.prototype, "postConstruct", 1);
var tae = fs, gs = class Np extends Oe {
  constructor(t, r, i, n) {
    super(), this.dragSourceDropTarget = t, this.ghost = r, this.horizontal = i, this.template = n;
  }
  init() {
    var t;
    this.setTemplate((t = this.template) != null ? t : Np.TEMPLATE);
    const r = this.getGui();
    this.addElementClasses(r), this.addElementClasses(this.eDragHandle, "drag-handle"), this.addElementClasses(this.eText, "text"), this.addElementClasses(this.eButton, "button"), this.eDragHandle.appendChild(It("columnDrag", this.gos)), this.eButton.appendChild(It("cancel", this.gos)), this.setupComponents(), !this.ghost && this.isDraggable() && this.addDragSource(), this.setupAria(), this.setupTooltip(), this.activateTabIndex(), this.refreshDraggable();
  }
  isDraggable() {
    return !0;
  }
  refreshDraggable() {
    this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !this.isDraggable());
  }
  setupAria() {
    const t = this.localeService.getLocaleTextFunc(), r = [this.getAriaDisplayName()];
    this.addAdditionalAriaInstructions(r, t), Si(this.getGui(), r.join(". "));
  }
  addAdditionalAriaInstructions(t, r) {
    if (this.isRemovable()) {
      const i = r("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
      t.push(i);
    }
  }
  setupTooltip() {
    const t = () => {
      const r = this.getTooltip();
      this.setTooltip({ newTooltipText: r });
    };
    t(), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, t);
  }
  getDragSourceId() {
  }
  getDefaultIconName() {
    return _e.ICON_NOT_ALLOWED;
  }
  addDragSource() {
    const { dragAndDropService: t, eDragHandle: r } = this, i = this.createGetDragItem(), n = this.getDefaultIconName(), o = {
      type: this.getDragSourceType(),
      sourceId: this.getDragSourceId(),
      eElement: r,
      getDefaultIconName: () => n,
      getDragItem: i,
      dragItemName: this.getDisplayName()
    };
    t.addDragSource(o, !0), this.addDestroyFunc(() => t.removeDragSource(o));
  }
  setupComponents() {
    this.setTextValue(), this.setupRemove(), this.ghost && this.addCssClass("ag-column-drop-cell-ghost");
  }
  isRemovable() {
    return !0;
  }
  refreshRemove() {
    We(this.eButton, this.isRemovable());
  }
  setupRemove() {
    this.refreshRemove();
    const t = { type: Np.EVENT_COLUMN_REMOVE };
    this.addGuiEventListener("keydown", (i) => this.onKeyDown(i)), this.addManagedListener(this.eButton, "click", (i) => {
      this.dispatchEvent(t), i.stopPropagation();
    });
    const r = new mr(this.eButton);
    this.addManagedListener(r, mr.EVENT_TAP, () => {
      this.dispatchEvent(t);
    }), this.addDestroyFunc(r.destroy.bind(r));
  }
  onKeyDown(t) {
    t.key === k.DELETE && this.isRemovable() && (t.preventDefault(), this.dispatchEvent({ type: Np.EVENT_COLUMN_REMOVE }));
  }
  getDisplayValue() {
    return this.getDisplayName();
  }
  setTextValue() {
    const t = this.getDisplayValue(), r = Yt(t);
    this.eText.innerHTML = r;
  }
  addElementClasses(t, r) {
    r = r ? `-${r}` : "";
    const i = this.horizontal ? "horizontal" : "vertical";
    t.classList.add(`ag-column-drop-cell${r}`, `ag-column-drop-${i}-cell${r}`);
  }
  destroy() {
    super.destroy(), this.dragSourceDropTarget = null;
  }
};
gs.EVENT_COLUMN_REMOVE = "columnRemove";
gs.TEMPLATE = /* html */
`<span role="option">
          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
        </span>`;
v([
  T("dragAndDropService")
], gs.prototype, "dragAndDropService", 2);
v([
  ne("eText")
], gs.prototype, "eText", 2);
v([
  ne("eDragHandle")
], gs.prototype, "eDragHandle", 2);
v([
  ne("eButton")
], gs.prototype, "eButton", 2);
v([
  te
], gs.prototype, "init", 1);
var rae = gs, Fh = class Sn extends Oe {
  constructor(t) {
    super(
      /* html */
      '<div class="ag-unselectable" role="presentation"></div>'
    ), this.horizontal = t, this.state = Sn.STATE_NOT_DRAGGING, this.guiDestroyFunctions = [], this.childPillComponents = [], this.resizeEnabled = !1, this.addElementClasses(this.getGui()), this.ePillDropList = document.createElement("div"), this.addElementClasses(this.ePillDropList, "list"), Nt(this.ePillDropList, "listbox");
  }
  isHorizontal() {
    return this.horizontal;
  }
  toggleResizable(t) {
    this.positionableFeature.setResizable(t ? { bottom: !0 } : !1), this.resizeEnabled = t;
  }
  isSourceEventFromTarget(t) {
    const { dropZoneTarget: r, dragSource: i } = t;
    return r.contains(i.eElement);
  }
  destroy() {
    this.destroyGui(), super.destroy();
  }
  destroyGui() {
    this.guiDestroyFunctions.forEach((t) => t()), this.guiDestroyFunctions.length = 0, this.childPillComponents.length = 0, Ht(this.getGui()), Ht(this.ePillDropList);
  }
  init(t) {
    this.params = t ?? {}, this.createManagedBean(new cs(
      this.getFocusableElement(),
      {
        handleKeyDown: this.handleKeyDown.bind(this)
      }
    )), this.setupDropTarget(), this.positionableFeature = new Vu(this.getGui(), { minHeight: 100 }), this.createManagedBean(this.positionableFeature), this.refreshGui(), Si(this.ePillDropList, this.getAriaLabel());
  }
  handleKeyDown(t) {
    const r = !this.horizontal;
    let i = t.key === k.DOWN, n = t.key === k.UP;
    if (!r) {
      const s = this.gos.get("enableRtl");
      i = !s && t.key === k.RIGHT || s && t.key === k.LEFT, n = !s && t.key === k.LEFT || s && t.key === k.RIGHT;
    }
    if (!i && !n)
      return;
    const o = this.focusService.findNextFocusableElement(
      this.getFocusableElement(),
      !1,
      n
    );
    o && (t.preventDefault(), o.focus());
  }
  addElementClasses(t, r) {
    r = r ? `-${r}` : "";
    const i = this.horizontal ? "horizontal" : "vertical";
    t.classList.add(`ag-column-drop${r}`, `ag-column-drop-${i}${r}`);
  }
  setupDropTarget() {
    this.dropTarget = {
      getContainer: this.getGui.bind(this),
      getIconName: this.getIconName.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragEnter: this.onDragEnter.bind(this),
      onDragLeave: this.onDragLeave.bind(this),
      onDragStop: this.onDragStop.bind(this),
      isInterestedIn: this.isInterestedIn.bind(this)
    }, this.dragAndDropService.addDropTarget(this.dropTarget);
  }
  minimumAllowedNewInsertIndex() {
    return 0;
  }
  checkInsertIndex(t) {
    const r = this.getNewInsertIndex(t);
    if (r < 0)
      return !1;
    const i = this.minimumAllowedNewInsertIndex(), n = Math.max(i, r), o = n !== this.insertIndex;
    return o && (this.insertIndex = n), o;
  }
  getNewInsertIndex(t) {
    const r = t.event, i = this.horizontal ? r.clientX : r.clientY, n = this.childPillComponents.map((s) => s.getGui().getBoundingClientRect()), o = n.findIndex((s) => this.horizontal ? s.right > i && s.left < i : s.top < i && s.bottom > i);
    if (o === -1) {
      const s = this.gos.get("enableRtl");
      return n.every((u) => i > (this.horizontal ? u.right : u.bottom)) ? s && this.horizontal ? 0 : this.childPillComponents.length : n.every((u) => i < (this.horizontal ? u.left : u.top)) ? s && this.horizontal ? this.childPillComponents.length : 0 : this.insertIndex;
    }
    return this.insertIndex <= o ? o + 1 : o;
  }
  checkDragStartedBySelf(t) {
    this.state === Sn.STATE_NOT_DRAGGING && (this.state = Sn.STATE_REARRANGE_ITEMS, this.potentialDndItems = this.getItems(t.dragSource.getDragItem()), this.refreshGui(), this.checkInsertIndex(t), this.refreshGui());
  }
  onDragging(t) {
    this.checkDragStartedBySelf(t), this.checkInsertIndex(t) && this.refreshGui();
  }
  handleDragEnterEnd(t) {
  }
  onDragEnter(t) {
    const r = this.getItems(t.dragSource.getDragItem());
    this.state = Sn.STATE_NEW_ITEMS_IN;
    const i = r.filter((o) => this.isItemDroppable(o, t)), n = i.every((o) => this.childPillComponents.map((s) => s.getItem()).indexOf(o) !== -1);
    if (i.length !== 0) {
      if (this.potentialDndItems = i, n) {
        this.state = Sn.STATE_NOT_DRAGGING;
        return;
      }
      this.handleDragEnterEnd(t), this.checkInsertIndex(t), this.refreshGui();
    }
  }
  isPotentialDndItems() {
    return VF(this.potentialDndItems);
  }
  handleDragLeaveEnd(t) {
  }
  onDragLeave(t) {
    if (this.state === Sn.STATE_REARRANGE_ITEMS) {
      const r = this.getItems(t.dragSource.getDragItem());
      this.removeItems(r);
    }
    this.isPotentialDndItems() && (this.handleDragLeaveEnd(t), this.potentialDndItems = [], this.refreshGui()), this.state = Sn.STATE_NOT_DRAGGING;
  }
  refreshOnDragStop() {
    return !0;
  }
  onDragStop() {
    if (this.isPotentialDndItems()) {
      let t = !1;
      this.state === Sn.STATE_NEW_ITEMS_IN ? (this.addItems(this.potentialDndItems), t = !0) : t = this.rearrangeItems(this.potentialDndItems), this.potentialDndItems = [], (this.refreshOnDragStop() || !t) && this.refreshGui();
    }
    this.state = Sn.STATE_NOT_DRAGGING;
  }
  removeItems(t) {
    const r = this.getExistingItems().filter((i) => !yi(t, i));
    this.updateItems(r);
  }
  addItems(t) {
    if (!t)
      return;
    const r = this.getExistingItems().slice(), i = t.filter((n) => r.indexOf(n) < 0);
    Ob(r, i, this.insertIndex), this.updateItems(r);
  }
  addItem(t) {
    this.insertIndex = this.getExistingItems().length, this.addItems([t]), this.refreshGui();
  }
  rearrangeItems(t) {
    const r = this.getNonGhostItems().slice();
    return Ob(r, t, this.insertIndex), On(r, this.getExistingItems()) ? !1 : (this.updateItems(r), !0);
  }
  refreshGui() {
    const t = this.ePillDropList.scrollTop, r = this.resizeEnabled, i = this.getFocusedItem();
    let n = this.focusService.findNextFocusableElement();
    n || (n = this.focusService.findNextFocusableElement(void 0, !1, !0)), this.toggleResizable(!1), this.destroyGui(), this.addIconAndTitleToGui(), this.addEmptyMessageToGui(), this.addItemsToGui(), this.isHorizontal() || (this.ePillDropList.scrollTop = t), r && this.toggleResizable(r), this.focusService.isKeyboardMode() && this.restoreFocus(i, n);
  }
  getFocusedItem() {
    const t = this.getGui(), r = this.gos.getActiveDomElement();
    return t.contains(r) ? Array.from(t.querySelectorAll(".ag-column-drop-cell")).indexOf(r) : -1;
  }
  restoreFocus(t, r) {
    const i = this.getGui(), n = Array.from(i.querySelectorAll(".ag-column-drop-cell"));
    if (t === -1)
      return;
    n.length === 0 && r.focus();
    const o = Math.min(n.length - 1, t), s = n[o];
    s && s.focus();
  }
  focusList(t) {
    const r = t ? this.childPillComponents.length - 1 : 0;
    this.restoreFocus(r, this.getFocusableElement());
  }
  getNonGhostItems() {
    const t = this.getExistingItems();
    return this.isPotentialDndItems() ? t.filter((r) => !yi(this.potentialDndItems, r)) : t;
  }
  addItemsToGui() {
    const r = this.getNonGhostItems().map((i) => this.createItemComponent(i, !1));
    if (this.isPotentialDndItems()) {
      const i = this.potentialDndItems.map((n) => this.createItemComponent(n, !0));
      this.insertIndex >= r.length ? r.push(...i) : r.splice(this.insertIndex, 0, ...i);
    }
    this.appendChild(this.ePillDropList), r.forEach((i, n) => {
      n > 0 && this.addArrow(this.ePillDropList), this.ePillDropList.appendChild(i.getGui());
    }), this.addAriaLabelsToComponents();
  }
  addAriaLabelsToComponents() {
    this.childPillComponents.forEach((t, r) => {
      const i = t.getGui();
      Nm(i, r + 1), _m(i, this.childPillComponents.length);
    });
  }
  createItemComponent(t, r) {
    const i = this.createPillComponent(t, this.dropTarget, r, this.horizontal);
    return i.addEventListener(rae.EVENT_COLUMN_REMOVE, this.removeItems.bind(this, [t])), this.context.createBean(i), this.guiDestroyFunctions.push(() => this.destroyBean(i)), r || this.childPillComponents.push(i), i;
  }
  addIconAndTitleToGui() {
    const { title: t, icon: r } = this.params;
    if (!t || !r)
      return;
    const i = document.createElement("div");
    if (Ch(i, !0), this.addElementClasses(i, "title-bar"), this.addElementClasses(r, "icon"), this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingItemsEmpty()), i.appendChild(r), !this.horizontal) {
      const n = document.createElement("span");
      this.addElementClasses(n, "title"), n.innerHTML = t, i.appendChild(n);
    }
    this.appendChild(i);
  }
  isExistingItemsEmpty() {
    return this.getExistingItems().length === 0;
  }
  addEmptyMessageToGui() {
    const { emptyMessage: t } = this.params;
    if (!t || !this.isExistingItemsEmpty() || this.isPotentialDndItems())
      return;
    const r = document.createElement("span");
    r.innerHTML = t, this.addElementClasses(r, "empty-message"), this.ePillDropList.appendChild(r);
  }
  addArrow(t) {
    if (this.horizontal) {
      const r = this.gos.get("enableRtl"), i = It(r ? "smallLeft" : "smallRight", this.gos);
      this.addElementClasses(i, "cell-separator"), t.appendChild(i);
    }
  }
};
Fh.STATE_NOT_DRAGGING = "notDragging";
Fh.STATE_NEW_ITEMS_IN = "newItemsIn";
Fh.STATE_REARRANGE_ITEMS = "rearrangeItems";
v([
  T("focusService")
], Fh.prototype, "focusService", 2);
v([
  T("dragAndDropService")
], Fh.prototype, "dragAndDropService", 2);
var iae = ["touchstart", "touchend", "touchmove", "touchcancel"], QN = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t();
  }
  setInterval(e, t) {
    return new qt((r) => {
      r(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, r, i) {
    const n = yi(iae, t);
    e.addEventListener(t, r, { capture: !!i, passive: n });
  }
  get shouldWrapOutgoing() {
    return !1;
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `https://www.ag-grid.com/${this.frameworkName === "solid" ? "react" : this.frameworkName}-data-grid${e ? `/${e}` : ""}`;
  }
}, Qo = class extends Q {
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, r = !1) {
    return r ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const r = e === k.UP, i = e === k.DOWN, n = e === k.LEFT;
    let o, s;
    if (r || i)
      s = r ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow(), o = t.column;
    else {
      const a = this.columnModel.getAllDisplayedColumns(), l = this.gos.get("enableRtl");
      s = t.rowIndex, o = n !== l ? a[0] : ze(a);
    }
    return {
      rowIndex: s,
      rowPinned: null,
      column: o
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let r = t, i = !1;
    for (; !i; ) {
      switch (e) {
        case k.UP:
          r = this.getCellAbove(r);
          break;
        case k.DOWN:
          r = this.getCellBelow(r);
          break;
        case k.RIGHT:
          this.gos.get("enableRtl") ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
          break;
        case k.LEFT:
          this.gos.get("enableRtl") ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
          break;
        default:
          r = null, console.warn("AG Grid: unknown key for navigation " + e);
          break;
      }
      r ? i = this.isCellGoodToFocusOn(r) : i = !0;
    }
    return r;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let r;
    switch (e.rowPinned) {
      case "top":
        r = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        r = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        r = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return r ? !t.isSuppressNavigable(r) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.columnModel.getDisplayedColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.columnModel.getDisplayedColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (this.isLastRowInContainer(e))
      switch (r) {
        case "bottom":
          return null;
        case "top":
          return this.rowModel.isRowsToRender() ? { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    const i = this.rowModel.getRow(e.rowIndex), n = this.getNextStickyPosition(i);
    return n || { rowIndex: t + 1, rowPinned: r };
  }
  getNextStickyPosition(e, t) {
    if (!this.gos.isGroupRowsSticky() || !e || !e.sticky)
      return;
    const r = this.rowRenderer.getStickyTopRowCtrls().some((a) => a.getRowNode().rowIndex === e.rowIndex);
    let i = [];
    r ? i = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
      (a, l) => a.getRowNode().rowIndex - l.getRowNode().rowIndex
    ) : i = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
      (a, l) => l.getRowNode().rowIndex - a.getRowNode().rowIndex
    );
    const n = t ? -1 : 1, o = i.findIndex((a) => a.getRowNode().rowIndex === e.rowIndex), s = i[o + n];
    if (s)
      return { rowIndex: s.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, r = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowData().length - 1 <= r : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowData().length - 1 <= r : this.paginationProxy.getPageLastRow() <= r;
  }
  getRowAbove(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (r ? t === 0 : t === this.paginationProxy.getPageFirstRow())
      return r === "top" ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    const n = this.rowModel.getRow(e.rowIndex), o = this.getNextStickyPosition(n, !0);
    return o || { rowIndex: t - 1, rowPinned: r };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.paginationProxy.getPageLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowData().length - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    const t = this.columnModel.getAllDisplayedColumns();
    let r = e.rowIndex, i = e.rowPinned, n = this.columnModel.getDisplayedColAfter(e.column);
    if (!n) {
      n = t[0];
      const o = this.getRowBelow(e);
      if (Re(o) || !o.rowPinned && !this.paginationProxy.isRowInPage(o))
        return null;
      r = o ? o.rowIndex : null, i = o ? o.rowPinned : null;
    }
    return { rowIndex: r, column: n, rowPinned: i };
  }
  getNextTabbedCellBackwards(e) {
    const t = this.columnModel.getAllDisplayedColumns();
    let r = e.rowIndex, i = e.rowPinned, n = this.columnModel.getDisplayedColBefore(e.column);
    if (!n) {
      n = ze(t);
      const o = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (Re(o) || !o.rowPinned && !this.paginationProxy.isRowInPage(o))
        return null;
      r = o ? o.rowIndex : null, i = o ? o.rowPinned : null;
    }
    return { rowIndex: r, column: n, rowPinned: i };
  }
};
v([
  T("columnModel")
], Qo.prototype, "columnModel", 2);
v([
  T("rowModel")
], Qo.prototype, "rowModel", 2);
v([
  T("rowRenderer")
], Qo.prototype, "rowRenderer", 2);
v([
  T("pinnedRowModel")
], Qo.prototype, "pinnedRowModel", 2);
v([
  T("paginationProxy")
], Qo.prototype, "paginationProxy", 2);
Qo = v([
  de("cellNavigationService")
], Qo);
var ha = class extends Q {
  constructor() {
    super(...arguments), this.consuming = !1;
  }
  setBeans(e) {
    this.logger = e.create("AlignedGridsService");
  }
  getAlignedGridApis() {
    var e;
    let t = (e = this.gos.get("alignedGrids")) != null ? e : [];
    const r = typeof t == "function";
    typeof t == "function" && (t = t());
    const i = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
    return t.map((o) => {
      var s;
      if (!o) {
        ks("alignedGrids contains an undefined option."), r || ks(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`), ks(i());
        return;
      }
      if (o instanceof Be)
        return o;
      const a = o;
      return "current" in a ? (s = a.current) == null ? void 0 : s.api : (a.api || ks(`alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${i()}`), a.api);
    }).filter((o) => !!o && !o.isDestroyed());
  }
  init() {
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      if (t.isDestroyed())
        return;
      const r = t.__getAlignedGridService();
      e(r);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    this.fireEvent((t) => {
      t.onColumnEvent(e);
    });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent((t) => {
      t.onScrollEvent(e);
    });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  getMasterColumns(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r);
    }) : e.column && t.push(e.column), t;
  }
  getColumnIds(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r.getColId());
    }) : e.column && t.push(e.column.getColId()), t;
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case A.EVENT_COLUMN_MOVED:
        case A.EVENT_COLUMN_VISIBLE:
        case A.EVENT_COLUMN_PINNED:
        case A.EVENT_COLUMN_RESIZED:
          const t = e;
          this.processColumnEvent(t);
          break;
        case A.EVENT_COLUMN_GROUP_OPENED:
          const r = e;
          this.processGroupOpenedEvent(r);
          break;
        case A.EVENT_COLUMN_PIVOT_CHANGED:
          console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    e.columnGroups.forEach((t) => {
      let r = null;
      if (t) {
        const i = t.getGroupId();
        r = this.columnModel.getProvidedColumnGroup(i);
      }
      t && !r || (this.logger.log("onColumnEvent-> processing " + e + " expanded = " + t.isExpanded()), this.columnModel.setColumnGroupOpened(r, t.isExpanded(), "alignedGridChanged"));
    });
  }
  processColumnEvent(e) {
    var t;
    const r = e.column;
    let i = null;
    if (r && (i = this.columnModel.getPrimaryColumn(r.getColId())), r && !i)
      return;
    const n = this.getMasterColumns(e);
    switch (e.type) {
      case A.EVENT_COLUMN_MOVED:
        {
          const u = e, d = e.api.getColumnState().map((h) => ({ colId: h.colId }));
          this.columnModel.applyColumnState(
            { state: d, applyOrder: !0 },
            "alignedGridChanged"
          ), this.logger.log(`onColumnEvent-> processing ${e.type} toIndex = ${u.toIndex}`);
        }
        break;
      case A.EVENT_COLUMN_VISIBLE:
        {
          const u = e, d = e.api.getColumnState().map((h) => ({ colId: h.colId, hide: h.hide }));
          this.columnModel.applyColumnState({ state: d }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} visible = ${u.visible}`);
        }
        break;
      case A.EVENT_COLUMN_PINNED:
        {
          const u = e, d = e.api.getColumnState().map((h) => ({ colId: h.colId, pinned: h.pinned }));
          this.columnModel.applyColumnState({ state: d }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} pinned = ${u.pinned}`);
        }
        break;
      case A.EVENT_COLUMN_RESIZED:
        const a = e, l = {};
        n.forEach((u) => {
          this.logger.log(`onColumnEvent-> processing ${e.type} actualWidth = ${u.getActualWidth()}`), l[u.getId()] = { key: u.getColId(), newWidth: u.getActualWidth() };
        }), (t = a.flexColumns) == null || t.forEach((u) => {
          l[u.getId()] && delete l[u.getId()];
        }), this.columnModel.setColumnWidths(Object.values(l), !1, a.finished, "alignedGridChanged");
        break;
    }
    const s = this.ctrlsService.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((a) => {
      a.setGridOption("alwaysShowVerticalScroll", s);
    });
  }
};
v([
  T("columnModel")
], ha.prototype, "columnModel", 2);
v([
  T("ctrlsService")
], ha.prototype, "ctrlsService", 2);
v([
  an(0, Gi("loggerFactory"))
], ha.prototype, "setBeans", 1);
v([
  te
], ha.prototype, "init", 1);
ha = v([
  de("alignedGridsService")
], ha);
var pa = class extends Q {
  constructor() {
    super(...arguments), this.selectedNodes = /* @__PURE__ */ new Map(), this.lastRowNode = null;
  }
  init() {
    this.rowSelection = this.gos.get("rowSelection"), this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.rowSelection = this.gos.get("rowSelection"), this.deselectAllRowNodes({ source: "api" });
    }), this.addManagedListener(this.eventService, A.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
  }
  destroy() {
    super.destroy(), this.resetNodes(), this.lastRowNode = null;
  }
  isMultiselect() {
    return this.rowSelection === "multiple";
  }
  setNodesSelected(e) {
    var t;
    const {
      newValue: r,
      clearSelection: i,
      suppressFinishActions: n,
      rangeSelect: o,
      nodes: s,
      event: a,
      source: l = "api"
    } = e;
    if (s.length === 0)
      return 0;
    if (s.length > 1 && !this.isMultiselect())
      return console.warn("AG Grid: cannot multi select while rowSelection='single'"), 0;
    const u = this.groupSelectsChildren && e.groupSelectsFiltered === !0, c = s.map((h) => h.footer ? h.sibling : h);
    if (o) {
      if (s.length > 1)
        return console.warn("AG Grid: cannot range select while selecting multiple rows"), 0;
      let h = null;
      if (l === "checkboxSelected" && r === !1 && this.lastRowNode && (this.lastRowNode.id ? h = this.lastRowNode : this.lastRowNode = null), h == null && (h = this.getLastSelectedNode()), h) {
        const p = c[0];
        if (p !== h && this.isMultiselect())
          return this.selectRange(p, h, r, l);
      }
    }
    this.lastRowNode = r ? null : c[0];
    let d = 0;
    for (let h = 0; h < c.length; h++) {
      const p = c[h];
      u && p.group || p.selectThisNode(r, a, l) && d++, this.groupSelectsChildren && ((t = p.childrenAfterGroup) != null && t.length) && (d += this.selectChildren(p, r, u, l));
    }
    if (!n && (r && (i || !this.isMultiselect()) && (d += this.clearOtherNodes(c[0], l)), d > 0)) {
      this.updateGroupsFromChildrenSelections(l);
      const p = {
        type: A.EVENT_SELECTION_CHANGED,
        source: l
      };
      this.eventService.dispatchEvent(p);
    }
    return d;
  }
  // selects all rows between this node and the last selected node (or the top if this is the first selection).
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, r = !0, i) {
    const n = this.rowModel.getNodesInRangeForSelection(e, t);
    let o = 0;
    n.forEach((a) => {
      if (a.group && this.groupSelectsChildren)
        return;
      a.selectThisNode(r, void 0, i) && o++;
    }), this.updateGroupsFromChildrenSelections(i);
    const s = {
      type: A.EVENT_SELECTION_CHANGED,
      source: i
    };
    return this.eventService.dispatchEvent(s), o;
  }
  selectChildren(e, t, r, i) {
    const n = r ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return Re(n) ? 0 : this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      groupSelectsFiltered: r,
      source: i,
      nodes: n
    });
  }
  getLastSelectedNode() {
    const e = Array.from(this.selectedNodes.keys());
    if (e.length == 0)
      return null;
    const t = this.selectedNodes.get(ze(e));
    return t || null;
  }
  getSelectedNodes() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && e.push(t);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && t.data && e.push(t.data);
    }), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((r, i) => {
      r && e(r) && t.set(i, r);
    }), this.selectedNodes = t;
  }
  // should only be called if groupSelectsChildren=true
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || this.rowModel.getType() !== "clientSide")
      return !1;
    const i = this.rowModel.getRootNode();
    t || (t = new ov(!0, i), t.setInactive());
    let n = !1;
    return t.forEachChangedNodeDepthFirst((o) => {
      if (o !== i) {
        const s = o.calculateSelectedFromChildren();
        n = o.selectThisNode(s === null ? !1 : s, void 0, e) || n;
      }
    }), n;
  }
  clearOtherNodes(e, t) {
    const r = /* @__PURE__ */ new Map();
    let i = 0;
    return this.selectedNodes.forEach((n) => {
      if (n && n.id !== e.id) {
        const o = this.selectedNodes.get(n.id);
        i += o.setSelectedParams({
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsChildren && n.parent && r.set(n.parent.id, n.parent);
      }
    }), r.forEach((n) => {
      const o = n.calculateSelectedFromChildren();
      n.selectThisNode(o === null ? !1 : o, void 0, t);
    }), i;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    if (q(t) && e.id !== t.id && t) {
      const i = t.id;
      this.selectedNodes.get(i) == e && this.selectedNodes.set(t.id, t);
    }
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(!1);
  }
  reset(e) {
    const t = this.getSelectionCount();
    if (this.resetNodes(), t) {
      const r = {
        type: A.EVENT_SELECTION_CHANGED,
        source: e
      };
      this.eventService.dispatchEvent(r);
    }
  }
  resetNodes() {
    var e;
    (e = this.selectedNodes) == null || e.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    if (this.rowModel.getType() !== "clientSide")
      return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null)
      return;
    const r = [];
    function i(n) {
      for (let o = 0, s = n.length; o < s; o++) {
        const a = n[o];
        if (a.isSelected())
          r.push(a);
        else {
          const l = a;
          l.group && l.children && i(l.children);
        }
      }
    }
    return i(t), r;
  }
  isEmpty() {
    let e = 0;
    return this.selectedNodes.forEach((t) => {
      t && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (a) => a.selectThisNode(!1, void 0, i), r = this.rowModel.getType() === "clientSide", { source: i, justFiltered: n, justCurrentPage: o } = e;
    if (o || n) {
      if (!r) {
        console.error("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(n, o).forEach(t);
    } else
      this.selectedNodes.forEach((a) => {
        a && t(a);
      }), this.reset(i);
    r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(i);
    const s = {
      type: A.EVENT_SELECTION_CHANGED,
      source: i
    };
    this.eventService.dispatchEvent(s);
  }
  getSelectedCounts(e, t) {
    let r = 0, i = 0;
    const n = (o) => {
      this.groupSelectsChildren && o.group || (o.isSelected() ? r++ : o.selectable && i++);
    };
    return this.getNodesToSelect(e, t).forEach(n), { selectedCount: r, notSelectedCount: i };
  }
  getSelectAllState(e, t) {
    const { selectedCount: r, notSelectedCount: i } = this.getSelectedCounts(e, t);
    return r === 0 && i === 0 ? !1 : r > 0 && i > 0 ? null : r > 0;
  }
  hasNodesToSelect(e = !1, t = !1) {
    return this.getNodesToSelect(e, t).filter((r) => r.selectable).length > 0;
  }
  /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e = !1, t = !1) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    const r = [];
    if (t)
      return this.paginationProxy.forEachNodeOnPage((n) => {
        if (!n.group) {
          r.push(n);
          return;
        }
        if (!n.expanded) {
          const o = (s) => {
            var a;
            r.push(s), (a = s.childrenAfterFilter) != null && a.length && s.childrenAfterFilter.forEach(o);
          };
          o(n);
          return;
        }
        this.groupSelectsChildren || r.push(n);
      }), r;
    const i = this.rowModel;
    return e ? (i.forEachNodeAfterFilter((n) => {
      r.push(n);
    }), r) : (i.forEachNode((n) => {
      r.push(n);
    }), r);
  }
  selectAllRowNodes(e) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    const { source: t, justFiltered: r, justCurrentPage: i } = e, n = (s) => s.selectThisNode(!0, void 0, t);
    this.getNodesToSelect(r, i).forEach(n), this.rowModel.getType() === "clientSide" && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t);
    const o = {
      type: A.EVENT_SELECTION_CHANGED,
      source: t
    };
    this.eventService.dispatchEvent(o);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t != null && t.id && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e))
      return;
    const r = new Set(e), i = [];
    this.rowModel.forEachNode((n) => {
      r.has(n.id) && i.push(n);
    }), this.setNodesSelected({
      newValue: !0,
      nodes: i,
      source: t
    });
  }
};
v([
  T("rowModel")
], pa.prototype, "rowModel", 2);
v([
  T("paginationProxy")
], pa.prototype, "paginationProxy", 2);
v([
  te
], pa.prototype, "init", 1);
pa = v([
  de("selectionService")
], pa);
var ru = class {
  constructor(e) {
    this.viaApi = (t, ...r) => (we(`Since v31, 'columnApi.${t}' is deprecated and moved to 'api.${t}'.`), this.api[t](...r)), this.api = e;
  }
  /** @deprecated v31 use `api.sizeColumnsToFit()` instead.   */
  sizeColumnsToFit(e) {
    this.viaApi("sizeColumnsToFit", e);
  }
  /** @deprecated v31 use `api.setColumnGroupOpened() instead. */
  setColumnGroupOpened(e, t) {
    this.viaApi("setColumnGroupOpened", e, t);
  }
  /** @deprecated v31 use `api.getColumnGroup() instead. */
  getColumnGroup(e, t) {
    return this.viaApi("getColumnGroup", e, t);
  }
  /** @deprecated v31 use `api.getProvidedColumnGroup() instead. */
  getProvidedColumnGroup(e) {
    return this.viaApi("getProvidedColumnGroup", e);
  }
  /** @deprecated v31 use `api.getDisplayNameForColumn() instead. */
  getDisplayNameForColumn(e, t) {
    return this.viaApi("getDisplayNameForColumn", e, t);
  }
  /** @deprecated v31 use `api.getDisplayNameForColumnGroup() instead. */
  getDisplayNameForColumnGroup(e, t) {
    return this.viaApi("getDisplayNameForColumnGroup", e, t);
  }
  /** @deprecated v31 use `api.getColumn() instead. */
  getColumn(e) {
    return this.viaApi("getColumn", e);
  }
  /** @deprecated v31 use `api.getColumns() instead. */
  getColumns() {
    return this.viaApi("getColumns");
  }
  /** @deprecated v31 use `api.applyColumnState() instead. */
  applyColumnState(e) {
    return this.viaApi("applyColumnState", e);
  }
  /** @deprecated v31 use `api.getColumnState() instead. */
  getColumnState() {
    return this.viaApi("getColumnState");
  }
  /** @deprecated v31 use `api.resetColumnState() instead. */
  resetColumnState() {
    this.viaApi("resetColumnState");
  }
  /** @deprecated v31 use `api.getColumnGroupState() instead. */
  getColumnGroupState() {
    return this.viaApi("getColumnGroupState");
  }
  /** @deprecated v31 use `api.setColumnGroupState() instead. */
  setColumnGroupState(e) {
    this.viaApi("setColumnGroupState", e);
  }
  /** @deprecated v31 use `api.resetColumnGroupState() instead. */
  resetColumnGroupState() {
    this.viaApi("resetColumnGroupState");
  }
  /** @deprecated v31 use `api.isPinning() instead. */
  isPinning() {
    return this.viaApi("isPinning");
  }
  /** @deprecated v31 use `api.isPinningLeft() instead. */
  isPinningLeft() {
    return this.viaApi("isPinningLeft");
  }
  /** @deprecated v31 use `api.isPinningRight() instead. */
  isPinningRight() {
    return this.viaApi("isPinningRight");
  }
  /** @deprecated v31 use `api.getDisplayedColAfter() instead. */
  getDisplayedColAfter(e) {
    return this.viaApi("getDisplayedColAfter", e);
  }
  /** @deprecated v31 use `api.getDisplayedColBefore() instead. */
  getDisplayedColBefore(e) {
    return this.viaApi("getDisplayedColBefore", e);
  }
  /** @deprecated v31 use `api.setColumnVisible() instead. */
  setColumnVisible(e, t) {
    this.viaApi("setColumnVisible", e, t);
  }
  /** @deprecated v31 use `api.setColumnsVisible() instead. */
  setColumnsVisible(e, t) {
    this.viaApi("setColumnsVisible", e, t);
  }
  /** @deprecated v31 use `api.setColumnPinned() instead. */
  setColumnPinned(e, t) {
    this.viaApi("setColumnPinned", e, t);
  }
  /** @deprecated v31 use `api.setColumnsPinned() instead. */
  setColumnsPinned(e, t) {
    this.viaApi("setColumnsPinned", e, t);
  }
  /** @deprecated v31 use `api.getAllGridColumns() instead. */
  getAllGridColumns() {
    return this.viaApi("getAllGridColumns");
  }
  /** @deprecated v31 use `api.getDisplayedLeftColumns() instead. */
  getDisplayedLeftColumns() {
    return this.viaApi("getDisplayedLeftColumns");
  }
  /** @deprecated v31 use `api.getDisplayedCenterColumns() instead. */
  getDisplayedCenterColumns() {
    return this.viaApi("getDisplayedCenterColumns");
  }
  /** @deprecated v31 use `api.getDisplayedRightColumns() instead. */
  getDisplayedRightColumns() {
    return this.viaApi("getDisplayedRightColumns");
  }
  /** @deprecated v31 use `api.getAllDisplayedColumns() instead. */
  getAllDisplayedColumns() {
    return this.viaApi("getAllDisplayedColumns");
  }
  /** @deprecated v31 use `api.getAllDisplayedVirtualColumns() instead. */
  getAllDisplayedVirtualColumns() {
    return this.viaApi("getAllDisplayedVirtualColumns");
  }
  /** @deprecated v31 use `api.moveColumn() instead. */
  moveColumn(e, t) {
    this.viaApi("moveColumn", e, t);
  }
  /** @deprecated v31 use `api.moveColumnByIndex() instead. */
  moveColumnByIndex(e, t) {
    this.viaApi("moveColumnByIndex", e, t);
  }
  /** @deprecated v31 use `api.moveColumns() instead. */
  moveColumns(e, t) {
    this.viaApi("moveColumns", e, t);
  }
  /** @deprecated v31 use `api.moveRowGroupColumn() instead. */
  moveRowGroupColumn(e, t) {
    this.viaApi("moveRowGroupColumn", e, t);
  }
  /** @deprecated v31 use `api.setColumnAggFunc() instead. */
  setColumnAggFunc(e, t) {
    this.viaApi("setColumnAggFunc", e, t);
  }
  /** @deprecated v31 use `api.setColumnWidth() instead. */
  setColumnWidth(e, t, r = !0, i) {
    this.viaApi("setColumnWidth", e, t, r, i);
  }
  /** @deprecated v31 use `api.setColumnWidths() instead. */
  setColumnWidths(e, t = !0, r) {
    this.viaApi("setColumnWidths", e, t, r);
  }
  /** @deprecated v31 use `api.setPivotMode() instead. */
  setPivotMode(e) {
    this.viaApi("setPivotMode", e);
  }
  /** @deprecated v31 use `api.isPivotMode() instead. */
  isPivotMode() {
    return this.viaApi("isPivotMode");
  }
  /** @deprecated v31 use `api.getPivotResultColumn() instead. */
  getPivotResultColumn(e, t) {
    return this.viaApi("getPivotResultColumn", e, t);
  }
  /** @deprecated v31 use `api.setValueColumns() instead. */
  setValueColumns(e) {
    this.viaApi("setValueColumns", e);
  }
  /** @deprecated v31 use `api.getValueColumns() instead. */
  getValueColumns() {
    return this.viaApi("getValueColumns");
  }
  /** @deprecated v31 use `api.removeValueColumn() instead. */
  removeValueColumn(e) {
    this.viaApi("removeValueColumn", e);
  }
  /** @deprecated v31 use `api.removeValueColumns() instead. */
  removeValueColumns(e) {
    this.viaApi("removeValueColumns", e);
  }
  /** @deprecated v31 use `api.addValueColumn() instead. */
  addValueColumn(e) {
    this.viaApi("addValueColumn", e);
  }
  /** @deprecated v31 use `api.addValueColumns() instead. */
  addValueColumns(e) {
    this.viaApi("addValueColumns", e);
  }
  /** @deprecated v31 use `api.setRowGroupColumns() instead. */
  setRowGroupColumns(e) {
    this.viaApi("setRowGroupColumns", e);
  }
  /** @deprecated v31 use `api.removeRowGroupColumn() instead. */
  removeRowGroupColumn(e) {
    this.viaApi("removeRowGroupColumn", e);
  }
  /** @deprecated v31 use `api.removeRowGroupColumns() instead. */
  removeRowGroupColumns(e) {
    this.viaApi("removeRowGroupColumns", e);
  }
  /** @deprecated v31 use `api.addRowGroupColumn() instead. */
  addRowGroupColumn(e) {
    this.viaApi("addRowGroupColumn", e);
  }
  /** @deprecated v31 use `api.addRowGroupColumns() instead. */
  addRowGroupColumns(e) {
    this.viaApi("addRowGroupColumns", e);
  }
  /** @deprecated v31 use `api.getRowGroupColumns() instead. */
  getRowGroupColumns() {
    return this.viaApi("getRowGroupColumns");
  }
  /** @deprecated v31 use `api.setPivotColumns() instead. */
  setPivotColumns(e) {
    this.viaApi("setPivotColumns", e);
  }
  /** @deprecated v31 use `api.removePivotColumn() instead. */
  removePivotColumn(e) {
    this.viaApi("removePivotColumn", e);
  }
  /** @deprecated v31 use `api.removePivotColumns() instead. */
  removePivotColumns(e) {
    this.viaApi("removePivotColumns", e);
  }
  /** @deprecated v31 use `api.addPivotColumn() instead. */
  addPivotColumn(e) {
    this.viaApi("addPivotColumn", e);
  }
  /** @deprecated v31 use `api.addPivotColumns() instead. */
  addPivotColumns(e) {
    this.viaApi("addPivotColumns", e);
  }
  /** @deprecated v31 use `api.getPivotColumns() instead. */
  getPivotColumns() {
    return this.viaApi("getPivotColumns");
  }
  /** @deprecated v31 use `api.getLeftDisplayedColumnGroups() instead. */
  getLeftDisplayedColumnGroups() {
    return this.viaApi("getLeftDisplayedColumnGroups");
  }
  /** @deprecated v31 use `api.getCenterDisplayedColumnGroups() instead. */
  getCenterDisplayedColumnGroups() {
    return this.viaApi("getCenterDisplayedColumnGroups");
  }
  /** @deprecated v31 use `api.getRightDisplayedColumnGroups() instead. */
  getRightDisplayedColumnGroups() {
    return this.viaApi("getRightDisplayedColumnGroups");
  }
  /** @deprecated v31 use `api.getAllDisplayedColumnGroups() instead. */
  getAllDisplayedColumnGroups() {
    return this.viaApi("getAllDisplayedColumnGroups");
  }
  /** @deprecated v31 use `api.autoSizeColumn() instead. */
  autoSizeColumn(e, t) {
    return this.viaApi("autoSizeColumn", e, t);
  }
  /** @deprecated v31 use `api.autoSizeColumns() instead. */
  autoSizeColumns(e, t) {
    this.viaApi("autoSizeColumns", e, t);
  }
  /** @deprecated v31 use `api.autoSizeAllColumns() instead. */
  autoSizeAllColumns(e) {
    this.viaApi("autoSizeAllColumns", e);
  }
  /** @deprecated v31 use `api.setPivotResultColumns() instead. */
  setPivotResultColumns(e) {
    this.viaApi("setPivotResultColumns", e);
  }
  /** @deprecated v31 use `api.getPivotResultColumns() instead. */
  getPivotResultColumns() {
    return this.viaApi("getPivotResultColumns");
  }
};
v([
  T("gridApi")
], ru.prototype, "api", 2);
ru = v([
  de("columnApi")
], ru);
var es = class extends Q {
  constructor() {
    super(...arguments), this.initialised = !1, this.isSsrm = !1;
  }
  init() {
    this.isSsrm = this.gos.isRowModelType("serverSide"), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (r) => this.callColumnCellValueChangedHandler(r), t = this.gos.useAsyncEvents();
    this.eventService.addEventListener(A.EVENT_CELL_VALUE_CHANGED, e, t), this.addDestroyFunc(() => this.eventService.removeEventListener(A.EVENT_CELL_VALUE_CHANGED, e, t)), this.addManagedPropertyListener("treeData", (r) => this.isTreeData = r.currentValue);
  }
  getValue(e, t, r = !1, i = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const n = e.getColDef(), o = n.field, s = e.getColId(), a = t.data;
    let l;
    const u = t.groupData && t.groupData[s] !== void 0, c = !i && t.aggData && t.aggData[s] !== void 0, d = this.isSsrm && i && !!e.getColDef().aggFunc, h = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (r && n.filterValueGetter ? l = this.executeFilterValueGetter(n.filterValueGetter, a, e, t) : this.isTreeData && c ? l = t.aggData[s] : this.isTreeData && n.valueGetter ? l = this.executeValueGetter(n.valueGetter, a, e, t) : this.isTreeData && o && a ? l = ml(a, o, e.isFieldContainsDots()) : u ? l = t.groupData[s] : c ? l = t.aggData[s] : n.valueGetter ? l = this.executeValueGetter(n.valueGetter, a, e, t) : h ? l = ml(a, t.field, e.isFieldContainsDots()) : o && a && !d && (l = ml(a, o, e.isFieldContainsDots())), this.cellExpressions && typeof l == "string" && l.indexOf("=") === 0) {
      const p = l.substring(1);
      l = this.executeValueGetter(p, a, e, t);
    }
    if (l == null) {
      const p = this.getOpenedGroup(t, e);
      if (p != null)
        return p;
    }
    return l;
  }
  parseValue(e, t, r, i) {
    const n = e.getColDef(), o = this.gos.addGridCommonParams({
      node: t,
      data: t == null ? void 0 : t.data,
      oldValue: i,
      newValue: r,
      colDef: n,
      column: e
    }), s = n.valueParser;
    return q(s) ? typeof s == "function" ? s(o) : this.expressionService.evaluate(s, o) : r;
  }
  formatValue(e, t, r, i, n = !0) {
    let o = null, s;
    const a = e.getColDef();
    if (i ? s = i : n && (s = a.valueFormatter), s) {
      const l = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t ? t.data : null,
        colDef: a,
        column: e
      });
      typeof s == "function" ? o = s(l) : o = this.expressionService.evaluate(s, l);
    } else if (a.refData)
      return a.refData[r] || "";
    return o == null && Array.isArray(r) && (o = r.join(", ")), o;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const i = t.getColDef().showRowGroup;
    let n = e.parent;
    for (; n != null; ) {
      if (n.rowGroupColumn && (i === !0 || i === n.rowGroupColumn.getColId()))
        return n.key;
      n = n.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, r, i) {
    const n = this.columnModel.getPrimaryColumn(t);
    if (!e || !n)
      return !1;
    Re(e.data) && (e.data = {});
    const { field: o, valueSetter: s } = n.getColDef();
    if (Re(o) && Re(s))
      return console.warn("AG Grid: you need either field or valueSetter set on colDef for editing to work"), !1;
    if (!this.dataTypeService.checkType(n, r))
      return console.warn("AG Grid: Data type of the new value does not match the cell data type of the column"), !1;
    const a = this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      oldValue: this.getValue(n, e),
      newValue: r,
      colDef: n.getColDef(),
      column: n
    });
    a.newValue = r;
    let l;
    if (q(s) ? typeof s == "function" ? l = s(a) : l = this.expressionService.evaluate(s, a) : l = this.setValueUsingField(e.data, o, r, n.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), a.newValue = this.getValue(n, e);
    const u = {
      type: A.EVENT_CELL_VALUE_CHANGED,
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: a.column,
      api: a.api,
      columnApi: a.columnApi,
      colDef: a.colDef,
      context: a.context,
      data: e.data,
      node: e,
      oldValue: a.oldValue,
      newValue: a.newValue,
      value: a.newValue,
      source: i
    };
    return this.eventService.dispatchEvent(u), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.getFrameworkOverrides().wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        columnApi: e.columnApi,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, r, i) {
    if (!t)
      return !1;
    let n = !1;
    if (!i)
      n = e[t] === r, n || (e[t] = r);
    else {
      const o = t.split(".");
      let s = e;
      for (; o.length > 0 && s; ) {
        const a = o.shift();
        o.length === 0 ? (n = s[a] === r, n || (s[a] = r)) : s = s[a];
      }
    }
    return !n;
  }
  executeFilterValueGetter(e, t, r, i) {
    const n = this.gos.addGridCommonParams({
      data: t,
      node: i,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, i)
    });
    return typeof e == "function" ? e(n) : this.expressionService.evaluate(e, n);
  }
  executeValueGetter(e, t, r, i) {
    const n = r.getColId(), o = this.valueCache.getValue(i, n);
    if (o !== void 0)
      return o;
    const s = this.gos.addGridCommonParams({
      data: t,
      node: i,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, i)
    });
    let a;
    return typeof e == "function" ? a = e(s) : a = this.expressionService.evaluate(e, s), this.valueCache.setValue(i, n, a), a;
  }
  getValueCallback(e, t) {
    const r = this.columnModel.getPrimaryColumn(t);
    return r ? this.getValue(r, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const r = this.getValue(e, t), i = e.getColDef().keyCreator;
    let n = r;
    if (i) {
      const o = this.gos.addGridCommonParams({
        value: r,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      n = i(o);
    }
    return typeof n == "string" || n == null || (n = String(n), n === "[object Object]" && we("a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key")), n;
  }
};
v([
  T("expressionService")
], es.prototype, "expressionService", 2);
v([
  T("columnModel")
], es.prototype, "columnModel", 2);
v([
  T("valueCache")
], es.prototype, "valueCache", 2);
v([
  T("dataTypeService")
], es.prototype, "dataTypeService", 2);
v([
  te
], es.prototype, "init", 1);
es = v([
  de("valueService")
], es);
var fg = class extends Q {
  constructor() {
    super(...arguments), this.expressionToFunctionCache = {};
  }
  setBeans(e) {
    this.logger = e.create("ExpressionService");
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    console.error("AG Grid: value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.columnApi,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (r) {
      return console.log("Processing of the expression failed"), console.log("Expression = " + e), console.log("Params =", t), console.log("Exception = " + r), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e])
      return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), r = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", t);
    return this.expressionToFunctionCache[e] = r, r;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
};
v([
  an(0, Gi("loggerFactory"))
], fg.prototype, "setBeans", 1);
fg = v([
  de("expressionService")
], fg);
var gg = class extends Q {
  setBeans(e) {
    this.logging = e.get("debug");
  }
  create(e) {
    return new OE(e, this.isLogging.bind(this));
  }
  isLogging() {
    return this.logging;
  }
};
v([
  an(0, Gi("gridOptionsService"))
], gg.prototype, "setBeans", 1);
gg = v([
  de("loggerFactory")
], gg);
var OE = class {
  constructor(e, t) {
    this.name = e, this.isLoggingFunc = t;
  }
  isLogging() {
    return this.isLoggingFunc();
  }
  log(e) {
    this.isLoggingFunc() && console.log("AG Grid." + this.name + ": " + e);
  }
}, ms = class extends Q {
  setComp(e, t, r) {
    this.view = e, this.eGridHostDiv = t, this.eGui = r, this.eGui.setAttribute("grid-id", this.context.getGridId()), this.dragAndDropService.addDropTarget({
      getContainer: () => this.eGui,
      isInterestedIn: (n) => n === 1 || n === 0,
      getIconName: () => _e.ICON_NOT_ALLOWED
    }), this.mouseEventService.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new qm(this.view)), this.addRtlSupport();
    const i = this.resizeObserverService.observeResize(
      this.eGridHostDiv,
      this.onGridSizeChanged.bind(this)
    );
    this.addDestroyFunc(() => i()), this.ctrlsService.register("gridCtrl", this);
  }
  isDetailGrid() {
    var e;
    const t = this.focusService.findTabbableParent(this.getGui());
    return ((e = t == null ? void 0 : t.getAttribute("row-id")) == null ? void 0 : e.startsWith("detail")) || !1;
  }
  showDropZones() {
    return Xe.__isRegistered("@ag-grid-enterprise/row-grouping", this.context.getGridId());
  }
  showSideBar() {
    return Xe.__isRegistered("@ag-grid-enterprise/side-bar", this.context.getGridId());
  }
  showStatusBar() {
    return Xe.__isRegistered("@ag-grid-enterprise/status-bar", this.context.getGridId());
  }
  showWatermark() {
    return Xe.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId());
  }
  onGridSizeChanged() {
    const e = {
      type: A.EVENT_GRID_SIZE_CHANGED,
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    };
    this.eventService.dispatchEvent(e);
  }
  addRtlSupport() {
    const e = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
    this.view.setRtlClass(e);
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.view.getFocusableContainers(), r = this.gos.getActiveDomElement(), n = t.findIndex((o) => o.contains(r)) + (e ? -1 : 1);
    return n <= 0 || n >= t.length ? !1 : this.focusService.focusInto(t[n]);
  }
  focusInnerElement(e) {
    const t = this.view.getFocusableContainers(), r = this.columnModel.getAllDisplayedColumns();
    if (e) {
      if (t.length > 1)
        return this.focusService.focusInto(ze(t), !0);
      const i = ze(r);
      if (this.focusService.focusGridView(i, !0))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
      if (this.focusService.focusGridView(r[0]))
        return !0;
      for (let i = 1; i < t.length; i++)
        if (this.focusService.focusInto(t[i]))
          return !0;
      return !1;
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
};
v([
  T("focusService")
], ms.prototype, "focusService", 2);
v([
  T("resizeObserverService")
], ms.prototype, "resizeObserverService", 2);
v([
  T("columnModel")
], ms.prototype, "columnModel", 2);
v([
  T("ctrlsService")
], ms.prototype, "ctrlsService", 2);
v([
  T("mouseEventService")
], ms.prototype, "mouseEventService", 2);
v([
  T("dragAndDropService")
], ms.prototype, "dragAndDropService", 2);
var _h = class extends Ih {
  constructor(t) {
    super(), this.eGridDiv = t;
  }
  postConstruct() {
    this.logger = this.loggerFactory.create("GridComp");
    const t = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (i) => this.addCssClass(i),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (i) => {
        this.getGui().style.userSelect = i ?? "", this.getGui().style.webkitUserSelect = i ?? "";
      },
      setCursor: (i) => {
        this.getGui().style.cursor = i ?? "";
      }
    };
    this.ctrl = this.createManagedBean(new ms());
    const r = this.createTemplate();
    this.setTemplate(r), this.ctrl.setComp(t, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => {
      },
      focusInnerElement: (i) => this.ctrl.focusInnerElement(i),
      forceFocusOutWhenTabGuardsAreEmpty: !0
    });
  }
  insertGridIntoDom() {
    const t = this.getGui();
    this.eGridDiv.appendChild(t), this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(t), this.logger.log("Grid removed from DOM");
    });
  }
  updateLayoutClasses(t, r) {
    const i = this.eRootWrapperBody.classList;
    i.toggle("ag-layout-auto-height", r.autoHeight), i.toggle("ag-layout-normal", r.normal), i.toggle("ag-layout-print", r.print), this.addOrRemoveCssClass("ag-layout-auto-height", r.autoHeight), this.addOrRemoveCssClass("ag-layout-normal", r.normal), this.addOrRemoveCssClass("ag-layout-print", r.print);
  }
  createTemplate() {
    const t = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "", r = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "", i = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "", n = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "";
    return (
      /* html */
      `<div class="ag-root-wrapper" role="presentation">
                ${t}
                <div class="ag-root-wrapper-body" ref="rootWrapperBody" role="presentation">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ${r}
                </div>
                ${i}
                <ag-pagination></ag-pagination>
                ${n}
            </div>`
    );
  }
  getFocusableElement() {
    return this.eRootWrapperBody;
  }
  getFocusableContainers() {
    const t = [
      this.gridBodyComp.getGui()
    ];
    return this.sideBarComp && t.push(
      this.sideBarComp.getGui()
    ), t.filter((r) => ii(r));
  }
};
v([
  T("loggerFactory")
], _h.prototype, "loggerFactory", 2);
v([
  ne("gridBody")
], _h.prototype, "gridBodyComp", 2);
v([
  ne("sideBar")
], _h.prototype, "sideBarComp", 2);
v([
  ne("rootWrapperBody")
], _h.prototype, "eRootWrapperBody", 2);
v([
  te
], _h.prototype, "postConstruct", 1);
var fa = class extends Q {
  progressSort(e, t, r) {
    const i = this.getNextSortDirection(e);
    this.setSortForColumn(e, i, t, r);
  }
  setSortForColumn(e, t, r, i) {
    t !== "asc" && t !== "desc" && (t = null);
    const n = this.gos.isColumnsSortingCoupledToGroup();
    let o = [e];
    if (n && e.getColDef().showRowGroup) {
      const l = this.columnModel.getSourceColumnsForGroupColumn(e), u = l == null ? void 0 : l.filter((c) => c.isSortable());
      u && (o = [e, ...u]);
    }
    o.forEach((l) => l.setSort(t, i));
    const s = (r || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"), a = [];
    if (!s) {
      const l = this.clearSortBarTheseColumns(o, i);
      a.push(...l);
    }
    this.updateSortIndex(e), a.push(...o), this.dispatchSortChangedEvents(i, a);
  }
  updateSortIndex(e) {
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = this.columnModel.getGroupDisplayColumnForGroup(e.getId()), i = t && r || e, n = this.getColumnsWithSortingOrdered();
    this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((a) => a.setSortIndex(null));
    const o = n.filter((a) => t && a.getColDef().showRowGroup ? !1 : a !== i);
    (i.getSort() ? [...o, i] : o).forEach((a, l) => {
      a.setSortIndex(l);
    });
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((r) => !!r.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const r = {
      type: A.EVENT_SORT_CHANGED,
      source: e
    };
    t && (r.columns = t), this.eventService.dispatchEvent(r);
  }
  clearSortBarTheseColumns(e, t) {
    const r = [];
    return this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((i) => {
      e.includes(i) || (i.getSort() && r.push(i), i.setSort(void 0, t));
    }), r;
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? t = this.gos.get("sortingOrder") : t = fa.DEFAULT_SORTING_ORDER, !Array.isArray(t) || t.length <= 0)
      return console.warn(`AG Grid: sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const r = t.indexOf(e.getSort()), i = r < 0, n = r == t.length - 1;
    let o;
    return i || n ? o = t[0] : o = t[r + 1], fa.DEFAULT_SORTING_ORDER.indexOf(o) < 0 ? (console.warn("AG Grid: invalid sort type " + o), null) : o;
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    let e = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((o) => !!o.getSort());
    if (this.columnModel.isPivotMode()) {
      const o = this.gos.isColumnsSortingCoupledToGroup();
      e = e.filter((s) => {
        const a = !!s.getAggFunc(), l = !s.isPrimary(), u = o ? this.columnModel.getGroupDisplayColumnForGroup(s.getId()) : s.getColDef().showRowGroup;
        return a || l || u;
      });
    }
    const t = this.columnModel.getRowGroupColumns().filter((o) => !!o.getSort()), r = {};
    e.forEach((o, s) => r[o.getId()] = s), e.sort((o, s) => {
      const a = o.getSortIndex(), l = s.getSortIndex();
      if (a != null && l != null)
        return a - l;
      if (a == null && l == null) {
        const u = r[o.getId()], c = r[s.getId()];
        return u > c ? 1 : -1;
      } else return l == null ? -1 : 1;
    });
    const i = this.gos.isColumnsSortingCoupledToGroup() && !!t.length;
    i && (e = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        e.map((o) => {
          var s;
          return (s = this.columnModel.getGroupDisplayColumnForGroup(o.getId())) != null ? s : o;
        })
      )
    ]);
    const n = /* @__PURE__ */ new Map();
    return e.forEach((o, s) => n.set(o, s)), i && t.forEach((o) => {
      const s = this.columnModel.getGroupDisplayColumnForGroup(o.getId());
      n.set(o, n.get(s));
    }), n;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [r, i]) => t - i).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = !!e.getColDef().showRowGroup;
    return t && r;
  }
  getDisplaySortForColumn(e) {
    const t = this.columnModel.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const i = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, n = i[0].getSort();
    return i.every((s) => s.getSort() == n) ? n : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
};
fa.DEFAULT_SORTING_ORDER = ["asc", "desc", null];
v([
  T("columnModel")
], fa.prototype, "columnModel", 2);
fa = v([
  de("sortController")
], fa);
var ut = class extends Q {
  static addKeyboardModeEvents(e) {
    this.instanceCount > 0 || (e.addEventListener("keydown", ut.toggleKeyboardMode), e.addEventListener("mousedown", ut.toggleKeyboardMode));
  }
  static removeKeyboardModeEvents(e) {
    this.instanceCount > 0 || (e.addEventListener("keydown", ut.toggleKeyboardMode), e.addEventListener("mousedown", ut.toggleKeyboardMode));
  }
  static toggleKeyboardMode(e) {
    const t = ut.keyboardModeActive, r = e.type === "keydown";
    r && (e.ctrlKey || e.metaKey || e.altKey) || t !== r && (ut.keyboardModeActive = r);
  }
  static unregisterGridCompController(e) {
    ut.removeKeyboardModeEvents(e);
  }
  init() {
    const e = this.clearFocusedCell.bind(this);
    this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_GROUP_OPENED, e), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady((t) => {
      this.gridCtrl = t.gridCtrl;
    });
  }
  registerKeyboardFocusEvents() {
    const e = this.gos.getDocument();
    ut.addKeyboardModeEvents(e), ut.instanceCount++, this.addDestroyFunc(() => {
      ut.instanceCount--, ut.unregisterGridCompController(e);
    });
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition)
      return;
    const e = this.focusedCellPosition.column, t = this.columnModel.getGridColumn(e.getId());
    e !== t && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return ut.keyboardModeActive;
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), Ks.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), tv.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(e, t) {
    let r = e;
    for (; r; ) {
      if (this.gos.getDomData(r, t))
        return !1;
      r = r.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(e) {
    return this.isCellRestoreFocused(e) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), !0) : !1;
  }
  isCellRestoreFocused(e) {
    return this.restoredFocusedCellPosition == null ? !1 : this.cellPositionUtils.equals(e, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(e) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = e);
  }
  getFocusEventParams() {
    const { rowIndex: e, rowPinned: t, column: r } = this.focusedCellPosition, i = {
      rowIndex: e,
      rowPinned: t,
      column: r,
      isFullWidthCell: !1
    }, n = this.rowRenderer.getRowByPosition({ rowIndex: e, rowPinned: t });
    return n && (i.isFullWidthCell = n.isFullWidth()), i;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null)
      return;
    const e = Ce({
      type: A.EVENT_CELL_FOCUS_CLEARED
    }, this.getFocusEventParams());
    this.focusedCellPosition = null, this.eventService.dispatchEvent(e);
  }
  setFocusedCell(e) {
    const {
      column: t,
      rowIndex: r,
      rowPinned: i,
      forceBrowserFocus: n = !1,
      preventScrollOnBrowserFocus: o = !1
    } = e, s = this.columnModel.getGridColumn(t);
    if (!s) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = s ? {
      rowIndex: r,
      rowPinned: Nn(i),
      column: s
    } : null;
    const a = Dt(Ce({
      type: A.EVENT_CELL_FOCUSED
    }, this.getFocusEventParams()), {
      forceBrowserFocus: n,
      preventScrollOnBrowserFocus: o,
      floating: null
    });
    this.eventService.dispatchEvent(a);
  }
  isCellFocused(e) {
    return this.focusedCellPosition == null ? !1 : this.cellPositionUtils.equals(e, this.focusedCellPosition);
  }
  isRowNodeFocused(e) {
    return this.isRowFocused(e.rowIndex, e.rowPinned);
  }
  isHeaderWrapperFocused(e) {
    if (this.focusedHeaderPosition == null)
      return !1;
    const t = e.getColumnGroupChild(), r = e.getRowIndex(), i = e.getPinned(), { column: n, headerRowIndex: o } = this.focusedHeaderPosition;
    return t === n && r === o && i == n.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(e, t) {
    this.focusedHeaderPosition = { headerRowIndex: e, column: t };
  }
  focusHeaderPosition(e) {
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { direction: t, fromTab: r, allowUserOverride: i, event: n, fromCell: o, rowWithoutSpanValue: s } = e;
    let { headerPosition: a } = e;
    if (o && this.filterManager.isAdvancedFilterHeaderActive())
      return this.focusAdvancedFilter(a);
    if (i) {
      const l = this.getFocusedHeader(), u = this.headerNavigationService.getHeaderRowCount();
      if (r) {
        const c = this.gos.getCallback("tabToNextHeader");
        c && (a = this.getHeaderPositionFromUserFunc({
          userFunc: c,
          direction: t,
          currentPosition: l,
          headerPosition: a,
          headerRowCount: u
        }));
      } else {
        const c = this.gos.getCallback("navigateToNextHeader");
        if (c && n) {
          const d = {
            key: n.key,
            previousHeaderPosition: l,
            nextHeaderPosition: a,
            headerRowCount: u,
            event: n
          };
          a = c(d);
        }
      }
    }
    return a ? this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: t,
      event: n,
      fromCell: o,
      rowWithoutSpanValue: s
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(e) {
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { userFunc: t, headerPosition: r, direction: i, event: n } = e, o = this.getFocusedHeader(), s = this.headerNavigationService.getHeaderRowCount(), a = this.getHeaderPositionFromUserFunc({
      userFunc: t,
      direction: i,
      currentPosition: o,
      headerPosition: r,
      headerRowCount: s
    });
    return !!a && this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: i,
      event: n
    });
  }
  getHeaderPositionFromUserFunc(e) {
    const { userFunc: t, direction: r, currentPosition: i, headerPosition: n, headerRowCount: o } = e, a = t({
      backwards: r === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: n,
      headerRowCount: o
    });
    return a === !0 || a === null ? (a === null && we("Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."), i) : a === !1 ? null : a;
  }
  focusProvidedHeaderPosition(e) {
    const { headerPosition: t, direction: r, fromCell: i, rowWithoutSpanValue: n, event: o } = e;
    if (t.headerRowIndex === -1)
      return this.filterManager.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(t) : this.focusGridView(t.column);
    this.headerNavigationService.scrollToColumn(t.column, r);
    const a = this.ctrlsService.getHeaderRowContainerCtrl(t.column.getPinned()).focusHeader(t.headerRowIndex, t.column, o);
    return a && (n != null || i) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(n ?? -1), a;
  }
  focusFirstHeader() {
    let e = this.columnModel.getAllDisplayedColumns()[0];
    if (!e)
      return !1;
    e.getParent() && (e = this.columnModel.getColumnGroupAtLevel(e, 0));
    const t = this.headerPositionUtils.getHeaderIndexToFocus(e, 0);
    return this.focusHeaderPosition({
      headerPosition: t,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(e) {
    const t = this.headerNavigationService.getHeaderRowCount() - 1, r = ze(this.columnModel.getAllDisplayedColumns());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: t, column: r },
      rowWithoutSpanValue: -1,
      event: e
    });
  }
  focusPreviousFromFirstCell(e) {
    return this.filterManager.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(e);
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(e, t) {
    return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === e && this.focusedCellPosition.rowPinned === Nn(t);
  }
  findFocusableElements(e, t, r = !1) {
    const i = A_;
    let n = JS;
    t && (n += ", " + t), r && (n += ', [tabindex="-1"]');
    const o = Array.prototype.slice.apply(e.querySelectorAll(i)).filter((l) => ii(l)), s = Array.prototype.slice.apply(e.querySelectorAll(n));
    return s.length ? ((l, u) => l.filter((c) => u.indexOf(c) === -1))(o, s) : o;
  }
  focusInto(e, t = !1, r = !1) {
    const i = this.findFocusableElements(e, null, r), n = t ? ze(i) : i[0];
    return n ? (n.focus({ preventScroll: !0 }), !0) : !1;
  }
  findFocusableElementBeforeTabGuard(e, t) {
    if (!t)
      return null;
    const r = this.findFocusableElements(e), i = r.indexOf(t);
    if (i === -1)
      return null;
    let n = -1;
    for (let o = i - 1; o >= 0; o--)
      if (r[o].classList.contains(
        "ag-tab-guard-top"
        /* TAB_GUARD_TOP */
      )) {
        n = o;
        break;
      }
    return n <= 0 ? null : r[n - 1];
  }
  findNextFocusableElement(e = this.eGridDiv, t, r) {
    const i = this.findFocusableElements(e, t ? ':not([tabindex="-1"])' : null), n = this.gos.getActiveDomElement();
    let o;
    t ? o = i.findIndex((a) => a.contains(n)) : o = i.indexOf(n);
    const s = o + (r ? -1 : 1);
    return s < 0 || s >= i.length ? null : i[s];
  }
  isTargetUnderManagedComponent(e, t) {
    if (!t)
      return !1;
    const r = e.querySelectorAll(`.${cs.FOCUS_MANAGED_CLASS}`);
    if (!r.length)
      return !1;
    for (let i = 0; i < r.length; i++)
      if (r[i].contains(t))
        return !0;
    return !1;
  }
  findTabbableParent(e, t = 5) {
    let r = 0;
    for (; e && lg(e) === null && ++r <= t; )
      e = e.parentElement;
    return lg(e) === null ? null : e;
  }
  focusGridView(e, t) {
    var r;
    if (this.gos.get("suppressCellFocus"))
      return t ? this.gos.get("suppressHeaderFocus") ? this.focusNextGridCoreContainer(!0, !0) : this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
    const i = t ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (!i)
      return !1;
    const { rowIndex: n, rowPinned: o } = i, s = this.getFocusedHeader();
    return !e && s && (e = s.column), n == null || !e ? !1 : (this.navigationService.ensureCellVisible({ rowIndex: n, column: e, rowPinned: o }), this.setFocusedCell({
      rowIndex: n,
      column: e,
      rowPinned: Nn(o),
      forceBrowserFocus: !0
    }), (r = this.rangeService) == null || r.setRangeToCell({ rowIndex: n, rowPinned: o, column: e }), !0);
  }
  focusNextGridCoreContainer(e, t = !1) {
    return !t && this.gridCtrl.focusNextInnerContainer(e) ? !0 : ((t || !e && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(e), !1);
  }
  focusAdvancedFilter(e) {
    var t, r;
    return this.advancedFilterFocusColumn = e == null ? void 0 : e.column, (r = (t = this.advancedFilterService) == null ? void 0 : t.getCtrl().focusHeaderComp()) != null ? r : !1;
  }
  focusNextFromAdvancedFilter(e, t) {
    var r, i;
    const n = (i = t ? void 0 : this.advancedFilterFocusColumn) != null ? i : (r = this.columnModel.getAllDisplayedColumns()) == null ? void 0 : r[0];
    return e ? this.focusHeaderPosition({
      headerPosition: {
        column: n,
        headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
      }
    }) : this.focusGridView(n);
  }
  clearAdvancedFilterColumn() {
    this.advancedFilterFocusColumn = void 0;
  }
};
ut.keyboardModeActive = !1;
ut.instanceCount = 0;
v([
  T("eGridDiv")
], ut.prototype, "eGridDiv", 2);
v([
  T("columnModel")
], ut.prototype, "columnModel", 2);
v([
  T("headerNavigationService")
], ut.prototype, "headerNavigationService", 2);
v([
  T("headerPositionUtils")
], ut.prototype, "headerPositionUtils", 2);
v([
  T("rowRenderer")
], ut.prototype, "rowRenderer", 2);
v([
  T("rowPositionUtils")
], ut.prototype, "rowPositionUtils", 2);
v([
  T("cellPositionUtils")
], ut.prototype, "cellPositionUtils", 2);
v([
  T("navigationService")
], ut.prototype, "navigationService", 2);
v([
  T("ctrlsService")
], ut.prototype, "ctrlsService", 2);
v([
  T("filterManager")
], ut.prototype, "filterManager", 2);
v([
  Qe("rangeService")
], ut.prototype, "rangeService", 2);
v([
  Qe("advancedFilterService")
], ut.prototype, "advancedFilterService", 2);
v([
  te
], ut.prototype, "init", 1);
ut = v([
  de("focusService")
], ut);
var qb = class extends Q {
  setMouseOver(e) {
    this.selectedColumns = e;
    const t = {
      type: A.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  clearMouseOver() {
    this.selectedColumns = null;
    const e = {
      type: A.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(e);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
};
qb = v([
  de("columnHoverService")
], qb);
var Bd = class extends Q {
  constructor() {
    super(...arguments), this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0);
  }
  finish() {
    this.active && this.flush(() => {
      this.active = !1;
    });
  }
  executeNextVMTurn(e) {
    this.active ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1);
    });
  }
  flush(e) {
    if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
      e();
      return;
    }
    const t = (r) => {
      for (; r.length; ) {
        const i = r.pop();
        i && i();
      }
    };
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => t(this.executeNextFuncs), 0), window.setTimeout(() => {
        e(), t(this.executeLaterFuncs);
      }, 200);
    });
  }
};
v([
  T("ctrlsService")
], Bd.prototype, "ctrlsService", 2);
v([
  te
], Bd.prototype, "postConstruct", 1);
Bd = v([
  de("columnAnimationService")
], Bd);
var iu = class extends Q {
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center, this.addManagedListener(this.eventService, A.EVENT_BODY_HEIGHT_CHANGED, this.checkPageSize.bind(this)), this.addManagedListener(this.eventService, A.EVENT_SCROLL_VISIBILITY_CHANGED, this.checkPageSize.bind(this)), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.paginationProxy.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const r = this.gos.getRowHeightAsNumber(), i = Math.floor(e / r);
        this.paginationProxy.setPageSize(i, "autoCalculated");
      };
      this.isBodyRendered ? kr(() => t(), 50)() : (t(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
};
v([
  T("ctrlsService")
], iu.prototype, "ctrlsService", 2);
v([
  T("paginationProxy")
], iu.prototype, "paginationProxy", 2);
v([
  te
], iu.prototype, "postConstruct", 1);
iu = v([
  de("paginationAutoPageSizeService")
], iu);
var mg = class extends Q {
  constructor() {
    super(...arguments), this.cacheVersion = 0;
  }
  init() {
    this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, r) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = r);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
};
v([
  te
], mg.prototype, "init", 1);
mg = v([
  de("valueCache")
], mg);
var nae = "paste", nu = class extends Q {
  init() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel), this.addManagedListener(this.eventService, A.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
  }
  onCellValueChanged(e) {
    e.source !== nae && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gos.get("suppressChangeDetection"))
      return;
    const r = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const i = this.gos.get("aggregateOnlyChangedColumns"), n = new ov(i, this.clientSideRowModel.getRootNode());
      n.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(n), n.forEachChangedNodeDepthFirst((o) => {
        r.push(o);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: r });
  }
};
v([
  T("rowModel")
], nu.prototype, "rowModel", 2);
v([
  T("rowRenderer")
], nu.prototype, "rowRenderer", 2);
v([
  te
], nu.prototype, "init", 1);
nu = v([
  de("changeDetectionService")
], nu);
var vg = class extends Q {
  adaptFunction(e, t) {
    const r = this.componentMetadataProvider.retrieve(e);
    return r && r.functionAdapter ? r.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh(i) {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(i) {
        const n = e(i), o = typeof n;
        if (o === "string" || o === "number" || o === "boolean") {
          this.eGui = Qr("<span>" + n + "</span>");
          return;
        }
        if (n == null) {
          this.eGui = Qr("<span></span>");
          return;
        }
        this.eGui = n;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : !1;
  }
};
v([
  T("componentMetadataProvider")
], vg.prototype, "componentMetadataProvider", 2);
vg = v([
  de("agComponentUtils")
], vg);
var Wd = class extends Q {
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "onParamsUpdated", "refresh"]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: [],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached", "refresh"]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged", "refresh"]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "getState"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      menuItem: {
        mandatoryMethodList: [],
        optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
      }
    };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
};
v([
  T("agComponentUtils")
], Wd.prototype, "agComponentUtils", 2);
v([
  te
], Wd.prototype, "postConstruct", 1);
Wd = v([
  de("componentMetadataProvider")
], Wd);
var oae = 25, jT = 10, yC = 8, sae = 4, bC = 4, wC = 6, aae = 16, zT = 14, SC = 8, lae = {
  // this item is required for custom themes
  "ag-theme-custom": {
    headerHeight: 25,
    headerCellMinWidth: 24,
    listItemHeight: sae * 5,
    rowHeight: 25,
    chartMenuPanelWidth: 220
  },
  "ag-theme-material": {
    headerHeight: yC * 7,
    headerCellMinWidth: 48,
    listItemHeight: yC * 4,
    rowHeight: yC * 6,
    chartMenuPanelWidth: 240
  },
  "ag-theme-balham": {
    headerHeight: bC * 8,
    headerCellMinWidth: 24,
    listItemHeight: bC * 6,
    rowHeight: bC * 7,
    chartMenuPanelWidth: 220
  },
  "ag-theme-alpine": {
    headerHeight: wC * 8,
    headerCellMinWidth: 36,
    listItemHeight: wC * 4,
    rowHeight: wC * 7,
    chartMenuPanelWidth: 240
  },
  "ag-theme-quartz": {
    headerHeight: zT + SC * 4.25,
    headerCellMinWidth: 36,
    listItemHeight: aae + SC,
    rowHeight: zT + SC * 3.5,
    chartMenuPanelWidth: 260
  }
}, UT = {
  headerHeight: ["ag-header-row"],
  headerCellMinWidth: ["ag-header-cell"],
  listItemHeight: ["ag-virtual-list-item"],
  rowHeight: ["ag-row"],
  chartMenuPanelWidth: ["ag-chart-docked-container"]
}, $d = class extends Q {
  constructor() {
    super(...arguments), this.calculatedSizes = {}, this.calculatedTheme = null;
  }
  postConstruct() {
    var e;
    const t = (e = this.getTheme().el) != null ? e : this.eGridDiv;
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.mutationObserver = new MutationObserver(() => {
      this.calculatedSizes = {}, this.calculatedTheme = null, this.calculatedTheme = this.getTheme(), this.fireGridStylesChangedEvent();
    }), this.mutationObserver.observe(t || this.eGridDiv, {
      attributes: !0,
      attributeFilter: ["class"]
    });
  }
  fireGridStylesChangedEvent() {
    const e = {
      type: A.EVENT_GRID_STYLES_CHANGED
    };
    this.eventService.dispatchEvent(e);
  }
  getSassVariable(e) {
    const { themeFamily: t, el: r } = this.getTheme();
    if (!t || t.indexOf("ag-theme") !== 0)
      return;
    this.calculatedSizes || (this.calculatedSizes = {}), this.calculatedSizes[t] || (this.calculatedSizes[t] = {});
    const i = this.calculatedSizes[t][e];
    return i ?? (this.calculatedSizes[t][e] = this.calculateValueForSassProperty(e, t, r), this.calculatedSizes[t][e]);
  }
  calculateValueForSassProperty(e, t, r) {
    const i = "ag-theme-" + (t.match("material") ? "material" : t.match("balham") ? "balham" : t.match("alpine") ? "alpine" : "custom"), n = lae[i][e], o = this.gos.getDocument();
    if (r || (r = this.eGridDiv), !UT[e])
      return n;
    const s = UT[e], a = o.createElement("div"), l = Array.from(r.classList);
    a.classList.add(t, ...l), a.style.position = "absolute";
    const u = s.reduce((d, h) => {
      const p = o.createElement("div");
      return p.style.position = "static", p.classList.add(h), d.appendChild(p), p;
    }, a);
    let c = 0;
    if (o.body) {
      o.body.appendChild(a);
      const d = e.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
      c = parseInt(window.getComputedStyle(u)[d], 10), o.body.removeChild(a);
    }
    return c || n;
  }
  isThemeDark() {
    const { theme: e } = this.getTheme();
    return !!e && e.indexOf("dark") >= 0;
  }
  chartMenuPanelWidth() {
    return this.getSassVariable("chartMenuPanelWidth");
  }
  getTheme() {
    if (this.calculatedTheme)
      return this.calculatedTheme;
    const e = /\bag-(material|(?:theme-([\w\-]*)))\b/g;
    let t = this.eGridDiv, r = null, i = [];
    for (; t; )
      if (r = e.exec(t.className), !r)
        t = t.parentElement || void 0;
      else {
        const o = t.className.match(e);
        o && (i = o);
        break;
      }
    if (!r)
      return { allThemes: i };
    const n = r[0];
    return this.calculatedTheme = { theme: n, el: t, themeFamily: n.replace(/-dark$/, ""), allThemes: i }, this.calculatedTheme;
  }
  getFromTheme(e, t) {
    var r;
    return (r = this.getSassVariable(t)) != null ? r : e;
  }
  getDefaultRowHeight() {
    return this.getFromTheme(oae, "rowHeight");
  }
  getListItemHeight() {
    return this.getFromTheme(20, "listItemHeight");
  }
  refreshRowHeightVariable() {
    const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), t = this.gos.get("rowHeight");
    if (t == null || isNaN(t) || !isFinite(t))
      return e !== null && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
    const r = `${t}px`;
    return e != r ? (this.eGridDiv.style.setProperty("--ag-line-height", r), t) : e != "" ? parseFloat(e) : -1;
  }
  getMinColWidth() {
    const e = this.getFromTheme(null, "headerCellMinWidth");
    return q(e) ? Math.max(e, jT) : jT;
  }
  destroy() {
    this.calculatedSizes = null, this.mutationObserver && this.mutationObserver.disconnect(), super.destroy();
  }
};
v([
  T("eGridDiv")
], $d.prototype, "eGridDiv", 2);
v([
  te
], $d.prototype, "postConstruct", 1);
$d = v([
  de("environment")
], $d);
var ou = class extends Q {
  constructor() {
    super(...arguments), this.scrollY = 0, this.uiBodyHeight = 0;
  }
  agWire(e) {
    this.logger = e.create("RowContainerHeightService");
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this)), this.maxDivHeight = m_(), this.logger.log("maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight();
    (t !== this.scrollY || r !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = r, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.logger.log(`Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: A.EVENT_ROW_CONTAINER_HEIGHT_CHANGED }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: A.EVENT_HEIGHT_SCALE_CHANGED }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), r = e / t;
    return this.maxScrollY * r;
  }
};
v([
  T("ctrlsService")
], ou.prototype, "ctrlsService", 2);
v([
  an(0, Gi("loggerFactory"))
], ou.prototype, "agWire", 1);
v([
  te
], ou.prototype, "postConstruct", 1);
ou = v([
  de("rowContainerHeightService")
], ou);
var su = class extends Q {
  init() {
    this.addManagedPropertyListener("isRowSelectable", () => this.updateSelectable());
  }
  /**
   * Used by CSRM only, to update selectable state after group state changes.
   */
  updateSelectableAfterGrouping() {
    this.updateSelectable(!0);
  }
  updateSelectable(e = !1) {
    const t = !!this.gos.get("rowSelection"), r = this.gos.get("isRowSelectable");
    if (!t || !r)
      return;
    const i = this.gos.get("groupSelectsChildren"), n = this.rowModel.getType() === "clientSide" && i, o = [], s = (a) => {
      if (e && !a.group)
        return;
      if (n && a.group) {
        const u = a.childrenAfterGroup.some((c) => c.selectable === !0);
        a.setRowSelectable(u, !0);
        return;
      }
      const l = r ? r(a) : !0;
      a.setRowSelectable(l, !0), !l && a.isSelected() && o.push(a);
    };
    if (n) {
      const a = this.rowModel;
      new ov(!1, a.getRootNode()).forEachChangedNodeDepthFirst(s, !0, !0);
    } else
      this.rowModel.forEachNode(s);
    o.length && this.selectionService.setNodesSelected({ nodes: o, newValue: !1, source: "selectableChanged" }), n && this.selectionService instanceof pa && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
  }
};
v([
  T("rowModel")
], su.prototype, "rowModel", 2);
v([
  T("selectionService")
], su.prototype, "selectionService", 2);
v([
  te
], su.prototype, "init", 1);
su = v([
  de("selectableService")
], su);
var ai = class extends Oe {
  constructor() {
    super(), this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate());
    const { btFirst: t, btPrevious: r, btNext: i, btLast: n, pageSizeComp: o } = this;
    this.activateTabIndex([t, r, i, n]), t.insertAdjacentElement("afterbegin", It(e ? "last" : "first", this.gos)), r.insertAdjacentElement("afterbegin", It(e ? "next" : "previous", this.gos)), i.insertAdjacentElement("afterbegin", It(e ? "previous" : "next", this.gos)), n.insertAdjacentElement("afterbegin", It(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(
      this.pageSizeComp.shouldShowPageSizeSelector()
    ), this.onPaginationChanged();
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(
      this.pageSizeComp.shouldShowPageSizeSelector()
    );
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedListener(this.eventService, A.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: r } = e;
      this.addManagedListener(t, "click", r), this.addManagedListener(t, "keydown", (i) => {
        (i.key === k.ENTER || i.key === k.SPACE) && (i.preventDefault(), r());
      });
    }), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationProxy.goToFirstPage();
  }
  setCurrentPageLabel() {
    const e = this.paginationProxy.getTotalPages() > 0, t = this.paginationProxy.getCurrentPage(), r = e ? t + 1 : 0;
    this.lbCurrent.textContent = this.formatNumber(r);
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    if (t)
      return t({ value: e });
    const r = this.localeService.getLocaleTextFunc(), i = r("thousandSeparator", ","), n = r("decimalSeparator", ".");
    return ZS(e, i, n);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), r = e("to", "to"), i = e("of", "of"), n = e("firstPage", "First Page"), o = e("previousPage", "Previous Page"), s = e("nextPage", "Next Page"), a = e("lastPage", "Last Page"), l = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${l}-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${r}</span>
                    <span id="ag-${l}-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${i}</span>
                    <span id="ag-${l}-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>
                    <div ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${i}</span>
                        <span id="ag-${l}-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>
                    <div ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationProxy.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationProxy.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationProxy.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationProxy.getCurrentPage(), t = this.paginationProxy.isLastPageFound(), r = this.paginationProxy.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const i = this.isZeroPagesToDisplay(), n = e === r - 1;
    this.nextButtonDisabled = n || i, this.lastButtonDisabled = !t || i || e === r - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    BS(e, t), e.classList.toggle("ag-disabled", t);
  }
  updateRowLabels() {
    const e = this.paginationProxy.getCurrentPage(), t = this.paginationProxy.getPageSize(), r = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null;
    let n, o;
    if (this.isZeroPagesToDisplay() ? n = o = 0 : (n = t * e + 1, o = n + t - 1, r && o > i && (o = i)), this.lbFirstRowOnPage.textContent = this.formatNumber(n), this.rowNodeBlockLoader.isLoading()) {
      const s = this.localeService.getLocaleTextFunc();
      this.lbLastRowOnPage.innerHTML = s("pageLastRowUnknown", "?");
    } else
      this.lbLastRowOnPage.textContent = this.formatNumber(o);
  }
  isZeroPagesToDisplay() {
    const e = this.paginationProxy.isLastPageFound(), t = this.paginationProxy.getTotalPages();
    return e && t === 0;
  }
  setTotalLabels() {
    const e = this.paginationProxy.isLastPageFound(), t = this.paginationProxy.getTotalPages(), r = e ? this.paginationProxy.getMasterRowCount() : null;
    if (r === 1) {
      const i = this.paginationProxy.getRow(0);
      if (i && i.group && !(i.groupData || i.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    if (e)
      this.lbTotal.textContent = this.formatNumber(t), this.lbRecordCount.textContent = this.formatNumber(r);
    else {
      const i = this.localeService.getLocaleTextFunc()("more", "more");
      this.lbTotal.innerHTML = i, this.lbRecordCount.innerHTML = i;
    }
  }
  setTotalLabelsToZero() {
    this.lbFirstRowOnPage.textContent = this.formatNumber(0), this.lbCurrent.textContent = this.formatNumber(0), this.lbLastRowOnPage.textContent = this.formatNumber(0), this.lbTotal.textContent = this.formatNumber(0), this.lbRecordCount.textContent = this.formatNumber(0);
  }
};
v([
  T("paginationProxy")
], ai.prototype, "paginationProxy", 2);
v([
  T("rowNodeBlockLoader")
], ai.prototype, "rowNodeBlockLoader", 2);
v([
  ne("btFirst")
], ai.prototype, "btFirst", 2);
v([
  ne("btPrevious")
], ai.prototype, "btPrevious", 2);
v([
  ne("btNext")
], ai.prototype, "btNext", 2);
v([
  ne("btLast")
], ai.prototype, "btLast", 2);
v([
  ne("lbRecordCount")
], ai.prototype, "lbRecordCount", 2);
v([
  ne("lbFirstRowOnPage")
], ai.prototype, "lbFirstRowOnPage", 2);
v([
  ne("lbLastRowOnPage")
], ai.prototype, "lbLastRowOnPage", 2);
v([
  ne("lbCurrent")
], ai.prototype, "lbCurrent", 2);
v([
  ne("lbTotal")
], ai.prototype, "lbTotal", 2);
v([
  ne("pageSizeComp")
], ai.prototype, "pageSizeComp", 2);
v([
  te
], ai.prototype, "postConstruct", 1);
var Nh = class eL extends Oe {
  constructor() {
    super(eL.TEMPLATE), this.inProgress = !1, this.destroyRequested = !1;
  }
  updateLayoutClasses(t, r) {
    const i = this.eOverlayWrapper.classList;
    i.toggle("ag-layout-auto-height", r.autoHeight), i.toggle("ag-layout-normal", r.normal), i.toggle("ag-layout-print", r.print);
  }
  postConstruct() {
    this.createManagedBean(new qm(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.overlayService.registerOverlayWrapperComp(this);
  }
  setWrapperTypeClass(t) {
    const r = this.eOverlayWrapper.classList;
    this.activeOverlayWrapperCssClass && r.toggle(this.activeOverlayWrapperCssClass, !1), this.activeOverlayWrapperCssClass = t, r.toggle(t, !0);
  }
  showOverlay(t, r, i) {
    this.inProgress || (this.setWrapperTypeClass(r), this.destroyActiveOverlay(), this.inProgress = !0, t && t.then((n) => {
      this.inProgress = !1, this.eOverlayWrapper.appendChild(n.getGui()), this.activeOverlay = n, this.updateListenerDestroyFunc = i, this.destroyRequested && (this.destroyRequested = !1, this.destroyActiveOverlay());
    }), this.setDisplayed(!0, { skipAriaHidden: !0 }));
  }
  destroyActiveOverlay() {
    var t;
    if (this.inProgress) {
      this.destroyRequested = !0;
      return;
    }
    this.activeOverlay && (this.activeOverlay = this.getContext().destroyBean(this.activeOverlay), (t = this.updateListenerDestroyFunc) == null || t.call(this), Ht(this.eOverlayWrapper));
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  destroy() {
    this.destroyActiveOverlay(), super.destroy();
  }
};
Nh.TEMPLATE = /* html */
`
        <div class="ag-overlay" role="presentation">
            <div class="ag-overlay-panel" role="presentation">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper" role="presentation"></div>
            </div>
        </div>`;
v([
  T("overlayService")
], Nh.prototype, "overlayService", 2);
v([
  ne("eOverlayWrapper")
], Nh.prototype, "eOverlayWrapper", 2);
v([
  te
], Nh.prototype, "postConstruct", 1);
var uae = Nh, au = class extends Q {
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.paginationProxy.getPageFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const r = this.pinnedRowModel.getPinnedBottomRowCount(), i = this.pinnedRowModel.getPinnedTopRowCount();
    return r ? (t = "bottom", e = r - 1) : this.rowModel.getRowCount() ? (t = null, e = this.paginationProxy.getPageLastRow()) : i && (t = "top", e = i - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  // tests if this row selection is before the other row selection
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top")
          return !0;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom")
          return !1;
        break;
      default:
        if (q(t.rowPinned))
          return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
};
v([
  T("rowModel")
], au.prototype, "rowModel", 2);
v([
  T("pinnedRowModel")
], au.prototype, "pinnedRowModel", 2);
v([
  T("paginationProxy")
], au.prototype, "paginationProxy", 2);
au = v([
  de("rowPositionUtils")
], au);
var Zb = class extends Q {
  createId(e) {
    const { rowIndex: t, rowPinned: r, column: i } = e;
    return this.createIdFromValues({ rowIndex: t, column: i, rowPinned: r });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: r, column: i } = e;
    return `${t}.${r ?? "null"}.${i.getId()}`;
  }
  equals(e, t) {
    const r = e.column === t.column, i = e.rowPinned === t.rowPinned, n = e.rowIndex === t.rowIndex;
    return r && i && n;
  }
};
Zb = v([
  de("cellPositionUtils")
], Zb);
var Rc = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, EC = class extends Rc {
  constructor(e, t, r, i) {
    super(e), this.initialRange = t, this.finalRange = r, this.ranges = i;
  }
}, tL = class rL {
  constructor(t) {
    this.actionStack = [], this.maxStackSize = t || rL.DEFAULT_STACK_SIZE, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(t) {
    t.cellValueChanges && t.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(t));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
};
tL.DEFAULT_STACK_SIZE = 10;
var YT = tL, Un = class extends Q {
  constructor() {
    super(...arguments), this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, r = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), i = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(r || i || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: o, rowIndex: s, column: a, oldValue: l, value: u } = e, c = {
        rowPinned: o,
        rowIndex: s,
        columnId: a.getColId(),
        newValue: u,
        oldValue: l
      };
      this.cellValueChanges.push(c);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  init() {
    if (!this.gos.get("undoRedoCellEditing"))
      return;
    const e = this.gos.get("undoRedoCellEditingLimit");
    e <= 0 || (this.undoStack = new YT(e), this.redoStack = new YT(e), this.addRowEditingListeners(), this.addCellEditingListeners(), this.addPasteListeners(), this.addFillListeners(), this.addCellKeyListeners(), this.addManagedListener(this.eventService, A.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged), this.addManagedListener(this.eventService, A.EVENT_MODEL_UPDATED, (t) => {
      t.keepUndoRedoStack || this.clearStacks();
    }), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_COLUMN_GROUP_OPENED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_COLUMN_MOVED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PINNED, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VISIBLE, this.clearStacks), this.addManagedListener(this.eventService, A.EVENT_ROW_DRAG_END, this.clearStacks), this.ctrlsService.whenReady((t) => {
      this.gridBodyCtrl = t.gridBodyCtrl;
    }));
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    const t = {
      type: A.EVENT_UNDO_STARTED,
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo"), i = {
      type: A.EVENT_UNDO_ENDED,
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(i);
  }
  redo(e) {
    const t = {
      type: A.EVENT_REDO_STARTED,
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo"), i = {
      type: A.EVENT_REDO_ENDED,
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(i);
  }
  undoRedo(e, t, r, i, n) {
    if (!e)
      return !1;
    const o = e.pop();
    return !o || !o.cellValueChanges ? !1 : (this.processAction(o, (s) => s[i], n), o instanceof EC ? this.processRange(this.rangeService, o.ranges || [o[r]]) : this.processCell(o.cellValueChanges), t.push(o), !0);
  }
  processAction(e, t, r) {
    e.cellValueChanges.forEach((i) => {
      const { rowIndex: n, rowPinned: o, columnId: s } = i, a = { rowIndex: n, rowPinned: o }, l = this.rowPositionUtils.getRowNode(a);
      l.displayed && l.setDataValue(s, t(i), r);
    });
  }
  processRange(e, t) {
    let r;
    e.removeAllCellRanges(!0), t.forEach((i, n) => {
      if (!i)
        return;
      const o = i.startRow, s = i.endRow;
      n === t.length - 1 && (r = {
        rowPinned: o.rowPinned,
        rowIndex: o.rowIndex,
        columnId: i.startColumn.getColId()
      }, this.setLastFocusedCell(r));
      const a = {
        rowStartIndex: o.rowIndex,
        rowStartPinned: o.rowPinned,
        rowEndIndex: s.rowIndex,
        rowEndPinned: s.rowPinned,
        columnStart: i.startColumn,
        columns: i.columns
      };
      e.addCellRange(a);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: r, rowPinned: i } = t, n = { rowIndex: r, rowPinned: i }, o = this.rowPositionUtils.getRowNode(n), s = {
      rowPinned: t.rowPinned,
      rowIndex: o.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(s, this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: r, columnId: i, rowPinned: n } = e, o = this.gridBodyCtrl.getScrollFeature(), s = this.columnModel.getGridColumn(i);
    if (!s)
      return;
    o.ensureIndexVisible(r), o.ensureColumnVisible(s);
    const a = { rowIndex: r, column: s, rowPinned: n };
    this.focusService.setFocusedCell(Dt(Ce({}, a), { forceBrowserFocus: !0 })), t == null || t.setRangeToCell(a);
  }
  addRowEditingListeners() {
    this.addManagedListener(this.eventService, A.EVENT_ROW_EDITING_STARTED, (e) => {
      this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }), this.addManagedListener(this.eventService, A.EVENT_ROW_EDITING_STOPPED, () => {
      const e = new Rc(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.activeRowEdit = null;
    });
  }
  addCellEditingListeners() {
    this.addManagedListener(this.eventService, A.EVENT_CELL_EDITING_STARTED, (e) => {
      this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }), this.addManagedListener(this.eventService, A.EVENT_CELL_EDITING_STOPPED, (e) => {
      if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
        const r = new Rc(this.cellValueChanges);
        this.pushActionsToUndoStack(r);
      }
    });
  }
  addPasteListeners() {
    this.addManagedListener(this.eventService, A.EVENT_PASTE_START, () => {
      this.isPasting = !0;
    }), this.addManagedListener(this.eventService, A.EVENT_PASTE_END, () => {
      const e = new Rc(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.isPasting = !1;
    });
  }
  addFillListeners() {
    this.addManagedListener(this.eventService, A.EVENT_FILL_START, () => {
      this.isRangeInAction = !0;
    }), this.addManagedListener(this.eventService, A.EVENT_FILL_END, (e) => {
      const t = new EC(this.cellValueChanges, e.initialRange, e.finalRange);
      this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
    });
  }
  addCellKeyListeners() {
    this.addManagedListener(this.eventService, A.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, () => {
      this.isRangeInAction = !0;
    }), this.addManagedListener(this.eventService, A.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, () => {
      let e;
      this.rangeService && this.gos.get("enableRangeSelection") ? e = new EC(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]) : e = new Rc(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
};
v([
  T("focusService")
], Un.prototype, "focusService", 2);
v([
  T("ctrlsService")
], Un.prototype, "ctrlsService", 2);
v([
  T("cellPositionUtils")
], Un.prototype, "cellPositionUtils", 2);
v([
  T("rowPositionUtils")
], Un.prototype, "rowPositionUtils", 2);
v([
  T("columnModel")
], Un.prototype, "columnModel", 2);
v([
  Qe("rangeService")
], Un.prototype, "rangeService", 2);
v([
  te
], Un.prototype, "init", 1);
Un = v([
  de("undoRedoService")
], Un);
var jd = class extends Q {
  findHeader(e, t) {
    let r, i;
    if (e.column instanceof ur ? r = this.columnModel.getDisplayedGroupAtDirection(e.column, t) : (i = `getDisplayedCol${t}`, r = this.columnModel[i](e.column)), !r)
      return;
    let { headerRowIndex: n } = e;
    if (this.getHeaderRowType(n) !== "filter") {
      const a = [r];
      for (; r.getParent(); )
        r = r.getParent(), a.push(r);
      r = a[a.length - 1 - n];
    }
    const { column: o, headerRowIndex: s } = this.getHeaderIndexToFocus(r, n);
    return {
      column: o,
      headerRowIndex: s
    };
  }
  getHeaderIndexToFocus(e, t) {
    let r;
    if (e instanceof ur && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
      const i = e;
      r = i.getLeafColumns()[0];
      let n = r;
      for (; n !== i; )
        t++, n = n.getParent();
    }
    return {
      column: r || e,
      headerRowIndex: t
    };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
  }
  getColumnVisibleParent(e, t) {
    const r = this.getHeaderRowType(t), i = r === "filter", n = r === "column";
    let o = i ? e : e.getParent(), s = t - 1, a = s;
    if (n && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; o && o.isPadding(); )
        o = o.getParent(), s--;
      a = s, s < 0 && (o = e, s = t, a = void 0);
    }
    return { column: o, headerRowIndex: s, headerRowIndexWithoutSpan: a };
  }
  getColumnVisibleChild(e, t, r = "After") {
    const i = this.getHeaderRowType(t);
    let n = e, o = t + 1, s = o;
    if (i === "group") {
      const a = e.getDisplayedLeafColumns(), l = r === "After" ? a[0] : ze(a), u = [];
      let c = l;
      for (; c.getParent() !== e; )
        c = c.getParent(), u.push(c);
      if (n = l, l.isSpanHeaderHeight())
        for (let d = u.length - 1; d >= 0; d--) {
          const h = u[d];
          if (!h.isPadding()) {
            n = h;
            break;
          }
          o++;
        }
      else
        n = ze(u), n || (n = l);
    }
    return { column: n, headerRowIndex: o, headerRowIndexWithoutSpan: s };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const r = this.columnModel.getAllDisplayedColumns(), i = r[t === "start" ? 0 : r.length - 1];
    if (!i)
      return;
    const o = this.ctrlsService.getHeaderRowContainerCtrl(i.getPinned()).getRowType(e);
    if (o == "group") {
      const s = this.columnModel.getColumnGroupAtLevel(i, e);
      return {
        headerRowIndex: e,
        column: s
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: o == null ? -1 : e,
      column: i
    };
  }
};
v([
  T("columnModel")
], jd.prototype, "columnModel", 2);
v([
  T("ctrlsService")
], jd.prototype, "ctrlsService", 2);
jd = v([
  de("headerPositionUtils")
], jd);
var Jb = class {
  buildColumnDefs(e, t, r) {
    const i = [], n = {};
    return e.forEach((o) => {
      const s = this.createDefFromColumn(o, t, r);
      let a = !0, l = s, u = o.getOriginalParent(), c = null;
      for (; u; ) {
        let d = null;
        if (u.isPadding()) {
          u = u.getOriginalParent();
          continue;
        }
        const h = n[u.getGroupId()];
        if (h) {
          h.children.push(l), a = !1;
          break;
        }
        if (d = this.createDefFromGroup(u), d && (d.children = [l], n[d.groupId] = d, l = d, u = u.getOriginalParent()), u != null && c === u) {
          a = !1;
          break;
        }
        c = u;
      }
      a && i.push(l);
    }), i;
  }
  createDefFromGroup(e) {
    const t = ig(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, r) {
    const i = ig(e.getColDef());
    return i.colId = e.getColId(), i.width = e.getActualWidth(), i.rowGroup = e.isRowGroupActive(), i.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, i.pivot = e.isPivotActive(), i.pivotIndex = e.isPivotActive() ? r.indexOf(e) : null, i.aggFunc = e.isValueActive() ? e.getAggFunc() : null, i.hide = e.isVisible() ? void 0 : !0, i.pinned = e.isPinned() ? e.getPinned() : null, i.sort = e.getSort() ? e.getSort() : null, i.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, i;
  }
};
Jb = v([
  de("columnDefFactory")
], Jb);
var zd = class {
  getInitialRowClasses(e) {
    const t = [];
    return q(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), Fb(t, this.processClassesFromGridOptions(e.rowNode)), Fb(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], r = (o) => {
      typeof o == "string" ? t.push(o) : Array.isArray(o) && o.forEach((s) => t.push(s));
    }, i = this.gos.get("rowClass");
    if (i) {
      if (typeof i == "function")
        return console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead"), [];
      r(i);
    }
    const n = this.gos.getCallback("getRowClass");
    if (n) {
      const o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      }, s = n(o);
      r(s);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(
      e,
      (r) => {
        t.push(r);
      },
      (r) => {
      }
    ), t;
  }
  processRowClassRules(e, t, r) {
    const i = this.gos.addGridCommonParams({
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    this.stylingService.processClassRules(
      void 0,
      this.gos.get("rowClassRules"),
      i,
      t,
      r
    );
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
};
v([
  T("stylingService")
], zd.prototype, "stylingService", 2);
v([
  T("gridOptionsService")
], zd.prototype, "gos", 2);
zd = v([
  de("rowCssClassCalculator")
], zd);
var lu = class extends Q {
  init() {
    this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup(), this.addManagedPropertyListener("accentedSort", (e) => this.isAccentedSort = e.currentValue), this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup());
  }
  doFullSort(e, t) {
    const r = (n, o) => ({ currentPos: o, rowNode: n }), i = e.map(r);
    return i.sort(this.compareRowNodes.bind(this, t)), i.map((n) => n.rowNode);
  }
  compareRowNodes(e, t, r) {
    const i = t.rowNode, n = r.rowNode;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o], l = a.sort === "desc", u = this.getValue(i, a.column), c = this.getValue(n, a.column);
      let d;
      const h = this.getComparator(a, i);
      if (h ? d = h(u, c, i, n, l) : d = Ae.defaultComparator(u, c, this.isAccentedSort), !isNaN(d) && d !== 0)
        return a.sort === "asc" ? d : d * -1;
    }
    return t.currentPos - r.currentPos;
  }
  getComparator(e, t) {
    const r = e.column, i = r.getColDef().comparator;
    if (i != null)
      return i;
    if (!r.getColDef().showRowGroup)
      return;
    const n = !t.group && r.getColDef().field;
    if (!n)
      return;
    const o = this.columnModel.getPrimaryColumn(n);
    if (o)
      return o.getColDef().comparator;
  }
  getValue(e, t) {
    var r, i;
    if (!this.primaryColumnsSortGroups)
      return this.valueService.getValue(t, e, !1, !1);
    if (e.rowGroupColumn === t) {
      if (this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive())) {
        const a = (r = e.allLeafChildren) == null ? void 0 : r[0];
        return a ? this.valueService.getValue(t, a, !1, !1) : void 0;
      }
      const s = this.columnModel.getGroupDisplayColumnForGroup(t.getId());
      return s ? (i = e.groupData) == null ? void 0 : i[s.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return this.valueService.getValue(t, e, !1, !1);
  }
};
v([
  T("valueService")
], lu.prototype, "valueService", 2);
v([
  T("columnModel")
], lu.prototype, "columnModel", 2);
v([
  te
], lu.prototype, "init", 1);
lu = v([
  de("rowNodeSorter")
], lu);
var Zs = class extends Q {
  constructor() {
    super(...arguments), this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  checkReady() {
    const e = this.params;
    this.ready = e.gridCtrl != null && e.gridBodyCtrl != null && e.center != null && e.left != null && e.right != null && e.bottomCenter != null && e.bottomLeft != null && e.bottomRight != null && e.topCenter != null && e.topLeft != null && e.topRight != null && e.stickyTopCenter != null && e.stickyTopLeft != null && e.stickyTopRight != null && e.stickyBottomCenter != null && e.stickyBottomLeft != null && e.stickyBottomRight != null && e.centerHeader != null && e.leftHeader != null && e.rightHeader != null && e.fakeHScrollComp != null && e.fakeVScrollComp != null && e.gridHeaderCtrl != null, this.ready && (this.readyCallbacks.forEach((t) => t(e)), this.readyCallbacks.length = 0);
  }
  whenReady(e) {
    this.ready ? e(this.params) : this.readyCallbacks.push(e);
  }
  register(e, t) {
    this.params[e] = t, this.checkReady();
  }
  registerHeaderContainer(e, t) {
    switch (t) {
      case "left":
        this.params.leftHeader = e;
        break;
      case "right":
        this.params.rightHeader = e;
        break;
      default:
        this.params.centerHeader = e;
        break;
    }
    this.checkReady();
  }
  get(e) {
    return this.params[e];
  }
  getParams() {
    return this.params;
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    return [this.params.leftHeader, this.params.rightHeader, this.params.centerHeader];
  }
  getHeaderRowContainerCtrl(e) {
    switch (e) {
      case "left":
        return this.params.leftHeader;
      case "right":
        return this.params.rightHeader;
      default:
        return this.params.centerHeader;
    }
  }
};
Zs.NAME = "ctrlsService";
Zs = v([
  de(Zs.NAME)
], Zs);
var Qb = class extends Q {
  constructor() {
    super(...arguments), this.registry = {};
  }
  register(e) {
    this.registry[e.controllerName] = e.controllerClass;
  }
  getInstance(e) {
    const t = this.registry[e];
    if (t != null)
      return new t();
  }
};
Qb = v([
  de("ctrlsFactory")
], Qb);
var Wa = class extends Oe {
  constructor(e, t) {
    super(e), this.direction = t, this.hideTimeout = null;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", XS() || Oo());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = qS(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = ["mouseenter", "mousedown", "touchstart"], t = ["mouseleave", "touchend"], r = this.getGui();
    e.forEach(
      (i) => this.addManagedListener(
        r,
        i,
        () => this.addOrRemoveCssClass("ag-scrollbar-active", !0)
      )
    ), t.forEach(
      (i) => this.addManagedListener(
        r,
        i,
        () => this.addOrRemoveCssClass("ag-scrollbar-active", !1)
      )
    );
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL, (e) => {
      e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
    }), this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL_END, () => {
      this.hideTimeout = window.setTimeout(() => {
        this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null;
      }, 400);
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewport();
    NS(() => ii(t), () => this.setScrollPosition(e), 100);
  }
  getViewport() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedListener(this.getViewport(), "scroll", e);
  }
};
v([
  ne("eViewport")
], Wa.prototype, "eViewport", 2);
v([
  ne("eContainer")
], Wa.prototype, "eContainer", 2);
v([
  T("scrollVisibleService")
], Wa.prototype, "scrollVisibleService", 2);
v([
  T("ctrlsService")
], Wa.prototype, "ctrlsService", 2);
v([
  T("animationFrameService")
], Wa.prototype, "animationFrameService", 2);
var $a = class iL extends Wa {
  constructor() {
    super(iL.TEMPLATE, "horizontal");
  }
  postConstruct() {
    super.postConstruct();
    const t = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, t), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, t), this.addManagedListener(this.eventService, A.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedPropertyListener("domLayout", t), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new Bu((r) => this.eContainer.style.width = `${r}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar)
      return;
    const t = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${t}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const t = this.scrollVisibleService.isVerticalScrollShowing();
    let r = this.columnModel.getDisplayedColumnsRightWidth();
    const i = !this.enableRtl && t, n = this.gos.getScrollbarWidth();
    i && (r += n), Wi(this.eRightSpacer, r), this.eRightSpacer.classList.toggle("ag-scroller-corner", r <= n);
    let o = this.columnModel.getDisplayedColumnsLeftWidth();
    this.enableRtl && t && (o += n), Wi(this.eLeftSpacer, o), this.eLeftSpacer.classList.toggle("ag-scroller-corner", o <= n);
  }
  setScrollVisible() {
    const t = this.scrollVisibleService.isHorizontalScrollShowing(), r = this.invisibleScrollbar, i = this.gos.get("suppressHorizontalScroll"), n = t && this.gos.getScrollbarWidth() || 0, s = i ? 0 : n === 0 && r ? 16 : n;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", r), Ys(this.getGui(), s), Ys(this.eViewport, s), Ys(this.eContainer, s), this.setDisplayed(t, { skipAriaHidden: !0 });
  }
  getScrollPosition() {
    return Fd(this.getViewport(), this.enableRtl);
  }
  setScrollPosition(t) {
    ii(this.getViewport()) || this.attemptSettingScrollPosition(t), _d(this.getViewport(), t, this.enableRtl);
  }
};
$a.TEMPLATE = /* html */
`<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`;
v([
  ne("eLeftSpacer")
], $a.prototype, "eLeftSpacer", 2);
v([
  ne("eRightSpacer")
], $a.prototype, "eRightSpacer", 2);
v([
  T("columnModel")
], $a.prototype, "columnModel", 2);
v([
  T("pinnedRowModel")
], $a.prototype, "pinnedRowModel", 2);
v([
  te
], $a.prototype, "postConstruct", 1);
var cae = $a, Ud = class extends Q {
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = this.gos.isDomLayout("print"), t = e ? 0 : this.columnModel.getDisplayedColumnsLeftWidth(), r = e ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: A.EVENT_LEFT_PINNED_WIDTH_CHANGED })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: A.EVENT_RIGHT_PINNED_WIDTH_CHANGED }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
};
v([
  T("columnModel")
], Ud.prototype, "columnModel", 2);
v([
  te
], Ud.prototype, "postConstruct", 1);
Ud = v([
  de("pinnedWidthService")
], Ud);
var uu = class extends Q {
  constructor() {
    super(...arguments), this.events = [];
  }
  postConstruct() {
    this.rowModel.getType() == "clientSide" && (this.clientSideRowModel = this.rowModel);
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than _.debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpanded(e, t) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const r = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((i) => this.eventService.dispatchEvent(i)), this.events = [];
    };
    t ? r() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced());
  }
};
v([
  T("animationFrameService")
], uu.prototype, "animationFrameService", 2);
v([
  T("rowModel")
], uu.prototype, "rowModel", 2);
v([
  te
], uu.prototype, "postConstruct", 1);
uu = v([
  de("rowNodeEventThrottle")
], uu);
var dae = {
  columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." },
  suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." },
  suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" },
  dndSource: { version: "31.2", message: "This feature has been replaced by `Row Dragging to an External DropZone`." },
  dndSourceOnRowDrag: { version: "31.2", message: "This feature has been replaced by `Row Dragging to an External DropZone`." }
}, ko = (e, t) => {
  var r;
  return ((r = t.rowModelType) != null ? r : "clientSide") === "clientSide" ? {
    module: "@ag-grid-enterprise/row-grouping"
    /* RowGroupingModule */
  } : null;
}, hae = {
  // supported on all row models, but need module for client side.
  enableRowGroup: ko,
  rowGroup: ko,
  rowGroupIndex: ko,
  enablePivot: ko,
  enableValue: ko,
  pivot: ko,
  pivotIndex: ko,
  aggFunc: ko,
  cellEditor: (e) => e.cellEditor === "agRichSelect" || e.cellEditor === "agRichSelectCellEditor" ? {
    module: "@ag-grid-enterprise/rich-select"
    /* RichSelectModule */
  } : null,
  menuTabs: (e) => {
    var t;
    const r = ["columnsMenuTab", "generalMenuTab"];
    return (t = e.menuTabs) != null && t.some((i) => r.includes(i)) ? {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    } : null;
  },
  columnsMenuParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  columnChooserParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  children: () => hl
}, pae = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0
}, fae = Object.keys(pae), hl = {
  objectName: "colDef",
  allProperties: fae,
  docsUrl: "column-properties/",
  deprecations: dae,
  validations: hae
}, gae = {
  enableChartToolPanelsButton: { version: "29" },
  functionsPassive: { version: "29.2" },
  onColumnRowGroupChangeRequest: { version: "29.2" },
  onColumnPivotChangeRequest: { version: "29.2" },
  onColumnValueChangeRequest: { version: "29.2" },
  onColumnAggFuncChangeRequest: { version: "29.2" },
  serverSideFilterAllLevels: { version: "30", message: "All server-side group levels are now filtered by default. This can be toggled using `serverSideOnlyRefreshFilteredGroups`." },
  suppressAggAtRootLevel: { version: "30", message: "The root level aggregation is now suppressed by default. This can be toggled using  `alwaysAggregateAtRootLevel`." },
  excludeHiddenColumnsFromQuickFilter: { version: "30", message: "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `includeHiddenColumnsInQuickFilter`." },
  enterMovesDown: { version: "30", renamed: "enterNavigatesVertically" },
  enterMovesDownAfterEdit: { version: "30", renamed: "enterNavigatesVerticallyAfterEdit" },
  suppressParentsInRowNodes: { version: "30.2", message: "Using suppressParentsInRowNodes is no longer recommended. To serialize nodes it is now recommended to instead remove the parent node reference before serialization." },
  advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." },
  suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." },
  cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" },
  cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" },
  suppressServerSideInfiniteScroll: { version: "31.1" },
  serverSideSortOnServer: { version: "31.1" },
  serverSideFilterOnServer: { version: "31.1" },
  enableCellChangeFlash: { version: "31.2", message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns." },
  groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." },
  groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." }
}, mae = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !1,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  suppressChartToolPanelsButton: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressAsyncEvents: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  enableCellChangeFlash: !1,
  cellFlashDelay: 500,
  cellFlashDuration: 500,
  cellFadeDelay: 1e3,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupIncludeTotalFooter: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  suppressServerSideInfiniteScroll: !1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSideSortOnServer: !1,
  serverSideFilterOnServer: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  suppressGroupMaintainValueType: !1,
  functionsPassive: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1
}, vae = {
  sideBar: {
    module: "@ag-grid-enterprise/side-bar"
    /* SideBarModule */
  },
  statusBar: {
    module: "@ag-grid-enterprise/status-bar"
    /* StatusBarModule */
  },
  enableCharts: {
    module: "@ag-grid-enterprise/charts"
    /* GridChartsModule */
  },
  getMainMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  getContextMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  allowContextMenuWithControlKey: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  enableAdvancedFilter: {
    module: "@ag-grid-enterprise/advanced-filter"
    /* AdvancedFilterModule */
  },
  treeData: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "@ag-grid-enterprise/row-grouping",
    dependencies: (e) => {
      var t;
      const r = (t = e.rowModelType) != null ? t : "clientSide";
      switch (r) {
        case "clientSide":
          const i = `treeData requires 'getDataPath' in the ${r} row model.`;
          return e.getDataPath ? null : i;
        case "serverSide":
          const n = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${r} row model.`;
          return e.isServerSideGroup && e.getServerSideGroupKey ? null : n;
      }
      return null;
    }
  },
  masterDetail: {
    module: "@ag-grid-enterprise/master-detail"
    /* MasterDetailModule */
  },
  enableRangeSelection: {
    module: "@ag-grid-enterprise/range-selection"
    /* RangeSelectionModule */
  },
  enableRangeHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  enableFillHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  groupDefaultExpanded: {
    supportedRowModels: ["clientSide"]
  },
  groupIncludeFooter: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e) => {
      var t;
      switch ((t = e.rowModelType) != null ? t : "clientSide") {
        case "clientSide":
          return null;
        case "serverSide":
          return e.suppressServerSideInfiniteScroll ? "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll" : null;
      }
      return null;
    }
  },
  groupIncludeTotalFooter: {
    supportedRowModels: ["clientSide"]
  },
  groupRemoveSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveLowestSingleChildren: [void 0, !1]
    }
  },
  groupRemoveLowestSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveSingleChildren: [void 0, !1]
    }
  },
  groupSelectsChildren: {
    dependencies: {
      rowSelection: ["multiple"]
    }
  },
  suppressParentsInRowNodes: {
    dependencies: {
      groupSelectsChildren: [void 0, !1]
    }
  },
  viewportDatasource: {
    supportedRowModels: ["viewport"],
    module: "@ag-grid-enterprise/viewport-row-model"
    /* ViewportRowModelModule */
  },
  serverSideDatasource: {
    supportedRowModels: ["serverSide"],
    module: "@ag-grid-enterprise/server-side-row-model"
    /* ServerSideRowModelModule */
  },
  cacheBlockSize: {
    supportedRowModels: ["serverSide", "infinite"]
  },
  datasource: {
    supportedRowModels: ["infinite"],
    module: "@ag-grid-community/infinite-row-model"
    /* InfiniteRowModelModule */
  },
  rowData: {
    supportedRowModels: ["clientSide"],
    module: "@ag-grid-community/client-side-row-model"
    /* ClientSideRowModelModule */
  },
  columnDefs: () => hl,
  defaultColDef: () => hl,
  defaultColGroupDef: () => hl,
  autoGroupColumnDef: () => hl
}, Cae = {
  objectName: "gridOptions",
  allProperties: [
    ...Id.ALL_PROPERTIES,
    ...ag.EVENT_CALLBACKS
  ],
  propertyExceptions: ["api", "columnApi"],
  docsUrl: "grid-options/",
  deprecations: gae,
  validations: vae
}, Ke = class {
  constructor() {
    this.destroyed = !1, this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new fn(), this.globalEventHandlerFactory = (e) => (t, r) => {
      if (this.destroyed)
        return;
      const i = Pp.has(t);
      if (i && !e || !i && e)
        return;
      const n = ag.getCallbackForEvent(t), o = this.gridOptions[n];
      typeof o == "function" && this.frameworkOverrides.wrapOutgoing(() => {
        o(r);
      });
    };
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get context() {
    return this.gridOptions.context;
  }
  init() {
    this.columnApi = new ru(this.api);
    const e = !this.get("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), e), this.eventService.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.getScrollbarWidth();
  }
  destroy() {
    this.destroyed = !0, this.columnApi = void 0;
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(e) {
    var t;
    return (t = this.gridOptions[e]) != null ? t : mae[e];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api,columnApi and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(e) {
    return this.mergeGridCommonParams(this.gridOptions[e]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(e) {
    return q(this.gridOptions[e]);
  }
  /**
  * Wrap the user callback and attach the api, columnApi and context to the params object on the way through.
  * @param callback User provided callback
  * @returns Wrapped callback where the params object not require api, columnApi and context
  */
  mergeGridCommonParams(e) {
    return e && ((r) => {
      const i = r;
      return i.api = this.api, i.columnApi = this.columnApi, i.context = this.context, e(i);
    });
  }
  static toBoolean(e) {
    return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
  }
  static toNumber(e) {
    if (typeof e == "number")
      return e;
    if (typeof e == "string") {
      const t = parseInt(e);
      return isNaN(t) ? void 0 : t;
    }
  }
  static toConstrainedNum(e, t) {
    return (r) => {
      const i = Ke.toNumber(r);
      if (!(i == null || i < e || i > t))
        return i;
    };
  }
  static getCoercedValue(e, t) {
    const r = Ke.PROPERTY_COERCIONS.get(e);
    return r ? r(t) : t;
  }
  static getCoercedGridOptions(e) {
    const t = {};
    return Object.entries(e).forEach(([r, i]) => {
      const n = Ke.getCoercedValue(r, i);
      t[r] = n;
    }), t;
  }
  updateGridOptions({ options: e, force: t, source: r = "api" }) {
    const i = { id: Ke.changeSetId++, properties: [] }, n = [];
    Object.entries(e).forEach(([o, s]) => {
      r === "api" && Une[o] && we(`${o} is an initial property and cannot be updated.`);
      const a = Ke.getCoercedValue(o, s), l = t || typeof a == "object" && r === "api", u = this.gridOptions[o];
      if (l || u !== a) {
        this.gridOptions[o] = a;
        const c = {
          type: o,
          currentValue: a,
          previousValue: u,
          changeSet: i,
          source: r
        };
        n.push(c);
      }
    }), this.validationService.processGridOptions(this.gridOptions), i.properties = n.map((o) => o.type), n.forEach((o) => {
      this.gridOptions.debug && console.log(`AG Grid: Updated property ${o.type} from `, o.previousValue, " to  ", o.currentValue), this.propertyEventService.dispatchEvent(o);
    });
  }
  addEventListener(e, t) {
    this.propertyEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.propertyEventService.removeEventListener(e, t);
  }
  // *************** Helper methods ************************** //
  // Methods to share common GridOptions related logic that goes above accessing a single property
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const t = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0 ? this.gridOptions.scrollbarWidth : y_();
      t != null && (this.scrollbarWidth = t, this.eventService.dispatchEvent({
        type: A.EVENT_SCROLLBAR_WIDTH_CHANGED
      }));
    }
    return this.scrollbarWidth;
  }
  isRowModelType(e) {
    return this.gridOptions.rowModelType === e || e === "clientSide" && Re(this.gridOptions.rowModelType);
  }
  isDomLayout(e) {
    var t;
    return ((t = this.gridOptions.domLayout) != null ? t : "normal") === e;
  }
  isRowSelection() {
    return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
  }
  useAsyncEvents() {
    return !this.get("suppressAsyncEvents");
  }
  isGetRowHeightFunction() {
    return typeof this.gridOptions.getRowHeight == "function";
  }
  getRowHeightForNode(e, t = !1, r) {
    if (r == null && (r = this.environment.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
      if (t)
        return { height: r, estimated: !0 };
      const n = {
        node: e,
        data: e.data
      }, o = this.getCallback("getRowHeight")(n);
      if (this.isNumeric(o))
        return o === 0 && we("The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."), { height: Math.max(1, o), estimated: !1 };
    }
    return e.detail && this.get("masterDetail") ? this.getMasterDetailRowHeight() : { height: this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : r, estimated: !1 };
  }
  getMasterDetailRowHeight() {
    return this.get("detailRowAutoHeight") ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: 300, estimated: !1 };
  }
  // we don't allow dynamic row height for virtual paging
  getRowHeightAsNumber() {
    if (!this.gridOptions.rowHeight || Re(this.gridOptions.rowHeight))
      return this.environment.getDefaultRowHeight();
    const e = this.environment.refreshRowHeightVariable();
    return e !== -1 ? e : (console.warn("AG Grid row height must be a number if not using standard row model"), this.environment.getDefaultRowHeight());
  }
  isNumeric(e) {
    return !isNaN(e) && typeof e == "number" && isFinite(e);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  // returns the dom data, or undefined if not found
  getDomData(e, t) {
    const r = e[this.getDomDataKey()];
    return r ? r[t] : void 0;
  }
  setDomData(e, t, r) {
    const i = this.getDomDataKey();
    let n = e[i];
    Re(n) && (n = {}, e[i] = n), n[t] = r;
  }
  getDocument() {
    let e = null;
    return this.gridOptions.getDocument && q(this.gridOptions.getDocument) ? e = this.gridOptions.getDocument() : this.eGridDiv && (e = this.eGridDiv.ownerDocument), e && q(e) ? e : document;
  }
  getWindow() {
    return this.getDocument().defaultView || window;
  }
  getRootNode() {
    return this.eGridDiv.getRootNode();
  }
  getActiveDomElement() {
    return this.getRootNode().activeElement;
  }
  getAsyncTransactionWaitMillis() {
    return q(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
  }
  isAnimateRows() {
    return this.get("ensureDomOrder") ? !1 : this.get("animateRows");
  }
  isGroupRowsSticky() {
    return !(this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print"));
  }
  isColumnsSortingCoupledToGroup() {
    const e = this.gridOptions.autoGroupColumnDef;
    return !(e != null && e.comparator) && !this.get("treeData");
  }
  getGroupAggFiltering() {
    const e = this.gridOptions.groupAggFiltering;
    if (typeof e == "function")
      return this.getCallback("groupAggFiltering");
    if (e === !0)
      return () => !0;
  }
  getGrandTotalRow() {
    const e = this.gridOptions.grandTotalRow;
    if (e)
      return e;
    if (this.gridOptions.groupIncludeTotalFooter)
      return "bottom";
  }
  getGroupTotalRowCallback() {
    const e = this.get("groupTotalRow");
    if (typeof e == "function")
      return this.getCallback("groupTotalRow");
    if (e)
      return () => e;
    const t = this.get("groupIncludeFooter");
    if (typeof t == "function") {
      const r = this.getCallback("groupIncludeFooter");
      return (i) => r(i) ? "bottom" : void 0;
    }
    return () => t ? "bottom" : void 0;
  }
  isGroupMultiAutoColumn() {
    return this.gridOptions.groupDisplayType ? this.gridOptions.groupDisplayType === "multipleColumns" : this.get("groupHideOpenParents");
  }
  isGroupUseEntireRow(e) {
    return e ? !1 : this.gridOptions.groupDisplayType === "groupRows";
  }
  getGridCommonParams() {
    return {
      api: this.api,
      columnApi: this.columnApi,
      context: this.context
    };
  }
  addGridCommonParams(e) {
    const t = e;
    return t.api = this.api, t.columnApi = this.columnApi, t.context = this.context, t;
  }
};
Ke.PROPERTY_COERCIONS = new Map([
  ...Id.BOOLEAN_PROPERTIES.map((e) => [e, Ke.toBoolean]),
  ...Id.NUMBER_PROPERTIES.map((e) => [e, Ke.toNumber]),
  ["groupAggFiltering", (e) => typeof e == "function" ? e : Ke.toBoolean(e)],
  ["pageSize", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["autoSizePadding", Ke.toConstrainedNum(0, Number.MAX_VALUE)],
  ["keepDetailRowsCount", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["rowBuffer", Ke.toConstrainedNum(0, Number.MAX_VALUE)],
  ["infiniteInitialRowCount", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["cacheOverflowSize", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["cacheBlockSize", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["serverSideInitialRowCount", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["viewportRowModelPageSize", Ke.toConstrainedNum(1, Number.MAX_VALUE)],
  ["viewportRowModelBufferSize", Ke.toConstrainedNum(0, Number.MAX_VALUE)]
]);
Ke.changeSetId = 0;
v([
  T("gridOptions")
], Ke.prototype, "gridOptions", 2);
v([
  T("eventService")
], Ke.prototype, "eventService", 2);
v([
  T("environment")
], Ke.prototype, "environment", 2);
v([
  T("frameworkOverrides")
], Ke.prototype, "frameworkOverrides", 2);
v([
  T("eGridDiv")
], Ke.prototype, "eGridDiv", 2);
v([
  T("validationService")
], Ke.prototype, "validationService", 2);
v([
  T("gridApi")
], Ke.prototype, "api", 2);
v([
  te
], Ke.prototype, "init", 1);
v([
  jr
], Ke.prototype, "destroy", 1);
Ke = v([
  de("gridOptionsService")
], Ke);
var ew = class extends Q {
  getLocaleTextFunc() {
    const e = this.gos.getCallback("getLocaleText");
    if (e)
      return (r, i, n) => e({
        key: r,
        defaultValue: i,
        variableValues: n
      });
    const t = this.gos.get("localeText");
    return (r, i, n) => {
      let o = t && t[r];
      if (o && n && n.length) {
        let s = 0;
        for (; !(s >= n.length || o.indexOf("${variable}") === -1); )
          o = o.replace("${variable}", n[s++]);
      }
      return o ?? i;
    };
  }
};
ew = v([
  de("localeService")
], ew);
var ME = class nL extends Wa {
  constructor() {
    super(nL.TEMPLATE, "vertical");
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new Jm(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedListener(this.eventService, A.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onRowContainerHeightChanged.bind(this));
  }
  setScrollVisible() {
    const t = this.scrollVisibleService.isVerticalScrollShowing(), r = this.invisibleScrollbar, i = t && this.gos.getScrollbarWidth() || 0, n = i === 0 && r ? 16 : i;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", r), Wi(this.getGui(), n), Wi(this.eViewport, n), Wi(this.eContainer, n), this.setDisplayed(t, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged() {
    const { ctrlsService: t } = this, i = t.getGridBodyCtrl().getBodyViewportElement(), n = this.getScrollPosition(), o = i.scrollTop;
    n != o && this.setScrollPosition(o, !0);
  }
  getScrollPosition() {
    return this.getViewport().scrollTop;
  }
  setScrollPosition(t, r) {
    !r && !ii(this.getViewport()) && this.attemptSettingScrollPosition(t), this.getViewport().scrollTop = t;
  }
};
ME.TEMPLATE = /* html */
`<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" ref="eViewport">
                <div class="ag-body-vertical-scroll-container" ref="eContainer"></div>
            </div>
        </div>`;
v([
  te
], ME.prototype, "postConstruct", 1);
var yae = ME, XT = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, KT = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"], ga = class extends Q {
  constructor() {
    super(...arguments), this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  init() {
    this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(dl(e.source));
    });
  }
  processDataTypeDefinitions() {
    var e;
    const t = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, Object.entries(t).forEach(([i, n]) => {
      this.dataTypeDefinitions[i] = Dt(Ce({}, n), {
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(n)
      });
    });
    const r = (e = this.gos.get("dataTypeDefinitions")) != null ? e : {};
    this.dataTypeMatchers = {}, Object.entries(r).forEach(([i, n]) => {
      const o = this.processDataTypeDefinition(n, r, [i], t);
      o && (this.dataTypeDefinitions[i] = o, n.dataTypeMatcher && (this.dataTypeMatchers[i] = n.dataTypeMatcher));
    }), this.checkObjectValueHandlers(t), ["dateString", "text", "number", "boolean", "date"].forEach((i) => {
      const n = this.dataTypeMatchers[i];
      n && delete this.dataTypeMatchers[i], this.dataTypeMatchers[i] = n ?? t[i].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const r = Ce(Ce({}, e), t);
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (r.columnTypes = [
      ...this.convertColumnTypes(e.columnTypes),
      ...this.convertColumnTypes(t.columnTypes)
    ]), r;
  }
  processDataTypeDefinition(e, t, r, i) {
    let n;
    const o = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let s = i[o];
      const a = t[o];
      if (s && a && (s = a), !this.validateDataTypeDefinition(e, s, o))
        return;
      n = this.mergeDataTypeDefinitions(
        s,
        e
      );
    } else {
      if (r.includes(o)) {
        we('Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.');
        return;
      }
      const s = t[o];
      if (!this.validateDataTypeDefinition(e, s, o))
        return;
      const a = this.processDataTypeDefinition(
        s,
        t,
        [...r, o],
        i
      );
      if (!a)
        return;
      n = this.mergeDataTypeDefinitions(
        a,
        e
      );
    }
    return Dt(Ce({}, n), {
      groupSafeValueFormatter: this.createGroupSafeValueFormatter(n)
    });
  }
  validateDataTypeDefinition(e, t, r) {
    return t ? t.baseDataType !== e.baseDataType ? (we('The "baseDataType" property of a data type definition must match that of its parent.'), !1) : !0 : (we(`The data type definition ${r} does not exist.`), !1);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter)
      return (t) => {
        var r, i;
        if ((r = t.node) != null && r.group) {
          const n = t.column.getAggFunc();
          if (n) {
            if (n === "first" || n === "last")
              return e.valueFormatter(t);
            if (e.baseDataType === "number" && n !== "count") {
              if (typeof t.value == "number")
                return e.valueFormatter(t);
              if (typeof t.value == "object") {
                if (!t.value)
                  return;
                if ("toNumber" in t.value)
                  return e.valueFormatter(Dt(Ce({}, t), {
                    value: t.value.toNumber()
                  }));
                if ("value" in t.value)
                  return e.valueFormatter(Dt(Ce({}, t), {
                    value: t.value.value
                  }));
              }
            }
          }
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        } else if (this.groupHideOpenParents && t.column.isRowGroupActive()) {
          if (typeof t.value != "string" || (i = e.dataTypeMatcher) != null && i.call(e, t.value))
            return e.valueFormatter(t);
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        }
        return e.valueFormatter(t);
      };
  }
  updateColDefAndGetDataTypeDefinitionColumnType(e, t, r) {
    let { cellDataType: i } = t;
    const { field: n } = t;
    if (i === void 0 && (i = e.cellDataType), (i == null || i === !0) && (i = this.canInferCellDataType(e, t) ? this.inferCellDataType(n, r) : !1), !i) {
      e.cellDataType = !1;
      return;
    }
    const o = this.dataTypeDefinitions[i];
    if (!o) {
      we(`Missing data type definition - "${i}"`);
      return;
    }
    return e.cellDataType = i, o.groupSafeValueFormatter && (e.valueFormatter = o.groupSafeValueFormatter), o.valueParser && (e.valueParser = o.valueParser), o.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, o, r), o.columnTypes;
  }
  updateColDefAndGetColumnType(e, t, r) {
    var i, n;
    const o = this.updateColDefAndGetDataTypeDefinitionColumnType(e, t, r), s = (n = (i = t.type) != null ? i : o) != null ? n : e.type;
    return e.type = s, s ? this.convertColumnTypes(s) : void 0;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const r = (i) => {
      t.add(i.key);
    };
    e.addEventListener(ct.EVENT_STATE_UPDATED, r), this.columnStateUpdateListenerDestroyFuncs.push(() => e.removeEventListener(ct.EVENT_STATE_UPDATED, r));
  }
  canInferCellDataType(e, t) {
    var r;
    if (this.rowModel.getType() !== "clientSide")
      return !1;
    const i = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (this.doColDefPropsPreventInference(t, i))
      return !1;
    const n = t.type === null ? e.type : t.type;
    if (n) {
      const o = (r = this.gos.get("columnTypes")) != null ? r : {};
      if (this.convertColumnTypes(n).some((a) => {
        const l = o[a.trim()];
        return l && this.doColDefPropsPreventInference(l, i);
      }))
        return !1;
    }
    return !this.doColDefPropsPreventInference(e, i);
  }
  doColDefPropsPreventInference(e, t) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(([r, i]) => this.doesColDefPropPreventInference(e, t, r, i));
  }
  doesColDefPropPreventInference(e, t, r, i) {
    if (!t[r])
      return !1;
    const n = e[r];
    return n === null ? (t[r] = !1, !1) : i === void 0 ? !!n : n === i;
  }
  inferCellDataType(e, t) {
    var r;
    if (!e)
      return;
    let i;
    const n = this.getInitialData();
    if (n) {
      const s = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      i = ml(n, e, s);
    } else
      this.initWaitForRowData(t);
    if (i == null)
      return;
    const [o] = (r = Object.entries(this.dataTypeMatchers).find(([s, a]) => a(i))) != null ? r : ["object"];
    return o;
  }
  getInitialData() {
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t != null && t.length)
        return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData)
      return;
    this.isWaitingForRowData = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const r = this.addManagedListener(this.eventService, A.EVENT_ROW_DATA_UPDATE_STARTED, (i) => {
      const { firstRowData: n } = i;
      if (!n)
        return;
      r == null || r(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(n, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations();
      const o = {
        type: A.EVENT_DATA_TYPES_INFERRED
      };
      this.eventService.dispatchEvent(o);
    });
  }
  isPendingInference() {
    return this.isWaitingForRowData;
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const r = [];
    this.columnStateUpdateListenerDestroyFuncs.forEach((o) => o()), this.columnStateUpdateListenerDestroyFuncs = [];
    const i = {}, n = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([o, s]) => {
      const a = this.columnModel.getGridColumn(o);
      if (!a)
        return;
      const l = a.getColDef();
      if (!this.columnModel.resetColumnDefIntoColumn(a, "cellDataTypeInferred"))
        return;
      const u = a.getColDef();
      if (t && u.type && u.type !== l.type) {
        const c = this.getUpdatedColumnState(a, s);
        c.rowGroup && c.rowGroupIndex == null && (i[o] = c), c.pivot && c.pivotIndex == null && (n[o] = c), r.push(c);
      }
    }), t && r.push(...this.columnModel.generateColumnStateForRowGroupAndPivotIndexes(i, n)), r.length && this.columnModel.applyColumnState({ state: r }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const r = this.columnModel.getColumnStateFromColDef(e);
    return t.forEach((i) => {
      delete r[i], i === "rowGroup" ? delete r.rowGroupIndex : i === "pivot" && delete r.pivotIndex;
    }), r;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, r = e.object;
    this.hasObjectValueParser = t.valueParser !== r.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== r.valueFormatter;
  }
  convertColumnTypes(e) {
    let t = [];
    return e instanceof Array ? e.some((i) => typeof i != "string") ? console.warn("if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : console.warn("colDef.type should be of type 'string' | 'string[]'"), t;
  }
  getDateStringTypeDefinition(e) {
    var t;
    return e ? (t = this.getDataTypeDefinition(e)) != null ? t : this.dataTypeDefinitions.dateString : this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var r;
    if (t == null)
      return !0;
    const i = (r = this.getDataTypeDefinition(e)) == null ? void 0 : r.dataTypeMatcher;
    return i ? i(t) : !0;
  }
  validateColDef(e) {
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && we('Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && we('Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'));
  }
  setColDefPropertiesForBaseDataType(e, t, r) {
    const i = (a, l, u) => {
      let c = a.getColDef().valueFormatter;
      return c === t.groupSafeValueFormatter && (c = t.valueFormatter), this.valueService.formatValue(a, l, u, c);
    }, n = Xe.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId()), o = this.localeService.getLocaleTextFunc(), s = (a) => {
      const { filterParams: l } = e;
      e.filterParams = typeof l == "object" ? Ce(Ce({}, l), a) : a;
    };
    switch (t.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor", n && s({
          comparator: (a, l) => {
            const u = a == null ? 0 : parseInt(a), c = l == null ? 0 : parseInt(l);
            return u === c ? 0 : u > c ? 1 : -1;
          }
        });
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (a) => !!a.colDef.editable && a.event.key === k.SPACE, s(n ? {
          valueFormatter: (a) => q(a.value) ? o(String(a.value), a.value ? "True" : "False") : o("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (a, l) => l,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (a, l) => l === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = (a) => i(a.column, a.node, a.value), n && s({
          valueFormatter: (a) => {
            const l = i(a.column, a.node, a.value);
            return q(l) ? l : o("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (a, l) => {
            if (l === 1 && a != null) {
              const u = KT[Number(a) - 1];
              return o(u, XT[u]);
            }
            return a ?? o("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = (l) => i(l.column, l.node, l.value);
        const a = t.dateParser;
        s(n ? {
          valueFormatter: (l) => {
            const u = i(l.column, l.node, l.value);
            return q(u) ? u : o("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (l) => {
            const u = a(l ?? void 0);
            return u ? [String(u.getFullYear()), String(u.getMonth() + 1), String(u.getDate())] : null;
          },
          treeListFormatter: (l, u) => {
            if (u === 1 && l != null) {
              const c = KT[Number(l) - 1];
              return o(c, XT[c]);
            }
            return l ?? o("blanks", "(Blanks)");
          }
        } : {
          comparator: (l, u) => {
            const c = a(u);
            return u == null || c < l ? -1 : c > l ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (a, l) => {
          const u = this.columnModel.getPrimaryColumn(r), c = u == null ? void 0 : u.getColDef();
          if (!u || !c)
            return 0;
          const d = a == null ? "" : i(u, null, a), h = l == null ? "" : i(u, null, l);
          return d === h ? 0 : d > h ? 1 : -1;
        }, e.keyCreator = (a) => i(a.column, a.node, a.value), n ? s({
          valueFormatter: (a) => {
            const l = i(a.column, a.node, a.value);
            return q(l) ? l : o("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (a) => i(
          a.column,
          a.node,
          this.valueService.getValue(a.column, a.node)
        );
        break;
      }
    }
  }
  getDefaultDataTypes() {
    const e = (r) => !!r.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (r) => {
          var i, n;
          return ((n = (i = r.newValue) == null ? void 0 : i.trim) == null ? void 0 : n.call(i)) === "" ? null : Number(r.newValue);
        },
        valueFormatter: (r) => r.value == null ? "" : typeof r.value != "number" || isNaN(r.value) ? t("invalidNumber", "Invalid Number") : String(r.value),
        dataTypeMatcher: (r) => typeof r == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (r) => r.newValue === "" ? null : Dd(r.newValue),
        dataTypeMatcher: (r) => typeof r == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (r) => {
          var i, n;
          return r.newValue == null ? r.newValue : ((n = (i = r.newValue) == null ? void 0 : i.trim) == null ? void 0 : n.call(i)) === "" ? null : String(r.newValue).toLowerCase() === "true";
        },
        valueFormatter: (r) => r.value == null ? "" : String(r.value),
        dataTypeMatcher: (r) => typeof r == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (r) => Jr(r.newValue == null ? null : String(r.newValue)),
        valueFormatter: (r) => {
          var i;
          return r.value == null ? "" : !(r.value instanceof Date) || isNaN(r.value.getTime()) ? t("invalidDate", "Invalid Date") : (i = Bi(r.value, !1)) != null ? i : "";
        },
        dataTypeMatcher: (r) => r instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (r) => {
          var i;
          return (i = Jr(r)) != null ? i : void 0;
        },
        dateFormatter: (r) => {
          var i;
          return (i = Bi(r ?? null, !1)) != null ? i : void 0;
        },
        valueParser: (r) => e(String(r.newValue)) ? r.newValue : null,
        valueFormatter: (r) => e(String(r.value)) ? r.value : "",
        dataTypeMatcher: (r) => typeof r == "string" && e(r)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (r) => {
          var i;
          return (i = Dd(r.value)) != null ? i : "";
        }
      }
    };
  }
};
v([
  T("rowModel")
], ga.prototype, "rowModel", 2);
v([
  T("columnModel")
], ga.prototype, "columnModel", 2);
v([
  T("valueService")
], ga.prototype, "valueService", 2);
v([
  te
], ga.prototype, "init", 1);
ga = v([
  de("dataTypeService")
], ga);
var ma = class extends Q {
  constructor() {
    super(...arguments), this.waitingForColumns = !1;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.ctrlsService.whenReady(() => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    this.columnModel.setColumnDefs(e ?? [], "gridInitializing"), this.rowModel.start();
  }
  gridReady() {
    this.dispatchGridReadyEvent();
    const e = Xe.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId());
    new OE("AG Grid", () => this.gos.get("debug")).log(`initialised successfully, enterprise = ${e}`);
  }
  dispatchGridReadyEvent() {
    const e = {
      type: A.EVENT_GRID_READY
    };
    this.eventService.dispatchEvent(e);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.columnModel.setColumnDefs(t, dl(e.source));
    }
  }
};
v([
  T("ctrlsService")
], ma.prototype, "ctrlsService", 2);
v([
  T("columnModel")
], ma.prototype, "columnModel", 2);
v([
  T("rowModel")
], ma.prototype, "rowModel", 2);
v([
  te
], ma.prototype, "postConstruct", 1);
ma = v([
  de("syncService")
], ma);
var va = class extends Q {
  constructor() {
    super(...arguments), this.manuallyDisplayed = !1;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, A.EVENT_ROW_DATA_UPDATED, () => this.onRowDataUpdated()), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded());
  }
  registerOverlayWrapperComp(e) {
    this.overlayWrapperComp = e, (!this.gos.get("columnDefs") || this.gos.isRowModelType("clientSide") && !this.gos.get("rowData")) && this.showLoadingOverlay();
  }
  showLoadingOverlay() {
    if (this.gos.get("suppressLoadingOverlay"))
      return;
    const e = {}, t = this.userComponentFactory.getLoadingOverlayCompDetails(e);
    this.showOverlay(t, "ag-overlay-loading-wrapper", "loadingOverlayComponentParams");
  }
  showNoRowsOverlay() {
    if (this.gos.get("suppressNoRowsOverlay"))
      return;
    const e = {}, t = this.userComponentFactory.getNoRowsOverlayCompDetails(e);
    this.showOverlay(t, "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams");
  }
  showOverlay(e, t, r) {
    const i = e.newAgStackInstance(), n = this.addManagedPropertyListener(r, ({ currentValue: o }) => {
      i.then((s) => {
        s.refresh && s.refresh(this.gos.addGridCommonParams(Ce({}, o ?? {})));
      });
    });
    this.manuallyDisplayed = this.columnModel.isReady() && !this.paginationProxy.isEmpty(), this.overlayWrapperComp.showOverlay(i, t, n);
  }
  hideOverlay() {
    this.manuallyDisplayed = !1, this.overlayWrapperComp.hideOverlay();
  }
  showOrHideOverlay() {
    const e = this.paginationProxy.isEmpty(), t = this.gos.get("suppressNoRowsOverlay");
    e && !t ? this.showNoRowsOverlay() : this.hideOverlay();
  }
  onRowDataUpdated() {
    this.showOrHideOverlay();
  }
  onNewColumnsLoaded() {
    this.columnModel.isReady() && !this.paginationProxy.isEmpty() && !this.manuallyDisplayed && this.hideOverlay();
  }
};
v([
  T("userComponentFactory")
], va.prototype, "userComponentFactory", 2);
v([
  T("paginationProxy")
], va.prototype, "paginationProxy", 2);
v([
  T("columnModel")
], va.prototype, "columnModel", 2);
v([
  te
], va.prototype, "postConstruct", 1);
va = v([
  de("overlayService")
], va);
var Hr = class extends Q {
  constructor() {
    super(...arguments), this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = kr(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = kr(() => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), 0), this.onRowSelectedDebounced = kr(() => {
      this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
    }, 0), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  postConstruct() {
    var e;
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide", this.cachedState = (e = this.gos.get("initialState")) != null ? e : {}, this.ctrlsService.whenReady(() => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
    const t = this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, ({ source: n }) => {
      n === "gridInitializing" && (t == null || t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()));
    }), r = this.addManagedListener(this.eventService, A.EVENT_ROW_COUNT_READY, () => {
      r == null || r(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
    }), i = this.addManagedListener(this.eventService, A.EVENT_FIRST_DATA_RENDERED, () => {
      i == null || i(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
    });
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    this.updateCachedState("sideBar", this.getSideBarState()), this.addManagedListener(this.eventService, A.EVENT_TOOL_PANEL_VISIBLE_CHANGED, () => this.updateCachedState("sideBar", this.getSideBarState())), this.addManagedListener(this.eventService, A.EVENT_SIDE_BAR_UPDATED, () => this.updateCachedState("sideBar", this.getSideBarState()));
  }
  setupStateOnColumnsInitialised() {
    var e;
    const t = (e = this.gos.get("initialState")) != null ? e : {};
    this.setColumnState(t), this.setColumnGroupState(t), this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState()), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VALUE_CHANGED, () => this.updateColumnState(["aggregation"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_MOVED, () => this.updateColumnState(["columnOrder"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PINNED, () => this.updateColumnState(["columnPinning"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_RESIZED, () => this.updateColumnState(["columnSizing"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VISIBLE, () => this.updateColumnState(["columnVisibility"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_CHANGED, () => this.updateColumnState(["pivot"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.updateColumnState(["pivot"])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateColumnState(["rowGroup"])), this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, () => this.updateColumnState(["sort"])), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, () => this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ])), this.addManagedListener(this.eventService, A.EVENT_COLUMN_GROUP_OPENED, () => this.updateCachedState("columnGroup", this.getColumnGroupState()));
  }
  setupStateOnRowCountReady() {
    var e;
    const {
      filter: t,
      rowGroupExpansion: r,
      rowSelection: i,
      pagination: n
    } = (e = this.gos.get("initialState")) != null ? e : {}, o = this.gos.get("advancedFilterModel");
    (t || o) && this.setFilterState(t, o), r && this.setRowGroupExpansionState(r), i && this.setRowSelectionState(i), n && this.setPaginationState(n), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState()), this.addManagedListener(this.eventService, A.EVENT_FILTER_CHANGED, () => this.updateCachedState("filter", this.getFilterState())), this.addManagedListener(this.eventService, A.EVENT_ROW_GROUP_OPENED, () => this.onRowGroupOpenedDebounced()), this.addManagedListener(this.eventService, A.EVENT_EXPAND_COLLAPSE_ALL, () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState())), this.addManagedListener(this.eventService, A.EVENT_SELECTION_CHANGED, () => {
      this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
    }), this.addManagedListener(this.eventService, A.EVENT_PAGINATION_CHANGED, (s) => {
      (s.newPage || s.newPageSize) && this.updateCachedState("pagination", this.getPaginationState());
    });
  }
  setupStateOnFirstDataRendered() {
    var e;
    const {
      scroll: t,
      rangeSelection: r,
      focusedCell: i,
      columnOrder: n
    } = (e = this.gos.get("initialState")) != null ? e : {};
    i && this.setFocusedCellState(i), r && this.setRangeSelectionState(r), t && this.setScrollState(t), this.setColumnPivotState(!!(n != null && n.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState()), this.updateCachedState("rangeSelection", this.getRangeSelectionState()), this.updateCachedState("scroll", this.getScrollState()), this.addManagedListener(this.eventService, A.EVENT_CELL_FOCUSED, () => this.updateCachedState("focusedCell", this.getFocusedCellState())), this.addManagedListener(this.eventService, A.EVENT_RANGE_SELECTION_CHANGED, (o) => {
      o.finished && this.updateCachedState("rangeSelection", this.getRangeSelectionState());
    }), this.addManagedListener(this.eventService, A.EVENT_BODY_SCROLL_END, () => this.updateCachedState("scroll", this.getScrollState()));
  }
  getColumnState() {
    const e = this.columnModel.isPivotMode(), t = [], r = [], i = [], n = [], o = [], s = [], a = [], l = [], u = [], c = this.columnModel.getColumnState();
    for (let d = 0; d < c.length; d++) {
      const {
        colId: h,
        sort: p,
        sortIndex: g,
        rowGroup: m,
        rowGroupIndex: f,
        aggFunc: C,
        pivot: w,
        pivotIndex: E,
        pinned: b,
        hide: y,
        width: S,
        flex: x
      } = c[d];
      u.push(h), p && (t[g ?? 0] = { colId: h, sort: p }), m && (r[f ?? 0] = h), typeof C == "string" && i.push({ colId: h, aggFunc: C }), w && (n[E ?? 0] = h), b && (b === "right" ? s : o).push(h), y && a.push(h), (x || S) && l.push({ colId: h, flex: x ?? void 0, width: S });
    }
    return {
      sort: t.length ? { sortModel: t } : void 0,
      rowGroup: r.length ? { groupColIds: r } : void 0,
      aggregation: i.length ? { aggregationModel: i } : void 0,
      pivot: n.length || e ? { pivotMode: e, pivotColIds: n } : void 0,
      columnPinning: o.length || s.length ? { leftColIds: o, rightColIds: s } : void 0,
      columnVisibility: a.length ? { hiddenColIds: a } : void 0,
      columnSizing: l.length ? { columnSizingModel: l } : void 0,
      columnOrder: u.length ? { orderedColIds: u } : void 0
    };
  }
  setColumnState(e) {
    const {
      sort: t,
      rowGroup: r,
      aggregation: i,
      pivot: n,
      columnPinning: o,
      columnVisibility: s,
      columnSizing: a,
      columnOrder: l
    } = e, u = {}, c = (g) => {
      let m = u[g];
      return m || (m = { colId: g }, u[g] = m, m);
    };
    t && t.sortModel.forEach(({ colId: g, sort: m }, f) => {
      const C = c(g);
      C.sort = m, C.sortIndex = f;
    }), r && r.groupColIds.forEach((g, m) => {
      const f = c(g);
      f.rowGroup = !0, f.rowGroupIndex = m;
    }), i && i.aggregationModel.forEach(({ colId: g, aggFunc: m }) => {
      c(g).aggFunc = m;
    }), n && (n.pivotColIds.forEach((g, m) => {
      const f = c(g);
      f.pivot = !0, f.pivotIndex = m;
    }), this.gos.updateGridOptions({ options: { pivotMode: n.pivotMode }, source: "gridInitializing" })), o && (o.leftColIds.forEach((g) => {
      c(g).pinned = "left";
    }), o.rightColIds.forEach((g) => {
      c(g).pinned = "right";
    })), s && s.hiddenColIds.forEach((g) => {
      c(g).hide = !0;
    }), a && a.columnSizingModel.forEach(({ colId: g, flex: m, width: f }) => {
      const C = c(g);
      C.flex = m ?? null, C.width = f;
    });
    const d = l == null ? void 0 : l.orderedColIds, h = !!(d != null && d.length), p = h ? d.map((g) => c(g)) : Object.values(u);
    if (p.length) {
      this.columnStates = p;
      const g = {
        sort: null,
        sortIndex: null,
        rowGroup: null,
        rowGroupIndex: null,
        aggFunc: null,
        pivot: null,
        pivotIndex: null,
        pinned: null,
        hide: null,
        flex: null
      };
      this.columnModel.applyColumnState({
        state: p,
        applyOrder: h,
        defaultState: g
      }, "gridInitializing");
    }
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const r = this.columnGroupStates;
    if (this.columnGroupStates = void 0, !!this.columnModel.isSecondaryColumnsPresent()) {
      if (t) {
        let i = [];
        for (const n of t)
          this.columnModel.getSecondaryColumn(n.colId) && i.push(n);
        this.columnModel.applyColumnState({
          state: i,
          applyOrder: e
        }, "gridInitializing");
      }
      r && this.columnModel.setColumnGroupState(r, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const e = this.columnModel.getColumnGroupState(), t = [];
    return e.forEach(({ groupId: r, open: i }) => {
      i && t.push(r);
    }), t.length ? { openColumnGroupIds: t } : void 0;
  }
  setColumnGroupState(e) {
    var t;
    if (!e.hasOwnProperty("columnGroup"))
      return;
    const r = new Set((t = e.columnGroup) == null ? void 0 : t.openColumnGroupIds), n = this.columnModel.getColumnGroupState().map(({ groupId: o }) => {
      const s = r.has(o);
      return s && r.delete(o), {
        groupId: o,
        open: s
      };
    });
    r.forEach((o) => {
      n.push({
        groupId: o,
        open: !0
      });
    }), n.length && (this.columnGroupStates = n), this.columnModel.setColumnGroupState(n, "gridInitializing");
  }
  getFilterState() {
    var e;
    let t = this.filterManager.getFilterModel();
    t && Object.keys(t).length === 0 && (t = void 0);
    const r = (e = this.filterManager.getAdvancedFilterModel()) != null ? e : void 0;
    return t || r ? { filterModel: t, advancedFilterModel: r } : void 0;
  }
  setFilterState(e, t) {
    const { filterModel: r, advancedFilterModel: i } = e ?? { advancedFilterModel: t };
    r && this.filterManager.setFilterModel(r, "columnFilter"), i && this.filterManager.setAdvancedFilterModel(i);
  }
  getRangeSelectionState() {
    var e;
    const t = (e = this.rangeService) == null ? void 0 : e.getCellRanges().map((r) => {
      const { id: i, type: n, startRow: o, endRow: s, columns: a, startColumn: l } = r;
      return {
        id: i,
        type: n,
        startRow: o,
        endRow: s,
        colIds: a.map((u) => u.getColId()),
        startColId: l.getColId()
      };
    });
    return t != null && t.length ? { cellRanges: t } : void 0;
  }
  setRangeSelectionState(e) {
    if (!this.gos.get("enableRangeSelection") || !this.rangeService)
      return;
    const t = [];
    e.cellRanges.forEach((r) => {
      const i = [];
      if (r.colIds.forEach((o) => {
        const s = this.columnModel.getGridColumn(o);
        s && i.push(s);
      }), !i.length)
        return;
      let n = this.columnModel.getGridColumn(r.startColId);
      if (!n) {
        const o = this.columnModel.getAllDisplayedColumns(), s = new Set(i);
        n = o.find((a) => s.has(a));
      }
      t.push(Dt(Ce({}, r), {
        columns: i,
        startColumn: n
      }));
    }), this.rangeService.setCellRanges(t);
  }
  getScrollState() {
    var e, t, r;
    if (!this.isClientSideRowModel)
      return;
    const i = (e = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : e.getScrollFeature(), { left: n } = (t = i == null ? void 0 : i.getHScrollPosition()) != null ? t : { left: 0 }, { top: o } = (r = i == null ? void 0 : i.getVScrollPosition()) != null ? r : { top: 0 };
    return o || n ? {
      top: o,
      left: n
    } : void 0;
  }
  setScrollState(e) {
    var t;
    if (!this.isClientSideRowModel)
      return;
    const { top: r, left: i } = e;
    (t = this.ctrlsService.getGridBodyCtrl()) == null || t.getScrollFeature().setScrollPosition(r, i);
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.sideBarService) == null ? void 0 : e.getSideBarComp()) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.focusService.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: r, rowPinned: i } = e;
      return {
        colId: t.getColId(),
        rowIndex: r,
        rowPinned: i
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { colId: t, rowIndex: r, rowPinned: i } = e;
    this.focusService.setFocusedCell({
      column: this.columnModel.getGridColumn(t),
      rowIndex: r,
      rowPinned: i,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    const e = this.paginationProxy.getCurrentPage(), t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationProxy.getPageSize();
    if (!(!e && !t))
      return { page: e, pageSize: t };
  }
  setPaginationState(e) {
    e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationProxy.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && this.paginationProxy.setPage(e.page);
  }
  getRowSelectionState() {
    var e;
    const t = this.selectionService.getSelectionState();
    return !t || !Array.isArray(t) && (t.selectAll === !1 || t.selectAllChildren === !1) && !((e = t == null ? void 0 : t.toggledNodes) != null && e.length) ? void 0 : t;
  }
  setRowSelectionState(e) {
    this.selectionService.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const e = this.expansionService.getExpandedRows();
    return e.length ? {
      expandedRowGroupIds: e
    } : void 0;
  }
  setRowGroupExpansionState(e) {
    this.expansionService.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let r = !1;
    Object.entries(t).forEach(([i, n]) => {
      Rb(n, this.cachedState[i]) || (r = !0);
    }), this.cachedState = Ce(Ce({}, this.cachedState), t), r && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const r = this.cachedState[e];
    this.setCachedStateValue(e, t), Rb(t, r) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = Dt(Ce({}, this.cachedState), {
      [e]: t
    });
  }
  refreshStaleState() {
    this.staleStateKeys.forEach((e) => {
      switch (e) {
        case "rowSelection":
          this.setCachedStateValue(e, this.getRowSelectionState());
          break;
      }
    }), this.staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = Array.from(this.queuedUpdateSources);
    this.queuedUpdateSources.clear();
    const t = {
      type: A.EVENT_STATE_UPDATED,
      sources: e,
      state: this.cachedState
    };
    this.eventService.dispatchEvent(t);
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = !0, this.columnAnimationService.setSuppressAnimation(!0), e(), setTimeout(() => {
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
};
v([
  T("filterManager")
], Hr.prototype, "filterManager", 2);
v([
  T("ctrlsService")
], Hr.prototype, "ctrlsService", 2);
v([
  T("focusService")
], Hr.prototype, "focusService", 2);
v([
  T("columnModel")
], Hr.prototype, "columnModel", 2);
v([
  T("paginationProxy")
], Hr.prototype, "paginationProxy", 2);
v([
  T("rowModel")
], Hr.prototype, "rowModel", 2);
v([
  T("selectionService")
], Hr.prototype, "selectionService", 2);
v([
  T("expansionService")
], Hr.prototype, "expansionService", 2);
v([
  T("columnAnimationService")
], Hr.prototype, "columnAnimationService", 2);
v([
  Qe("sideBarService")
], Hr.prototype, "sideBarService", 2);
v([
  Qe("rangeService")
], Hr.prototype, "rangeService", 2);
v([
  te
], Hr.prototype, "postConstruct", 1);
Hr = v([
  de("stateService")
], Hr);
var Yd = class extends Q {
  init() {
    this.processGridOptions(this.gridOptions);
  }
  processGridOptions(e) {
    this.processOptions(e, Cae);
  }
  processColumnDefs(e) {
    this.processOptions(e, hl);
  }
  processOptions(e, t) {
    const { validations: r, deprecations: i, allProperties: n, propertyExceptions: o, objectName: s, docsUrl: a } = t;
    n && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...o ?? [], ...Object.keys(i)],
      n,
      s,
      a
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((c) => {
      var d;
      const h = i[c];
      if (h)
        if ("renamed" in h) {
          const { renamed: E, version: b } = h;
          l.add(`As of v${b}, ${String(c)} is deprecated. Please use ${String(E)} instead.`), e[E] = e[c];
        } else {
          const { message: E, version: b } = h;
          l.add(`As of v${b}, ${String(c)} is deprecated. ${E ?? ""}`);
        }
      const p = e[c];
      if (p == null || p === !1)
        return;
      const g = r[c];
      let m;
      if (g)
        if (typeof g == "function") {
          const E = g(e, this.gridOptions);
          if (!E)
            return;
          if ("objectName" in E) {
            const b = e[c];
            if (Array.isArray(b)) {
              b.forEach((y) => {
                this.processOptions(y, E);
              });
              return;
            }
            this.processOptions(e[c], E);
            return;
          }
          m = E;
        } else
          m = g;
      else return;
      const { module: f, dependencies: C, supportedRowModels: w } = m;
      if (w) {
        const E = (d = this.gridOptions.rowModelType) != null ? d : "clientSide";
        if (!w.includes(E)) {
          l.add(`${String(c)} is not supported with the '${E}' row model.`);
          return;
        }
      }
      if (f) {
        const E = Array.isArray(f) ? f : [f];
        let b = !0;
        if (E.forEach((y) => {
          Xe.__assertRegistered(y, String(c), this.context.getGridId()) || (b = !1, l.add(`${String(c)} is only available when ${y} is loaded.`));
        }), !b)
          return;
      }
      if (C) {
        const E = this.checkForWarning(c, C, e);
        if (E) {
          l.add(E);
          return;
        }
      }
    }), l.size > 0 && l.forEach((c) => {
      we(c);
    });
  }
  checkForWarning(e, t, r) {
    if (typeof t == "function")
      return t(r, this.gridOptions);
    const n = Object.entries(t).find(([a, l]) => {
      const u = r[a];
      return !l.includes(u);
    });
    if (!n)
      return null;
    const [o, s] = n;
    return s.length > 1 ? `'${String(e)}' requires '${o}' to be one of [${s.join(", ")}].` : `'${String(e)}' requires '${o}' to be ${s[0]}.`;
  }
  checkProperties(e, t, r, i, n) {
    const o = ["__ob__", "__v_skip", "__metadata__"], s = F_(
      Object.getOwnPropertyNames(e),
      [...o, ...t, ...r],
      r
    );
    if (Tr(s, (a, l) => {
      we(`invalid ${i} property '${a}' did you mean any of these: ${l.slice(0, 8).join(", ")}`);
    }), Object.keys(s).length > 0 && n) {
      const a = this.getFrameworkOverrides().getDocLink(n);
      we(`to see all the valid ${i} properties please check: ${a}`);
    }
  }
};
v([
  T("gridOptions")
], Yd.prototype, "gridOptions", 2);
v([
  te
], Yd.prototype, "init", 1);
Yd = v([
  de("validationService")
], Yd);
var Cg = class extends Q {
  constructor() {
    super(...arguments), this.syncEventListeners = /* @__PURE__ */ new Map(), this.asyncEventListeners = /* @__PURE__ */ new Map(), this.syncGlobalEventListeners = /* @__PURE__ */ new Set(), this.globalEventListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.frameworkEventWrappingService = new LS(this.getFrameworkOverrides());
  }
  addEventListener(e, t) {
    const r = this.frameworkEventWrappingService.wrap(t), i = this.gos.useAsyncEvents() && !Pp.has(e), n = i ? this.asyncEventListeners : this.syncEventListeners;
    n.has(e) || n.set(e, /* @__PURE__ */ new Set()), n.get(e).add(r), this.eventService.addEventListener(e, r, i);
  }
  removeEventListener(e, t) {
    var r;
    const i = this.frameworkEventWrappingService.unwrap(t), n = this.asyncEventListeners.get(e), o = !!(n != null && n.delete(i));
    o || (r = this.syncEventListeners.get(e)) == null || r.delete(i), this.eventService.removeEventListener(e, i, o);
  }
  addGlobalListener(e) {
    const t = this.frameworkEventWrappingService.wrapGlobal(e);
    if (this.gos.useAsyncEvents()) {
      const i = (o, s) => {
        Pp.has(o) && t(o, s);
      }, n = (o, s) => {
        Pp.has(o) || t(o, s);
      };
      this.globalEventListenerPairs.set(e, { syncListener: i, asyncListener: n }), this.eventService.addGlobalListener(i, !1), this.eventService.addGlobalListener(n, !0);
    } else
      this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, !1);
  }
  removeGlobalListener(e) {
    const t = this.frameworkEventWrappingService.unwrapGlobal(e);
    if (this.globalEventListenerPairs.has(t)) {
      const { syncListener: i, asyncListener: n } = this.globalEventListenerPairs.get(t);
      this.eventService.removeGlobalListener(i, !1), this.eventService.removeGlobalListener(n, !0), this.globalEventListenerPairs.delete(e);
    } else
      this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((r, i) => {
      r.forEach((n) => this.eventService.removeEventListener(i, n, t)), r.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((r) => this.eventService.removeGlobalListener(r, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncEventListeners, !1), this.destroyEventListeners(this.asyncEventListeners, !0), this.destroyGlobalListeners(this.syncGlobalEventListeners, !1), this.globalEventListenerPairs.forEach(({ syncListener: e, asyncListener: t }) => {
      this.eventService.removeGlobalListener(e, !1), this.eventService.removeGlobalListener(t, !0);
    }), this.globalEventListenerPairs.clear();
  }
};
v([
  te
], Cg.prototype, "postConstruct", 1);
Cg = v([
  de("apiEventService")
], Cg);
var FE = class extends Oe {
  constructor() {
    super(
      /* html */
      '<span class="ag-paging-page-size"></span>'
    ), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.paginationProxy.getPageSize() || (this.paginationProxy.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  init() {
    this.addManagedPropertyListener("paginationPageSizeSelector", () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedListener(
      this.eventService,
      A.EVENT_PAGINATION_CHANGED,
      (e) => this.handlePaginationChanged(e)
    );
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.paginationProxy.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp && this.appendChild(this.selectPageSizeComp));
  }
  reset() {
    Ht(this.getGui()), this.selectPageSizeComp && (this.destroyBean(this.selectPageSizeComp), this.selectPageSizeComp = void 0);
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get("paginationPageSizeSelector") !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.paginationProxy.getPageSize(), r = !t || !e.includes(t);
    r && (e.unshift(""), we(
      `The paginationPageSize grid option is set to a value that is not in the list of page size options.
                Please make sure that the paginationPageSize grid option is set to one of the values in the 
                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.`
    )), this.selectPageSizeComp && (this.destroyBean(this.selectPageSizeComp), this.selectPageSizeComp = void 0);
    const i = this.localeService.getLocaleTextFunc(), n = i("pageSizeSelectorLabel", "Page Size:"), o = e.map((a) => ({
      value: String(a),
      text: String(a)
    })), s = i("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new $m()).addOptions(o).setValue(String(r ? "" : t)).setAriaLabel(s).setLabel(n).onValueChange(() => this.handlePageSizeItemSelected()), this.hasEmptyOption = r;
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get("paginationPageSizeSelector");
    return !Array.isArray(t) || !this.validateValues(t) ? e : [...t].sort((r, i) => r - i);
  }
  validateValues(e) {
    if (!e.length)
      return we(
        `The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.
                If you want to hide the page size selector, please set the paginationPageSizeSelector to false.`
      ), !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], i = typeof r == "number", n = r > 0;
      if (!i)
        return we(
          `The paginationPageSizeSelector grid option contains a non-numeric value.
                    Please make sure that all values in the paginationPageSizeSelector array are numbers.`
        ), !1;
      if (!n)
        return we(
          `The paginationPageSizeSelector grid option contains a negative number or zero.
                    Please make sure that all values in the paginationPageSizeSelector array are positive.`
        ), !1;
    }
    return !0;
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
};
v([
  T("paginationProxy")
], FE.prototype, "paginationProxy", 2);
v([
  te
], FE.prototype, "init", 1);
var Xd = class extends Q {
  constructor() {
    super(), this.descriptionContainer = null, this.announceValue = kr(this.announceValue.bind(this), 200);
  }
  postConstruct() {
    const e = this.gos.getDocument(), t = this.descriptionContainer = e.createElement("div");
    t.classList.add("ag-aria-description-container"), HS(t, "polite"), s_(t, "additions text"), o_(t, !0), this.eGridDiv.appendChild(t);
  }
  announceValue(e) {
    this.descriptionContainer && (this.descriptionContainer.textContent = "", setTimeout(() => {
      this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e);
    }, 50));
  }
  destroy() {
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (Ht(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null;
  }
};
v([
  T("eGridDiv")
], Xd.prototype, "eGridDiv", 2);
v([
  te
], Xd.prototype, "postConstruct", 1);
Xd = v([
  de("ariaAnnouncementService")
], Xd);
var tw = class {
};
tw.gridOptions = void 0;
var bae = 1, wae = class {
  create(e, t, r, i, n) {
    var o;
    let s = {};
    tw.gridOptions ? (Zr(s, tw.gridOptions, !0, !0), s = Ce(Ce({}, s), t)) : s = t;
    const a = Ke.getCoercedGridOptions(s), l = !!a.debug, u = (o = a.gridId) != null ? o : String(bae++), c = this.getRegisteredModules(n, u), d = this.createBeansList(a.rowModelType, c, u), h = this.createProvidedBeans(e, a, n);
    if (!d) {
      ks("Failed to create grid.");
      return;
    }
    const p = {
      providedBeanInstances: h,
      beanClasses: d,
      debug: l,
      gridId: u
    }, g = new OE("Context", () => p.debug), m = new One(p, g), f = m.getBean("beans");
    return this.registerModuleUserComponents(f, c), this.registerStackComponents(f, c), this.registerControllers(f, c), r(m), f.syncService.start(), i && i(m), m.getBean("gridApi");
  }
  registerControllers(e, t) {
    t.forEach((r) => {
      r.controllers && r.controllers.forEach((i) => e.ctrlsFactory.register(i));
    });
  }
  registerStackComponents(e, t) {
    const r = this.createAgStackComponentsList(t);
    e.agStackComponentsRegistry.setupComponents(r);
  }
  getRegisteredModules(e, t) {
    const r = e ? e.modules : null, i = Xe.__getRegisteredModules(t), n = [], o = {}, s = (a, l, u) => {
      ((d) => {
        o[d.moduleName] || (o[d.moduleName] = !0, n.push(d), Xe.__register(d, a, u));
      })(l), l.dependantModules && l.dependantModules.forEach((d) => s(a, d, u));
    };
    return r && r.forEach((a) => s(!0, a, t)), i && i.forEach((a) => s(!Xe.__isPackageBased(), a, void 0)), n;
  }
  registerModuleUserComponents(e, t) {
    this.extractModuleEntity(
      t,
      (i) => i.userComponents ? i.userComponents : []
    ).forEach((i) => {
      e.userComponentRegistry.registerDefaultComponent(i.componentName, i.componentClass);
    });
  }
  createProvidedBeans(e, t, r) {
    let i = r ? r.frameworkOverrides : null;
    Re(i) && (i = new QN());
    const n = {
      gridOptions: t,
      eGridDiv: e,
      globalEventListener: r ? r.globalEventListener : null,
      globalSyncEventListener: r ? r.globalSyncEventListener : null,
      frameworkOverrides: i
    };
    return r && r.providedBeanInstances && Object.assign(n, r.providedBeanInstances), n;
  }
  createAgStackComponentsList(e) {
    let t = [
      { componentName: "AgCheckbox", componentClass: jm },
      { componentName: "AgRadioButton", componentClass: Z_ },
      { componentName: "AgToggleButton", componentClass: YN },
      { componentName: "AgInputTextField", componentClass: _a },
      { componentName: "AgInputTextArea", componentClass: jse },
      { componentName: "AgInputNumberField", componentClass: gE },
      { componentName: "AgInputDateField", componentClass: zse },
      { componentName: "AgInputRange", componentClass: Use },
      { componentName: "AgRichSelect", componentClass: sv },
      { componentName: "AgSelect", componentClass: $m },
      { componentName: "AgSlider", componentClass: Xse },
      { componentName: "AgGridBody", componentClass: bn },
      { componentName: "AgHeaderRoot", componentClass: Bse },
      { componentName: "AgSortIndicator", componentClass: vE },
      { componentName: "AgPagination", componentClass: ai },
      { componentName: "AgPageSizeSelector", componentClass: FE },
      { componentName: "AgOverlayWrapper", componentClass: uae },
      { componentName: "AgGroupComponent", componentClass: Kse },
      { componentName: "AgRowContainer", componentClass: Wu },
      { componentName: "AgFakeHorizontalScroll", componentClass: cae },
      { componentName: "AgFakeVerticalScroll", componentClass: yae },
      { componentName: "AgAutocomplete", componentClass: tae }
    ];
    const r = this.extractModuleEntity(
      e,
      (i) => i.agStackComponents ? i.agStackComponents : []
    );
    return t = t.concat(r), t;
  }
  createBeansList(e = "clientSide", t, r) {
    const i = t.filter((l) => !l.rowModel || l.rowModel === e), n = {
      clientSide: "@ag-grid-community/client-side-row-model",
      infinite: "@ag-grid-community/infinite-row-model",
      serverSide: "@ag-grid-enterprise/server-side-row-model",
      viewport: "@ag-grid-enterprise/viewport-row-model"
      /* ViewportRowModelModule */
    };
    if (!n[e]) {
      ks("Could not find row model for rowModelType = " + e);
      return;
    }
    if (!Xe.__assertRegistered(n[e], `rowModelType = '${e}'`, r))
      return;
    const o = [
      Ge,
      au,
      Zb,
      jd,
      iu,
      Be,
      dg,
      vg,
      Wd,
      Ub,
      Zo,
      ou,
      Gd,
      ew,
      Yd,
      Vd,
      Ld,
      _b,
      fn,
      Ke,
      Eo,
      pa,
      zi,
      vr,
      ca,
      Hd,
      Ei,
      fg,
      Rd,
      ha,
      Pr,
      mg,
      es,
      gg,
      da,
      Jo,
      _e,
      ru,
      ut,
      po,
      $d,
      Qo,
      pg,
      eu,
      fa,
      qb,
      Bd,
      su,
      Pd,
      nu,
      tu,
      Un,
      Nb,
      Jb,
      zd,
      zn,
      lu,
      Zs,
      Ud,
      uu,
      Qb,
      ga,
      ei,
      ma,
      va,
      Hr,
      kd,
      Cg,
      Xd,
      Ui
    ], s = this.extractModuleEntity(i, (l) => l.beans ? l.beans : []);
    o.push(...s);
    const a = [];
    return o.forEach((l) => {
      a.indexOf(l) < 0 && a.push(l);
    }), a;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
}, Sae = class {
  wrap(e, t, r = [], i) {
    const n = this.createWrapper(e, i);
    return t.forEach((o) => {
      this.createMethod(n, o, !0);
    }), r.forEach((o) => {
      this.createMethod(n, o, !1);
    }), n;
  }
  unwrap(e) {
    return e;
  }
  createMethod(e, t, r) {
    e.addMethod(t, this.createMethodProxy(e, t, r));
  }
  createMethodProxy(e, t, r) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (r && console.warn("AG Grid: Framework component is missing the method " + t + "()"), null);
    };
  }
}, Zu = typeof global > "u" ? {} : global;
Zu.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Zu.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Zu.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Zu.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Zu.Node = typeof Node > "u" ? {} : Node;
Zu.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var _E = class Pc {
  constructor(t, r, i, n, o, s) {
    this.nextId = 0, this.rowCountReady = !1, this.allNodesMap = {}, this.rootNode = t, this.gos = r, this.eventService = i, this.columnModel = n, this.beans = s, this.selectionService = o, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = Pc.ROOT_NODE_ID, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [];
  }
  getCopyOfNodesMap() {
    return Ae.cloneObject(this.allNodesMap);
  }
  getRowNode(t) {
    return this.allNodesMap[t];
  }
  setRowData(t) {
    if (typeof t == "string") {
      console.warn("AG Grid: rowData must be an array.");
      return;
    }
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(t);
    const r = this.rootNode, i = this.rootNode.sibling;
    r.childrenAfterFilter = null, r.childrenAfterGroup = null, r.childrenAfterAggFilter = null, r.childrenAfterSort = null, r.childrenMapped = null, r.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, t ? r.allLeafChildren = t.map((n) => this.createNode(n, this.rootNode, Pc.TOP_LEVEL)) : (r.allLeafChildren = [], r.childrenAfterGroup = []), i && (i.childrenAfterFilter = r.childrenAfterFilter, i.childrenAfterGroup = r.childrenAfterGroup, i.childrenAfterAggFilter = r.childrenAfterAggFilter, i.childrenAfterSort = r.childrenAfterSort, i.childrenMapped = r.childrenMapped, i.allLeafChildren = r.allLeafChildren);
  }
  updateRowData(t, r) {
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(t.add);
    const i = {
      remove: [],
      update: [],
      add: []
    }, n = [];
    return this.executeRemove(t, i, n), this.executeUpdate(t, i, n), this.executeAdd(t, i), this.updateSelection(n, "rowDataChanged"), r && Ae.sortRowNodesByOrder(this.rootNode.allLeafChildren, r), i;
  }
  isRowCountReady() {
    return this.rowCountReady;
  }
  dispatchRowDataUpdateStartedEvent(t) {
    const r = {
      type: A.EVENT_ROW_DATA_UPDATE_STARTED,
      firstRowData: t != null && t.length ? t[0] : null
    };
    this.eventService.dispatchEvent(r);
  }
  updateSelection(t, r) {
    const i = t.length > 0;
    if (i && this.selectionService.setNodesSelected({
      newValue: !1,
      nodes: t,
      suppressFinishActions: !0,
      source: r
    }), this.selectionService.updateGroupsFromChildrenSelections(r), i) {
      const n = {
        type: A.EVENT_SELECTION_CHANGED,
        source: r
      };
      this.eventService.dispatchEvent(n);
    }
  }
  executeAdd(t, r) {
    var i;
    const { add: n, addIndex: o } = t;
    if (Ae.missingOrEmpty(n))
      return;
    const s = n.map((a) => this.createNode(a, this.rootNode, Pc.TOP_LEVEL));
    if (typeof o == "number" && o >= 0) {
      const { allLeafChildren: a } = this.rootNode, l = a.length;
      let u = o;
      if (this.gos.get("treeData") && o > 0 && l > 0) {
        for (let p = 0; p < l; p++)
          if (((i = a[p]) == null ? void 0 : i.rowIndex) == o - 1) {
            u = p + 1;
            break;
          }
      }
      const d = a.slice(0, u), h = a.slice(u, a.length);
      this.rootNode.allLeafChildren = [...d, ...s, ...h];
    } else
      this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...s];
    this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren), r.add = s;
  }
  executeRemove(t, r, i) {
    const { remove: n } = t;
    if (Ae.missingOrEmpty(n))
      return;
    const o = {};
    n.forEach((s) => {
      const a = this.lookupRowNode(s);
      a && (a.isSelected() && i.push(a), a.clearRowTopAndRowIndex(), o[a.id] = !0, delete this.allNodesMap[a.id], r.remove.push(a));
    }), this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter((s) => !o[s.id]), this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(t, r, i) {
    const { update: n } = t;
    Ae.missingOrEmpty(n) || n.forEach((o) => {
      const s = this.lookupRowNode(o);
      s && (s.updateData(o), !s.selectable && s.isSelected() && i.push(s), this.setMasterForRow(s, o, Pc.TOP_LEVEL, !1), r.update.push(s));
    });
  }
  lookupRowNode(t) {
    const r = this.gos.getCallback("getRowId");
    let i;
    if (r) {
      const n = r({ data: t, level: 0 });
      if (i = this.allNodesMap[n], !i)
        return console.error(`AG Grid: could not find row id=${n}, data item was not found for this id`), null;
    } else if (i = this.rootNode.allLeafChildren.find((n) => n.data === t), !i)
      return console.error("AG Grid: could not find data item as object was not found", t), console.error("Consider using getRowId to help the Grid find matching row data"), null;
    return i || null;
  }
  createNode(t, r, i) {
    const n = new Ve(this.beans);
    n.group = !1, this.setMasterForRow(n, t, i, !0);
    const o = this.gos.get("suppressParentsInRowNodes");
    return r && !o && (n.parent = r), n.level = i, n.setDataAndId(t, this.nextId.toString()), this.allNodesMap[n.id] && console.warn(`AG Grid: duplicate node id '${n.id}' detected from getRowId callback, this could cause issues in your grid.`), this.allNodesMap[n.id] = n, this.nextId++, n;
  }
  setMasterForRow(t, r, i, n) {
    if (this.gos.get("treeData"))
      t.setMaster(!1), n && (t.expanded = !1);
    else {
      if (this.gos.get("masterDetail")) {
        const a = this.gos.get("isRowMaster");
        a ? t.setMaster(a(r)) : t.setMaster(!0);
      } else
        t.setMaster(!1);
      if (n) {
        const a = this.columnModel.getRowGroupColumns(), l = a ? a.length : 0, u = i + l;
        t.expanded = t.master ? this.isExpanded(u) : !1;
      }
    }
  }
  isExpanded(t) {
    const r = this.gos.get("groupDefaultExpanded");
    return r === -1 ? !0 : t < r;
  }
};
_E.TOP_LEVEL = 0;
_E.ROOT_NODE_ID = "ROOT_NODE_ID";
var Eae = _E, Br = class extends Q {
  constructor() {
    super(...arguments), this.onRowHeightChanged_debounced = Ae.debounce(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowCountReady = !1;
  }
  init() {
    const e = this.refreshModel.bind(this, {
      step: "group"
      /* EVERYTHING */
    }), t = !this.gos.get("suppressAnimationFrame"), r = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: t
    });
    this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, r), this.addManagedListener(this.eventService, A.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {
      step: "pivot"
      /* PIVOT */
    })), this.addManagedListener(this.eventService, A.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, A.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this)), this.addManagedListener(this.eventService, A.EVENT_GRID_READY, () => this.onGridReady()), this.addPropertyListeners(), this.rootNode = new Ve(this.beans), this.nodeManager = new Eae(
      this.rootNode,
      this.gos,
      this.eventService,
      this.columnModel,
      this.selectionService,
      this.beans
    );
  }
  addPropertyListeners() {
    const e = /* @__PURE__ */ new Set([
      "treeData",
      "masterDetail"
    ]), t = /* @__PURE__ */ new Set([
      "suppressParentsInRowNodes",
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType"
    ]), r = /* @__PURE__ */ new Set([
      "excludeChildrenWhenTreeDataFiltering"
    ]), i = /* @__PURE__ */ new Set([
      "removePivotHeaderRowWhenSingleValueColumn",
      "pivotRowTotals",
      "pivotColumnGroupTotals",
      "suppressExpandablePivotGroups"
    ]), n = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "groupIncludeTotalFooter",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), o = /* @__PURE__ */ new Set([
      "postSortRows",
      "groupDisplayType",
      "accentedSort"
    ]), s = /* @__PURE__ */ new Set([]), a = /* @__PURE__ */ new Set([
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupIncludeFooter",
      "groupTotalRow"
    ]), l = [
      ...e,
      ...t,
      ...r,
      ...i,
      ...i,
      ...n,
      ...o,
      ...s,
      ...a
    ];
    this.addManagedPropertyListeners(l, (u) => {
      var c;
      const d = (c = u.changeSet) == null ? void 0 : c.properties;
      if (!d)
        return;
      const h = (p) => d.some((g) => p.has(g));
      if (h(e)) {
        this.setRowData(this.rootNode.allLeafChildren.map((p) => p.data));
        return;
      }
      if (h(t)) {
        this.refreshModel({
          step: "group"
          /* EVERYTHING */
        });
        return;
      }
      if (h(r)) {
        this.refreshModel({
          step: "filter"
          /* FILTER */
        });
        return;
      }
      if (h(i)) {
        this.refreshModel({
          step: "pivot"
          /* PIVOT */
        });
        return;
      }
      if (h(n)) {
        this.refreshModel({
          step: "aggregate"
          /* AGGREGATE */
        });
        return;
      }
      if (h(o)) {
        this.refreshModel({
          step: "sort"
          /* SORT */
        });
        return;
      }
      if (h(s)) {
        this.refreshModel({
          step: "filter_aggregates"
          /* FILTER_AGGREGATES */
        });
        return;
      }
      h(a) && this.refreshModel({
        step: "map"
        /* MAP */
      });
    }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.hasStarted = !0, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData();
  }
  setInitialData() {
    const e = this.gos.get("rowData");
    e && (this.shouldSkipSettingDataOnStart = !0, this.setRowData(e));
  }
  ensureRowHeightsValid(e, t, r, i) {
    let n, o = !1;
    do {
      n = !1;
      const s = this.getRowIndexAtPixel(e), a = this.getRowIndexAtPixel(t), l = Math.max(s, r), u = Math.min(a, i);
      for (let c = l; c <= u; c++) {
        const d = this.getRow(c);
        if (d.rowHeightEstimated) {
          const h = this.gos.getRowHeightForNode(d);
          d.setRowHeight(h.height), n = !0, o = !0;
        }
      }
      n && this.setRowTopAndRowIndex();
    } while (n);
    return o;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const r = /* @__PURE__ */ new Set(), i = this.gos.isDomLayout("normal");
    for (let n = 0; n < this.rowsToDisplay.length; n++) {
      const o = this.rowsToDisplay[n];
      if (o.id != null && r.add(o.id), o.rowHeight == null) {
        const s = this.gos.getRowHeightForNode(o, i, e);
        o.setRowHeight(s.height, s.estimated);
      }
      o.setRowTop(t), o.setRowIndex(n), t += o.rowHeight;
    }
    return r;
  }
  clearRowTopAndRowIndex(e, t) {
    const r = e.isActive(), i = (o) => {
      o && o.id != null && !t.has(o.id) && o.clearRowTopAndRowIndex();
    }, n = (o) => {
      if (i(o), i(o.detailNode), i(o.sibling), o.hasChildren() && o.childrenAfterGroup) {
        const s = o.level == -1;
        r && !s && !o.expanded || o.childrenAfterGroup.forEach(n);
      }
    };
    n(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, r = 0) {
    const i = this.getRowIndexAtPixel(t), n = this.getRow(i), o = !this.gos.get("suppressAnimationFrame");
    return n === e[0] ? !1 : (e.forEach((s) => {
      Ae.removeFromArray(this.rootNode.allLeafChildren, s);
    }), e.forEach((s, a) => {
      Ae.insertIntoArray(this.rootNode.allLeafChildren, s, Math.max(i + r, 0) + a);
    }), this.refreshModel({
      step: "group",
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: o
    }), !0);
  }
  highlightRowAtPixel(e, t) {
    const r = t != null ? this.getRowIndexAtPixel(t) : null, i = r != null ? this.getRow(r) : null;
    if (!i || !e || i === e || t == null) {
      this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
      return;
    }
    const n = this.getHighlightPosition(t, i);
    this.lastHighlightedRow && this.lastHighlightedRow !== i && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null), i.setHighlighted(n), this.lastHighlightedRow = i;
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const n = this.getRowIndexAtPixel(e);
      if (t = this.getRow(n || 0), !t)
        return 1;
    }
    const { rowTop: r, rowHeight: i } = t;
    return e - r < i / 2 ? 0 : 1;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  getTopLevelRowCount() {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return 1;
    const t = this.rootNode.childrenAfterAggFilter;
    return t ? t.length : 0;
  }
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return e;
    let r = this.rootNode.childrenAfterSort[e];
    if (this.gos.get("groupHideOpenParents"))
      for (; r.expanded && r.childrenAfterSort && r.childrenAfterSort.length > 0; )
        r = r.childrenAfterSort[0];
    return r.rowIndex;
  }
  getRowBounds(e) {
    if (Ae.missing(this.rowsToDisplay))
      return null;
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = this.gos.isAnimateRows(), i = e.columns.length === 0 || e.columns.some((n) => n.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: i, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({ step: "sort", keepRenderedRows: !0, animate: e, keepEditingRows: !0 });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({
      step: "pivot"
      /* PIVOT */
    }) : this.refreshModel({
      step: "aggregate"
      /* AGGREGATE */
    });
  }
  createChangePath(e) {
    const t = Ae.missingOrEmpty(e), r = new ov(!1, this.rootNode);
    return (t || this.gos.get("treeData")) && r.setInactive(), r;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null)
      return !1;
    const t = e.rowNodeTransactions.filter(
      (i) => i.add != null && i.add.length > 0 || i.remove != null && i.remove.length > 0
    );
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = "group";
    const r = {
      everything: "group",
      group: "group",
      filter: "filter",
      map: "map",
      aggregate: "aggregate",
      sort: "sort",
      pivot: "pivot"
      /* PIVOT */
    };
    if (Ae.exists(e) && (t = r[e]), Ae.missing(t)) {
      console.error(`AG Grid: invalid step ${e}, available steps are ${Object.keys(r).join(", ")}`);
      return;
    }
    const i = !this.gos.get("suppressAnimationFrame");
    return {
      step: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: i
    };
  }
  refreshModel(e) {
    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.shouldRowModelIgnoreRefresh())
      return;
    let t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t))
      return;
    const r = this.createChangePath(t.rowNodeTransactions);
    switch (this.isRefreshingModel = !0, t.step) {
      case "group":
        this.doRowGrouping(
          t.rowNodeTransactions,
          t.rowNodeOrder,
          r,
          !!t.afterColumnsChanged
        );
      case "filter":
        this.doFilter(r);
      case "pivot":
        this.doPivot(r);
      case "aggregate":
        this.doAggregate(r);
      case "filter_aggregates":
        this.doFilterAggregates(r);
      case "sort":
        this.doSort(t.rowNodeTransactions, r);
      case "map":
        this.doRowsToDisplay();
    }
    const i = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(r, i), this.isRefreshingModel = !1;
    const n = {
      type: A.EVENT_MODEL_UPDATED,
      animate: t.animate,
      keepRenderedRows: t.keepRenderedRows,
      newData: t.newData,
      newPage: !1,
      keepUndoRedoStack: t.keepUndoRedoStack
    };
    this.eventService.dispatchEvent(n);
  }
  isEmpty() {
    const e = Ae.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return Ae.missing(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return Ae.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let r = !t, i = !1;
    const n = [], o = this.gos.get("groupSelectsChildren");
    return this.forEachNodeAfterFilterAndSort((s) => {
      if (i)
        return;
      if (r && (s === t || s === e) && (i = !0, s.group && o)) {
        n.push(...s.allLeafChildren);
        return;
      }
      if (!r) {
        if (s !== t && s !== e)
          return;
        r = !0;
      }
      if (!s.group || !o) {
        n.push(s);
        return;
      }
    }), n;
  }
  setDatasource(e) {
    console.error("AG Grid: should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0)
      return -1;
    let t = 0, r = this.rowsToDisplay.length - 1;
    if (e <= 0)
      return 0;
    if (Ae.last(this.rowsToDisplay).rowTop <= e)
      return this.rowsToDisplay.length - 1;
    let n = -1, o = -1;
    for (; ; ) {
      const s = Math.floor((t + r) / 2), a = this.rowsToDisplay[s];
      if (this.isRowInPixel(a, e) || (a.rowTop < e ? t = s + 1 : a.rowTop > e && (r = s - 1), n === t && o === r))
        return s;
      n = t, o = r;
    }
  }
  isRowInPixel(e, t) {
    const r = e.rowTop, i = e.rowTop + e.rowHeight;
    return r <= t && i > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, r) => e(t, r));
  }
  forEachNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback: e,
      recursionType: 0,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback: e,
      recursionType: 1,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback: e,
      recursionType: 2,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback: e,
      recursionType: 3,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: r, recursionType: i, includeFooterNodes: n } = e;
    let { index: o } = e;
    const s = (a) => {
      var l;
      const u = (l = t[0]) == null ? void 0 : l.parent;
      if (!u)
        return;
      const c = n && this.gos.getGrandTotalRow(), d = this.gos.getGroupTotalRowCallback(), h = n && d({ node: u });
      if (u === this.rootNode) {
        c === a && (u.createFooter(), r(u.sibling, o++));
        return;
      }
      h === a && (u.createFooter(), r(u.sibling, o++));
    };
    s("top");
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (r(l, o++), l.hasChildren() && !l.footer) {
        let u = null;
        switch (i) {
          case 0:
            u = l.childrenAfterGroup;
            break;
          case 1:
            u = l.childrenAfterAggFilter;
            break;
          case 2:
            u = l.childrenAfterSort;
            break;
          case 3:
            u = l.leafGroup ? null : l.childrenAfterSort;
            break;
        }
        u && (o = this.recursivelyWalkNodesAndCallback({
          nodes: [...u],
          callback: r,
          recursionType: i,
          index: o,
          includeFooterNodes: n
        }));
      }
    }
    return s("bottom"), o;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var t;
    (t = this.aggregationStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  // + gridApi.expandAll()
  // + gridApi.collapseAll()
  expandOrCollapseAll(e) {
    const t = this.gos.get("treeData"), r = this.columnModel.isPivotActive(), i = (s) => {
      s && s.forEach((a) => {
        const l = () => {
          a.expanded = e, i(a.childrenAfterGroup);
        };
        if (t) {
          Ae.exists(a.childrenAfterGroup) && l();
          return;
        }
        if (r) {
          !a.leafGroup && l();
          return;
        }
        a.group && l();
      });
    };
    this.rootNode && i(this.rootNode.childrenAfterGroup), this.refreshModel({
      step: "map"
      /* MAP */
    });
    const n = e ? "expandAll" : "collapseAll", o = {
      type: A.EVENT_EXPAND_COLLAPSE_ALL,
      source: n
    };
    this.eventService.dispatchEvent(o);
  }
  doSort(e, t) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions: e,
      changedPath: t
    });
  }
  doRowGrouping(e, t, r, i) {
    if (this.groupStage) {
      if (e ? this.groupStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: e,
        rowNodeOrder: t,
        changedPath: r
      }) : this.groupStage.execute({
        rowNode: this.rootNode,
        changedPath: r,
        afterColumnsChanged: i
      }), this.gos.get("groupSelectsChildren") && this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", r)) {
        const o = {
          type: A.EVENT_SELECTION_CHANGED,
          source: "rowGroupChanged"
        };
        this.eventService.dispatchEvent(o);
      }
    } else
      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren, this.rootNode.sibling && (this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup), this.rootNode.updateHasChildren();
    this.nodeManager.isRowCountReady() && (this.rowCountReady = !0, this.eventService.dispatchEventOnce({
      type: A.EVENT_ROW_COUNT_READY
    }));
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getCopyOfNodesMap() {
    return this.nodeManager.getCopyOfNodesMap();
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Ve.ID_PREFIX_ROW_GROUP) == 0) {
      let r;
      return this.forEachNode((i) => {
        i.id === e && (r = i);
      }), r;
    }
    return this.nodeManager.getRowNode(e);
  }
  // rows: the rows to put into the model
  setRowData(e) {
    this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh();
  }
  dispatchUpdateEventsAndRefresh() {
    const e = {
      type: A.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(e), this.refreshModel({
      step: "group",
      newData: !0
    });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const r = this.gos.getAsyncTransactionWaitMillis();
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.executeBatchUpdateRowData();
      }, r);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let r = !1;
    if (this.rowDataTransactionBatch && this.rowDataTransactionBatch.forEach((i) => {
      const n = this.nodeManager.updateRowData(i.rowDataTransaction, void 0);
      t.push(n), i.callback && e.push(i.callback.bind(null, n)), typeof i.rowDataTransaction.addIndex == "number" && (r = !0);
    }), this.commonUpdateRowData(t, void 0, r), e.length > 0 && window.setTimeout(() => {
      e.forEach((i) => i());
    }, 0), t.length > 0) {
      const i = {
        type: A.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
        results: t
      };
      this.eventService.dispatchEvent(i);
    }
    this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(e, t) {
    this.valueCache.onDataChanged();
    const r = this.nodeManager.updateRowData(e, t), i = typeof e.addIndex == "number";
    return this.commonUpdateRowData([r], t, i), r;
  }
  createRowNodeOrder() {
    if (this.gos.get("suppressMaintainUnsortedOrder"))
      return;
    const t = {};
    if (this.rootNode && this.rootNode.allLeafChildren)
      for (let r = 0; r < this.rootNode.allLeafChildren.length; r++) {
        const i = this.rootNode.allLeafChildren[r];
        t[i.id] = r;
      }
    return t;
  }
  // common to updateRowData and batchUpdateRowData
  commonUpdateRowData(e, t, r) {
    if (!this.hasStarted)
      return;
    const i = !this.gos.get("suppressAnimationFrame");
    r && (t = this.createRowNodeOrder());
    const n = {
      type: A.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(n), this.refreshModel({
      step: "group",
      rowNodeTransactions: e,
      rowNodeOrder: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: i
    });
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({ step: "map", keepRenderedRows: !0, keepEditingRows: !0, keepUndoRedoStack: !0 });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, !0), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const r = t.detailNode;
      r && r.setRowHeight(r.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges() {
    this.columnModel.isAutoRowHeightActive() || this.resetRowHeights();
  }
  onGridReady() {
    this.hasStarted || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
};
v([
  T("columnModel")
], Br.prototype, "columnModel", 2);
v([
  T("selectionService")
], Br.prototype, "selectionService", 2);
v([
  T("valueCache")
], Br.prototype, "valueCache", 2);
v([
  T("beans")
], Br.prototype, "beans", 2);
v([
  T("filterStage")
], Br.prototype, "filterStage", 2);
v([
  T("sortStage")
], Br.prototype, "sortStage", 2);
v([
  T("flattenStage")
], Br.prototype, "flattenStage", 2);
v([
  Qe("groupStage")
], Br.prototype, "groupStage", 2);
v([
  Qe("aggregationStage")
], Br.prototype, "aggregationStage", 2);
v([
  Qe("pivotStage")
], Br.prototype, "pivotStage", 2);
v([
  Qe("filterAggregatesStage")
], Br.prototype, "filterAggregatesStage", 2);
v([
  te
], Br.prototype, "init", 1);
Br = v([
  de("rowModel")
], Br);
var yg = class extends Q {
  execute(e) {
    const { changedPath: t } = e;
    this.filterService.filter(t);
  }
};
v([
  T("filterService")
], yg.prototype, "filterService", 2);
yg = v([
  de("filterStage")
], yg);
var Kd = class extends Q {
  execute(e) {
    const t = this.sortController.getSortOptions(), r = Ae.exists(t) && t.length > 0, i = r && Ae.exists(e.rowNodeTransactions) && this.gos.get("deltaSort"), n = t.some((o) => this.gos.isColumnsSortingCoupledToGroup() ? o.column.isPrimary() && o.column.isRowGroupActive() : !!o.column.getColDef().showRowGroup);
    this.sortService.sort(t, r, i, e.rowNodeTransactions, e.changedPath, n);
  }
};
v([
  T("sortService")
], Kd.prototype, "sortService", 2);
v([
  T("sortController")
], Kd.prototype, "sortController", 2);
Kd = v([
  de("sortStage")
], Kd);
var bg = class extends Q {
  execute(e) {
    const t = e.rowNode, r = [], i = this.beans.columnModel.isPivotMode(), n = i && t.leafGroup, o = n ? [t] : t.childrenAfterSort, s = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(s, o, r, i, 0);
    const a = r.length > 0;
    if (!n && a && s.grandTotalRow) {
      t.createFooter();
      const u = s.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(s, t.sibling, r, 0, u);
    }
    return r;
  }
  getFlattenDetails() {
    const e = this.gos.get("groupRemoveSingleChildren");
    return {
      groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"),
      groupRemoveSingleChildren: e,
      isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
      hideOpenParents: this.gos.get("groupHideOpenParents"),
      grandTotalRow: this.gos.getGrandTotalRow(),
      groupTotalRow: this.gos.getGroupTotalRowCallback()
    };
  }
  recursivelyAddToRowsToDisplay(e, t, r, i, n) {
    if (!Ae.missingOrEmpty(t))
      for (let o = 0; o < t.length; o++) {
        const s = t[o], a = s.hasChildren(), l = i && !a, u = e.groupRemoveSingleChildren && a && s.childrenAfterGroup.length === 1, c = e.groupRemoveLowestSingleChildren && a && s.leafGroup && s.childrenAfterGroup.length === 1, d = i && s.leafGroup, h = e.hideOpenParents && s.expanded && !s.master && !d;
        if (!l && !h && !u && !c && this.addRowNodeToRowsToDisplay(e, s, r, n), !(i && s.leafGroup)) {
          if (a) {
            const g = u || c;
            if (s.expanded || g) {
              const m = e.groupTotalRow({ node: s });
              m || s.destroyFooter();
              const f = g ? n : n + 1;
              m === "top" && (s.createFooter(), this.addRowNodeToRowsToDisplay(e, s.sibling, r, f)), this.recursivelyAddToRowsToDisplay(
                e,
                s.childrenAfterSort,
                r,
                i,
                f
              ), m === "bottom" && (s.createFooter(), this.addRowNodeToRowsToDisplay(e, s.sibling, r, f));
            }
          } else if (s.master && s.expanded) {
            const g = this.createDetailNode(s);
            this.addRowNodeToRowsToDisplay(e, g, r, n);
          }
        }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, r, i, n) {
    n ? r.unshift(t) : r.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : i);
  }
  createDetailNode(e) {
    if (Ae.exists(e.detailNode))
      return e.detailNode;
    const t = new Ve(this.beans);
    return t.detail = !0, t.selectable = !1, t.parent = e, Ae.exists(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
};
v([
  T("beans")
], bg.prototype, "beans", 2);
bg = v([
  de("flattenStage")
], bg);
var qd = class extends Q {
  sort(e, t, r, i, n, o) {
    const s = this.gos.get("groupMaintainOrder"), a = this.columnModel.getAllGridColumns().some((h) => h.isRowGroupActive());
    let l = {};
    r && i && (l = this.calculateDirtyNodes(i));
    const u = this.columnModel.isPivotMode(), c = this.gos.getCallback("postSortRows"), d = (h) => {
      var p;
      this.pullDownGroupDataForHideOpenParents(h.childrenAfterAggFilter, !0);
      const g = u && h.leafGroup;
      if (s && a && !h.leafGroup && !o) {
        const f = (p = this.columnModel.getRowGroupColumns()) == null ? void 0 : p[h.level + 1], C = (f == null ? void 0 : f.getSort()) === null, w = h.childrenAfterAggFilter.slice(0);
        if (h.childrenAfterSort && !C) {
          const E = {};
          h.childrenAfterSort.forEach((b, y) => {
            E[b.id] = y;
          }), w.sort((b, y) => {
            var S, x;
            return ((S = E[b.id]) != null ? S : 0) - ((x = E[y.id]) != null ? x : 0);
          });
        }
        h.childrenAfterSort = w;
      } else !t || g ? h.childrenAfterSort = h.childrenAfterAggFilter.slice(0) : r ? h.childrenAfterSort = this.doDeltaSort(h, l, n, e) : h.childrenAfterSort = this.rowNodeSorter.doFullSort(h.childrenAfterAggFilter, e);
      if (h.sibling && (h.sibling.childrenAfterSort = h.childrenAfterSort), this.updateChildIndexes(h), c) {
        const f = { nodes: h.childrenAfterSort };
        c(f);
      }
    };
    n && n.forEachChangedNodeDepthFirst(d), this.updateGroupDataForHideOpenParents(n);
  }
  calculateDirtyNodes(e) {
    const t = {}, r = (i) => {
      i && i.forEach((n) => t[n.id] = !0);
    };
    return e && e.forEach((i) => {
      r(i.add), r(i.update), r(i.remove);
    }), t;
  }
  doDeltaSort(e, t, r, i) {
    const n = e.childrenAfterAggFilter, o = e.childrenAfterSort;
    if (!o)
      return this.rowNodeSorter.doFullSort(n, i);
    const s = {}, a = [];
    n.forEach((d) => {
      t[d.id] || !r.canSkip(d) ? a.push(d) : s[d.id] = !0;
    });
    const l = o.filter((d) => s[d.id]), u = (d, h) => ({ currentPos: h, rowNode: d }), c = a.map(u).sort((d, h) => this.rowNodeSorter.compareRowNodes(i, d, h));
    return this.mergeSortedArrays(
      i,
      c,
      l.map(u)
    ).map(({ rowNode: d }) => d);
  }
  // Merge two sorted arrays into each other
  mergeSortedArrays(e, t, r) {
    const i = [];
    let n = 0, o = 0;
    for (; n < t.length && o < r.length; )
      this.rowNodeSorter.compareRowNodes(e, t[n], r[o]) < 0 ? i.push(t[n++]) : i.push(r[o++]);
    for (; n < t.length; )
      i.push(t[n++]);
    for (; o < r.length; )
      i.push(r[o++]);
    return i;
  }
  updateChildIndexes(e) {
    if (Ae.missing(e.childrenAfterSort))
      return;
    const t = e.childrenAfterSort;
    for (let r = 0; r < t.length; r++) {
      const i = t[r], n = r === 0, o = r === e.childrenAfterSort.length - 1;
      i.setFirstChild(n), i.setLastChild(o), i.setChildIndex(r);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents"))
      return;
    if (this.gos.get("treeData"))
      return Ae.warnOnce("The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."), !1;
    const t = (r) => {
      this.pullDownGroupDataForHideOpenParents(r.childrenAfterSort, !1), r.childrenAfterSort.forEach((i) => {
        i.hasChildren() && t(i);
      });
    };
    e && e.executeFromRootNode((r) => t(r));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gos.get("groupHideOpenParents") || Ae.missing(e) || e.forEach((r) => {
      this.columnModel.getGroupDisplayColumns().forEach((n) => {
        const o = n.getColDef().showRowGroup;
        if (typeof o != "string") {
          console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
          return;
        }
        const s = o, a = this.columnModel.getPrimaryColumn(s);
        if (a !== r.rowGroupColumn)
          if (t)
            r.setGroupValue(n.getId(), void 0);
          else {
            const u = r.getFirstChildOfFirstChild(a);
            u && r.setGroupValue(n.getId(), u.key);
          }
      });
    });
  }
};
v([
  T("columnModel")
], qd.prototype, "columnModel", 2);
v([
  T("rowNodeSorter")
], qd.prototype, "rowNodeSorter", 2);
qd = v([
  de("sortService")
], qd);
var wg = class extends Q {
  filter(e) {
    const t = this.filterManager.isChildFilterPresent();
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const r = (i, n) => {
      i.hasChildren() && e && !n ? i.childrenAfterFilter = i.childrenAfterGroup.filter((o) => {
        const s = o.childrenAfterFilter && o.childrenAfterFilter.length > 0, a = o.data && this.filterManager.doesRowPassFilter({ rowNode: o });
        return s || a;
      }) : i.childrenAfterFilter = i.childrenAfterGroup, i.sibling && (i.sibling.childrenAfterFilter = i.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const i = (o, s) => {
        if (o.childrenAfterGroup)
          for (let a = 0; a < o.childrenAfterGroup.length; a++) {
            const l = o.childrenAfterGroup[a], u = s || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? i(o.childrenAfterGroup[a], u) : r(l, u);
          }
        r(o, s);
      }, n = (o) => i(o, !1);
      t.executeFromRootNode(n);
    } else {
      const i = (n) => r(n, !1);
      t.forEachChangedNodeDepthFirst(i, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
};
v([
  T("filterManager")
], wg.prototype, "filterManager", 2);
wg = v([
  de("filterService")
], wg);
var Ca = class extends Q {
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()));
  }
  isActive() {
    const e = this.gos.exists("getRowId");
    return this.gos.get("resetRowDataOnUpdate") ? !1 : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t)
      return;
    const [r, i] = t;
    this.clientSideRowModel.updateRowData(r, i);
  }
  // converts the setRowData() command to a transaction
  createTransactionForRowData(e) {
    if (Ae.missing(this.clientSideRowModel)) {
      console.error("AG Grid: ImmutableService only works with ClientSideRowModel");
      return;
    }
    const t = this.gos.getCallback("getRowId");
    if (t == null) {
      console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
      return;
    }
    const r = {
      remove: [],
      update: [],
      add: []
    }, i = this.clientSideRowModel.getCopyOfNodesMap(), o = this.gos.get("suppressMaintainUnsortedOrder") ? void 0 : {};
    return Ae.exists(e) && e.forEach((s, a) => {
      const l = t({ data: s, level: 0 }), u = i[l];
      o && (o[l] = a), u ? (u.data !== s && r.update.push(s), i[l] = void 0) : r.add.push(s);
    }), Ae.iterateObject(i, (s, a) => {
      a && r.remove.push(a.data);
    }), [r, o];
  }
  onRowDataUpdated() {
    const e = this.gos.get("rowData");
    e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)));
  }
};
v([
  T("rowModel")
], Ca.prototype, "rowModel", 2);
v([
  T("rowRenderer")
], Ca.prototype, "rowRenderer", 2);
v([
  T("selectionService")
], Ca.prototype, "selectionService", 2);
v([
  te
], Ca.prototype, "postConstruct", 1);
Ca = v([
  de("immutableService")
], Ca);
var xae = "31.3.4", Aae = {
  version: xae,
  moduleName: "@ag-grid-community/client-side-row-model",
  rowModel: "clientSide",
  beans: [Br, yg, Kd, bg, qd, wg, Ca]
}, Dae = Object.defineProperty, Tae = Object.getOwnPropertyDescriptor, Ur = (e, t, r, i) => {
  for (var n = i > 1 ? void 0 : i ? Tae(t, r) : t, o = e.length - 1, s; o >= 0; o--)
    (s = e[o]) && (n = (i ? s(t, r, n) : s(n)) || n);
  return i && n && Dae(t, r, n), n;
}, Rae = (e, t) => (r, i) => t(r, i, e), Zd = class extends Yb {
  constructor(e, t, r) {
    super(e), this.parentCache = t, this.params = r, this.startRow = e * r.blockSize, this.endRow = this.startRow + r.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(e, t, r) {
    Ae.exists(t) ? e.setDataAndId(t, r.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (Ae.missing(this.params.datasource.getRows)) {
      console.warn("AG Grid: datasource is missing getRows method");
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    return {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gos.getGridCommonParams().context
    };
  }
  forEachNode(e, t, r) {
    this.rowNodes.forEach((i, n) => {
      this.startRow + n < r && e(i, t.next());
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.next());
    const r = e - this.startRow;
    return this.rowNodes[r];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  // creates empty row nodes, data is missing as not loaded yet
  createRowNodes() {
    this.rowNodes = [];
    for (let e = 0; e < this.params.blockSize; e++) {
      const t = this.startRow + e, r = new Ve(this.beans);
      r.setRowHeight(this.params.rowHeight), r.uiLevel = 0, r.setRowIndex(t), r.setRowTop(this.params.rowHeight * t), this.rowNodes.push(r);
    }
  }
  processServerResult(e) {
    this.rowNodes.forEach((r, i) => {
      const n = e.rowData ? e.rowData[i] : void 0;
      !r.id && r.alreadyRendered && n && (this.rowNodes[i] = new Ve(this.beans), this.rowNodes[i].setRowIndex(r.rowIndex), this.rowNodes[i].setRowTop(r.rowTop), this.rowNodes[i].setRowHeight(r.rowHeight), r.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[i], n, this.startRow + i);
    });
    const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, t);
  }
  destroyRowNodes() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    });
  }
};
Ur([
  T("beans")
], Zd.prototype, "beans", 2);
Ur([
  te
], Zd.prototype, "postConstruct", 1);
Ur([
  jr
], Zd.prototype, "destroyRowNodes", 1);
var Ju = class oL extends Q {
  constructor(t) {
    super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = t.initialRowCount, this.params = t;
  }
  setBeans(t) {
    this.logger = t.create("InfiniteCache");
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(t, r = !1) {
    const i = Math.floor(t / this.params.blockSize);
    let n = this.blocks[i];
    if (!n) {
      if (r)
        return;
      n = this.createBlock(i);
    }
    return n.getRow(t);
  }
  createBlock(t) {
    const r = this.createBean(new Zd(t, this, this.params));
    return this.blocks[r.getId()] = r, this.blockCount++, this.purgeBlocksIfNeeded(r), this.params.rowNodeBlockLoader.addBlock(r), r;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((r) => r.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroyAllBlocks() {
    this.getBlocksInOrder().forEach((t) => this.destroyBlock(t));
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(t, r) {
    this.isAlive() && (this.logger.log(`onPageLoaded: page = ${t.getId()}, lastRow = ${r}`), this.checkRowCount(t, r), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(t) {
    const r = this.getBlocksInOrder().filter((a) => a != t), i = (a, l) => l.getLastAccessed() - a.getLastAccessed();
    r.sort(i);
    const n = this.params.maxBlocksInCache > 0, o = n ? this.params.maxBlocksInCache - 1 : null, s = oL.MAX_EMPTY_BLOCKS_TO_KEEP - 1;
    r.forEach((a, l) => {
      const u = a.getState() === Zd.STATE_WAITING_TO_LOAD && l >= s, c = n ? l >= o : !1;
      if (u || c) {
        if (this.isBlockCurrentlyDisplayed(a) || this.isBlockFocused(a))
          return;
        this.removeBlockFromCache(a);
      }
    });
  }
  isBlockFocused(t) {
    const r = this.focusService.getFocusCellToUseAfterRefresh();
    if (!r || r.rowPinned != null)
      return !1;
    const i = t.getStartRow(), n = t.getEndRow();
    return r.rowIndex >= i && r.rowIndex < n;
  }
  isBlockCurrentlyDisplayed(t) {
    const r = t.getStartRow(), i = t.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(r, i);
  }
  removeBlockFromCache(t) {
    t && this.destroyBlock(t);
  }
  checkRowCount(t, r) {
    if (typeof r == "number" && r >= 0)
      this.rowCount = r, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const n = (t.getId() + 1) * this.params.blockSize + this.params.overflowSize;
      this.rowCount < n && (this.rowCount = n);
    }
  }
  setRowCount(t, r) {
    this.rowCount = t, Ae.exists(r) && (this.lastRowIndexKnown = r), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(t) {
    const r = new Ql();
    this.getBlocksInOrder().forEach((i) => i.forEachNode(t, r, this.rowCount));
  }
  getBlocksInOrder() {
    const t = (i, n) => i.getId() - n.getId();
    return Ae.getAllValuesInObject(this.blocks).sort(t);
  }
  destroyBlock(t) {
    delete this.blocks[t.getId()], this.destroyBean(t), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(t);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      const t = {
        type: A.EVENT_STORE_UPDATED
      };
      this.eventService.dispatchEvent(t);
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const t = [];
    this.getBlocksInOrder().forEach((r) => {
      r.getId() * this.params.blockSize >= this.rowCount && t.push(r);
    }), t.length > 0 && t.forEach((r) => this.destroyBlock(r));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((t) => this.removeBlockFromCache(t)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(t, r) {
    const i = [];
    let n = -1, o = !1;
    const s = new Ql();
    Ae.missing(t) && (o = !0);
    let a = !1;
    return this.getBlocksInOrder().forEach((u) => {
      if (!a) {
        if (o && n + 1 !== u.getId()) {
          a = !0;
          return;
        }
        n = u.getId(), u.forEachNode((c) => {
          const d = c === t || c === r;
          (o || d) && i.push(c), d && (o = !o);
        }, s, this.rowCount);
      }
    }), a || o ? [] : i;
  }
};
Ju.MAX_EMPTY_BLOCKS_TO_KEEP = 2;
Ur([
  T("rowRenderer")
], Ju.prototype, "rowRenderer", 2);
Ur([
  T("focusService")
], Ju.prototype, "focusService", 2);
Ur([
  Rae(0, Gi("loggerFactory"))
], Ju.prototype, "setBeans", 1);
Ur([
  jr
], Ju.prototype, "destroyAllBlocks", 1);
var Pae = Ju, Yn = class extends Q {
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid(e, t, r, i) {
    return !1;
  }
  init() {
    this.gos.isRowModelType("infinite") && (this.rowHeight = this.gos.getRowHeightAsNumber(), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps());
  }
  verifyProps() {
    this.gos.exists("initialGroupOrderComparator") && Ae.warnOnce("initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side");
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroyDatasource() {
    this.datasource && (this.getContext().destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, A.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, A.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this)), this.addManagedListener(this.eventService, A.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this)), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = this.gos.getRowHeightAsNumber(), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let e;
    this.cacheParams ? e = this.isSortModelDifferent() : e = !0, e && this.reset();
  }
  isSortModelDifferent() {
    return !Ae.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : [];
  }
  reset() {
    if (!this.datasource)
      return;
    this.gos.getCallback("getRowId") != null || this.selectionService.reset("rowDataChanged"), this.resetCache();
  }
  createModelUpdatedEvent() {
    return {
      type: A.EVENT_MODEL_UPDATED,
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    };
  }
  resetCache() {
    this.destroyCache(), this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: this.filterManager.getFilterModel(),
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: this.gos.get("infiniteInitialRowCount"),
      maxBlocksInCache: this.gos.get("maxBlocksInCache"),
      rowHeight: this.gos.getRowHeightAsNumber(),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: this.gos.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: this.gos.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: new Ql()
    }, this.infiniteCache = this.createBean(new Pae(this.cacheParams)), this.eventService.dispatchEventOnce({
      type: A.EVENT_ROW_COUNT_READY
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  updateRowHeights() {
    this.forEachNode((t) => {
      t.setRowHeight(this.rowHeight), t.setRowTop(this.rowHeight * t.rowIndex);
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  destroyCache() {
    this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache));
  }
  onCacheUpdated() {
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  getRow(e) {
    if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
      return this.infiniteCache.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((r) => {
      r.id === e && (t = r);
    }), t;
  }
  forEachNode(e) {
    this.infiniteCache && this.infiniteCache.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), r = this.getRowCount() - 1;
      return t > r ? r : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    this.infiniteCache && this.infiniteCache.refreshCache();
  }
  purgeCache() {
    this.infiniteCache && this.infiniteCache.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1;
  }
  setRowCount(e, t) {
    this.infiniteCache && this.infiniteCache.setRowCount(e, t);
  }
};
Ur([
  T("filterManager")
], Yn.prototype, "filterManager", 2);
Ur([
  T("sortController")
], Yn.prototype, "sortController", 2);
Ur([
  T("selectionService")
], Yn.prototype, "selectionService", 2);
Ur([
  T("rowRenderer")
], Yn.prototype, "rowRenderer", 2);
Ur([
  T("rowNodeBlockLoader")
], Yn.prototype, "rowNodeBlockLoader", 2);
Ur([
  te
], Yn.prototype, "init", 1);
Ur([
  jr
], Yn.prototype, "destroyDatasource", 1);
Yn = Ur([
  de("rowModel")
], Yn);
var Iae = "31.3.4", Oae = {
  version: Iae,
  moduleName: "@ag-grid-community/infinite-row-model",
  rowModel: "infinite",
  beans: [Yn]
}, Mae = Object.defineProperty, Fae = Object.getOwnPropertyDescriptor, li = (e, t, r, i) => {
  for (var n = i > 1 ? void 0 : i ? Fae(t, r) : t, o = e.length - 1, s; o >= 0; o--)
    (s = e[o]) && (n = (i ? s(t, r, n) : s(n)) || n);
  return i && n && Mae(t, r, n), n;
}, _ae = class {
  setBeans(e) {
    this.beans = e;
  }
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, Nae = class {
  constructor(e) {
    this.groupColumns = [];
    const {
      columnModel: t,
      valueService: r,
      gos: i,
      processCellCallback: n,
      processHeaderCallback: o,
      processGroupHeaderCallback: s,
      processRowGroupCallback: a
    } = e;
    this.columnModel = t, this.valueService = r, this.gos = i, this.processCellCallback = n, this.processHeaderCallback = o, this.processGroupHeaderCallback = s, this.processRowGroupCallback = a;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    const t = this.getHeaderName(this.processHeaderCallback, e);
    return t ?? "";
  }
  extractRowCellValue(e, t, r, i, n) {
    const s = (!this.gos.get("groupHideOpenParents") || n.footer) && this.shouldRenderGroupSummaryCell(n, e, t) ? this.createValueForGroupNode(e, n) : this.valueService.getValue(e, n);
    return this.processCell({
      accumulatedRowIndex: r,
      rowNode: n,
      column: e,
      value: s,
      processCellCallback: this.processCellCallback,
      type: i
    });
  }
  shouldRenderGroupSummaryCell(e, t, r) {
    var i;
    if (!(e && e.group))
      return !1;
    if (this.groupColumns.indexOf(t) !== -1) {
      if (((i = e.groupData) == null ? void 0 : i[t.getId()]) != null || this.gos.isRowModelType("serverSide") && e.group)
        return !0;
      if (e.footer && e.level === -1) {
        const a = t.getColDef();
        return a == null || a.showRowGroup === !0 || a.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId();
      }
    }
    const s = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
    return r === 0 && s;
  }
  getHeaderName(e, t) {
    return e ? e(this.gos.addGridCommonParams({ column: t })) : this.columnModel.getDisplayNameForColumn(t, "csv", !0);
  }
  createValueForGroupNode(e, t) {
    if (this.processRowGroupCallback)
      return this.processRowGroupCallback(this.gos.addGridCommonParams({ column: e, node: t }));
    const r = this.gos.get("treeData"), i = this.gos.get("suppressGroupMaintainValueType"), n = (l) => {
      var u, c;
      if (r || i)
        return l.key;
      const d = (u = l.groupData) == null ? void 0 : u[e.getId()];
      return !d || !l.rowGroupColumn || l.rowGroupColumn.getColDef().useValueFormatterForExport === !1 ? d : (c = this.valueService.formatValue(l.rowGroupColumn, l, d)) != null ? c : d;
    }, o = t.footer, s = [n(t)];
    if (!this.gos.isGroupMultiAutoColumn())
      for (; t.parent; )
        t = t.parent, s.push(n(t));
    const a = s.reverse().join(" -> ");
    return o ? `Total ${a}` : a;
  }
  processCell(e) {
    var t;
    const { accumulatedRowIndex: r, rowNode: i, column: n, value: o, processCellCallback: s, type: a } = e;
    return s ? {
      value: (t = s(this.gos.addGridCommonParams({
        accumulatedRowIndex: r,
        column: n,
        node: i,
        value: o,
        type: a,
        parseValue: (l) => this.valueService.parseValue(n, i, l, this.valueService.getValue(n, i)),
        formatValue: (l) => {
          var u;
          return (u = this.valueService.formatValue(n, i, l)) != null ? u : l;
        }
      }))) != null ? t : ""
    } : n.getColDef().useValueFormatterForExport !== !1 ? {
      value: o ?? "",
      valueFormatted: this.valueService.formatValue(n, i, o)
    } : { value: o ?? "" };
  }
}, Lae = class {
  static download(e, t) {
    const r = document.defaultView || window;
    if (!r) {
      console.warn("AG Grid: There is no `window` associated with the current `document`");
      return;
    }
    const i = document.createElement("a"), n = r.URL.createObjectURL(t);
    i.setAttribute("href", n), i.setAttribute("download", e), i.style.display = "none", document.body.appendChild(i), i.dispatchEvent(new MouseEvent("click", {
      bubbles: !1,
      cancelable: !0,
      view: r
    })), document.body.removeChild(i), r.setTimeout(() => {
      r.URL.revokeObjectURL(n);
    }, 0);
  }
}, qT = `\r
`, Gae = class extends Nae {
  constructor(e) {
    super(e), this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: r } = e;
    this.suppressQuotes = t, this.columnSeparator = r;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, qT), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((r, i) => {
        i !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(r.data.value || ""), r.mergeAcross && this.appendEmptyCells(r.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, r, i) {
    r != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(i);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, r) {
    var i;
    t != 0 && (this.result += this.columnSeparator);
    const n = this.extractRowCellValue(e, t, t, "csv", r);
    this.result += this.putInQuotes((i = n.valueFormatted) != null ? i : n.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (console.warn("AG Grid: unknown value type during csv conversion"), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += qT), this.isFirstLine = !1;
  }
}, ts = class extends _ae {
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gos: this.gos
    });
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      console.warn("AG Grid: Export cancelled. Export is not allowed as per your configuration.");
      return;
    }
    const t = this.getMergedParams(e), r = this.getData(t), i = new Blob(["\uFEFF", r], { type: "text/plain" }), n = typeof t.fileName == "function" ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
    Lae.download(this.getFileName(n), i);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const r = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(r);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { columnModel: t, valueService: r, gos: i } = this, {
      processCellCallback: n,
      processHeaderCallback: o,
      processGroupHeaderCallback: s,
      processRowGroupCallback: a,
      suppressQuotes: l,
      columnSeparator: u
    } = e;
    return new Gae({
      columnModel: t,
      valueService: r,
      gos: i,
      processCellCallback: n || void 0,
      processHeaderCallback: o || void 0,
      processGroupHeaderCallback: s || void 0,
      processRowGroupCallback: a || void 0,
      suppressQuotes: l || !1,
      columnSeparator: u || ","
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
li([
  T("columnModel")
], ts.prototype, "columnModel", 2);
li([
  T("valueService")
], ts.prototype, "valueService", 2);
li([
  T("gridSerializer")
], ts.prototype, "gridSerializer", 2);
li([
  T("gridOptionsService")
], ts.prototype, "gos", 2);
li([
  te
], ts.prototype, "postConstruct", 1);
ts = li([
  de("csvCreator")
], ts);
var Xn = class extends Q {
  serialize(e, t = {}) {
    const { allColumns: r, columnKeys: i, skipRowGroups: n } = t, o = this.getColumnsToExport(r, n, i);
    return Ae.compose(
      // first pass, put in the header names of the cols
      this.prepareSession(o),
      this.prependContent(t),
      this.exportColumnGroups(t, o),
      this.exportHeaders(t, o),
      this.processPinnedTopRows(t, o),
      this.processRows(t, o),
      this.processPinnedBottomRows(t, o),
      this.appendContent(t)
    )(e).parse();
  }
  processRow(e, t, r, i) {
    const n = t.shouldRowBeSkipped || (() => !1), o = this.gos.get("groupRemoveSingleChildren"), s = this.gos.get("groupRemoveLowestSingleChildren"), l = t.rowPositions != null || !!t.onlySelected, u = this.gos.get("groupHideOpenParents") && !l, c = this.columnModel.isPivotMode() ? i.leafGroup : !i.group, d = !!i.footer;
    t.skipRowGroups;
    const h = s && i.leafGroup, p = i.allChildrenCount === 1 && (o || h);
    if (!c && !d && (t.skipRowGroups || p || u) || t.onlySelected && !i.isSelected() || t.skipPinnedTop && i.rowPinned === "top" || t.skipPinnedBottom && i.rowPinned === "bottom" || i.level === -1 && !c && !d || n(this.gos.addGridCommonParams({ node: i })))
      return;
    const f = e.onNewBodyRow(i);
    if (r.forEach((C, w) => {
      f.onColumn(C, w, i);
    }), t.getCustomContentBelowRow) {
      const C = t.getCustomContentBelowRow(this.gos.addGridCommonParams({ node: i }));
      C && e.addCustomContent(C);
    }
  }
  appendContent(e) {
    return (t) => {
      const r = e.appendContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const r = e.prependContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (r) => {
      if (!e.skipColumnGroupHeaders) {
        const i = new KF(), n = this.displayedGroupCreator.createDisplayedGroups(
          t,
          i,
          null
        );
        this.recursivelyAddHeaderGroups(n, r, e.processGroupHeaderCallback);
      }
      return r;
    };
  }
  exportHeaders(e, t) {
    return (r) => {
      if (!e.skipColumnHeaders) {
        const i = r.onNewHeaderRow();
        t.forEach((n, o) => {
          i.onColumn(n, o, void 0);
        });
      }
      return r;
    };
  }
  processPinnedTopRows(e, t) {
    return (r) => {
      const i = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((n) => n.rowPinned === "top").sort((n, o) => n.rowIndex - o.rowIndex).map((n) => this.pinnedRowModel.getPinnedTopRow(n.rowIndex)).forEach(i) : this.pinnedRowModel.forEachPinnedTopRow(i), r;
    };
  }
  processRows(e, t) {
    return (r) => {
      const i = this.rowModel, n = i.getType(), o = n === "clientSide", s = n === "serverSide", a = !o && e.onlySelected, l = this.processRow.bind(this, r, e, t), {
        exportedRows: u = "filteredAndSorted"
      } = e;
      if (e.rowPositions)
        e.rowPositions.filter((c) => c.rowPinned == null).sort((c, d) => c.rowIndex - d.rowIndex).map((c) => i.getRow(c.rowIndex)).forEach(l);
      else if (this.columnModel.isPivotMode())
        o ? i.forEachPivotNode(l, !0) : s ? i.forEachNodeAfterFilterAndSort(l, !0) : i.forEachNode(l);
      else if (e.onlySelectedAllPages || a) {
        const c = this.selectionService.getSelectedNodes();
        this.replicateSortedOrder(c), c.forEach(l);
      } else
        u === "all" ? i.forEachNode(l) : o || s ? i.forEachNodeAfterFilterAndSort(l, !0) : i.forEachNode(l);
      return r;
    };
  }
  replicateSortedOrder(e) {
    const t = this.sortController.getSortOptions(), r = (i, n) => {
      var o, s, a, l;
      return i.rowIndex != null && n.rowIndex != null ? i.rowIndex - n.rowIndex : i.level === n.level ? ((o = i.parent) == null ? void 0 : o.id) === ((s = n.parent) == null ? void 0 : s.id) ? this.rowNodeSorter.compareRowNodes(t, {
        rowNode: i,
        currentPos: (a = i.rowIndex) != null ? a : -1
      }, {
        rowNode: n,
        currentPos: (l = n.rowIndex) != null ? l : -1
      }) : r(i.parent, n.parent) : i.level > n.level ? r(i.parent, n) : r(i, n.parent);
    };
    e.sort(r);
  }
  processPinnedBottomRows(e, t) {
    return (r) => {
      const i = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((n) => n.rowPinned === "bottom").sort((n, o) => n.rowIndex - o.rowIndex).map((n) => this.pinnedRowModel.getPinnedBottomRow(n.rowIndex)).forEach(i) : this.pinnedRowModel.forEachPinnedBottomRow(i), r;
    };
  }
  getColumnsToExport(e = !1, t = !1, r) {
    const i = this.columnModel.isPivotMode();
    if (r && r.length)
      return this.columnModel.getGridColumns(r);
    const n = this.gos.get("treeData");
    let o = [];
    return e && !i ? o = this.columnModel.getAllGridColumns() : o = this.columnModel.getAllDisplayedColumns(), t && !n && (o = o.filter((s) => s.getColId() !== Kl)), o;
  }
  recursivelyAddHeaderGroups(e, t, r) {
    const i = [];
    e.forEach((n) => {
      const o = n;
      o.getChildren && o.getChildren().forEach((s) => i.push(s));
    }), e.length > 0 && e[0] instanceof ur && this.doAddHeaderHeader(t, e, r), i && i.length > 0 && this.recursivelyAddHeaderGroups(i, t, r);
  }
  doAddHeaderHeader(e, t, r) {
    const i = e.onNewHeaderGroupingRow();
    let n = 0;
    t.forEach((o) => {
      const s = o;
      let a;
      r ? a = r(this.gos.addGridCommonParams({
        columnGroup: s
      })) : a = this.columnModel.getDisplayNameForColumnGroup(s, "header");
      const l = s.getLeafColumns().reduce((u, c, d, h) => {
        let p = Ae.last(u);
        return c.getColumnGroupShow() === "open" ? (!p || p[1] != null) && (p = [d], u.push(p)) : p && p[1] == null && (p[1] = d - 1), d === h.length - 1 && p && p[1] == null && (p[1] = d), u;
      }, []);
      i.onColumn(s, a || "", n++, s.getLeafColumns().length - 1, l);
    });
  }
};
li([
  T("displayedGroupCreator")
], Xn.prototype, "displayedGroupCreator", 2);
li([
  T("columnModel")
], Xn.prototype, "columnModel", 2);
li([
  T("rowModel")
], Xn.prototype, "rowModel", 2);
li([
  T("pinnedRowModel")
], Xn.prototype, "pinnedRowModel", 2);
li([
  T("selectionService")
], Xn.prototype, "selectionService", 2);
li([
  T("rowNodeSorter")
], Xn.prototype, "rowNodeSorter", 2);
li([
  T("sortController")
], Xn.prototype, "sortController", 2);
Xn = li([
  de("gridSerializer")
], Xn);
var kae = "31.3.4", Vae = {
  version: kae,
  moduleName: "@ag-grid-community/csv-export",
  beans: [ts, Xn]
}, { utf8_encode: fbe } = Ae;
Xe.__registerModules([Aae, Oae, Vae], !1, void 0);
var Hae = Object.defineProperty, Bae = Object.defineProperties, Wae = Object.getOwnPropertyDescriptors, ZT = Object.getOwnPropertySymbols, $ae = Object.prototype.hasOwnProperty, jae = Object.prototype.propertyIsEnumerable, JT = (e, t, r) => t in e ? Hae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Mt = (e, t) => {
  for (var r in t || (t = {}))
    $ae.call(t, r) && JT(e, r, t[r]);
  if (ZT)
    for (var r of ZT(t))
      jae.call(t, r) && JT(e, r, t[r]);
  return e;
}, Wr = (e, t) => Bae(e, Wae(t)), NE = Cn({
  setMethods: () => {
  }
}), zae = (e) => {
  const { initialProps: t, addUpdateCallback: r, CustomComponentClass: i, setMethods: n } = e, [o, s] = ee(t);
  return gt(() => {
    r((a) => s(a));
  }, []), /* @__PURE__ */ D.createElement(NE.Provider, { value: { setMethods: n } }, /* @__PURE__ */ D.createElement(i, Mt({}, o)));
}, Uae = $r(zae), Yae = 0;
function QT() {
  return `agPortalKey_${++Yae}`;
}
var sL = class {
  constructor(e, t, r, i) {
    this.portal = null, this.oldPortal = null, this.reactComponent = e, this.portalManager = t, this.componentType = r, this.suppressFallbackMethods = !!i, this.statelessComponent = this.isStateless(this.reactComponent), this.key = QT(), this.portalKey = QT(), this.instanceCreated = this.isStatelessComponent() ? qt.resolve(!1) : new qt((n) => {
      this.resolveInstanceCreated = n;
    });
  }
  getGui() {
    return this.eParentElement;
  }
  /** `getGui()` returns the parent element. This returns the actual root element. */
  getRootElement() {
    return this.eParentElement.firstChild;
  }
  destroy() {
    return this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy(), this.portalManager.destroyPortal(this.portal);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), r = document.createElement(t || "div");
    return r.classList.add("ag-react-container"), e.reactContainer = r, r;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && (Ae.warnOnce('Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.'), Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle())), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && (Ae.warnOnce('Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.'), this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t))));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] != null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const r = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!r) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const i = r[e];
    if (i)
      return i.apply(r, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.params = e, this.createOrUpdatePortal(e), new qt((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (this.ref = (t) => {
      var r;
      this.componentInstance = t, this.addParentContainerStyleAndClasses(), (r = this.resolveInstanceCreated) == null || r.call(this, !0), this.resolveInstanceCreated = void 0;
    }, e.ref = this.ref), this.reactElement = this.createElement(this.reactComponent, Wr(Mt({}, e), { key: this.key })), this.portal = xa(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createElement(e, t) {
    return zc(e, t);
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, (t) => {
      e(t);
    });
  }
  isNullValue() {
    return this.valueRenderedIsNull(this.params);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  valueRenderedIsNull(e) {
    if (!this.componentType.cellRenderer)
      return !1;
    const t = console.error;
    try {
      return console.error = () => {
      }, D1(zc(this.reactComponent, e)) === "";
    } catch {
    } finally {
      console.error = t;
    }
    return !1;
  }
  /*
  * fallback methods - these will be invoked if a corresponding instance method is not present
  * for example if refresh is called and is not available on the component instance, then refreshComponent on this
  * class will be invoked instead
  *
  * Currently only refresh is supported
  */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const r = this[`${e}Component`];
    if (!this.suppressFallbackMethods && r)
      return r.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? !1 : !!this[`${e}Component`];
  }
};
function LE(e, t, r) {
  e.forEach((i) => {
    const n = t[i];
    n && (r[i] = n);
  });
}
var vs = class extends sL {
  constructor() {
    super(...arguments), this.awaitUpdateCallback = new qt((e) => {
      this.resolveUpdateCallback = e;
    }), this.wrapperComponent = Uae;
  }
  init(e) {
    return this.sourceParams = e, super.init(this.getProps());
  }
  addMethod() {
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  getFrameworkComponentInstance() {
    return this;
  }
  createElement(e, t) {
    return super.createElement(this.wrapperComponent, {
      initialProps: t,
      CustomComponentClass: e,
      setMethods: (r) => this.setMethods(r),
      addUpdateCallback: (r) => {
        this.updateCallback = () => (r(this.getProps()), new qt((i) => {
          setTimeout(() => {
            i();
          });
        })), this.resolveUpdateCallback();
      }
    });
  }
  setMethods(e) {
    this.providedMethods = e, LE(this.getOptionalMethods(), this.providedMethods, this);
  }
  getOptionalMethods() {
    return [];
  }
  getProps() {
    return Wr(Mt({}, this.sourceParams), {
      key: this.key,
      ref: this.ref
    });
  }
  refreshProps() {
    return this.updateCallback ? this.updateCallback() : new qt((e) => this.awaitUpdateCallback.then(() => {
      this.updateCallback().then(() => e());
    }));
  }
}, Xae = class extends vs {
  constructor() {
    super(...arguments), this.date = null, this.onDateChange = (e) => this.updateDate(e);
  }
  getDate() {
    return this.date;
  }
  setDate(e) {
    this.date = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled"];
  }
  updateDate(e) {
    this.setDate(e), this.sourceParams.onDateChanged();
  }
  getProps() {
    const e = super.getProps();
    return e.date = this.date, e.onDateChange = this.onDateChange, delete e.onDateChanged, e;
  }
}, Kae = class extends vs {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e), this.onUiChange = () => this.sourceParams.filterChangedCallback();
  }
  isFilterActive() {
    return this.model != null;
  }
  doesFilterPass(e) {
    return this.providedMethods.doesFilterPass(e);
  }
  getModel() {
    return this.model;
  }
  setModel(e) {
    return this.model = e, this.refreshProps();
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onAnyFilterChanged"];
  }
  updateModel(e) {
    this.setModel(e).then(() => this.sourceParams.filterChangedCallback());
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e.onUiChange = this.onUiChange, delete e.filterChangedCallback, delete e.filterModifiedCallback, delete e.valueGetter, e;
  }
};
function aL(e, t) {
  e.parentFilterInstance((r) => {
    (r.setModel(t) || qt.resolve()).then(() => {
      e.filterParams.filterChangedCallback();
    });
  });
}
var qae = class {
  constructor(e, t) {
    this.floatingFilterParams = e, this.refreshProps = t, this.model = null, this.onModelChange = (r) => this.updateModel(r);
  }
  getProps() {
    return Wr(Mt({}, this.floatingFilterParams), {
      model: this.model,
      onModelChange: this.onModelChange
    });
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.floatingFilterParams = e, this.refreshProps();
  }
  setMethods(e) {
    LE(this.getOptionalMethods(), e, this);
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), aL(this.floatingFilterParams, e);
  }
}, Zae = class extends vs {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e);
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), aL(this.sourceParams, e);
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e;
  }
}, Jae = class extends vs {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, Qae = class extends vs {
  constructor() {
    super(...arguments), this.active = !1, this.expanded = !1, this.onActiveChange = (e) => this.updateActive(e);
  }
  setActive(e) {
    this.awaitSetActive(e);
  }
  setExpanded(e) {
    this.expanded = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["select", "configureDefaults"];
  }
  awaitSetActive(e) {
    return this.active = e, this.refreshProps();
  }
  updateActive(e) {
    const t = this.awaitSetActive(e);
    e && t.then(() => this.sourceParams.onItemActivated());
  }
  getProps() {
    const e = super.getProps();
    return e.active = this.active, e.expanded = this.expanded, e.onActiveChange = this.onActiveChange, delete e.onItemActivated, e;
  }
}, ele = class extends vs {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, tle = class extends vs {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, rle = class extends vs {
  constructor() {
    super(...arguments), this.onStateChange = (e) => this.updateState(e);
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getState() {
    return this.state;
  }
  updateState(e) {
    this.state = e, this.refreshProps(), this.sourceParams.onStateUpdated();
  }
  getProps() {
    const e = super.getProps();
    return e.state = this.state, e.onStateChange = this.onStateChange, e;
  }
}, lL = class uL {
  constructor(t, r, i) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = r || "div", this.refresher = t, this.maxComponentCreationTimeMs = i || uL.MAX_COMPONENT_CREATION_TIME_IN_MS;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(t) {
    this.portals = this.portals.filter((r) => r !== t), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(t, r, i) {
    this.portals = [...this.portals, t], this.waitForInstance(r, i), this.batchUpdate();
  }
  updateReactPortal(t, r) {
    this.portals[this.portals.indexOf(t)] = r, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || (this.refresher(), this.hasPendingPortalUpdate = !1);
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(t, r, i = Date.now()) {
    if (this.destroyed) {
      r(null);
      return;
    }
    if (t.rendered())
      r(t);
    else {
      if (Date.now() - i >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {
        if (t.isNullValue()) {
          r(t);
          return;
        }
        console.error(`AG Grid: React Component '${t.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms.`), console.error("    If the component is using `forwardRef` but not `useImperativeHandle`, add the following: `useImperativeHandle(ref, () => ({}));`");
        return;
      }
      window.setTimeout(() => {
        this.waitForInstance(t, r, i);
      });
    }
  }
};
lL.MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
var ile = lL, Yr = D.createContext({}), on = (...e) => e.filter((r) => r != null && r !== "").join(" "), ki = class cL {
  constructor(...t) {
    this.classesMap = {}, t.forEach((r) => {
      this.classesMap[r] = !0;
    });
  }
  setClass(t, r) {
    if (!!this.classesMap[t] == r)
      return this;
    const n = new cL();
    return n.classesMap = Mt({}, this.classesMap), n.classesMap[t] = r, n;
  }
  toString() {
    return Object.keys(this.classesMap).filter((r) => this.classesMap[r]).join(" ");
  }
}, Qu = (e) => {
  const t = () => typeof Symbol == "function" && Symbol.for, r = () => t() ? Symbol.for("react.memo") : 60115;
  return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === r();
}, nle = qp.createRoot != null && qp.flushSync != null, Lp = !1;
function ole(e) {
  return Lp || setTimeout(() => Lp = !1, 0), Lp = !0, e();
}
var GE = (e, t) => {
  nle && e && !Lp ? qp.flushSync(t) : t();
};
function kE(e, t, r) {
  if (t == null || e == null)
    return t;
  if (e === t || t.length === 0 && e.length === 0)
    return e;
  if (r || e.length === 0 && t.length > 0 || e.length > 0 && t.length === 0)
    return t;
  const i = [], n = [], o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  for (let a = 0; a < t.length; a++) {
    const l = t[a];
    s.set(l.getInstanceId(), l);
  }
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    o.set(l.getInstanceId(), l), s.has(l.getInstanceId()) && i.push(l);
  }
  for (let a = 0; a < t.length; a++) {
    const l = t[a], u = l.getInstanceId();
    o.has(u) || n.push(l);
  }
  return i.length === e.length && n.length === 0 ? e : i.length === 0 && n.length === t.length ? t : i.length === 0 ? n : n.length === 0 ? i : [...i, ...n];
}
var Lh = (e, t, r, i) => {
  if (!e || e.componentFromFramework || t.isDestroyed())
    return;
  const o = e.newAgStackInstance();
  if (!o)
    return;
  let s, a, l = !1;
  return o.then((u) => {
    if (l) {
      t.destroyBean(u);
      return;
    }
    s = u, a = s.getGui(), r.appendChild(a), eR(i, s);
  }), () => {
    l = !0, s && (a && a.parentElement && a.parentElement.removeChild(a), t.destroyBean(s), i && eR(i, void 0));
  };
}, eR = (e, t) => {
  if (e)
    if (e instanceof Function)
      e(t);
    else {
      const r = e;
      r.current = t;
    }
}, sle = (e) => {
  const t = e.newAgStackInstance();
  if (t)
    return t.resolveNow(null, (r) => r);
}, dL = ns((e, t) => {
  var r;
  const i = bt(Yr).context, n = re(null), o = re(null), s = re(null), a = re(null), l = re(null), u = re(), [c, d] = ee(), [h, p] = ee(), [g, m] = ee(), [f, C] = ee(() => new ki()), [w, E] = ee(() => new ki("ag-hidden")), [b, y] = ee(() => new ki("ag-hidden")), [S, x] = ee(() => new ki("ag-invisible"));
  jg(t, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), Vi(() => Lh(c, i, o.current), [c]);
  const R = fe((V) => {
    if (n.current = V, !n.current) {
      i.destroyBean(u.current), u.current = null;
      return;
    }
    const B = {
      setInnerRenderer: ($, L) => {
        d($), m(L);
      },
      setChildCount: ($) => p($),
      addOrRemoveCssClass: ($, L) => C((z) => z.setClass($, L)),
      setContractedDisplayed: ($) => y((L) => L.setClass("ag-hidden", !$)),
      setExpandedDisplayed: ($) => E((L) => L.setClass("ag-hidden", !$)),
      setCheckboxVisible: ($) => x((L) => L.setClass("ag-invisible", !$))
    };
    u.current = i.createBean(new La()), u.current.init(B, n.current, s.current, a.current, l.current, dL, e);
  }, []), P = Ee(() => `ag-cell-wrapper ${f.toString()}`, [f]), O = Ee(() => `ag-group-expanded ${w.toString()}`, [w]), I = Ee(() => `ag-group-contracted ${b.toString()}`, [b]), M = Ee(() => `ag-group-checkbox ${S.toString()}`, [S]), _ = c && c.componentFromFramework, G = _ ? c.componentClass : void 0, F = c == null && g != null, N = Ae.escapeString(g, !0);
  return /* @__PURE__ */ D.createElement("span", Mt({ className: P, ref: R }, e.colDef ? {} : { role: (r = u.current) == null ? void 0 : r.getCellAriaRole() }), /* @__PURE__ */ D.createElement("span", { className: O, ref: a }), /* @__PURE__ */ D.createElement("span", { className: I, ref: l }), /* @__PURE__ */ D.createElement("span", { className: M, ref: s }), /* @__PURE__ */ D.createElement("span", { className: "ag-group-value", ref: o }, F && /* @__PURE__ */ D.createElement(D.Fragment, null, N), _ && /* @__PURE__ */ D.createElement(G, Mt({}, c.params))), /* @__PURE__ */ D.createElement("span", { className: "ag-group-child-count" }, h));
}), tR = dL, ale = (e) => {
  const { ctrl: t } = e, r = t.isAlive(), { context: i } = bt(Yr), n = r ? t.getColId() : void 0, [o, s] = ee(), a = re(null), l = re(null), u = re(null), c = re();
  let d = re();
  r && !d.current && (d.current = new Sh(() => a.current));
  const h = fe((f) => {
    var C;
    if (a.current = f, !a.current || !r)
      return;
    const w = {
      setWidth: (b) => {
        a.current && (a.current.style.width = b);
      },
      addOrRemoveCssClass: (b, y) => d.current.addOrRemoveCssClass(b, y),
      setAriaSort: (b) => {
        a.current && (b ? Ae.setAriaSort(a.current, b) : Ae.removeAriaSort(a.current));
      },
      setUserCompDetails: (b) => s(b),
      getUserCompInstance: () => c.current || void 0
    };
    t.setComp(w, a.current, l.current, u.current);
    const E = t.getSelectAllGui();
    (C = l.current) == null || C.insertAdjacentElement("afterend", E);
  }, []);
  Vi(() => Lh(o, i, u.current, c), [o]), gt(() => {
    t.setDragSource(a.current);
  }, [o]);
  const p = Ee(() => !!((o == null ? void 0 : o.componentFromFramework) && Qu(o.componentClass)), [o]), g = o && o.componentFromFramework, m = o && o.componentClass;
  return /* @__PURE__ */ D.createElement(
    "div",
    {
      ref: h,
      className: "ag-header-cell",
      "col-id": n,
      role: "columnheader"
    },
    /* @__PURE__ */ D.createElement("div", { ref: l, className: "ag-header-cell-resize", role: "presentation" }),
    /* @__PURE__ */ D.createElement("div", { ref: u, className: "ag-header-cell-comp-wrapper", role: "presentation" }, g && p && /* @__PURE__ */ D.createElement(m, Mt({}, o.params)), g && !p && /* @__PURE__ */ D.createElement(m, Wr(Mt({}, o.params), { ref: c })))
  );
}, lle = $r(ale), ule = (e) => {
  const { context: t } = bt(Yr), { ctrl: r } = e, [i, n] = ee(() => new ki()), [o, s] = ee(() => new ki()), [a, l] = ee("false"), [u, c] = ee(), [d, h] = ee(), p = Ee(() => r.getColId(), []), g = re(null), m = re(null), f = re(), C = fe((x) => {
    if (g.current = x, !g.current)
      return;
    const R = {
      setWidth: (P) => {
        g.current && (g.current.style.width = P);
      },
      addOrRemoveCssClass: (P, O) => n((I) => I.setClass(P, O)),
      setUserCompDetails: (P) => h(P),
      setResizableDisplayed: (P) => {
        s((O) => O.setClass("ag-hidden", !P)), l(P ? "false" : "true");
      },
      setAriaExpanded: (P) => c(P),
      getUserCompInstance: () => f.current || void 0
    };
    r.setComp(R, g.current, m.current);
  }, []);
  Vi(() => Lh(d, t, g.current), [d]), gt(() => {
    g.current && r.setDragSource(g.current);
  }, [d]);
  const w = Ee(() => !!((d == null ? void 0 : d.componentFromFramework) && Qu(d.componentClass)), [d]), E = Ee(() => "ag-header-group-cell " + i.toString(), [i]), b = Ee(() => "ag-header-cell-resize " + o.toString(), [o]), y = d && d.componentFromFramework, S = d && d.componentClass;
  return /* @__PURE__ */ D.createElement(
    "div",
    {
      ref: C,
      className: E,
      "col-id": p,
      role: "columnheader",
      "aria-expanded": u
    },
    y && w && /* @__PURE__ */ D.createElement(S, Mt({}, d.params)),
    y && !w && /* @__PURE__ */ D.createElement(S, Wr(Mt({}, d.params), { ref: f })),
    /* @__PURE__ */ D.createElement("div", { ref: m, "aria-hidden": a, className: b })
  );
}, cle = $r(ule);
function VE() {
  Ae.warnOnce("Using custom components without `reactiveCustomComponents = true` is deprecated.");
}
var dle = (e) => {
  const { context: t, gos: r } = bt(Yr), [i, n] = ee(() => new ki("ag-header-cell", "ag-floating-filter")), [o, s] = ee(() => new ki()), [a, l] = ee(() => new ki("ag-floating-filter-button", "ag-hidden")), [u, c] = ee("false"), [d, h] = ee(), [p, g] = ee(1), m = re(null), f = re(null), C = re(null), w = re(null), E = re(), b = re(), y = (V) => {
    V != null && E.current && E.current(V);
  }, { ctrl: S } = e, x = fe((V) => {
    if (m.current = V, !m.current)
      return;
    b.current = new qt(($) => {
      E.current = $;
    });
    const B = {
      addOrRemoveCssClass: ($, L) => n((z) => z.setClass($, L)),
      addOrRemoveBodyCssClass: ($, L) => s((z) => z.setClass($, L)),
      setButtonWrapperDisplayed: ($) => {
        l((L) => L.setClass("ag-hidden", !$)), c($ ? "false" : "true");
      },
      setWidth: ($) => {
        m.current && (m.current.style.width = $);
      },
      setCompDetails: ($) => h($),
      getFloatingFilterComp: () => b.current ? b.current : null,
      setMenuIcon: ($) => {
        var L;
        return (L = w.current) == null ? void 0 : L.appendChild($);
      }
    };
    S.setComp(B, m.current, w.current, f.current);
  }, []);
  Vi(() => Lh(d, t, f.current, y), [d]);
  const R = Ee(() => i.toString(), [i]), P = Ee(() => o.toString(), [o]), O = Ee(() => a.toString(), [a]), I = Ee(() => !!(d && d.componentFromFramework && Qu(d.componentClass)), [d]), M = Ee(() => r.get("reactiveCustomComponents"), []), _ = Ee(() => {
    if (d)
      if (M) {
        const V = new qae(d.params, () => g((B) => B + 1));
        return y(V), V;
      } else d.componentFromFramework && VE();
  }, [d]), G = _ == null ? void 0 : _.getProps(), F = d && d.componentFromFramework, N = d && d.componentClass;
  return /* @__PURE__ */ D.createElement("div", { ref: x, className: R, role: "gridcell" }, /* @__PURE__ */ D.createElement("div", { ref: f, className: P, role: "presentation" }, F && !M && /* @__PURE__ */ D.createElement(N, Wr(Mt({}, d.params), { ref: I ? () => {
  } : y })), F && M && /* @__PURE__ */ D.createElement(NE.Provider, { value: {
    setMethods: (V) => _.setMethods(V)
  } }, /* @__PURE__ */ D.createElement(N, Mt({}, G)))), /* @__PURE__ */ D.createElement("div", { ref: C, "aria-hidden": u, className: O, role: "presentation" }, /* @__PURE__ */ D.createElement("button", { ref: w, type: "button", className: "ag-button ag-floating-filter-button-button", tabIndex: -1 })));
}, hle = $r(dle), ple = (e) => {
  const { ctrl: t } = e, { topOffset: r, rowHeight: i } = Ee(() => t.getTopAndHeight(), []), n = t.getAriaRowIndex(), o = t.getHeaderRowClass(), [s, a] = ee(() => i + "px"), [l, u] = ee(() => r + "px"), c = re(null), d = re(null), [h, p] = ee(() => t.getHeaderCtrls()), g = re(null), m = fe((w) => {
    if (g.current = w, !w)
      return;
    const E = {
      setHeight: (b) => a(b),
      setTop: (b) => u(b),
      setHeaderCtrls: (b, y, S) => {
        d.current = c.current, c.current = b;
        const x = kE(d.current, b, y);
        x !== d.current && GE(S, () => p(x));
      },
      setWidth: (b) => {
        g.current && (g.current.style.width = b);
      }
    };
    t.setComp(E, !1);
  }, []), f = Ee(() => ({
    height: s,
    top: l
  }), [s, l]), C = fe((w) => {
    switch (t.getType()) {
      case zb.COLUMN_GROUP:
        return /* @__PURE__ */ D.createElement(cle, { ctrl: w, key: w.getInstanceId() });
      case zb.FLOATING_FILTER:
        return /* @__PURE__ */ D.createElement(hle, { ctrl: w, key: w.getInstanceId() });
      default:
        return /* @__PURE__ */ D.createElement(lle, { ctrl: w, key: w.getInstanceId() });
    }
  }, []);
  return /* @__PURE__ */ D.createElement("div", { ref: m, className: o, role: "row", style: f, "aria-rowindex": n }, h.map(C));
}, fle = $r(ple), gle = (e) => {
  const [t, r] = ee(!0), [i, n] = ee([]), { context: o } = bt(Yr), s = re(null), a = re(null), l = re(null), u = e.pinned === "left", c = e.pinned === "right", d = !u && !c, h = fe((m) => {
    if (s.current = m, !s.current) {
      o.destroyBean(l.current), l.current = null;
      return;
    }
    const f = {
      setDisplayed: r,
      setCtrls: (C) => n(C),
      // centre only
      setCenterWidth: (C) => {
        a.current && (a.current.style.width = C);
      },
      setViewportScrollLeft: (C) => {
        s.current && (s.current.scrollLeft = C);
      },
      // pinned only
      setPinnedContainerWidth: (C) => {
        s.current && (s.current.style.width = C, s.current.style.minWidth = C, s.current.style.maxWidth = C);
      }
    };
    l.current = o.createBean(new ds(e.pinned)), l.current.setComp(f, s.current);
  }, []), p = t ? "" : "ag-hidden", g = () => i.map((m) => /* @__PURE__ */ D.createElement(fle, { ctrl: m, key: m.getInstanceId() }));
  return /* @__PURE__ */ D.createElement(D.Fragment, null, u && /* @__PURE__ */ D.createElement("div", { ref: h, className: "ag-pinned-left-header " + p, "aria-hidden": !t, role: "rowgroup" }, g()), c && /* @__PURE__ */ D.createElement("div", { ref: h, className: "ag-pinned-right-header " + p, "aria-hidden": !t, role: "rowgroup" }, g()), d && /* @__PURE__ */ D.createElement("div", { ref: h, className: "ag-header-viewport " + p, role: "presentation" }, /* @__PURE__ */ D.createElement("div", { ref: a, className: "ag-header-container", role: "rowgroup" }, g())));
}, xC = $r(gle), mle = () => {
  const [e, t] = ee(() => new ki()), [r, i] = ee(), { context: n } = bt(Yr), o = re(null), s = re(null), a = fe((c) => {
    if (o.current = c, !c) {
      n.destroyBean(s.current), s.current = null;
      return;
    }
    const d = {
      addOrRemoveCssClass: (h, p) => t((g) => g.setClass(h, p)),
      setHeightAndMinHeight: (h) => i(h)
    };
    s.current = n.createBean(new hs()), s.current.setComp(d, o.current, o.current);
  }, []), l = Ee(() => "ag-header " + e.toString(), [e]), u = Ee(() => ({
    height: r,
    minHeight: r
  }), [r]);
  return /* @__PURE__ */ D.createElement("div", { ref: a, className: l, style: u, role: "presentation" }, /* @__PURE__ */ D.createElement(xC, { pinned: "left" }), /* @__PURE__ */ D.createElement(xC, { pinned: null }), /* @__PURE__ */ D.createElement(xC, { pinned: "right" }));
}, vle = $r(mle), Cle = (e, t) => {
  gt(() => {
    const r = t.current;
    if (r) {
      const i = r.parentElement;
      if (i) {
        const n = document.createComment(e);
        return i.insertBefore(n, r), () => {
          i.removeChild(n);
        };
      }
    }
  }, [e]);
}, Fs = Cle, yle = (e) => {
  const t = re(e), r = re(), i = re(!1), n = re(!1), [, o] = ee(0);
  i.current && (n.current = !0), gt(() => (i.current || (r.current = t.current(), i.current = !0), o((s) => s + 1), () => {
    n.current && r.current && r.current();
  }), []);
}, ble = (e) => {
  const [t, r] = ee(), { context: i, popupService: n, localeService: o, gos: s } = bt(Yr);
  return yle(() => {
    const { editDetails: a, cellCtrl: l, eParentCell: u } = e, { compDetails: c } = a, d = s.get("stopEditingWhenCellsLoseFocus"), h = i.createBean(new HN(c.params)), p = h.getGui();
    if (e.jsChildComp) {
      const E = e.jsChildComp.getGui();
      E && p.appendChild(E);
    }
    const g = {
      column: l.getColumn(),
      rowNode: l.getRowNode(),
      type: "popupCellEditor",
      eventSource: u,
      ePopup: p,
      position: a.popupPosition,
      keepWithinBounds: !0
    }, m = n.positionPopupByComponent.bind(n, g), f = o.getLocaleTextFunc(), C = n.addPopup({
      modal: d,
      eChild: p,
      closeOnEsc: !0,
      closedCallback: () => {
        l.onPopupEditorClosed();
      },
      anchorToElement: u,
      positionCallback: m,
      ariaLabel: f("ariaLabelCellEditor", "Cell Editor")
    }), w = C ? C.hideFunc : void 0;
    return r(h), e.jsChildComp && e.jsChildComp.afterGuiAttached && e.jsChildComp.afterGuiAttached(), () => {
      w != null && w(), i.destroyBean(h);
    };
  }), /* @__PURE__ */ D.createElement(D.Fragment, null, t && e.wrappedContent && xa(e.wrappedContent, t.getGui()));
}, rR = $r(ble), wle = (e, t, r, i, n, o) => {
  const { context: s } = bt(Yr), a = fe(() => {
    const l = n.current;
    if (!l)
      return;
    const u = l.getGui();
    u && u.parentElement && u.parentElement.removeChild(u), s.destroyBean(l), n.current = void 0;
  }, []);
  gt(() => {
    const l = e != null, u = e && e.compDetails && !e.compDetails.componentFromFramework, c = t && r == null;
    if (!(l && u && !c)) {
      a();
      return;
    }
    const h = e.compDetails;
    if (n.current) {
      const C = n.current, E = C.refresh != null && e.force == !1 ? C.refresh(h.params) : !1;
      if (E === !0 || E === void 0)
        return;
      a();
    }
    const p = h.newAgStackInstance();
    if (!p)
      return;
    const g = p.resolveNow(null, (C) => C);
    if (!g)
      return;
    const m = g.getGui();
    if (!m)
      return;
    (t ? r : o.current).appendChild(m), n.current = g;
  }, [e, t, i]), gt(() => a, []);
}, Sle = wle, Ele = class {
  constructor(e, t) {
    this.cellEditorParams = e, this.refreshProps = t, this.instanceCreated = new qt((r) => {
      this.resolveInstanceCreated = r;
    }), this.onValueChange = (r) => this.updateValue(r), this.value = e.value;
  }
  getProps() {
    return Wr(Mt({}, this.cellEditorParams), {
      initialValue: this.cellEditorParams.value,
      value: this.value,
      onValueChange: this.onValueChange
    });
  }
  getValue() {
    return this.value;
  }
  refresh(e) {
    this.cellEditorParams = e, this.refreshProps();
  }
  setMethods(e) {
    LE(this.getOptionalMethods(), e, this);
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  setRef(e) {
    var t;
    this.componentInstance = e, (t = this.resolveInstanceCreated) == null || t.call(this), this.resolveInstanceCreated = void 0;
  }
  getOptionalMethods() {
    return ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached"];
  }
  updateValue(e) {
    this.value = e, this.refreshProps();
  }
}, xle = (e, t, r) => {
  const i = r.getColumn();
  if (!e && t.isPopup && t.isPopup()) {
    const n = `AG Grid: Found an issue in column ${i.getColId()}. If using React, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid React cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as React needs to know this information BEFORE the component is created.`;
    Ae.doOnce(() => console.warn(n), "jsEditorComp-isPopup-" + r.getColumn().getColId());
  }
  if (e && t.getPopupPosition && t.getPopupPosition() != null) {
    const n = `AG Grid: Found an issue in column ${i.getColId()}. If using React, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid React cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as React needs to know this information BEFORE the component is created.`;
    Ae.doOnce(() => console.warn(n), "jsEditorComp-getPopupPosition-" + r.getColumn().getColId());
  }
}, Ale = (e, t, r) => {
  const { compProxy: i } = e;
  r(i);
  const n = i.getProps(), o = Qu(t);
  return /* @__PURE__ */ D.createElement(NE.Provider, { value: {
    setMethods: (s) => i.setMethods(s)
  } }, o && /* @__PURE__ */ D.createElement(t, Mt({}, n)), !o && /* @__PURE__ */ D.createElement(t, Wr(Mt({}, n), { ref: (s) => i.setRef(s) })));
}, iR = (e, t, r) => {
  const i = e.compProxy;
  return /* @__PURE__ */ D.createElement(D.Fragment, null, !i && /* @__PURE__ */ D.createElement(t, Wr(Mt({}, e.compDetails.params), { ref: r })), i && Ale(e, t, r));
}, Dle = (e, t, r, i, n, o) => {
  const s = e.compDetails, a = s.componentClass, l = s.componentFromFramework && !e.popup, u = s.componentFromFramework && e.popup, c = !s.componentFromFramework && e.popup;
  return /* @__PURE__ */ D.createElement(D.Fragment, null, l && iR(e, a, t), u && /* @__PURE__ */ D.createElement(
    rR,
    {
      editDetails: e,
      cellCtrl: n,
      eParentCell: i,
      wrappedContent: iR(e, a, r)
    }
  ), c && o && /* @__PURE__ */ D.createElement(
    rR,
    {
      editDetails: e,
      cellCtrl: n,
      eParentCell: i,
      jsChildComp: o
    }
  ));
}, Tle = (e, t, r, i, n, o, s) => {
  const { compDetails: a, value: l } = e, u = !a, c = a && a.componentFromFramework, d = a && a.componentClass, h = l != null && l.toString ? l.toString() : l, p = () => /* @__PURE__ */ D.createElement(D.Fragment, null, u && /* @__PURE__ */ D.createElement(D.Fragment, null, h), c && !o && /* @__PURE__ */ D.createElement(d, Wr(Mt({}, a.params), { key: t, ref: i })), c && o && /* @__PURE__ */ D.createElement(d, Wr(Mt({}, a.params), { key: t })));
  return /* @__PURE__ */ D.createElement(D.Fragment, null, n ? /* @__PURE__ */ D.createElement("span", { role: "presentation", id: `cell-${r}`, className: "ag-cell-value", ref: s }, p()) : p());
}, Rle = (e) => {
  const { context: t } = bt(Yr), { cellCtrl: r, printLayout: i, editingRow: n } = e, o = r.getTabIndex(), s = r.getColumnIdSanitised(), a = r.getInstanceId(), [l, u] = ee(() => r.isCellRenderer() ? void 0 : { compDetails: void 0, value: r.getValueToDisplay(), force: !1 }), [c, d] = ee(), [h, p] = ee(1), [g, m] = ee(), [f, C] = ee(!1), [w, E] = ee(!1), [b, y] = ee(!1), [S, x] = ee(), R = Ee(() => r.isForceWrapper(), [r]), P = Ee(() => r.getCellAriaRole(), [r]), O = re(null), I = re(null), M = re(), _ = re(), G = re(), F = re([]), N = re(), [V, B] = ee(0), $ = fe((ae) => {
    N.current = ae, B((W) => W + 1);
  }, []), L = l != null && (f || b || w), z = R || L, j = fe((ae, W) => {
    _.current = W, W && (xle(ae, W, r), W.isCancelBeforeStart && W.isCancelBeforeStart() && setTimeout(() => {
      r.stopEditing(!0), r.focusCell(!0);
    }));
  }, [r]), U = fe(
    (ae) => j(!0, ae),
    [j]
  ), oe = fe(
    (ae) => j(!1, ae),
    [j]
  );
  let ie = re();
  ie.current || (ie.current = new Sh(() => O.current)), Sle(l, z, N.current, V, M, O);
  const le = re();
  Vi(() => {
    const ae = le.current, W = l;
    if (le.current = l, ae == null || ae.compDetails == null || W == null || W.compDetails == null)
      return;
    const be = ae.compDetails, X = W.compDetails;
    if (be.componentClass != X.componentClass || I.current == null || I.current.refresh == null)
      return;
    I.current.refresh(X.params) != !0 && p((He) => He + 1);
  }, [l]), Vi(() => {
    if (!(c && !c.compDetails.componentFromFramework))
      return;
    const W = c.compDetails, be = c.popup === !0, X = sle(W);
    if (!X)
      return;
    const Te = X.getGui();
    if (j(be, X), !be) {
      const He = (R ? G : O).current;
      He == null || He.appendChild(Te), X.afterGuiAttached && X.afterGuiAttached();
    }
    return x(X), () => {
      t.destroyBean(X), j(be, void 0), x(void 0), Te && Te.parentElement && Te.parentElement.removeChild(Te);
    };
  }, [c]);
  const ce = fe((ae) => {
    if (G.current = ae, !G.current) {
      F.current.forEach((be) => be()), F.current = [];
      return;
    }
    const W = (be) => {
      var X;
      if (be) {
        const Te = be.getGui();
        (X = G.current) == null || X.insertAdjacentElement("afterbegin", Te), F.current.push(() => {
          t.destroyBean(be), Ae.removeFromParent(Te);
        });
      }
      return be;
    };
    if (f) {
      const be = r.createSelectionCheckbox();
      W(be);
    }
    b && W(r.createDndSource()), w && W(r.createRowDragComp());
  }, [r, t, b, w, f]), he = fe((ae) => {
    if (O.current = ae, !O.current || !r)
      return;
    const W = {
      addOrRemoveCssClass: (X, Te) => ie.current.addOrRemoveCssClass(X, Te),
      setUserStyles: (X) => m(X),
      getFocusableElement: () => O.current,
      setIncludeSelection: (X) => C(X),
      setIncludeRowDrag: (X) => E(X),
      setIncludeDndSource: (X) => y(X),
      getCellEditor: () => _.current || null,
      getCellRenderer: () => I.current ? I.current : M.current,
      getParentOfValue: () => N.current ? N.current : G.current ? G.current : O.current,
      setRenderDetails: (X, Te, He) => {
        u((je) => (je == null ? void 0 : je.compDetails) !== X || (je == null ? void 0 : je.value) !== Te || (je == null ? void 0 : je.force) !== He ? {
          value: Te,
          compDetails: X,
          force: He
        } : je);
      },
      setEditDetails: (X, Te, He, je) => {
        if (X) {
          let jt;
          je ? jt = new Ele(X.params, () => p((Mr) => Mr + 1)) : X.componentFromFramework && VE(), d({
            compDetails: X,
            popup: Te,
            popupPosition: He,
            compProxy: jt
          }), Te || u(void 0);
        } else
          d((jt) => {
            jt != null && jt.compProxy && (_.current = void 0);
          });
      }
    }, be = G.current || void 0;
    r.setComp(W, O.current, be, i, n);
  }, []), Z = Ee(() => !!(l && l.compDetails && l.compDetails.componentFromFramework && Qu(l.compDetails.componentClass)), [l]);
  Vi(() => {
    var ae;
    O.current && (ie.current.addOrRemoveCssClass("ag-cell-value", !z), ie.current.addOrRemoveCssClass("ag-cell-inline-editing", !!c && !c.popup), ie.current.addOrRemoveCssClass("ag-cell-popup-editing", !!c && !!c.popup), ie.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !c || !!c.popup), (ae = r.getRowCtrl()) == null || ae.setInlineEditingCss(!!c), r.shouldRestoreFocus() && !r.isEditing() && O.current.focus({ preventScroll: !0 }));
  });
  const se = () => /* @__PURE__ */ D.createElement(D.Fragment, null, l != null && Tle(
    l,
    h,
    a,
    I,
    z,
    Z,
    $
  ), c != null && Dle(
    c,
    oe,
    U,
    O.current,
    r,
    S
  ));
  return /* @__PURE__ */ D.createElement(
    "div",
    {
      ref: he,
      style: g,
      tabIndex: o,
      role: P,
      "col-id": s
    },
    z ? /* @__PURE__ */ D.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: ce }, se()) : se()
  );
}, Ple = $r(Rle), Ile = (e) => {
  const { context: t, gos: r } = bt(Yr), { rowCtrl: i, containerType: n } = e, o = i.getTabIndex(), s = re(i.getDomOrder()), a = i.isFullWidth(), l = i.getRowNode().displayed, [u, c] = ee(() => l ? i.getRowIndex() : null), [d, h] = ee(() => i.getRowId()), [p, g] = ee(() => i.getBusinessKey()), [m, f] = ee(() => i.getRowStyles()), C = re(null), w = re(null), [E, b] = ee(() => null), [y, S] = ee(), [x, R] = ee(() => l ? i.getInitialRowTop(n) : void 0), [P, O] = ee(() => l ? i.getInitialTransform(n) : void 0), I = re(null), M = re(), _ = re(!1), [G, F] = ee(0);
  gt(() => {
    var ie;
    if (_.current || !y || G > 10)
      return;
    const le = (ie = I.current) == null ? void 0 : ie.firstChild;
    le ? (i.setupDetailRowAutoHeight(le), _.current = !0) : F((ce) => ce + 1);
  }, [y, G]);
  let N = re();
  N.current || (N.current = new Sh(() => I.current));
  const V = fe((ie) => {
    if (I.current = ie, !I.current) {
      i.unsetComp(n);
      return;
    }
    if (!i.isAlive())
      return;
    const le = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: R,
      setTransform: O,
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (ce, he) => N.current.addOrRemoveCssClass(ce, he),
      setDomOrder: (ce) => s.current = ce,
      setRowIndex: c,
      setRowId: h,
      setRowBusinessKey: g,
      setUserStyles: f,
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (ce, he) => {
        w.current = C.current, C.current = ce;
        const Z = kE(w.current, ce, s.current);
        Z !== w.current && GE(he, () => b(Z));
      },
      showFullWidth: (ce) => S(ce),
      getFullWidthCellRenderer: () => M.current,
      refreshFullWidth: (ce) => j.current ? (S((he) => Wr(Mt({}, he), {
        params: ce()
      })), !0) : !M.current || !M.current.refresh ? !1 : M.current.refresh(ce())
    };
    i.setComp(le, I.current, n);
  }, []);
  Vi(() => Lh(y, t, I.current, M), [y]);
  const B = Ee(() => {
    const ie = { top: x, transform: P };
    return Object.assign(ie, m), ie;
  }, [x, P, m]), $ = a && y && y.componentFromFramework, L = !a && E != null, z = Ee(() => !!((y == null ? void 0 : y.componentFromFramework) && Qu(y.componentClass)), [y]), j = re(!1);
  gt(() => {
    j.current = z && !!y && !!r.get("reactiveCustomComponents");
  }, [z, y]);
  const U = () => E == null ? void 0 : E.map((ie) => /* @__PURE__ */ D.createElement(
    Ple,
    {
      cellCtrl: ie,
      editingRow: i.isEditing(),
      printLayout: i.isPrintLayout(),
      key: ie.getInstanceId()
    }
  )), oe = () => {
    const ie = y.componentClass;
    return /* @__PURE__ */ D.createElement(D.Fragment, null, z && /* @__PURE__ */ D.createElement(ie, Mt({}, y.params)), !z && /* @__PURE__ */ D.createElement(ie, Wr(Mt({}, y.params), { ref: M })));
  };
  return /* @__PURE__ */ D.createElement(
    "div",
    {
      ref: V,
      role: "row",
      style: B,
      "row-index": u,
      "row-id": d,
      "row-business-key": p,
      tabIndex: o
    },
    L && U(),
    $ && oe()
  );
}, Ole = $r(Ile), Mle = (e) => {
  const { context: t } = bt(Yr), { name: r } = e, i = Ee(() => GN(r), [r]), n = re(null), o = re(null), s = re([]), a = re([]), [l, u] = ee(() => []), c = re(!1), d = re(), h = Ee(() => hg.getRowContainerCssClasses(r), [r]), p = Ee(() => on(h.viewport), [h]), g = Ee(() => on(h.container), [h]), m = r === St.CENTER || r === St.TOP_CENTER || r === St.BOTTOM_CENTER || r === St.STICKY_TOP_CENTER || r === St.STICKY_BOTTOM_CENTER, f = m ? n : o;
  Fs(" AG Row Container " + r + " ", f);
  const C = fe(() => m ? n.current != null && o.current != null : o.current != null, []), w = fe(() => m ? n.current == null && o.current == null : o.current == null, []), E = fe(() => {
    if (w() && (t.destroyBean(d.current), d.current = null), C()) {
      const x = (P) => {
        const O = kE(a.current, s.current, c.current);
        O !== a.current && (a.current = O, GE(P, () => u(O)));
      }, R = {
        setViewportHeight: (P) => {
          n.current && (n.current.style.height = P);
        },
        setRowCtrls: ({ rowCtrls: P, useFlushSync: O }) => {
          const I = !!O && s.current.length > 0 && P.length > 0;
          s.current = P, x(I);
        },
        setDomOrder: (P) => {
          c.current != P && (c.current = P, x(!1));
        },
        setContainerWidth: (P) => {
          o.current && (o.current.style.width = P);
        }
      };
      d.current = t.createBean(new hg(r)), d.current.setComp(R, o.current, n.current);
    }
  }, [C, w]), b = fe((x) => {
    o.current = x, E();
  }, [E]), y = fe((x) => {
    n.current = x, E();
  }, [E]), S = () => /* @__PURE__ */ D.createElement(
    "div",
    {
      className: g,
      ref: b,
      role: "rowgroup"
    },
    l.map(
      (x) => /* @__PURE__ */ D.createElement(Ole, { rowCtrl: x, containerType: i, key: x.getInstanceId() })
    )
  );
  return /* @__PURE__ */ D.createElement(D.Fragment, null, m ? /* @__PURE__ */ D.createElement("div", { className: p, ref: y, role: "presentation" }, S()) : S());
}, Fle = $r(Mle), _le = () => {
  const { context: e, agStackComponentsRegistry: t, resizeObserverService: r } = bt(Yr), [i, n] = ee(""), [o, s] = ee(0), [a, l] = ee(0), [u, c] = ee("0px"), [d, h] = ee("0px"), [p, g] = ee("100%"), [m, f] = ee("0px"), [C, w] = ee("0px"), [E, b] = ee("100%"), [y, S] = ee(""), [x, R] = ee(""), [P, O] = ee(null), [I, M] = ee(""), [_, G] = ee(null), [F, N] = ee("ag-layout-normal");
  let V = re();
  V.current || (V.current = new Sh(() => B.current));
  const B = re(null), $ = re(null), L = re(null), z = re(null), j = re(null), U = re(null), oe = re(null), ie = re([]), le = re([]);
  Fs(" AG Grid Body ", B), Fs(" AG Pinned Top ", $), Fs(" AG Sticky Top ", L), Fs(" AG Middle ", U), Fs(" AG Pinned Bottom ", oe);
  const ce = fe((Lt) => {
    if (B.current = Lt, !B.current) {
      e.destroyBeans(ie.current), le.current.forEach((wt) => wt()), ie.current = [], le.current = [];
      return;
    }
    if (!e)
      return;
    const zt = (wt) => {
      const pr = t.getComponentClass(wt), ys = e.createBean(new pr());
      return ie.current.push(ys), ys;
    }, er = (wt, pr) => {
      wt.appendChild(pr), le.current.push(() => wt.removeChild(pr));
    };
    er(B.current, document.createComment(" AG Fake Horizontal Scroll ")), er(B.current, zt("AG-FAKE-HORIZONTAL-SCROLL").getGui()), er(B.current, document.createComment(" AG Overlay Wrapper ")), er(B.current, zt("AG-OVERLAY-WRAPPER").getGui()), j.current && (er(j.current, document.createComment(" AG Fake Vertical Scroll ")), er(j.current, zt("AG-FAKE-VERTICAL-SCROLL").getGui()));
    const ui = {
      setRowAnimationCssOnBodyViewport: n,
      setColumnCount: (wt) => {
        B.current && Ae.setAriaColCount(B.current, wt);
      },
      setRowCount: (wt) => {
        B.current && Ae.setAriaRowCount(B.current, wt);
      },
      setTopHeight: s,
      setBottomHeight: l,
      setStickyTopHeight: c,
      setStickyTopTop: h,
      setStickyTopWidth: g,
      setTopDisplay: S,
      setBottomDisplay: R,
      setColumnMovingCss: (wt, pr) => V.current.addOrRemoveCssClass(wt, pr),
      updateLayoutClasses: N,
      setAlwaysVerticalScrollClass: O,
      setPinnedTopBottomOverflowY: M,
      setCellSelectableCss: (wt, pr) => G(pr ? wt : null),
      setBodyViewportWidth: (wt) => {
        U.current && (U.current.style.width = wt);
      },
      registerBodyViewportResizeListener: (wt) => {
        if (U.current) {
          const pr = r.observeResize(U.current, wt);
          le.current.push(() => pr());
        }
      },
      setStickyBottomHeight: f,
      setStickyBottomBottom: w,
      setStickyBottomWidth: b
    }, Qi = e.createBean(new Or());
    ie.current.push(Qi), Qi.setComp(
      ui,
      B.current,
      U.current,
      $.current,
      oe.current,
      L.current,
      z.current
    );
  }, []), he = Ee(
    () => on("ag-root", "ag-unselectable", F),
    [F]
  ), Z = Ee(
    () => on("ag-body-viewport", i, F, P, _),
    [i, F, P, _]
  ), se = Ee(
    () => on("ag-body", F),
    [F]
  ), ae = Ee(
    () => on("ag-floating-top", _),
    [_]
  ), W = Ee(
    () => on("ag-sticky-top", _),
    [_]
  ), be = Ee(
    () => on("ag-sticky-bottom", _),
    [_]
  ), X = Ee(
    () => on("ag-floating-bottom", _),
    [_]
  ), Te = Ee(() => ({
    height: o,
    minHeight: o,
    display: y,
    overflowY: I
  }), [o, y, I]), He = Ee(() => ({
    height: u,
    top: d,
    width: p
  }), [u, d, p]), je = Ee(() => ({
    height: m,
    bottom: C,
    width: E
  }), [m, C, E]), jt = Ee(() => ({
    height: a,
    minHeight: a,
    display: x,
    overflowY: I
  }), [a, x, I]), Mr = (Lt) => /* @__PURE__ */ D.createElement(Fle, { name: Lt, key: `${Lt}-container` }), Qt = ({
    section: Lt,
    children: zt,
    className: er,
    style: ui
  }) => /* @__PURE__ */ D.createElement("div", { ref: Lt, className: er, role: "presentation", style: ui }, zt.map(Mr));
  return /* @__PURE__ */ D.createElement("div", { ref: ce, className: he, role: "treegrid" }, /* @__PURE__ */ D.createElement(vle, null), Qt({ section: $, className: ae, style: Te, children: [
    St.TOP_LEFT,
    St.TOP_CENTER,
    St.TOP_RIGHT,
    St.TOP_FULL_WIDTH
  ] }), /* @__PURE__ */ D.createElement("div", { className: se, ref: j, role: "presentation" }, Qt({
    section: U,
    className: Z,
    children: [
      St.LEFT,
      St.CENTER,
      St.RIGHT,
      St.FULL_WIDTH
    ]
  })), Qt({ section: L, className: W, style: He, children: [
    St.STICKY_TOP_LEFT,
    St.STICKY_TOP_CENTER,
    St.STICKY_TOP_RIGHT,
    St.STICKY_TOP_FULL_WIDTH
  ] }), Qt({ section: z, className: be, style: je, children: [
    St.STICKY_BOTTOM_LEFT,
    St.STICKY_BOTTOM_CENTER,
    St.STICKY_BOTTOM_RIGHT,
    St.STICKY_BOTTOM_FULL_WIDTH
  ] }), Qt({ section: oe, className: X, style: jt, children: [
    St.BOTTOM_LEFT,
    St.BOTTOM_CENTER,
    St.BOTTOM_RIGHT,
    St.BOTTOM_FULL_WIDTH
  ] }));
}, Nle = $r(_le), Lle = (e, t) => {
  const { children: r, eFocusableElement: i, onTabKeyDown: n, gridCtrl: o, forceFocusOutWhenTabGuardsAreEmpty: s } = e, { context: a } = bt(Yr), l = re(null), u = re(null), c = re(), d = (f) => {
    const C = f == null ? void 0 : parseInt(f, 10).toString();
    [l, u].forEach((w) => {
      var E, b;
      C === void 0 ? (E = w.current) == null || E.removeAttribute("tabindex") : (b = w.current) == null || b.setAttribute("tabindex", C);
    });
  };
  jg(t, () => ({
    forceFocusOutOfContainer(f) {
      var C;
      (C = c.current) == null || C.forceFocusOutOfContainer(f);
    }
  }));
  const h = fe(() => {
    if (!l.current && !u.current) {
      a.destroyBean(c.current), c.current = null;
      return;
    }
    if (l.current && u.current) {
      const f = {
        setTabIndex: d
      };
      c.current = a.createBean(new iv({
        comp: f,
        eTopGuard: l.current,
        eBottomGuard: u.current,
        eFocusableElement: i,
        onTabKeyDown: n,
        forceFocusOutWhenTabGuardsAreEmpty: s,
        focusInnerElement: (C) => o.focusInnerElement(C)
      }));
    }
  }, []), p = fe((f) => {
    l.current = f, h();
  }, [h]), g = fe((f) => {
    u.current = f, h();
  }, [h]), m = (f) => {
    const C = f === "top" ? _p.TAB_GUARD_TOP : _p.TAB_GUARD_BOTTOM;
    return /* @__PURE__ */ D.createElement(
      "div",
      {
        className: `${_p.TAB_GUARD} ${C}`,
        role: "presentation",
        ref: f === "top" ? p : g
      }
    );
  };
  return /* @__PURE__ */ D.createElement(D.Fragment, null, m("top"), r, m("bottom"));
}, Gle = ns(Lle), kle = $r(Gle), Vle = ({ context: e }) => {
  const [t, r] = ee(""), [i, n] = ee(""), [o, s] = ee(""), [a, l] = ee(null), [u, c] = ee(null), [d, h] = ee(!1), [p, g] = ee(), m = re(null), f = re(null), C = re(), [w, E] = ee(null), b = re(() => {
  }), y = fe(() => {
  }, []), S = Ee(() => e.isDestroyed() ? null : e.getBean("beans"), [e]);
  Fs(" AG Grid ", f);
  const x = fe((M) => {
    if (f.current = M, !f.current) {
      e.destroyBean(m.current), m.current = null;
      return;
    }
    if (e.isDestroyed())
      return;
    m.current = e.createBean(new ms());
    const _ = m.current;
    b.current = _.focusInnerElement.bind(_);
    const G = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass: r,
      forceFocusOutOfContainer: (F) => {
        var N;
        (N = C.current) == null || N.forceFocusOutOfContainer(F);
      },
      updateLayoutClasses: s,
      getFocusableContainers: () => {
        var F, N;
        const V = [], B = (F = f.current) == null ? void 0 : F.querySelector(".ag-root"), $ = (N = f.current) == null ? void 0 : N.querySelector(".ag-side-bar:not(.ag-hidden)");
        return B && V.push(B), $ && V.push($), V;
      },
      setCursor: l,
      setUserSelect: c
    };
    _.setComp(G, f.current, f.current), h(!0);
  }, []);
  gt(() => {
    if (!p || !S || !m.current || !w || !f.current)
      return;
    const M = m.current, _ = [], { agStackComponentsRegistry: G } = S, F = G.getComponentClass("AG-GRID-HEADER-DROP-ZONES"), N = G.getComponentClass("AG-SIDE-BAR"), V = G.getComponentClass("AG-STATUS-BAR"), B = G.getComponentClass("AG-WATERMARK"), $ = G.getComponentClass("AG-PAGINATION"), L = [], z = f.current;
    if (M.showDropZones() && F) {
      const j = e.createBean(new F()), U = j.getGui();
      z.insertAdjacentElement("afterbegin", U), L.push(U), _.push(j);
    }
    if (M.showSideBar() && N) {
      const j = e.createBean(new N()), U = j.getGui(), oe = w.querySelector(".ag-tab-guard-bottom");
      oe && (oe.insertAdjacentElement("beforebegin", U), L.push(U)), _.push(j);
    }
    if (M.showStatusBar() && V) {
      const j = e.createBean(new V()), U = j.getGui();
      z.insertAdjacentElement("beforeend", U), L.push(U), _.push(j);
    }
    if ($) {
      const j = e.createBean(new $()), U = j.getGui();
      z.insertAdjacentElement("beforeend", U), L.push(U), _.push(j);
    }
    if (M.showWatermark() && B) {
      const j = e.createBean(new B()), U = j.getGui();
      z.insertAdjacentElement("beforeend", U), L.push(U), _.push(j);
    }
    return () => {
      e.destroyBeans(_), L.forEach((j) => {
        j.parentElement && j.parentElement.removeChild(j);
      });
    };
  }, [p, w, S]);
  const R = Ee(() => on("ag-root-wrapper", t, i, o), [t, i, o]), P = Ee(() => on("ag-root-wrapper-body", "ag-focus-managed", o), [o]), O = Ee(() => ({
    userSelect: u ?? "",
    WebkitUserSelect: u ?? "",
    cursor: a ?? ""
  }), [u, a]), I = fe((M) => {
    C.current = M, g(M !== null);
  }, []);
  return /* @__PURE__ */ D.createElement("div", { ref: x, className: R, style: O, role: "presentation" }, /* @__PURE__ */ D.createElement("div", { className: P, ref: E, role: "presentation" }, d && w && S && /* @__PURE__ */ D.createElement(Yr.Provider, { value: S }, /* @__PURE__ */ D.createElement(
    kle,
    {
      ref: I,
      eFocusableElement: w,
      onTabKeyDown: y,
      gridCtrl: m.current,
      forceFocusOutWhenTabGuardsAreEmpty: !0
    },
    // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    /* @__PURE__ */ D.createElement(Nle, null)
  ))));
}, Hle = $r(Vle), hL = (e) => {
  var t, r;
  const i = re(), n = re(null), o = re(null), s = re([]), a = re([]), l = re(e), u = re(!1), [c, d] = ee(void 0), [, h] = ee(0), p = fe((f) => {
    if (n.current = f, !n.current) {
      s.current.forEach((x) => x()), s.current.length = 0;
      return;
    }
    const C = e.modules || [];
    o.current || (o.current = new ile(
      () => h((x) => x + 1),
      e.componentWrappingElement,
      e.maxComponentCreationTimeMs
    ), s.current.push(() => {
      var x;
      (x = o.current) == null || x.destroy(), o.current = null;
    }));
    const w = ag.combineAttributesAndGridOptions(e.gridOptions, e), E = {
      providedBeanInstances: {
        frameworkComponentWrapper: new Wle(o.current, !!w.reactiveCustomComponents)
      },
      modules: C,
      frameworkOverrides: new jle()
    }, b = (x) => {
      d(x), s.current.push(() => {
        x.destroy();
      }), x.getBean(Zs.NAME).whenReady(() => {
        if (x.isDestroyed())
          return;
        const P = i.current;
        P && e.setGridApi && e.setGridApi(P, new ru(P));
      });
    }, y = (x) => {
      x.getBean(Zs.NAME).whenReady(() => {
        a.current.forEach((P) => P()), a.current.length = 0, u.current = !0;
      });
    }, S = new wae();
    i.current = S.create(
      n.current,
      w,
      b,
      y,
      E
    );
  }, []), g = Ee(() => Mt({
    height: "100%"
  }, e.containerStyle || {}), [e.containerStyle]), m = fe((f) => {
    u.current ? f() : a.current.push(f);
  }, []);
  return gt(() => {
    const f = Ble(l.current, e);
    l.current = e, m(() => {
      i.current && ag.processOnChange(f, i.current);
    });
  }, [e]), /* @__PURE__ */ D.createElement("div", { style: g, className: e.className, ref: p }, c && !c.isDestroyed() ? /* @__PURE__ */ D.createElement(Hle, { context: c }) : null, (r = (t = o.current) == null ? void 0 : t.getPortals()) != null ? r : null);
};
function Ble(e, t) {
  const r = {};
  return Object.keys(t).forEach((i) => {
    const n = t[i];
    e[i] !== n && (r[i] = n);
  }), r;
}
var Wle = class extends Sae {
  constructor(e, t) {
    super(), this.parent = e, this.reactiveCustomComponents = t;
  }
  createWrapper(e, t) {
    if (this.reactiveCustomComponents) {
      const n = ((o) => {
        switch (o) {
          case "filter":
            return Kae;
          case "floatingFilterComponent":
            return Zae;
          case "dateComponent":
            return Xae;
          case "loadingOverlayComponent":
            return Jae;
          case "noRowsOverlayComponent":
            return ele;
          case "statusPanel":
            return tle;
          case "toolPanel":
            return rle;
          case "menuItem":
            return Qae;
        }
      })(t.propertyName);
      if (n)
        return new n(e, this.parent, t);
    } else
      switch (t.propertyName) {
        case "filter":
        case "floatingFilterComponent":
        case "dateComponent":
        case "loadingOverlayComponent":
        case "noRowsOverlayComponent":
        case "statusPanel":
        case "toolPanel":
        case "menuItem":
          VE();
          break;
      }
    const r = !t.cellRenderer && t.propertyName !== "toolPanel";
    return new sL(e, this.parent, t, r);
  }
}, $le = ns((e, t) => {
  const { ctrlsFactory: r, context: i, gos: n, resizeObserverService: o, clientSideRowModel: s, serverSideRowModel: a } = bt(Yr), [l, u] = ee(() => new ki()), [c, d] = ee(() => new ki()), [h, p] = ee(), [g, m] = ee(), f = re(), C = re(null), w = re(), E = Ee(() => Xe.__getGridRegisteredModules(e.api.getGridId()), [e]), b = Ee(() => l.toString() + " ag-details-row", [l]), y = Ee(() => c.toString() + " ag-details-grid", [c]);
  t && jg(t, () => ({
    refresh() {
      var R, P;
      return (P = (R = f.current) == null ? void 0 : R.refresh()) != null ? P : !1;
    }
  })), e.template && Ae.warnOnce("detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/");
  const S = fe((R) => {
    if (C.current = R, !C.current) {
      i.destroyBean(f.current), w.current && w.current();
      return;
    }
    const P = {
      addOrRemoveCssClass: (I, M) => u((_) => _.setClass(I, M)),
      addOrRemoveDetailGridCssClass: (I, M) => d((_) => _.setClass(I, M)),
      setDetailGrid: (I) => p(I),
      setRowData: (I) => m(I),
      getGui: () => C.current
    }, O = r.getInstance("detailCellRenderer");
    if (O && (i.createBean(O), O.init(P, e), f.current = O, n.get("detailRowAutoHeight"))) {
      const I = () => {
        if (C.current == null)
          return;
        const M = C.current.clientHeight;
        M != null && M > 0 && setTimeout(() => {
          e.node.setRowHeight(M), s ? s.onRowHeightChanged() : a && a.onRowHeightChanged();
        }, 0);
      };
      w.current = o.observeResize(C.current, I), I();
    }
  }, []), x = fe((R, P) => {
    var O;
    (O = f.current) == null || O.registerDetailWithMaster(R, P);
  }, []);
  return /* @__PURE__ */ D.createElement("div", { className: b, ref: S }, h && /* @__PURE__ */ D.createElement(hL, Wr(Mt({ className: y }, h), { modules: E, rowData: g, setGridApi: x })));
}), jle = class extends QN {
  constructor() {
    super("react"), this.frameworkComponents = {
      agGroupCellRenderer: tR,
      agGroupRowRenderer: tR,
      agDetailCellRenderer: $le
    }, this.wrapIncoming = (e, t) => t === "ensureVisible" ? ole(e) : e(), this.renderingEngine = "react";
  }
  frameworkComponent(e) {
    return this.frameworkComponents[e];
  }
  isFrameworkComponent(e) {
    if (!e)
      return !1;
    const t = e.prototype;
    return !(t && "getGui" in t);
  }
}, zle = class extends $t {
  constructor() {
    super(...arguments), this.apiListeners = [], this.setGridApi = (e, t) => {
      this.api = e, this.columnApi = t, this.apiListeners.forEach((r) => r(e));
    };
  }
  registerApiListener(e) {
    this.apiListeners.push(e);
  }
  componentWillUnmount() {
    this.apiListeners.length = 0;
  }
  render() {
    return /* @__PURE__ */ D.createElement(hL, Wr(Mt({}, this.props), { setGridApi: this.setGridApi }));
  }
};
const gbe = ({
  rowData: e,
  columnDefs: t,
  height: r = "500px",
  defaultColDef: i,
  gridOptions: n
}) => {
  const o = Ee(() => ({
    flex: 1,
    minWidth: 100,
    resizable: !0,
    sortable: !0,
    ...i
  }), [i]);
  return /* @__PURE__ */ H("div", { className: "ag-theme-quartz", style: { height: r, width: "100%" }, children: /* @__PURE__ */ H(
    zle,
    {
      rowData: e,
      columnDefs: t,
      defaultColDef: o,
      gridOptions: n
    }
  ) });
}, Ule = {
  info: {
    icon: "info",
    classes: "bg-primary/10 border-primary/50 text-primary"
  },
  success: {
    icon: "check-circle",
    classes: "bg-green-500/10 border-green-500/50 text-green-700 dark:text-green-400"
  },
  warning: {
    icon: "alert-triangle",
    classes: "bg-yellow-500/10 border-yellow-500/50 text-yellow-700 dark:text-yellow-400"
  },
  danger: {
    icon: "x-circle",
    classes: "bg-red-500/10 border-red-500/50 text-red-700 dark:text-red-500"
  }
}, mbe = ({
  title: e,
  children: t,
  variant: r = "info",
  className: i
}) => {
  const n = Ule[r];
  return /* @__PURE__ */ ve("div", { className: `flex items-start gap-4 p-4 border-l-4 rounded-r-lg ${n.classes} ${i || ""}`, role: "alert", children: [
    /* @__PURE__ */ H("div", { className: "flex-shrink-0", children: /* @__PURE__ */ H(Hi, { name: n.icon, size: 20 }) }),
    /* @__PURE__ */ ve("div", { className: "flex-grow", children: [
      /* @__PURE__ */ H("h4", { className: "font-semibold", children: e }),
      t && /* @__PURE__ */ H("div", { className: "text-sm mt-1", children: t })
    ] })
  ] });
};
var ti = "top", Yi = "bottom", Xi = "right", ri = "left", HE = "auto", Gh = [ti, Yi, Xi, ri], cu = "start", Jd = "end", Yle = "clippingParents", pL = "viewport", mc = "popper", Xle = "reference", nR = /* @__PURE__ */ Gh.reduce(function(e, t) {
  return e.concat([t + "-" + cu, t + "-" + Jd]);
}, []), fL = /* @__PURE__ */ [].concat(Gh, [HE]).reduce(function(e, t) {
  return e.concat([t, t + "-" + cu, t + "-" + Jd]);
}, []), Kle = "beforeRead", qle = "read", Zle = "afterRead", Jle = "beforeMain", Qle = "main", eue = "afterMain", tue = "beforeWrite", rue = "write", iue = "afterWrite", nue = [Kle, qle, Zle, Jle, Qle, eue, tue, rue, iue];
function Kn(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function xi(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function ya(e) {
  var t = xi(e).Element;
  return e instanceof t || e instanceof Element;
}
function $i(e) {
  var t = xi(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function BE(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = xi(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function oue(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(r) {
    var i = t.styles[r] || {}, n = t.attributes[r] || {}, o = t.elements[r];
    !$i(o) || !Kn(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(s) {
      var a = n[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function sue(e) {
  var t = e.state, r = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, s = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : r[i]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !$i(n) || !Kn(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const gL = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: oue,
  effect: sue,
  requires: ["computeStyles"]
};
function Gn(e) {
  return e.split("-")[0];
}
var Js = Math.max, Sg = Math.min, du = Math.round;
function rw() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function mL() {
  return !/^((?!chrome|android).)*safari/i.test(rw());
}
function hu(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var i = e.getBoundingClientRect(), n = 1, o = 1;
  t && $i(e) && (n = e.offsetWidth > 0 && du(i.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && du(i.height) / e.offsetHeight || 1);
  var s = ya(e) ? xi(e) : window, a = s.visualViewport, l = !mL() && r, u = (i.left + (l && a ? a.offsetLeft : 0)) / n, c = (i.top + (l && a ? a.offsetTop : 0)) / o, d = i.width / n, h = i.height / o;
  return {
    width: d,
    height: h,
    top: c,
    right: u + d,
    bottom: c + h,
    left: u,
    x: u,
    y: c
  };
}
function WE(e) {
  var t = hu(e), r = e.offsetWidth, i = e.offsetHeight;
  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: r,
    height: i
  };
}
function vL(e, t) {
  var r = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (r && BE(r)) {
    var i = t;
    do {
      if (i && e.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function xo(e) {
  return xi(e).getComputedStyle(e);
}
function aue(e) {
  return ["table", "td", "th"].indexOf(Kn(e)) >= 0;
}
function Cs(e) {
  return ((ya(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function lv(e) {
  return Kn(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (BE(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Cs(e)
  );
}
function oR(e) {
  return !$i(e) || // https://github.com/popperjs/popper-core/issues/837
  xo(e).position === "fixed" ? null : e.offsetParent;
}
function lue(e) {
  var t = /firefox/i.test(rw()), r = /Trident/i.test(rw());
  if (r && $i(e)) {
    var i = xo(e);
    if (i.position === "fixed")
      return null;
  }
  var n = lv(e);
  for (BE(n) && (n = n.host); $i(n) && ["html", "body"].indexOf(Kn(n)) < 0; ) {
    var o = xo(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function kh(e) {
  for (var t = xi(e), r = oR(e); r && aue(r) && xo(r).position === "static"; )
    r = oR(r);
  return r && (Kn(r) === "html" || Kn(r) === "body" && xo(r).position === "static") ? t : r || lue(e) || t;
}
function $E(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Bc(e, t, r) {
  return Js(e, Sg(t, r));
}
function uue(e, t, r) {
  var i = Bc(e, t, r);
  return i > r ? r : i;
}
function CL() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function yL(e) {
  return Object.assign({}, CL(), e);
}
function bL(e, t) {
  return t.reduce(function(r, i) {
    return r[i] = e, r;
  }, {});
}
var cue = function(t, r) {
  return t = typeof t == "function" ? t(Object.assign({}, r.rects, {
    placement: r.placement
  })) : t, yL(typeof t != "number" ? t : bL(t, Gh));
};
function due(e) {
  var t, r = e.state, i = e.name, n = e.options, o = r.elements.arrow, s = r.modifiersData.popperOffsets, a = Gn(r.placement), l = $E(a), u = [ri, Xi].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var d = cue(n.padding, r), h = WE(o), p = l === "y" ? ti : ri, g = l === "y" ? Yi : Xi, m = r.rects.reference[c] + r.rects.reference[l] - s[l] - r.rects.popper[c], f = s[l] - r.rects.reference[l], C = kh(o), w = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = m / 2 - f / 2, b = d[p], y = w - h[c] - d[g], S = w / 2 - h[c] / 2 + E, x = Bc(b, S, y), R = l;
    r.modifiersData[i] = (t = {}, t[R] = x, t.centerOffset = x - S, t);
  }
}
function hue(e) {
  var t = e.state, r = e.options, i = r.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || vL(t.elements.popper, n) && (t.elements.arrow = n));
}
const pue = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: due,
  effect: hue,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function pu(e) {
  return e.split("-")[1];
}
var fue = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function gue(e, t) {
  var r = e.x, i = e.y, n = t.devicePixelRatio || 1;
  return {
    x: du(r * n) / n || 0,
    y: du(i * n) / n || 0
  };
}
function sR(e) {
  var t, r = e.popper, i = e.popperRect, n = e.placement, o = e.variation, s = e.offsets, a = e.position, l = e.gpuAcceleration, u = e.adaptive, c = e.roundOffsets, d = e.isFixed, h = s.x, p = h === void 0 ? 0 : h, g = s.y, m = g === void 0 ? 0 : g, f = typeof c == "function" ? c({
    x: p,
    y: m
  }) : {
    x: p,
    y: m
  };
  p = f.x, m = f.y;
  var C = s.hasOwnProperty("x"), w = s.hasOwnProperty("y"), E = ri, b = ti, y = window;
  if (u) {
    var S = kh(r), x = "clientHeight", R = "clientWidth";
    if (S === xi(r) && (S = Cs(r), xo(S).position !== "static" && a === "absolute" && (x = "scrollHeight", R = "scrollWidth")), S = S, n === ti || (n === ri || n === Xi) && o === Jd) {
      b = Yi;
      var P = d && S === y && y.visualViewport ? y.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        S[x]
      );
      m -= P - i.height, m *= l ? 1 : -1;
    }
    if (n === ri || (n === ti || n === Yi) && o === Jd) {
      E = Xi;
      var O = d && S === y && y.visualViewport ? y.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        S[R]
      );
      p -= O - i.width, p *= l ? 1 : -1;
    }
  }
  var I = Object.assign({
    position: a
  }, u && fue), M = c === !0 ? gue({
    x: p,
    y: m
  }, xi(r)) : {
    x: p,
    y: m
  };
  if (p = M.x, m = M.y, l) {
    var _;
    return Object.assign({}, I, (_ = {}, _[b] = w ? "0" : "", _[E] = C ? "0" : "", _.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", _));
  }
  return Object.assign({}, I, (t = {}, t[b] = w ? m + "px" : "", t[E] = C ? p + "px" : "", t.transform = "", t));
}
function mue(e) {
  var t = e.state, r = e.options, i = r.gpuAcceleration, n = i === void 0 ? !0 : i, o = r.adaptive, s = o === void 0 ? !0 : o, a = r.roundOffsets, l = a === void 0 ? !0 : a, u = {
    placement: Gn(t.placement),
    variation: pu(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, sR(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, sR(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const vue = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: mue,
  data: {}
};
var fp = {
  passive: !0
};
function Cue(e) {
  var t = e.state, r = e.instance, i = e.options, n = i.scroll, o = n === void 0 ? !0 : n, s = i.resize, a = s === void 0 ? !0 : s, l = xi(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", r.update, fp);
  }), a && l.addEventListener("resize", r.update, fp), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", r.update, fp);
    }), a && l.removeEventListener("resize", r.update, fp);
  };
}
const yue = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Cue,
  data: {}
};
var bue = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Gp(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return bue[t];
  });
}
var wue = {
  start: "end",
  end: "start"
};
function aR(e) {
  return e.replace(/start|end/g, function(t) {
    return wue[t];
  });
}
function jE(e) {
  var t = xi(e), r = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: i
  };
}
function zE(e) {
  return hu(Cs(e)).left + jE(e).scrollLeft;
}
function Sue(e, t) {
  var r = xi(e), i = Cs(e), n = r.visualViewport, o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, s = n.height;
    var u = mL();
    (u || !u && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + zE(e),
    y: l
  };
}
function Eue(e) {
  var t, r = Cs(e), i = jE(e), n = (t = e.ownerDocument) == null ? void 0 : t.body, o = Js(r.scrollWidth, r.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), s = Js(r.scrollHeight, r.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + zE(e), l = -i.scrollTop;
  return xo(n || r).direction === "rtl" && (a += Js(r.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function UE(e) {
  var t = xo(e), r = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + n + i);
}
function wL(e) {
  return ["html", "body", "#document"].indexOf(Kn(e)) >= 0 ? e.ownerDocument.body : $i(e) && UE(e) ? e : wL(lv(e));
}
function Wc(e, t) {
  var r;
  t === void 0 && (t = []);
  var i = wL(e), n = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = xi(i), s = n ? [o].concat(o.visualViewport || [], UE(i) ? i : []) : i, a = t.concat(s);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Wc(lv(s)))
  );
}
function iw(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function xue(e, t) {
  var r = hu(e, !1, t === "fixed");
  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;
}
function lR(e, t, r) {
  return t === pL ? iw(Sue(e, r)) : ya(t) ? xue(t, r) : iw(Eue(Cs(e)));
}
function Aue(e) {
  var t = Wc(lv(e)), r = ["absolute", "fixed"].indexOf(xo(e).position) >= 0, i = r && $i(e) ? kh(e) : e;
  return ya(i) ? t.filter(function(n) {
    return ya(n) && vL(n, i) && Kn(n) !== "body";
  }) : [];
}
function Due(e, t, r, i) {
  var n = t === "clippingParents" ? Aue(e) : [].concat(t), o = [].concat(n, [r]), s = o[0], a = o.reduce(function(l, u) {
    var c = lR(e, u, i);
    return l.top = Js(c.top, l.top), l.right = Sg(c.right, l.right), l.bottom = Sg(c.bottom, l.bottom), l.left = Js(c.left, l.left), l;
  }, lR(e, s, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function SL(e) {
  var t = e.reference, r = e.element, i = e.placement, n = i ? Gn(i) : null, o = i ? pu(i) : null, s = t.x + t.width / 2 - r.width / 2, a = t.y + t.height / 2 - r.height / 2, l;
  switch (n) {
    case ti:
      l = {
        x: s,
        y: t.y - r.height
      };
      break;
    case Yi:
      l = {
        x: s,
        y: t.y + t.height
      };
      break;
    case Xi:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case ri:
      l = {
        x: t.x - r.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var u = n ? $E(n) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case cu:
        l[u] = l[u] - (t[c] / 2 - r[c] / 2);
        break;
      case Jd:
        l[u] = l[u] + (t[c] / 2 - r[c] / 2);
        break;
    }
  }
  return l;
}
function Qd(e, t) {
  t === void 0 && (t = {});
  var r = t, i = r.placement, n = i === void 0 ? e.placement : i, o = r.strategy, s = o === void 0 ? e.strategy : o, a = r.boundary, l = a === void 0 ? Yle : a, u = r.rootBoundary, c = u === void 0 ? pL : u, d = r.elementContext, h = d === void 0 ? mc : d, p = r.altBoundary, g = p === void 0 ? !1 : p, m = r.padding, f = m === void 0 ? 0 : m, C = yL(typeof f != "number" ? f : bL(f, Gh)), w = h === mc ? Xle : mc, E = e.rects.popper, b = e.elements[g ? w : h], y = Due(ya(b) ? b : b.contextElement || Cs(e.elements.popper), l, c, s), S = hu(e.elements.reference), x = SL({
    reference: S,
    element: E,
    placement: n
  }), R = iw(Object.assign({}, E, x)), P = h === mc ? R : S, O = {
    top: y.top - P.top + C.top,
    bottom: P.bottom - y.bottom + C.bottom,
    left: y.left - P.left + C.left,
    right: P.right - y.right + C.right
  }, I = e.modifiersData.offset;
  if (h === mc && I) {
    var M = I[n];
    Object.keys(O).forEach(function(_) {
      var G = [Xi, Yi].indexOf(_) >= 0 ? 1 : -1, F = [ti, Yi].indexOf(_) >= 0 ? "y" : "x";
      O[_] += M[F] * G;
    });
  }
  return O;
}
function Tue(e, t) {
  t === void 0 && (t = {});
  var r = t, i = r.placement, n = r.boundary, o = r.rootBoundary, s = r.padding, a = r.flipVariations, l = r.allowedAutoPlacements, u = l === void 0 ? fL : l, c = pu(i), d = c ? a ? nR : nR.filter(function(g) {
    return pu(g) === c;
  }) : Gh, h = d.filter(function(g) {
    return u.indexOf(g) >= 0;
  });
  h.length === 0 && (h = d);
  var p = h.reduce(function(g, m) {
    return g[m] = Qd(e, {
      placement: m,
      boundary: n,
      rootBoundary: o,
      padding: s
    })[Gn(m)], g;
  }, {});
  return Object.keys(p).sort(function(g, m) {
    return p[g] - p[m];
  });
}
function Rue(e) {
  if (Gn(e) === HE)
    return [];
  var t = Gp(e);
  return [aR(e), t, aR(t)];
}
function Pue(e) {
  var t = e.state, r = e.options, i = e.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = r.mainAxis, o = n === void 0 ? !0 : n, s = r.altAxis, a = s === void 0 ? !0 : s, l = r.fallbackPlacements, u = r.padding, c = r.boundary, d = r.rootBoundary, h = r.altBoundary, p = r.flipVariations, g = p === void 0 ? !0 : p, m = r.allowedAutoPlacements, f = t.options.placement, C = Gn(f), w = C === f, E = l || (w || !g ? [Gp(f)] : Rue(f)), b = [f].concat(E).reduce(function(oe, ie) {
      return oe.concat(Gn(ie) === HE ? Tue(t, {
        placement: ie,
        boundary: c,
        rootBoundary: d,
        padding: u,
        flipVariations: g,
        allowedAutoPlacements: m
      }) : ie);
    }, []), y = t.rects.reference, S = t.rects.popper, x = /* @__PURE__ */ new Map(), R = !0, P = b[0], O = 0; O < b.length; O++) {
      var I = b[O], M = Gn(I), _ = pu(I) === cu, G = [ti, Yi].indexOf(M) >= 0, F = G ? "width" : "height", N = Qd(t, {
        placement: I,
        boundary: c,
        rootBoundary: d,
        altBoundary: h,
        padding: u
      }), V = G ? _ ? Xi : ri : _ ? Yi : ti;
      y[F] > S[F] && (V = Gp(V));
      var B = Gp(V), $ = [];
      if (o && $.push(N[M] <= 0), a && $.push(N[V] <= 0, N[B] <= 0), $.every(function(oe) {
        return oe;
      })) {
        P = I, R = !1;
        break;
      }
      x.set(I, $);
    }
    if (R)
      for (var L = g ? 3 : 1, z = function(ie) {
        var le = b.find(function(ce) {
          var he = x.get(ce);
          if (he)
            return he.slice(0, ie).every(function(Z) {
              return Z;
            });
        });
        if (le)
          return P = le, "break";
      }, j = L; j > 0; j--) {
        var U = z(j);
        if (U === "break") break;
      }
    t.placement !== P && (t.modifiersData[i]._skip = !0, t.placement = P, t.reset = !0);
  }
}
const Iue = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Pue,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function uR(e, t, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - r.y,
    right: e.right - t.width + r.x,
    bottom: e.bottom - t.height + r.y,
    left: e.left - t.width - r.x
  };
}
function cR(e) {
  return [ti, Xi, Yi, ri].some(function(t) {
    return e[t] >= 0;
  });
}
function Oue(e) {
  var t = e.state, r = e.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, s = Qd(t, {
    elementContext: "reference"
  }), a = Qd(t, {
    altBoundary: !0
  }), l = uR(s, i), u = uR(a, n, o), c = cR(l), d = cR(u);
  t.modifiersData[r] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": d
  });
}
const Mue = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Oue
};
function Fue(e, t, r) {
  var i = Gn(e), n = [ri, ti].indexOf(i) >= 0 ? -1 : 1, o = typeof r == "function" ? r(Object.assign({}, t, {
    placement: e
  })) : r, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * n, [ri, Xi].indexOf(i) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function _ue(e) {
  var t = e.state, r = e.options, i = e.name, n = r.offset, o = n === void 0 ? [0, 0] : n, s = fL.reduce(function(c, d) {
    return c[d] = Fue(d, t.rects, o), c;
  }, {}), a = s[t.placement], l = a.x, u = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[i] = s;
}
const Nue = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: _ue
};
function Lue(e) {
  var t = e.state, r = e.name;
  t.modifiersData[r] = SL({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const Gue = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Lue,
  data: {}
};
function kue(e) {
  return e === "x" ? "y" : "x";
}
function Vue(e) {
  var t = e.state, r = e.options, i = e.name, n = r.mainAxis, o = n === void 0 ? !0 : n, s = r.altAxis, a = s === void 0 ? !1 : s, l = r.boundary, u = r.rootBoundary, c = r.altBoundary, d = r.padding, h = r.tether, p = h === void 0 ? !0 : h, g = r.tetherOffset, m = g === void 0 ? 0 : g, f = Qd(t, {
    boundary: l,
    rootBoundary: u,
    padding: d,
    altBoundary: c
  }), C = Gn(t.placement), w = pu(t.placement), E = !w, b = $E(C), y = kue(b), S = t.modifiersData.popperOffsets, x = t.rects.reference, R = t.rects.popper, P = typeof m == "function" ? m(Object.assign({}, t.rects, {
    placement: t.placement
  })) : m, O = typeof P == "number" ? {
    mainAxis: P,
    altAxis: P
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, P), I = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, M = {
    x: 0,
    y: 0
  };
  if (S) {
    if (o) {
      var _, G = b === "y" ? ti : ri, F = b === "y" ? Yi : Xi, N = b === "y" ? "height" : "width", V = S[b], B = V + f[G], $ = V - f[F], L = p ? -R[N] / 2 : 0, z = w === cu ? x[N] : R[N], j = w === cu ? -R[N] : -x[N], U = t.elements.arrow, oe = p && U ? WE(U) : {
        width: 0,
        height: 0
      }, ie = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : CL(), le = ie[G], ce = ie[F], he = Bc(0, x[N], oe[N]), Z = E ? x[N] / 2 - L - he - le - O.mainAxis : z - he - le - O.mainAxis, se = E ? -x[N] / 2 + L + he + ce + O.mainAxis : j + he + ce + O.mainAxis, ae = t.elements.arrow && kh(t.elements.arrow), W = ae ? b === "y" ? ae.clientTop || 0 : ae.clientLeft || 0 : 0, be = (_ = I == null ? void 0 : I[b]) != null ? _ : 0, X = V + Z - be - W, Te = V + se - be, He = Bc(p ? Sg(B, X) : B, V, p ? Js($, Te) : $);
      S[b] = He, M[b] = He - V;
    }
    if (a) {
      var je, jt = b === "x" ? ti : ri, Mr = b === "x" ? Yi : Xi, Qt = S[y], Lt = y === "y" ? "height" : "width", zt = Qt + f[jt], er = Qt - f[Mr], ui = [ti, ri].indexOf(C) !== -1, Qi = (je = I == null ? void 0 : I[y]) != null ? je : 0, wt = ui ? zt : Qt - x[Lt] - R[Lt] - Qi + O.altAxis, pr = ui ? Qt + x[Lt] + R[Lt] - Qi - O.altAxis : er, ys = p && ui ? uue(wt, Qt, pr) : Bc(p ? wt : zt, Qt, p ? pr : er);
      S[y] = ys, M[y] = ys - Qt;
    }
    t.modifiersData[i] = M;
  }
}
const Hue = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Vue,
  requiresIfExists: ["offset"]
};
function Bue(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Wue(e) {
  return e === xi(e) || !$i(e) ? jE(e) : Bue(e);
}
function $ue(e) {
  var t = e.getBoundingClientRect(), r = du(t.width) / e.offsetWidth || 1, i = du(t.height) / e.offsetHeight || 1;
  return r !== 1 || i !== 1;
}
function jue(e, t, r) {
  r === void 0 && (r = !1);
  var i = $i(t), n = $i(t) && $ue(t), o = Cs(t), s = hu(e, n, r), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !r) && ((Kn(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  UE(o)) && (a = Wue(t)), $i(t) ? (l = hu(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = zE(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function zue(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), i = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    r.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!r.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return e.forEach(function(o) {
    r.has(o.name) || n(o);
  }), i;
}
function Uue(e) {
  var t = zue(e);
  return nue.reduce(function(r, i) {
    return r.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function Yue(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(r) {
      Promise.resolve().then(function() {
        t = void 0, r(e());
      });
    })), t;
  };
}
function Xue(e) {
  var t = e.reduce(function(r, i) {
    var n = r[i.name];
    return r[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, r;
  }, {});
  return Object.keys(t).map(function(r) {
    return t[r];
  });
}
var dR = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function hR() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function Kue(e) {
  e === void 0 && (e = {});
  var t = e, r = t.defaultModifiers, i = r === void 0 ? [] : r, n = t.defaultOptions, o = n === void 0 ? dR : n;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, dR, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], h = !1, p = {
      state: c,
      setOptions: function(C) {
        var w = typeof C == "function" ? C(c.options) : C;
        m(), c.options = Object.assign({}, o, c.options, w), c.scrollParents = {
          reference: ya(a) ? Wc(a) : a.contextElement ? Wc(a.contextElement) : [],
          popper: Wc(l)
        };
        var E = Uue(Xue([].concat(i, c.options.modifiers)));
        return c.orderedModifiers = E.filter(function(b) {
          return b.enabled;
        }), g(), p.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!h) {
          var C = c.elements, w = C.reference, E = C.popper;
          if (hR(w, E)) {
            c.rects = {
              reference: jue(w, kh(E), c.options.strategy === "fixed"),
              popper: WE(E)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(O) {
              return c.modifiersData[O.name] = Object.assign({}, O.data);
            });
            for (var b = 0; b < c.orderedModifiers.length; b++) {
              if (c.reset === !0) {
                c.reset = !1, b = -1;
                continue;
              }
              var y = c.orderedModifiers[b], S = y.fn, x = y.options, R = x === void 0 ? {} : x, P = y.name;
              typeof S == "function" && (c = S({
                state: c,
                options: R,
                name: P,
                instance: p
              }) || c);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Yue(function() {
        return new Promise(function(f) {
          p.forceUpdate(), f(c);
        });
      }),
      destroy: function() {
        m(), h = !0;
      }
    };
    if (!hR(a, l))
      return p;
    p.setOptions(u).then(function(f) {
      !h && u.onFirstUpdate && u.onFirstUpdate(f);
    });
    function g() {
      c.orderedModifiers.forEach(function(f) {
        var C = f.name, w = f.options, E = w === void 0 ? {} : w, b = f.effect;
        if (typeof b == "function") {
          var y = b({
            state: c,
            name: C,
            instance: p,
            options: E
          }), S = function() {
          };
          d.push(y || S);
        }
      });
    }
    function m() {
      d.forEach(function(f) {
        return f();
      }), d = [];
    }
    return p;
  };
}
var que = [yue, Gue, vue, gL, Nue, Iue, Hue, pue, Mue], Zue = /* @__PURE__ */ Kue({
  defaultModifiers: que
}), Jue = "tippy-box", EL = "tippy-content", Que = "tippy-backdrop", xL = "tippy-arrow", AL = "tippy-svg-arrow", Is = {
  passive: !0,
  capture: !0
}, DL = function() {
  return document.body;
};
function ece(e, t) {
  return {}.hasOwnProperty.call(e, t);
}
function AC(e, t, r) {
  if (Array.isArray(e)) {
    var i = e[t];
    return i ?? (Array.isArray(r) ? r[t] : r);
  }
  return e;
}
function YE(e, t) {
  var r = {}.toString.call(e);
  return r.indexOf("[object") === 0 && r.indexOf(t + "]") > -1;
}
function TL(e, t) {
  return typeof e == "function" ? e.apply(void 0, t) : e;
}
function pR(e, t) {
  if (t === 0)
    return e;
  var r;
  return function(i) {
    clearTimeout(r), r = setTimeout(function() {
      e(i);
    }, t);
  };
}
function tce(e, t) {
  var r = Object.assign({}, e);
  return t.forEach(function(i) {
    delete r[i];
  }), r;
}
function rce(e) {
  return e.split(/\s+/).filter(Boolean);
}
function nl(e) {
  return [].concat(e);
}
function fR(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function ice(e) {
  return e.filter(function(t, r) {
    return e.indexOf(t) === r;
  });
}
function nce(e) {
  return e.split("-")[0];
}
function Eg(e) {
  return [].slice.call(e);
}
function gR(e) {
  return Object.keys(e).reduce(function(t, r) {
    return e[r] !== void 0 && (t[r] = e[r]), t;
  }, {});
}
function $c() {
  return document.createElement("div");
}
function eh(e) {
  return ["Element", "Fragment"].some(function(t) {
    return YE(e, t);
  });
}
function oce(e) {
  return YE(e, "NodeList");
}
function sce(e) {
  return YE(e, "MouseEvent");
}
function ace(e) {
  return !!(e && e._tippy && e._tippy.reference === e);
}
function lce(e) {
  return eh(e) ? [e] : oce(e) ? Eg(e) : Array.isArray(e) ? e : Eg(document.querySelectorAll(e));
}
function DC(e, t) {
  e.forEach(function(r) {
    r && (r.style.transitionDuration = t + "ms");
  });
}
function mR(e, t) {
  e.forEach(function(r) {
    r && r.setAttribute("data-state", t);
  });
}
function uce(e) {
  var t, r = nl(e), i = r[0];
  return i != null && (t = i.ownerDocument) != null && t.body ? i.ownerDocument : document;
}
function cce(e, t) {
  var r = t.clientX, i = t.clientY;
  return e.every(function(n) {
    var o = n.popperRect, s = n.popperState, a = n.props, l = a.interactiveBorder, u = nce(s.placement), c = s.modifiersData.offset;
    if (!c)
      return !0;
    var d = u === "bottom" ? c.top.y : 0, h = u === "top" ? c.bottom.y : 0, p = u === "right" ? c.left.x : 0, g = u === "left" ? c.right.x : 0, m = o.top - i + d > l, f = i - o.bottom - h > l, C = o.left - r + p > l, w = r - o.right - g > l;
    return m || f || C || w;
  });
}
function TC(e, t, r) {
  var i = t + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(n) {
    e[i](n, r);
  });
}
function vR(e, t) {
  for (var r = t; r; ) {
    var i;
    if (e.contains(r))
      return !0;
    r = r.getRootNode == null || (i = r.getRootNode()) == null ? void 0 : i.host;
  }
  return !1;
}
var xn = {
  isTouch: !1
}, CR = 0;
function dce() {
  xn.isTouch || (xn.isTouch = !0, window.performance && document.addEventListener("mousemove", RL));
}
function RL() {
  var e = performance.now();
  e - CR < 20 && (xn.isTouch = !1, document.removeEventListener("mousemove", RL)), CR = e;
}
function hce() {
  var e = document.activeElement;
  if (ace(e)) {
    var t = e._tippy;
    e.blur && !t.state.isVisible && e.blur();
  }
}
function pce() {
  document.addEventListener("touchstart", dce, Is), window.addEventListener("blur", hce);
}
var fce = typeof window < "u" && typeof document < "u", gce = fce ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function Za(e) {
  var t = e === "destroy" ? "n already-" : " ";
  return [e + "() was called on a" + t + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function yR(e) {
  var t = /[ \t]{2,}/g, r = /^[ \t]*/gm;
  return e.replace(t, " ").replace(r, "").trim();
}
function mce(e) {
  return yR(`
  %ctippy.js

  %c` + yR(e) + `

  %c This is a development-only message. It will be removed in production.
  `);
}
function PL(e) {
  return [
    mce(e),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var th;
process.env.NODE_ENV !== "production" && vce();
function vce() {
  th = /* @__PURE__ */ new Set();
}
function ro(e, t) {
  if (e && !th.has(t)) {
    var r;
    th.add(t), (r = console).warn.apply(r, PL(t));
  }
}
function nw(e, t) {
  if (e && !th.has(t)) {
    var r;
    th.add(t), (r = console).error.apply(r, PL(t));
  }
}
function Cce(e) {
  var t = !e, r = Object.prototype.toString.call(e) === "[object Object]" && !e.addEventListener;
  nw(t, ["tippy() was passed", "`" + String(e) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), nw(r, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var IL = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, yce = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, mi = Object.assign({
  appendTo: DL,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, IL, yce), bce = Object.keys(mi), wce = function(t) {
  process.env.NODE_ENV !== "production" && ML(t, []);
  var r = Object.keys(t);
  r.forEach(function(i) {
    mi[i] = t[i];
  });
};
function OL(e) {
  var t = e.plugins || [], r = t.reduce(function(i, n) {
    var o = n.name, s = n.defaultValue;
    if (o) {
      var a;
      i[o] = e[o] !== void 0 ? e[o] : (a = mi[o]) != null ? a : s;
    }
    return i;
  }, {});
  return Object.assign({}, e, r);
}
function Sce(e, t) {
  var r = t ? Object.keys(OL(Object.assign({}, mi, {
    plugins: t
  }))) : bce, i = r.reduce(function(n, o) {
    var s = (e.getAttribute("data-tippy-" + o) || "").trim();
    if (!s)
      return n;
    if (o === "content")
      n[o] = s;
    else
      try {
        n[o] = JSON.parse(s);
      } catch {
        n[o] = s;
      }
    return n;
  }, {});
  return i;
}
function bR(e, t) {
  var r = Object.assign({}, t, {
    content: TL(t.content, [e])
  }, t.ignoreAttributes ? {} : Sce(e, t.plugins));
  return r.aria = Object.assign({}, mi.aria, r.aria), r.aria = {
    expanded: r.aria.expanded === "auto" ? t.interactive : r.aria.expanded,
    content: r.aria.content === "auto" ? t.interactive ? null : "describedby" : r.aria.content
  }, r;
}
function ML(e, t) {
  e === void 0 && (e = {}), t === void 0 && (t = []);
  var r = Object.keys(e);
  r.forEach(function(i) {
    var n = tce(mi, Object.keys(IL)), o = !ece(n, i);
    o && (o = t.filter(function(s) {
      return s.name === i;
    }).length === 0), ro(o, ["`" + i + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var Ece = function() {
  return "innerHTML";
};
function ow(e, t) {
  e[Ece()] = t;
}
function wR(e) {
  var t = $c();
  return e === !0 ? t.className = xL : (t.className = AL, eh(e) ? t.appendChild(e) : ow(t, e)), t;
}
function SR(e, t) {
  eh(t.content) ? (ow(e, ""), e.appendChild(t.content)) : typeof t.content != "function" && (t.allowHTML ? ow(e, t.content) : e.textContent = t.content);
}
function sw(e) {
  var t = e.firstElementChild, r = Eg(t.children);
  return {
    box: t,
    content: r.find(function(i) {
      return i.classList.contains(EL);
    }),
    arrow: r.find(function(i) {
      return i.classList.contains(xL) || i.classList.contains(AL);
    }),
    backdrop: r.find(function(i) {
      return i.classList.contains(Que);
    })
  };
}
function FL(e) {
  var t = $c(), r = $c();
  r.className = Jue, r.setAttribute("data-state", "hidden"), r.setAttribute("tabindex", "-1");
  var i = $c();
  i.className = EL, i.setAttribute("data-state", "hidden"), SR(i, e.props), t.appendChild(r), r.appendChild(i), n(e.props, e.props);
  function n(o, s) {
    var a = sw(t), l = a.box, u = a.content, c = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (o.content !== s.content || o.allowHTML !== s.allowHTML) && SR(u, e.props), s.arrow ? c ? o.arrow !== s.arrow && (l.removeChild(c), l.appendChild(wR(s.arrow))) : l.appendChild(wR(s.arrow)) : c && l.removeChild(c);
  }
  return {
    popper: t,
    onUpdate: n
  };
}
FL.$$tippy = !0;
var xce = 1, gp = [], RC = [];
function Ace(e, t) {
  var r = bR(e, Object.assign({}, mi, OL(gR(t)))), i, n, o, s = !1, a = !1, l = !1, u = !1, c, d, h, p = [], g = pR(X, r.interactiveDebounce), m, f = xce++, C = null, w = ice(r.plugins), E = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: f,
    reference: e,
    popper: $c(),
    popperInstance: C,
    props: r,
    state: E,
    plugins: w,
    // methods
    clearDelayTimeouts: wt,
    setProps: pr,
    setContent: ys,
    show: v1,
    hide: C1,
    hideWithInteractivity: y1,
    enable: ui,
    disable: Qi,
    unmount: b1,
    destroy: w1
  };
  if (!r.render)
    return process.env.NODE_ENV !== "production" && nw(!0, "render() function has not been supplied."), b;
  var y = r.render(b), S = y.popper, x = y.onUpdate;
  S.setAttribute("data-tippy-root", ""), S.id = "tippy-" + b.id, b.popper = S, e._tippy = b, S._tippy = b;
  var R = w.map(function(J) {
    return J.fn(b);
  }), P = e.hasAttribute("aria-expanded");
  return ae(), L(), V(), B("onCreate", [b]), r.showOnCreate && zt(), S.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), S.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && G().addEventListener("mousemove", g);
  }), b;
  function O() {
    var J = b.props.touch;
    return Array.isArray(J) ? J : [J, 0];
  }
  function I() {
    return O()[0] === "hold";
  }
  function M() {
    var J;
    return !!((J = b.props.render) != null && J.$$tippy);
  }
  function _() {
    return m || e;
  }
  function G() {
    var J = _().parentNode;
    return J ? uce(J) : document;
  }
  function F() {
    return sw(S);
  }
  function N(J) {
    return b.state.isMounted && !b.state.isVisible || xn.isTouch || c && c.type === "focus" ? 0 : AC(b.props.delay, J ? 0 : 1, mi.delay);
  }
  function V(J) {
    J === void 0 && (J = !1), S.style.pointerEvents = b.props.interactive && !J ? "" : "none", S.style.zIndex = "" + b.props.zIndex;
  }
  function B(J, Se, Ne) {
    if (Ne === void 0 && (Ne = !0), R.forEach(function(Ye) {
      Ye[J] && Ye[J].apply(Ye, Se);
    }), Ne) {
      var dt;
      (dt = b.props)[J].apply(dt, Se);
    }
  }
  function $() {
    var J = b.props.aria;
    if (J.content) {
      var Se = "aria-" + J.content, Ne = S.id, dt = nl(b.props.triggerTarget || e);
      dt.forEach(function(Ye) {
        var Fr = Ye.getAttribute(Se);
        if (b.state.isVisible)
          Ye.setAttribute(Se, Fr ? Fr + " " + Ne : Ne);
        else {
          var Di = Fr && Fr.replace(Ne, "").trim();
          Di ? Ye.setAttribute(Se, Di) : Ye.removeAttribute(Se);
        }
      });
    }
  }
  function L() {
    if (!(P || !b.props.aria.expanded)) {
      var J = nl(b.props.triggerTarget || e);
      J.forEach(function(Se) {
        b.props.interactive ? Se.setAttribute("aria-expanded", b.state.isVisible && Se === _() ? "true" : "false") : Se.removeAttribute("aria-expanded");
      });
    }
  }
  function z() {
    G().removeEventListener("mousemove", g), gp = gp.filter(function(J) {
      return J !== g;
    });
  }
  function j(J) {
    if (!(xn.isTouch && (l || J.type === "mousedown"))) {
      var Se = J.composedPath && J.composedPath()[0] || J.target;
      if (!(b.props.interactive && vR(S, Se))) {
        if (nl(b.props.triggerTarget || e).some(function(Ne) {
          return vR(Ne, Se);
        })) {
          if (xn.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          B("onClickOutside", [b, J]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || le());
      }
    }
  }
  function U() {
    l = !0;
  }
  function oe() {
    l = !1;
  }
  function ie() {
    var J = G();
    J.addEventListener("mousedown", j, !0), J.addEventListener("touchend", j, Is), J.addEventListener("touchstart", oe, Is), J.addEventListener("touchmove", U, Is);
  }
  function le() {
    var J = G();
    J.removeEventListener("mousedown", j, !0), J.removeEventListener("touchend", j, Is), J.removeEventListener("touchstart", oe, Is), J.removeEventListener("touchmove", U, Is);
  }
  function ce(J, Se) {
    Z(J, function() {
      !b.state.isVisible && S.parentNode && S.parentNode.contains(S) && Se();
    });
  }
  function he(J, Se) {
    Z(J, Se);
  }
  function Z(J, Se) {
    var Ne = F().box;
    function dt(Ye) {
      Ye.target === Ne && (TC(Ne, "remove", dt), Se());
    }
    if (J === 0)
      return Se();
    TC(Ne, "remove", d), TC(Ne, "add", dt), d = dt;
  }
  function se(J, Se, Ne) {
    Ne === void 0 && (Ne = !1);
    var dt = nl(b.props.triggerTarget || e);
    dt.forEach(function(Ye) {
      Ye.addEventListener(J, Se, Ne), p.push({
        node: Ye,
        eventType: J,
        handler: Se,
        options: Ne
      });
    });
  }
  function ae() {
    I() && (se("touchstart", be, {
      passive: !0
    }), se("touchend", Te, {
      passive: !0
    })), rce(b.props.trigger).forEach(function(J) {
      if (J !== "manual")
        switch (se(J, be), J) {
          case "mouseenter":
            se("mouseleave", Te);
            break;
          case "focus":
            se(gce ? "focusout" : "blur", He);
            break;
          case "focusin":
            se("focusout", He);
            break;
        }
    });
  }
  function W() {
    p.forEach(function(J) {
      var Se = J.node, Ne = J.eventType, dt = J.handler, Ye = J.options;
      Se.removeEventListener(Ne, dt, Ye);
    }), p = [];
  }
  function be(J) {
    var Se, Ne = !1;
    if (!(!b.state.isEnabled || je(J) || a)) {
      var dt = ((Se = c) == null ? void 0 : Se.type) === "focus";
      c = J, m = J.currentTarget, L(), !b.state.isVisible && sce(J) && gp.forEach(function(Ye) {
        return Ye(J);
      }), J.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || s) && b.props.hideOnClick !== !1 && b.state.isVisible ? Ne = !0 : zt(J), J.type === "click" && (s = !Ne), Ne && !dt && er(J);
    }
  }
  function X(J) {
    var Se = J.target, Ne = _().contains(Se) || S.contains(Se);
    if (!(J.type === "mousemove" && Ne)) {
      var dt = Lt().concat(S).map(function(Ye) {
        var Fr, Di = Ye._tippy, za = (Fr = Di.popperInstance) == null ? void 0 : Fr.state;
        return za ? {
          popperRect: Ye.getBoundingClientRect(),
          popperState: za,
          props: r
        } : null;
      }).filter(Boolean);
      cce(dt, J) && (z(), er(J));
    }
  }
  function Te(J) {
    var Se = je(J) || b.props.trigger.indexOf("click") >= 0 && s;
    if (!Se) {
      if (b.props.interactive) {
        b.hideWithInteractivity(J);
        return;
      }
      er(J);
    }
  }
  function He(J) {
    b.props.trigger.indexOf("focusin") < 0 && J.target !== _() || b.props.interactive && J.relatedTarget && S.contains(J.relatedTarget) || er(J);
  }
  function je(J) {
    return xn.isTouch ? I() !== J.type.indexOf("touch") >= 0 : !1;
  }
  function jt() {
    Mr();
    var J = b.props, Se = J.popperOptions, Ne = J.placement, dt = J.offset, Ye = J.getReferenceClientRect, Fr = J.moveTransition, Di = M() ? sw(S).arrow : null, za = Ye ? {
      getBoundingClientRect: Ye,
      contextElement: Ye.contextElement || _()
    } : e, wx = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Xh) {
        var Ua = Xh.state;
        if (M()) {
          var S1 = F(), Av = S1.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Kh) {
            Kh === "placement" ? Av.setAttribute("data-placement", Ua.placement) : Ua.attributes.popper["data-popper-" + Kh] ? Av.setAttribute("data-" + Kh, "") : Av.removeAttribute("data-" + Kh);
          }), Ua.attributes.popper = {};
        }
      }
    }, bs = [{
      name: "offset",
      options: {
        offset: dt
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Fr
      }
    }, wx];
    M() && Di && bs.push({
      name: "arrow",
      options: {
        element: Di,
        padding: 3
      }
    }), bs.push.apply(bs, (Se == null ? void 0 : Se.modifiers) || []), b.popperInstance = Zue(za, S, Object.assign({}, Se, {
      placement: Ne,
      onFirstUpdate: h,
      modifiers: bs
    }));
  }
  function Mr() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function Qt() {
    var J = b.props.appendTo, Se, Ne = _();
    b.props.interactive && J === DL || J === "parent" ? Se = Ne.parentNode : Se = TL(J, [Ne]), Se.contains(S) || Se.appendChild(S), b.state.isMounted = !0, jt(), process.env.NODE_ENV !== "production" && ro(b.props.interactive && J === mi.appendTo && Ne.nextElementSibling !== S, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function Lt() {
    return Eg(S.querySelectorAll("[data-tippy-root]"));
  }
  function zt(J) {
    b.clearDelayTimeouts(), J && B("onTrigger", [b, J]), ie();
    var Se = N(!0), Ne = O(), dt = Ne[0], Ye = Ne[1];
    xn.isTouch && dt === "hold" && Ye && (Se = Ye), Se ? i = setTimeout(function() {
      b.show();
    }, Se) : b.show();
  }
  function er(J) {
    if (b.clearDelayTimeouts(), B("onUntrigger", [b, J]), !b.state.isVisible) {
      le();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(J.type) >= 0 && s)) {
      var Se = N(!1);
      Se ? n = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, Se) : o = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function ui() {
    b.state.isEnabled = !0;
  }
  function Qi() {
    b.hide(), b.state.isEnabled = !1;
  }
  function wt() {
    clearTimeout(i), clearTimeout(n), cancelAnimationFrame(o);
  }
  function pr(J) {
    if (process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("setProps")), !b.state.isDestroyed) {
      B("onBeforeUpdate", [b, J]), W();
      var Se = b.props, Ne = bR(e, Object.assign({}, Se, gR(J), {
        ignoreAttributes: !0
      }));
      b.props = Ne, ae(), Se.interactiveDebounce !== Ne.interactiveDebounce && (z(), g = pR(X, Ne.interactiveDebounce)), Se.triggerTarget && !Ne.triggerTarget ? nl(Se.triggerTarget).forEach(function(dt) {
        dt.removeAttribute("aria-expanded");
      }) : Ne.triggerTarget && e.removeAttribute("aria-expanded"), L(), V(), x && x(Se, Ne), b.popperInstance && (jt(), Lt().forEach(function(dt) {
        requestAnimationFrame(dt._tippy.popperInstance.forceUpdate);
      })), B("onAfterUpdate", [b, J]);
    }
  }
  function ys(J) {
    b.setProps({
      content: J
    });
  }
  function v1() {
    process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("show"));
    var J = b.state.isVisible, Se = b.state.isDestroyed, Ne = !b.state.isEnabled, dt = xn.isTouch && !b.props.touch, Ye = AC(b.props.duration, 0, mi.duration);
    if (!(J || Se || Ne || dt) && !_().hasAttribute("disabled") && (B("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, M() && (S.style.visibility = "visible"), V(), ie(), b.state.isMounted || (S.style.transition = "none"), M()) {
        var Fr = F(), Di = Fr.box, za = Fr.content;
        DC([Di, za], 0);
      }
      h = function() {
        var bs;
        if (!(!b.state.isVisible || u)) {
          if (u = !0, S.offsetHeight, S.style.transition = b.props.moveTransition, M() && b.props.animation) {
            var xv = F(), Xh = xv.box, Ua = xv.content;
            DC([Xh, Ua], Ye), mR([Xh, Ua], "visible");
          }
          $(), L(), fR(RC, b), (bs = b.popperInstance) == null || bs.forceUpdate(), B("onMount", [b]), b.props.animation && M() && he(Ye, function() {
            b.state.isShown = !0, B("onShown", [b]);
          });
        }
      }, Qt();
    }
  }
  function C1() {
    process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("hide"));
    var J = !b.state.isVisible, Se = b.state.isDestroyed, Ne = !b.state.isEnabled, dt = AC(b.props.duration, 1, mi.duration);
    if (!(J || Se || Ne) && (B("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, u = !1, s = !1, M() && (S.style.visibility = "hidden"), z(), le(), V(!0), M()) {
        var Ye = F(), Fr = Ye.box, Di = Ye.content;
        b.props.animation && (DC([Fr, Di], dt), mR([Fr, Di], "hidden"));
      }
      $(), L(), b.props.animation ? M() && ce(dt, b.unmount) : b.unmount();
    }
  }
  function y1(J) {
    process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("hideWithInteractivity")), G().addEventListener("mousemove", g), fR(gp, g), g(J);
  }
  function b1() {
    process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (Mr(), Lt().forEach(function(J) {
      J._tippy.unmount();
    }), S.parentNode && S.parentNode.removeChild(S), RC = RC.filter(function(J) {
      return J !== b;
    }), b.state.isMounted = !1, B("onHidden", [b]));
  }
  function w1() {
    process.env.NODE_ENV !== "production" && ro(b.state.isDestroyed, Za("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), W(), delete e._tippy, b.state.isDestroyed = !0, B("onDestroy", [b]));
  }
}
function Vh(e, t) {
  t === void 0 && (t = {});
  var r = mi.plugins.concat(t.plugins || []);
  process.env.NODE_ENV !== "production" && (Cce(e), ML(t, r)), pce();
  var i = Object.assign({}, t, {
    plugins: r
  }), n = lce(e);
  if (process.env.NODE_ENV !== "production") {
    var o = eh(i.content), s = n.length > 1;
    ro(o && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = n.reduce(function(l, u) {
    var c = u && Ace(u, i);
    return c && l.push(c), l;
  }, []);
  return eh(e) ? a[0] : a;
}
Vh.defaultProps = mi;
Vh.setDefaultProps = wce;
Vh.currentInput = xn;
Object.assign({}, gL, {
  effect: function(t) {
    var r = t.state, i = {
      popper: {
        position: r.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(r.elements.popper.style, i.popper), r.styles = i, r.elements.arrow && Object.assign(r.elements.arrow.style, i.arrow);
  }
});
Vh.setDefaultProps({
  render: FL
});
function _L(e, t) {
  if (e == null) return {};
  var r = {}, i = Object.keys(e), n, o;
  for (o = 0; o < i.length; o++)
    n = i[o], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
  return r;
}
var NL = typeof window < "u" && typeof document < "u";
function aw(e, t) {
  e && (typeof e == "function" && e(t), {}.hasOwnProperty.call(e, "current") && (e.current = t));
}
function ER() {
  return NL && document.createElement("div");
}
function Dce(e) {
  var t = {
    "data-placement": e.placement
  };
  return e.referenceHidden && (t["data-reference-hidden"] = ""), e.escaped && (t["data-escaped"] = ""), t;
}
function LL(e, t) {
  if (e === t)
    return !0;
  if (typeof e == "object" && e != null && typeof t == "object" && t != null) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (var r in e)
      if (t.hasOwnProperty(r)) {
        if (!LL(e[r], t[r]))
          return !1;
      } else
        return !1;
    return !0;
  } else
    return !1;
}
function Tce(e) {
  var t = [];
  return e.forEach(function(r) {
    t.find(function(i) {
      return LL(r, i);
    }) || t.push(r);
  }), t;
}
function Rce(e, t) {
  var r, i;
  return Object.assign({}, t, {
    popperOptions: Object.assign({}, e.popperOptions, t.popperOptions, {
      modifiers: Tce([].concat(((r = e.popperOptions) == null ? void 0 : r.modifiers) || [], ((i = t.popperOptions) == null ? void 0 : i.modifiers) || []))
    })
  });
}
var PC = NL ? Vi : gt;
function Pce(e) {
  var t = re();
  return t.current || (t.current = typeof e == "function" ? e() : e), t.current;
}
function xR(e, t, r) {
  r.split(/\s+/).forEach(function(i) {
    i && e.classList[t](i);
  });
}
var Ice = {
  name: "className",
  defaultValue: "",
  fn: function(t) {
    var r = t.popper.firstElementChild, i = function() {
      var a;
      return !!((a = t.props.render) != null && a.$$tippy);
    };
    function n() {
      if (t.props.className && !i()) {
        process.env.NODE_ENV !== "production" && console.warn(["@tippyjs/react: Cannot use `className` prop in conjunction with", "`render` prop. Place the className on the element you are", "rendering."].join(" "));
        return;
      }
      xR(r, "add", t.props.className);
    }
    function o() {
      i() && xR(r, "remove", t.props.className);
    }
    return {
      onCreate: n,
      onBeforeUpdate: o,
      onAfterUpdate: n
    };
  }
};
function Oce(e) {
  function t(r) {
    var i = r.children, n = r.content, o = r.visible, s = r.singleton, a = r.render, l = r.reference, u = r.disabled, c = u === void 0 ? !1 : u, d = r.ignoreAttributes, h = d === void 0 ? !0 : d;
    r.__source, r.__self;
    var p = _L(r, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]), g = o !== void 0, m = s !== void 0, f = ee(!1), C = f[0], w = f[1], E = ee({}), b = E[0], y = E[1], S = ee(), x = S[0], R = S[1], P = Pce(function() {
      return {
        container: ER(),
        renders: 1
      };
    }), O = Object.assign({
      ignoreAttributes: h
    }, p, {
      content: P.container
    });
    g && (process.env.NODE_ENV !== "production" && ["trigger", "hideOnClick", "showOnCreate"].forEach(function(G) {
      O[G] !== void 0 && console.warn(["@tippyjs/react: Cannot specify `" + G + "` prop in", "controlled mode (`visible` prop)"].join(" "));
    }), O.trigger = "manual", O.hideOnClick = !1), m && (c = !0);
    var I = O, M = O.plugins || [];
    a && (I = Object.assign({}, O, {
      plugins: m && s.data != null ? [].concat(M, [{
        fn: function() {
          return {
            onTrigger: function(N, V) {
              var B = s.data.children.find(function($) {
                var L = $.instance;
                return L.reference === V.currentTarget;
              });
              N.state.$$activeSingletonInstance = B.instance, R(B.content);
            }
          };
        }
      }]) : M,
      render: function() {
        return {
          popper: P.container
        };
      }
    }));
    var _ = [l].concat(i ? [i.type] : []);
    return PC(function() {
      var G = l;
      l && l.hasOwnProperty("current") && (G = l.current);
      var F = e(G || P.ref || ER(), Object.assign({}, I, {
        plugins: [Ice].concat(O.plugins || [])
      }));
      return P.instance = F, c && F.disable(), o && F.show(), m && s.hook({
        instance: F,
        content: n,
        props: I,
        setSingletonContent: R
      }), w(!0), function() {
        F.destroy(), s == null || s.cleanup(F);
      };
    }, _), PC(function() {
      var G;
      if (P.renders === 1) {
        P.renders++;
        return;
      }
      var F = P.instance;
      F.setProps(Rce(F.props, I)), (G = F.popperInstance) == null || G.forceUpdate(), c ? F.disable() : F.enable(), g && (o ? F.show() : F.hide()), m && s.hook({
        instance: F,
        content: n,
        props: I,
        setSingletonContent: R
      });
    }), PC(function() {
      var G;
      if (a) {
        var F = P.instance;
        F.setProps({
          popperOptions: Object.assign({}, F.props.popperOptions, {
            modifiers: [].concat((((G = F.props.popperOptions) == null ? void 0 : G.modifiers) || []).filter(function(N) {
              var V = N.name;
              return V !== "$$tippyReact";
            }), [{
              name: "$$tippyReact",
              enabled: !0,
              phase: "beforeWrite",
              requires: ["computeStyles"],
              fn: function(V) {
                var B, $ = V.state, L = (B = $.modifiersData) == null ? void 0 : B.hide;
                (b.placement !== $.placement || b.referenceHidden !== (L == null ? void 0 : L.isReferenceHidden) || b.escaped !== (L == null ? void 0 : L.hasPopperEscaped)) && y({
                  placement: $.placement,
                  referenceHidden: L == null ? void 0 : L.isReferenceHidden,
                  escaped: L == null ? void 0 : L.hasPopperEscaped
                }), $.attributes.popper = {};
              }
            }])
          })
        });
      }
    }, [b.placement, b.referenceHidden, b.escaped].concat(_)), /* @__PURE__ */ D.createElement(D.Fragment, null, i ? /* @__PURE__ */ Gt(i, {
      ref: function(F) {
        P.ref = F, aw(i.ref, F);
      }
    }) : null, C && /* @__PURE__ */ xa(a ? a(Dce(b), x, P.instance) : n, P.container));
  }
  return t;
}
var Mce = function(e, t) {
  return /* @__PURE__ */ ns(function(i, n) {
    var o = i.children, s = _L(i, ["children"]);
    return (
      // If I spread them separately here, Babel adds the _extends ponyfill for
      // some reason
      /* @__PURE__ */ D.createElement(e, Object.assign({}, t, s), o ? /* @__PURE__ */ Gt(o, {
        ref: function(l) {
          aw(n, l), aw(o.ref, l);
        }
      }) : null)
    );
  });
}, Fce = /* @__PURE__ */ Mce(/* @__PURE__ */ Oce(Vh));
const _ce = ({ children: e, content: t, ...r }) => {
  const { theme: i } = ku(), n = D.isValidElement(e) ? e : /* @__PURE__ */ H("span", { children: e });
  return /* @__PURE__ */ H(
    Fce,
    {
      content: t,
      theme: i,
      animation: "fade",
      duration: 200,
      delay: [200, 0],
      placement: "top",
      ...r,
      children: n
    }
  );
}, Nce = ({ id: e, message: t, type: r = "info", duration: i = 3e3, onDismiss: n }) => {
  const [o, s] = ee(!0);
  gt(() => {
    if (i > 0) {
      const u = setTimeout(() => {
        s(!1);
        const c = setTimeout(() => n(e), 300);
        return () => clearTimeout(c);
      }, i);
      return () => clearTimeout(u);
    }
  }, [i, e, n]);
  const a = {
    success: "bg-green-600 border-green-700 text-white",
    error: "bg-red-600 border-red-700 text-white",
    info: "bg-primary border-primary-focus text-white",
    // Adjusted for better theme contrast
    warning: "bg-orange-500 border-orange-600 text-white"
  }, l = {
    success: "",
    error: "",
    info: "",
    warning: ""
  };
  return /* @__PURE__ */ ve(
    Oa,
    {
      className: `p-4 mb-2 flex items-center shadow-lg transition-all duration-300 transform ${o ? "translate-x-0 opacity-100" : "translate-x-full opacity-0"} ${a[r]}`,
      padding: "p-0",
      border: "border-0",
      children: [
        /* @__PURE__ */ H("div", { className: "px-3 text-xl", children: l[r] }),
        /* @__PURE__ */ H("div", { className: "flex-1 py-4 text-base", children: t }),
        /* @__PURE__ */ H("button", { onClick: () => n(e), className: "px-3 py-4 text-white text-xl hover:bg-black/20 transition-colors", children: "" })
      ]
    }
  );
}, GL = Cn(void 0), vbe = () => {
  const e = bt(GL);
  if (e === void 0)
    throw new Error("useToast must be used within a ToastProvider");
  return e;
}, Cbe = ({ children: e }) => {
  const [t, r] = ee([]), i = fe((s, a = "info", l = 3e3) => {
    const u = Date.now().toString() + Math.random().toString(36).substring(2, 9);
    r((c) => [...c, { id: u, message: s, type: a, duration: l }]);
  }, []), n = fe((s) => {
    r((a) => a.filter((l) => l.id !== s));
  }, []), o = D.useMemo(() => ({ addToast: i, dismissToast: n }), [i, n]);
  return /* @__PURE__ */ ve(GL.Provider, { value: o, children: [
    e,
    xa(
      // This container holds all the toasts and positions them on the screen
      /* @__PURE__ */ H("div", { className: "fixed bottom-4 right-4 z-50 w-80 max-w-full space-y-2", children: t.map((s) => /* @__PURE__ */ H(
        Nce,
        {
          id: s.id,
          message: s.message,
          type: s.type,
          duration: s.duration,
          onDismiss: n
        },
        s.id
      )) }),
      document.body
      // Portal toasts to the body to escape stacking contexts
    )
  ] });
}, ybe = ({ children: e, className: t, value: r, onValueChange: i }) => {
  const n = D.Children.count(e), o = r !== void 0 && i !== void 0, s = D.Children.map(e, (a, l) => {
    if (!D.isValidElement(a))
      return a;
    let u = a.props.className || "";
    const c = a.props.value;
    n > 1 && (l === 0 ? u += " rounded-r-none" : l === n - 1 ? u += " rounded-l-none" : u += " rounded-none", l > 0 && (u += " -ml-px"));
    let d = { className: u };
    if (o) {
      const h = c === r;
      d.variant = h ? "primary" : "outline", h && (d.className += " shadow-inner"), d.onClick = (p) => {
        c !== void 0 && i(c), a.props.onClick && a.props.onClick(p);
      };
    }
    return D.cloneElement(a, d);
  });
  return /* @__PURE__ */ H("div", { className: `inline-flex items-center ${t || ""}`, children: s });
}, Lce = ({ label: e, id: t, className: r, ...i }) => {
  const [n] = ee(() => t || `checkbox-${Math.random().toString(36).substr(2, 9)}`);
  return /* @__PURE__ */ ve("div", { className: "flex items-center", children: [
    /* @__PURE__ */ H(
      "input",
      {
        id: n,
        type: "checkbox",
        className: `form-checkbox h-4 w-4 rounded transition-colors duration-200 ease-in-out cursor-pointer text-primary border-border bg-card focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed ${r || ""}`,
        ...i
      }
    ),
    e && /* @__PURE__ */ H("label", { htmlFor: n, className: "ml-2 text-sm text-text cursor-pointer", children: e })
  ] });
}, Hh = D.forwardRef(
  ({
    label: e,
    helperText: t,
    error: r = !1,
    required: i = !1,
    showOptionalLabel: n = !1,
    className: o,
    containerClassName: s,
    ...a
  }, l) => {
    const u = "w-full px-3 py-2 rounded-md bg-card border transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2", c = r ? "border-danger text-danger-foreground focus:ring-danger" : "border-border text-text focus:ring-primary focus:border-primary";
    return /* @__PURE__ */ ve("div", { className: `w-full ${s || ""}`, children: [
      e && /* @__PURE__ */ ve("div", { className: "flex justify-between items-center mb-1", children: [
        /* @__PURE__ */ ve("label", { htmlFor: a.id || a.name, className: "block text-sm font-medium text-text-light", children: [
          e,
          i && /* @__PURE__ */ H("span", { className: "text-danger ml-1", children: "*" })
        ] }),
        n && !i && /* @__PURE__ */ H("span", { className: "text-xs text-text-light", children: "Optional" })
      ] }),
      /* @__PURE__ */ H(
        "input",
        {
          ref: l,
          className: `${u} ${c} ${o || ""}`,
          required: i,
          ...a
        }
      ),
      t && /* @__PURE__ */ H("p", { className: `mt-1 text-xs ${r ? "text-danger" : "text-text-light"}`, children: t })
    ] });
  }
);
Hh.displayName = "Input";
const bbe = ({
  options: e,
  label: t,
  value: r,
  onOptionSelect: i,
  placeholder: n,
  id: o,
  className: s,
  ...a
}) => {
  const [l, u] = ee(""), [c, d] = ee(e), [h, p] = ee(!1), [g, m] = ee(-1), f = re(null), C = re(null), w = o || `combobox-${Math.random().toString(36).substr(2, 9)}`;
  gt(() => {
    if (r !== void 0) {
      const R = e.find((P) => P.value === r);
      u(R ? R.label : "");
    }
  }, [r, e]), gt(() => {
    d(l === "" ? e : e.filter(
      (R) => R.label.toLowerCase().includes(l.toLowerCase())
    )), m(-1);
  }, [l, e]);
  const E = (R) => {
    u(R.target.value), p(!0);
  }, b = (R) => {
    u(R.label), p(!1), i == null || i(R.value, R.label);
  }, y = () => {
    p(!0);
  }, S = fe((R) => {
    f.current && !f.current.contains(R.target) && p(!1);
  }, []);
  gt(() => (document.addEventListener("mousedown", S), () => {
    document.removeEventListener("mousedown", S);
  }), [S]);
  const x = (R) => {
    var P;
    if (R.key === "ArrowDown")
      R.preventDefault(), m((O) => O < c.length - 1 ? O + 1 : O);
    else if (R.key === "ArrowUp")
      R.preventDefault(), m((O) => O > 0 ? O - 1 : 0);
    else if (R.key === "Enter") {
      if (R.preventDefault(), g !== -1 && c[g])
        b(c[g]);
      else {
        const O = e.find((I) => I.label.toLowerCase() === l.toLowerCase());
        O ? b(O) : (u(""), i == null || i(null, null));
      }
      p(!1);
    } else R.key === "Escape" && (p(!1), (P = C.current) == null || P.blur());
  };
  return /* @__PURE__ */ ve("div", { className: `relative ${s || ""}`, ref: f, children: [
    t && /* @__PURE__ */ H("label", { htmlFor: w, className: "block text-sm font-medium text-text mb-1", children: t }),
    /* @__PURE__ */ H(
      Hh,
      {
        id: w,
        type: "text",
        placeholder: n,
        value: l,
        onChange: E,
        onFocus: y,
        onKeyDown: x,
        autoComplete: "off",
        ref: C,
        ...a
      }
    ),
    h && c.length > 0 && /* @__PURE__ */ H("ul", { className: "absolute z-10 w-full mt-1 bg-card border border-border rounded-md shadow-lg py-1 overflow-auto max-h-60 focus:outline-none", children: c.map((R, P) => /* @__PURE__ */ H(
      "li",
      {
        className: `px-4 py-2 text-sm cursor-pointer ${g === P ? "bg-primary/10 text-primary" : "hover:bg-bg-hover text-text"}`,
        onClick: () => b(R),
        role: "option",
        "aria-selected": g === P,
        children: R.label
      },
      R.value
    )) })
  ] });
};
function ge(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : /* @__PURE__ */ new Date(NaN);
}
function pt(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t);
}
function pn(e, t) {
  const r = ge(e);
  return isNaN(t) ? pt(e, NaN) : (t && r.setDate(r.getDate() + t), r);
}
function mn(e, t) {
  const r = ge(e);
  if (isNaN(t)) return pt(e, NaN);
  if (!t)
    return r;
  const i = r.getDate(), n = pt(e, r.getTime());
  n.setMonth(r.getMonth() + t + 1, 0);
  const o = n.getDate();
  return i >= o ? n : (r.setFullYear(
    n.getFullYear(),
    n.getMonth(),
    i
  ), r);
}
function XE(e, t) {
  const r = +ge(e);
  return pt(e, r + t);
}
const kL = 6048e5, Gce = 864e5, uv = 6e4, cv = 36e5, kce = 1e3;
function Vce(e, t) {
  return XE(e, t * cv);
}
let Hce = {};
function ja() {
  return Hce;
}
function Ao(e, t) {
  var a, l, u, c;
  const r = ja(), i = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (a = t == null ? void 0 : t.locale) == null ? void 0 : a.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0, n = ge(e), o = n.getDay(), s = (o < i ? 7 : 0) + o - i;
  return n.setDate(n.getDate() - s), n.setHours(0, 0, 0, 0), n;
}
function fu(e) {
  return Ao(e, { weekStartsOn: 1 });
}
function VL(e) {
  const t = ge(e), r = t.getFullYear(), i = pt(e, 0);
  i.setFullYear(r + 1, 0, 4), i.setHours(0, 0, 0, 0);
  const n = fu(i), o = pt(e, 0);
  o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0);
  const s = fu(o);
  return t.getTime() >= n.getTime() ? r + 1 : t.getTime() >= s.getTime() ? r : r - 1;
}
function ba(e) {
  const t = ge(e);
  return t.setHours(0, 0, 0, 0), t;
}
function xg(e) {
  const t = ge(e), r = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return r.setUTCFullYear(t.getFullYear()), +e - +r;
}
function gu(e, t) {
  const r = ba(e), i = ba(t), n = +r - xg(r), o = +i - xg(i);
  return Math.round((n - o) / Gce);
}
function Bce(e) {
  const t = VL(e), r = pt(e, 0);
  return r.setFullYear(t, 0, 4), r.setHours(0, 0, 0, 0), fu(r);
}
function lw(e, t) {
  return XE(e, t * uv);
}
function KE(e, t) {
  const r = t * 3;
  return mn(e, r);
}
function Wce(e, t) {
  return XE(e, t * 1e3);
}
function Ag(e, t) {
  const r = t * 7;
  return pn(e, r);
}
function fo(e, t) {
  return mn(e, t * 12);
}
function AR(e) {
  let t;
  return e.forEach(function(r) {
    const i = ge(r);
    (t === void 0 || t < i || isNaN(Number(i))) && (t = i);
  }), t || /* @__PURE__ */ new Date(NaN);
}
function DR(e) {
  let t;
  return e.forEach((r) => {
    const i = ge(r);
    (!t || t > i || isNaN(+i)) && (t = i);
  }), t || /* @__PURE__ */ new Date(NaN);
}
function $ce(e, t) {
  const r = ba(e), i = ba(t);
  return +r == +i;
}
function go(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function Dg(e) {
  if (!go(e) && typeof e != "number")
    return !1;
  const t = ge(e);
  return !isNaN(Number(t));
}
function Tg(e, t) {
  const r = ge(e), i = ge(t), n = r.getFullYear() - i.getFullYear(), o = r.getMonth() - i.getMonth();
  return n * 12 + o;
}
function Qs(e) {
  const t = ge(e);
  return Math.trunc(t.getMonth() / 3) + 1;
}
function Rg(e, t) {
  const r = ge(e), i = ge(t), n = r.getFullYear() - i.getFullYear(), o = Qs(r) - Qs(i);
  return n * 4 + o;
}
function Pg(e, t) {
  const r = ge(e), i = ge(t);
  return r.getFullYear() - i.getFullYear();
}
function jce(e, t) {
  const r = ge(e), i = ge(t), n = TR(r, i), o = Math.abs(gu(r, i));
  r.setDate(r.getDate() - n * o);
  const s = +(TR(r, i) === -n), a = n * (o - s);
  return a === 0 ? 0 : a;
}
function TR(e, t) {
  const r = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return r < 0 ? -1 : r > 0 ? 1 : r;
}
function HL(e) {
  const t = ge(e);
  return t.setHours(23, 59, 59, 999), t;
}
function BL(e) {
  const t = ge(e), r = t.getMonth();
  return t.setFullYear(t.getFullYear(), r + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function uw(e) {
  const t = ge(e), r = t.getMonth(), i = r - r % 3;
  return t.setMonth(i, 1), t.setHours(0, 0, 0, 0), t;
}
function WL(e) {
  const t = ge(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function $L(e) {
  const t = ge(e), r = t.getFullYear();
  return t.setFullYear(r + 1, 0, 0), t.setHours(23, 59, 59, 999), t;
}
function dv(e) {
  const t = ge(e), r = pt(e, 0);
  return r.setFullYear(t.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r;
}
function zce(e, t) {
  var a, l;
  const r = ja(), i = r.weekStartsOn ?? ((l = (a = r.locale) == null ? void 0 : a.options) == null ? void 0 : l.weekStartsOn) ?? 0, n = ge(e), o = n.getDay(), s = (o < i ? -7 : 0) + 6 - (o - i);
  return n.setDate(n.getDate() + s), n.setHours(23, 59, 59, 999), n;
}
const Uce = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, Yce = (e, t, r) => {
  let i;
  const n = Uce[e];
  return typeof n == "string" ? i = n : t === 1 ? i = n.one : i = n.other.replace("{{count}}", t.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + i : i + " ago" : i;
};
function IC(e) {
  return (t = {}) => {
    const r = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[r] || e.formats[e.defaultWidth];
  };
}
const Xce = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, Kce = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, qce = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, Zce = {
  date: IC({
    formats: Xce,
    defaultWidth: "full"
  }),
  time: IC({
    formats: Kce,
    defaultWidth: "full"
  }),
  dateTime: IC({
    formats: qce,
    defaultWidth: "full"
  })
}, Jce = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, Qce = (e, t, r, i) => Jce[e];
function vc(e) {
  return (t, r) => {
    const i = r != null && r.context ? String(r.context) : "standalone";
    let n;
    if (i === "formatting" && e.formattingValues) {
      const s = e.defaultFormattingWidth || e.defaultWidth, a = r != null && r.width ? String(r.width) : s;
      n = e.formattingValues[a] || e.formattingValues[s];
    } else {
      const s = e.defaultWidth, a = r != null && r.width ? String(r.width) : e.defaultWidth;
      n = e.values[a] || e.values[s];
    }
    const o = e.argumentCallback ? e.argumentCallback(t) : t;
    return n[o];
  };
}
const ede = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, tde = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, rde = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, ide = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, nde = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, ode = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, sde = (e, t) => {
  const r = Number(e), i = r % 100;
  if (i > 20 || i < 10)
    switch (i % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
}, ade = {
  ordinalNumber: sde,
  era: vc({
    values: ede,
    defaultWidth: "wide"
  }),
  quarter: vc({
    values: tde,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: vc({
    values: rde,
    defaultWidth: "wide"
  }),
  day: vc({
    values: ide,
    defaultWidth: "wide"
  }),
  dayPeriod: vc({
    values: nde,
    defaultWidth: "wide",
    formattingValues: ode,
    defaultFormattingWidth: "wide"
  })
};
function Cc(e) {
  return (t, r = {}) => {
    const i = r.width, n = i && e.matchPatterns[i] || e.matchPatterns[e.defaultMatchWidth], o = t.match(n);
    if (!o)
      return null;
    const s = o[0], a = i && e.parsePatterns[i] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(a) ? ude(a, (d) => d.test(s)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      lde(a, (d) => d.test(s))
    );
    let u;
    u = e.valueCallback ? e.valueCallback(l) : l, u = r.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      r.valueCallback(u)
    ) : u;
    const c = t.slice(s.length);
    return { value: u, rest: c };
  };
}
function lde(e, t) {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r) && t(e[r]))
      return r;
}
function ude(e, t) {
  for (let r = 0; r < e.length; r++)
    if (t(e[r]))
      return r;
}
function cde(e) {
  return (t, r = {}) => {
    const i = t.match(e.matchPattern);
    if (!i) return null;
    const n = i[0], o = t.match(e.parsePattern);
    if (!o) return null;
    let s = e.valueCallback ? e.valueCallback(o[0]) : o[0];
    s = r.valueCallback ? r.valueCallback(s) : s;
    const a = t.slice(n.length);
    return { value: s, rest: a };
  };
}
const dde = /^(\d+)(th|st|nd|rd)?/i, hde = /\d+/i, pde = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, fde = {
  any: [/^b/i, /^(a|c)/i]
}, gde = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, mde = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, vde = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, Cde = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, yde = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, bde = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, wde = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, Sde = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, Ede = {
  ordinalNumber: cde({
    matchPattern: dde,
    parsePattern: hde,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: Cc({
    matchPatterns: pde,
    defaultMatchWidth: "wide",
    parsePatterns: fde,
    defaultParseWidth: "any"
  }),
  quarter: Cc({
    matchPatterns: gde,
    defaultMatchWidth: "wide",
    parsePatterns: mde,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: Cc({
    matchPatterns: vde,
    defaultMatchWidth: "wide",
    parsePatterns: Cde,
    defaultParseWidth: "any"
  }),
  day: Cc({
    matchPatterns: yde,
    defaultMatchWidth: "wide",
    parsePatterns: bde,
    defaultParseWidth: "any"
  }),
  dayPeriod: Cc({
    matchPatterns: wde,
    defaultMatchWidth: "any",
    parsePatterns: Sde,
    defaultParseWidth: "any"
  })
}, jL = {
  code: "en-US",
  formatDistance: Yce,
  formatLong: Zce,
  formatRelative: Qce,
  localize: ade,
  match: Ede,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function xde(e) {
  const t = ge(e);
  return gu(t, dv(t)) + 1;
}
function qE(e) {
  const t = ge(e), r = +fu(t) - +Bce(t);
  return Math.round(r / kL) + 1;
}
function ZE(e, t) {
  var c, d, h, p;
  const r = ge(e), i = r.getFullYear(), n = ja(), o = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((d = (c = t == null ? void 0 : t.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((p = (h = n.locale) == null ? void 0 : h.options) == null ? void 0 : p.firstWeekContainsDate) ?? 1, s = pt(e, 0);
  s.setFullYear(i + 1, 0, o), s.setHours(0, 0, 0, 0);
  const a = Ao(s, t), l = pt(e, 0);
  l.setFullYear(i, 0, o), l.setHours(0, 0, 0, 0);
  const u = Ao(l, t);
  return r.getTime() >= a.getTime() ? i + 1 : r.getTime() >= u.getTime() ? i : i - 1;
}
function Ade(e, t) {
  var a, l, u, c;
  const r = ja(), i = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((l = (a = t == null ? void 0 : t.locale) == null ? void 0 : a.options) == null ? void 0 : l.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1, n = ZE(e, t), o = pt(e, 0);
  return o.setFullYear(n, 0, i), o.setHours(0, 0, 0, 0), Ao(o, t);
}
function zL(e, t) {
  const r = ge(e), i = +Ao(r, t) - +Ade(r, t);
  return Math.round(i / kL) + 1;
}
function ht(e, t) {
  const r = e < 0 ? "-" : "", i = Math.abs(e).toString().padStart(t, "0");
  return r + i;
}
const Vo = {
  // Year
  y(e, t) {
    const r = e.getFullYear(), i = r > 0 ? r : 1 - r;
    return ht(t === "yy" ? i % 100 : i, t.length);
  },
  // Month
  M(e, t) {
    const r = e.getMonth();
    return t === "M" ? String(r + 1) : ht(r + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return ht(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const r = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return r.toUpperCase();
      case "aaa":
        return r;
      case "aaaaa":
        return r[0];
      case "aaaa":
      default:
        return r === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return ht(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return ht(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return ht(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return ht(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const r = t.length, i = e.getMilliseconds(), n = Math.trunc(
      i * Math.pow(10, r - 3)
    );
    return ht(n, t.length);
  }
}, Ja = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, RR = {
  // Era
  G: function(e, t, r) {
    const i = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      case "G":
      case "GG":
      case "GGG":
        return r.era(i, { width: "abbreviated" });
      case "GGGGG":
        return r.era(i, { width: "narrow" });
      case "GGGG":
      default:
        return r.era(i, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, r) {
    if (t === "yo") {
      const i = e.getFullYear(), n = i > 0 ? i : 1 - i;
      return r.ordinalNumber(n, { unit: "year" });
    }
    return Vo.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, r, i) {
    const n = ZE(e, i), o = n > 0 ? n : 1 - n;
    if (t === "YY") {
      const s = o % 100;
      return ht(s, 2);
    }
    return t === "Yo" ? r.ordinalNumber(o, { unit: "year" }) : ht(o, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const r = VL(e);
    return ht(r, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const r = e.getFullYear();
    return ht(r, t.length);
  },
  // Quarter
  Q: function(e, t, r) {
    const i = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "Q":
        return String(i);
      case "QQ":
        return ht(i, 2);
      case "Qo":
        return r.ordinalNumber(i, { unit: "quarter" });
      case "QQQ":
        return r.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return r.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return r.quarter(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, r) {
    const i = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "q":
        return String(i);
      case "qq":
        return ht(i, 2);
      case "qo":
        return r.ordinalNumber(i, { unit: "quarter" });
      case "qqq":
        return r.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return r.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return r.quarter(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, r) {
    const i = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return Vo.M(e, t);
      case "Mo":
        return r.ordinalNumber(i + 1, { unit: "month" });
      case "MMM":
        return r.month(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return r.month(i, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return r.month(i, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, r) {
    const i = e.getMonth();
    switch (t) {
      case "L":
        return String(i + 1);
      case "LL":
        return ht(i + 1, 2);
      case "Lo":
        return r.ordinalNumber(i + 1, { unit: "month" });
      case "LLL":
        return r.month(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return r.month(i, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return r.month(i, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, r, i) {
    const n = zL(e, i);
    return t === "wo" ? r.ordinalNumber(n, { unit: "week" }) : ht(n, t.length);
  },
  // ISO week of year
  I: function(e, t, r) {
    const i = qE(e);
    return t === "Io" ? r.ordinalNumber(i, { unit: "week" }) : ht(i, t.length);
  },
  // Day of the month
  d: function(e, t, r) {
    return t === "do" ? r.ordinalNumber(e.getDate(), { unit: "date" }) : Vo.d(e, t);
  },
  // Day of year
  D: function(e, t, r) {
    const i = xde(e);
    return t === "Do" ? r.ordinalNumber(i, { unit: "dayOfYear" }) : ht(i, t.length);
  },
  // Day of week
  E: function(e, t, r) {
    const i = e.getDay();
    switch (t) {
      case "E":
      case "EE":
      case "EEE":
        return r.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return r.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return r.day(i, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return r.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, r, i) {
    const n = e.getDay(), o = (n - i.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "e":
        return String(o);
      case "ee":
        return ht(o, 2);
      case "eo":
        return r.ordinalNumber(o, { unit: "day" });
      case "eee":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return r.day(n, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return r.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, r, i) {
    const n = e.getDay(), o = (n - i.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "c":
        return String(o);
      case "cc":
        return ht(o, t.length);
      case "co":
        return r.ordinalNumber(o, { unit: "day" });
      case "ccc":
        return r.day(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return r.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return r.day(n, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return r.day(n, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, r) {
    const i = e.getDay(), n = i === 0 ? 7 : i;
    switch (t) {
      case "i":
        return String(n);
      case "ii":
        return ht(n, t.length);
      case "io":
        return r.ordinalNumber(n, { unit: "day" });
      case "iii":
        return r.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return r.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return r.day(i, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return r.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, r) {
    const n = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, r) {
    const i = e.getHours();
    let n;
    switch (i === 12 ? n = Ja.noon : i === 0 ? n = Ja.midnight : n = i / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, r) {
    const i = e.getHours();
    let n;
    switch (i >= 17 ? n = Ja.evening : i >= 12 ? n = Ja.afternoon : i >= 4 ? n = Ja.morning : n = Ja.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, r) {
    if (t === "ho") {
      let i = e.getHours() % 12;
      return i === 0 && (i = 12), r.ordinalNumber(i, { unit: "hour" });
    }
    return Vo.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, r) {
    return t === "Ho" ? r.ordinalNumber(e.getHours(), { unit: "hour" }) : Vo.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, r) {
    const i = e.getHours() % 12;
    return t === "Ko" ? r.ordinalNumber(i, { unit: "hour" }) : ht(i, t.length);
  },
  // Hour [1-24]
  k: function(e, t, r) {
    let i = e.getHours();
    return i === 0 && (i = 24), t === "ko" ? r.ordinalNumber(i, { unit: "hour" }) : ht(i, t.length);
  },
  // Minute
  m: function(e, t, r) {
    return t === "mo" ? r.ordinalNumber(e.getMinutes(), { unit: "minute" }) : Vo.m(e, t);
  },
  // Second
  s: function(e, t, r) {
    return t === "so" ? r.ordinalNumber(e.getSeconds(), { unit: "second" }) : Vo.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return Vo.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, r) {
    const i = e.getTimezoneOffset();
    if (i === 0)
      return "Z";
    switch (t) {
      case "X":
        return IR(i);
      case "XXXX":
      case "XX":
        return Os(i);
      case "XXXXX":
      case "XXX":
      default:
        return Os(i, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, r) {
    const i = e.getTimezoneOffset();
    switch (t) {
      case "x":
        return IR(i);
      case "xxxx":
      case "xx":
        return Os(i);
      case "xxxxx":
      case "xxx":
      default:
        return Os(i, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, r) {
    const i = e.getTimezoneOffset();
    switch (t) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + PR(i, ":");
      case "OOOO":
      default:
        return "GMT" + Os(i, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, r) {
    const i = e.getTimezoneOffset();
    switch (t) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + PR(i, ":");
      case "zzzz":
      default:
        return "GMT" + Os(i, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, r) {
    const i = Math.trunc(e.getTime() / 1e3);
    return ht(i, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, r) {
    const i = e.getTime();
    return ht(i, t.length);
  }
};
function PR(e, t = "") {
  const r = e > 0 ? "-" : "+", i = Math.abs(e), n = Math.trunc(i / 60), o = i % 60;
  return o === 0 ? r + String(n) : r + String(n) + t + ht(o, 2);
}
function IR(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + ht(Math.abs(e) / 60, 2) : Os(e, t);
}
function Os(e, t = "") {
  const r = e > 0 ? "-" : "+", i = Math.abs(e), n = ht(Math.trunc(i / 60), 2), o = ht(i % 60, 2);
  return r + n + t + o;
}
const OR = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, UL = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, Dde = (e, t) => {
  const r = e.match(/(P+)(p+)?/) || [], i = r[1], n = r[2];
  if (!n)
    return OR(e, t);
  let o;
  switch (i) {
    case "P":
      o = t.dateTime({ width: "short" });
      break;
    case "PP":
      o = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      o = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      o = t.dateTime({ width: "full" });
      break;
  }
  return o.replace("{{date}}", OR(i, t)).replace("{{time}}", UL(n, t));
}, Ig = {
  p: UL,
  P: Dde
}, Tde = /^D+$/, Rde = /^Y+$/, Pde = ["D", "DD", "YY", "YYYY"];
function YL(e) {
  return Tde.test(e);
}
function XL(e) {
  return Rde.test(e);
}
function cw(e, t, r) {
  const i = Ide(e, t, r);
  if (console.warn(i), Pde.includes(e)) throw new RangeError(i);
}
function Ide(e, t, r) {
  const i = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${i} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const Ode = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Mde = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Fde = /^'([^]*?)'?$/, _de = /''/g, Nde = /[a-zA-Z]/;
function MR(e, t, r) {
  var c, d, h, p, g, m, f, C;
  const i = ja(), n = (r == null ? void 0 : r.locale) ?? i.locale ?? jL, o = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((d = (c = r == null ? void 0 : r.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((p = (h = i.locale) == null ? void 0 : h.options) == null ? void 0 : p.firstWeekContainsDate) ?? 1, s = (r == null ? void 0 : r.weekStartsOn) ?? ((m = (g = r == null ? void 0 : r.locale) == null ? void 0 : g.options) == null ? void 0 : m.weekStartsOn) ?? i.weekStartsOn ?? ((C = (f = i.locale) == null ? void 0 : f.options) == null ? void 0 : C.weekStartsOn) ?? 0, a = ge(e);
  if (!Dg(a))
    throw new RangeError("Invalid time value");
  let l = t.match(Mde).map((w) => {
    const E = w[0];
    if (E === "p" || E === "P") {
      const b = Ig[E];
      return b(w, n.formatLong);
    }
    return w;
  }).join("").match(Ode).map((w) => {
    if (w === "''")
      return { isToken: !1, value: "'" };
    const E = w[0];
    if (E === "'")
      return { isToken: !1, value: Lde(w) };
    if (RR[E])
      return { isToken: !0, value: w };
    if (E.match(Nde))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + E + "`"
      );
    return { isToken: !1, value: w };
  });
  n.localize.preprocessor && (l = n.localize.preprocessor(a, l));
  const u = {
    firstWeekContainsDate: o,
    weekStartsOn: s,
    locale: n
  };
  return l.map((w) => {
    if (!w.isToken) return w.value;
    const E = w.value;
    (!(r != null && r.useAdditionalWeekYearTokens) && XL(E) || !(r != null && r.useAdditionalDayOfYearTokens) && YL(E)) && cw(E, t, String(e));
    const b = RR[E[0]];
    return b(a, E, n.localize, u);
  }).join("");
}
function Lde(e) {
  const t = e.match(Fde);
  return t ? t[1].replace(_de, "'") : e;
}
function FR(e) {
  return ge(e).getDate();
}
function Gde(e) {
  return ge(e).getDay();
}
function kde(e) {
  const t = ge(e), r = t.getFullYear(), i = t.getMonth(), n = pt(e, 0);
  return n.setFullYear(r, i + 1, 0), n.setHours(0, 0, 0, 0), n.getDate();
}
function Vde() {
  return Object.assign({}, ja());
}
function kn(e) {
  return ge(e).getHours();
}
function Hde(e) {
  let r = ge(e).getDay();
  return r === 0 && (r = 7), r;
}
function Vn(e) {
  return ge(e).getMinutes();
}
function Vr(e) {
  return ge(e).getMonth();
}
function mo(e) {
  return ge(e).getSeconds();
}
function dw(e) {
  return ge(e).getTime();
}
function $e(e) {
  return ge(e).getFullYear();
}
function rs(e, t) {
  const r = ge(e), i = ge(t);
  return r.getTime() > i.getTime();
}
function wa(e, t) {
  const r = ge(e), i = ge(t);
  return +r < +i;
}
function Bde(e, t) {
  const r = ge(e), i = ge(t);
  return +r == +i;
}
function Wde(e, t) {
  const r = t instanceof Date ? pt(t, 0) : new t(0);
  return r.setFullYear(
    e.getFullYear(),
    e.getMonth(),
    e.getDate()
  ), r.setHours(
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  ), r;
}
const $de = 10;
class KL {
  constructor() {
    me(this, "subPriority", 0);
  }
  validate(t, r) {
    return !0;
  }
}
class jde extends KL {
  constructor(t, r, i, n, o) {
    super(), this.value = t, this.validateValue = r, this.setValue = i, this.priority = n, o && (this.subPriority = o);
  }
  validate(t, r) {
    return this.validateValue(t, this.value, r);
  }
  set(t, r, i) {
    return this.setValue(t, r, this.value, i);
  }
}
class zde extends KL {
  constructor() {
    super(...arguments);
    me(this, "priority", $de);
    me(this, "subPriority", -1);
  }
  set(r, i) {
    return i.timestampIsSet ? r : pt(r, Wde(r, Date));
  }
}
class it {
  run(t, r, i, n) {
    const o = this.parse(t, r, i, n);
    return o ? {
      setter: new jde(
        o.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: o.rest
    } : null;
  }
  validate(t, r, i) {
    return !0;
  }
}
class Ude extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 140);
    me(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, { width: "abbreviated" }) || n.era(r, { width: "narrow" });
      case "GGGGG":
        return n.era(r, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(r, { width: "wide" }) || n.era(r, { width: "abbreviated" }) || n.era(r, { width: "narrow" });
    }
  }
  set(r, i, n) {
    return i.era = n, r.setFullYear(n, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
const Xt = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, Rn = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Kt(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  };
}
function kt(e, t) {
  const r = t.match(e);
  return r ? {
    value: parseInt(r[0], 10),
    rest: t.slice(r[0].length)
  } : null;
}
function Pn(e, t) {
  const r = t.match(e);
  if (!r)
    return null;
  if (r[0] === "Z")
    return {
      value: 0,
      rest: t.slice(1)
    };
  const i = r[1] === "+" ? 1 : -1, n = r[2] ? parseInt(r[2], 10) : 0, o = r[3] ? parseInt(r[3], 10) : 0, s = r[5] ? parseInt(r[5], 10) : 0;
  return {
    value: i * (n * cv + o * uv + s * kce),
    rest: t.slice(r[0].length)
  };
}
function qL(e) {
  return kt(Xt.anyDigitsSigned, e);
}
function Wt(e, t) {
  switch (e) {
    case 1:
      return kt(Xt.singleDigit, t);
    case 2:
      return kt(Xt.twoDigits, t);
    case 3:
      return kt(Xt.threeDigits, t);
    case 4:
      return kt(Xt.fourDigits, t);
    default:
      return kt(new RegExp("^\\d{1," + e + "}"), t);
  }
}
function Og(e, t) {
  switch (e) {
    case 1:
      return kt(Xt.singleDigitSigned, t);
    case 2:
      return kt(Xt.twoDigitsSigned, t);
    case 3:
      return kt(Xt.threeDigitsSigned, t);
    case 4:
      return kt(Xt.fourDigitsSigned, t);
    default:
      return kt(new RegExp("^-?\\d{1," + e + "}"), t);
  }
}
function JE(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function ZL(e, t) {
  const r = t > 0, i = r ? t : 1 - t;
  let n;
  if (i <= 50)
    n = e || 100;
  else {
    const o = i + 50, s = Math.trunc(o / 100) * 100, a = e >= o % 100;
    n = e + s - (a ? 100 : 0);
  }
  return r ? n : 1 - n;
}
function JL(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
class Yde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 130);
    me(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(r, i, n) {
    const o = (s) => ({
      year: s,
      isTwoDigitYear: i === "yy"
    });
    switch (i) {
      case "y":
        return Kt(Wt(4, r), o);
      case "yo":
        return Kt(
          n.ordinalNumber(r, {
            unit: "year"
          }),
          o
        );
      default:
        return Kt(Wt(i.length, r), o);
    }
  }
  validate(r, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(r, i, n) {
    const o = r.getFullYear();
    if (n.isTwoDigitYear) {
      const a = ZL(
        n.year,
        o
      );
      return r.setFullYear(a, 0, 1), r.setHours(0, 0, 0, 0), r;
    }
    const s = !("era" in i) || i.era === 1 ? n.year : 1 - n.year;
    return r.setFullYear(s, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class Xde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 130);
    me(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    const o = (s) => ({
      year: s,
      isTwoDigitYear: i === "YY"
    });
    switch (i) {
      case "Y":
        return Kt(Wt(4, r), o);
      case "Yo":
        return Kt(
          n.ordinalNumber(r, {
            unit: "year"
          }),
          o
        );
      default:
        return Kt(Wt(i.length, r), o);
    }
  }
  validate(r, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(r, i, n, o) {
    const s = ZE(r, o);
    if (n.isTwoDigitYear) {
      const l = ZL(
        n.year,
        s
      );
      return r.setFullYear(
        l,
        0,
        o.firstWeekContainsDate
      ), r.setHours(0, 0, 0, 0), Ao(r, o);
    }
    const a = !("era" in i) || i.era === 1 ? n.year : 1 - n.year;
    return r.setFullYear(a, 0, o.firstWeekContainsDate), r.setHours(0, 0, 0, 0), Ao(r, o);
  }
}
class Kde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 130);
    me(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i) {
    return Og(i === "R" ? 4 : i.length, r);
  }
  set(r, i, n) {
    const o = pt(r, 0);
    return o.setFullYear(n, 0, 4), o.setHours(0, 0, 0, 0), fu(o);
  }
}
class qde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 130);
    me(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(r, i) {
    return Og(i === "u" ? 4 : i.length, r);
  }
  set(r, i, n) {
    return r.setFullYear(n, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class Zde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 120);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "Q":
      case "QQ":
        return Wt(i.length, r);
      case "Qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        }) || n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 4;
  }
  set(r, i, n) {
    return r.setMonth((n - 1) * 3, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class Jde extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 120);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "q":
      case "qq":
        return Wt(i.length, r);
      case "qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        }) || n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 4;
  }
  set(r, i, n) {
    return r.setMonth((n - 1) * 3, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class Qde extends it {
  constructor() {
    super(...arguments);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    me(this, "priority", 110);
  }
  parse(r, i, n) {
    const o = (s) => s - 1;
    switch (i) {
      case "M":
        return Kt(
          kt(Xt.month, r),
          o
        );
      case "MM":
        return Kt(Wt(2, r), o);
      case "Mo":
        return Kt(
          n.ordinalNumber(r, {
            unit: "month"
          }),
          o
        );
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.month(r, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(r, { width: "wide", context: "formatting" }) || n.month(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.month(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 11;
  }
  set(r, i, n) {
    return r.setMonth(n, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class ehe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 110);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    const o = (s) => s - 1;
    switch (i) {
      case "L":
        return Kt(
          kt(Xt.month, r),
          o
        );
      case "LL":
        return Kt(Wt(2, r), o);
      case "Lo":
        return Kt(
          n.ordinalNumber(r, {
            unit: "month"
          }),
          o
        );
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.month(r, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(r, { width: "wide", context: "standalone" }) || n.month(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.month(r, { width: "narrow", context: "standalone" });
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 11;
  }
  set(r, i, n) {
    return r.setMonth(n, 1), r.setHours(0, 0, 0, 0), r;
  }
}
function the(e, t, r) {
  const i = ge(e), n = zL(i, r) - t;
  return i.setDate(i.getDate() - n * 7), i;
}
class rhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 100);
    me(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "w":
        return kt(Xt.week, r);
      case "wo":
        return n.ordinalNumber(r, { unit: "week" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 53;
  }
  set(r, i, n, o) {
    return Ao(the(r, n, o), o);
  }
}
function ihe(e, t) {
  const r = ge(e), i = qE(r) - t;
  return r.setDate(r.getDate() - i * 7), r;
}
class nhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 100);
    me(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "I":
        return kt(Xt.week, r);
      case "Io":
        return n.ordinalNumber(r, { unit: "week" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 53;
  }
  set(r, i, n) {
    return fu(ihe(r, n));
  }
}
const ohe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], she = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class ahe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "subPriority", 1);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "d":
        return kt(Xt.date, r);
      case "do":
        return n.ordinalNumber(r, { unit: "date" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    const n = r.getFullYear(), o = JL(n), s = r.getMonth();
    return o ? i >= 1 && i <= she[s] : i >= 1 && i <= ohe[s];
  }
  set(r, i, n) {
    return r.setDate(n), r.setHours(0, 0, 0, 0), r;
  }
}
class lhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "subpriority", 1);
    me(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    switch (i) {
      case "D":
      case "DD":
        return kt(Xt.dayOfYear, r);
      case "Do":
        return n.ordinalNumber(r, { unit: "date" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    const n = r.getFullYear();
    return JL(n) ? i >= 1 && i <= 366 : i >= 1 && i <= 365;
  }
  set(r, i, n) {
    return r.setMonth(0, n), r.setHours(0, 0, 0, 0), r;
  }
}
function QE(e, t, r) {
  var d, h, p, g;
  const i = ja(), n = (r == null ? void 0 : r.weekStartsOn) ?? ((h = (d = r == null ? void 0 : r.locale) == null ? void 0 : d.options) == null ? void 0 : h.weekStartsOn) ?? i.weekStartsOn ?? ((g = (p = i.locale) == null ? void 0 : p.options) == null ? void 0 : g.weekStartsOn) ?? 0, o = ge(e), s = o.getDay(), l = (t % 7 + 7) % 7, u = 7 - n, c = t < 0 || t > 6 ? t - (s + u) % 7 : (l + u) % 7 - (s + u) % 7;
  return pn(o, c);
}
class uhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return n.day(r, { width: "wide", context: "formatting" }) || n.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 6;
  }
  set(r, i, n, o) {
    return r = QE(r, n, o), r.setHours(0, 0, 0, 0), r;
  }
}
class che extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n, o) {
    const s = (a) => {
      const l = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + l;
    };
    switch (i) {
      case "e":
      case "ee":
        return Kt(Wt(i.length, r), s);
      case "eo":
        return Kt(
          n.ordinalNumber(r, {
            unit: "day"
          }),
          s
        );
      case "eee":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
      case "eeeee":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return n.day(r, { width: "wide", context: "formatting" }) || n.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(r, { width: "short", context: "formatting" }) || n.day(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 6;
  }
  set(r, i, n, o) {
    return r = QE(r, n, o), r.setHours(0, 0, 0, 0), r;
  }
}
class dhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(r, i, n, o) {
    const s = (a) => {
      const l = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + l;
    };
    switch (i) {
      case "c":
      case "cc":
        return Kt(Wt(i.length, r), s);
      case "co":
        return Kt(
          n.ordinalNumber(r, {
            unit: "day"
          }),
          s
        );
      case "ccc":
        return n.day(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.day(r, { width: "short", context: "standalone" }) || n.day(r, { width: "narrow", context: "standalone" });
      case "ccccc":
        return n.day(r, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(r, { width: "short", context: "standalone" }) || n.day(r, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return n.day(r, { width: "wide", context: "standalone" }) || n.day(r, {
          width: "abbreviated",
          context: "standalone"
        }) || n.day(r, { width: "short", context: "standalone" }) || n.day(r, { width: "narrow", context: "standalone" });
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 6;
  }
  set(r, i, n, o) {
    return r = QE(r, n, o), r.setHours(0, 0, 0, 0), r;
  }
}
function hhe(e, t) {
  const r = ge(e), i = Hde(r), n = t - i;
  return pn(r, n);
}
class phe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 90);
    me(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, i, n) {
    const o = (s) => s === 0 ? 7 : s;
    switch (i) {
      case "i":
      case "ii":
        return Wt(i.length, r);
      case "io":
        return n.ordinalNumber(r, { unit: "day" });
      case "iii":
        return Kt(
          n.day(r, {
            width: "abbreviated",
            context: "formatting"
          }) || n.day(r, {
            width: "short",
            context: "formatting"
          }) || n.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiii":
        return Kt(
          n.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiiii":
        return Kt(
          n.day(r, {
            width: "short",
            context: "formatting"
          }) || n.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiii":
      default:
        return Kt(
          n.day(r, {
            width: "wide",
            context: "formatting"
          }) || n.day(r, {
            width: "abbreviated",
            context: "formatting"
          }) || n.day(r, {
            width: "short",
            context: "formatting"
          }) || n.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 7;
  }
  set(r, i, n) {
    return r = hhe(r, n), r.setHours(0, 0, 0, 0), r;
  }
}
class fhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 80);
    me(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "a":
      case "aa":
      case "aaa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, i, n) {
    return r.setHours(JE(n), 0, 0, 0), r;
  }
}
class ghe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 80);
    me(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "b":
      case "bb":
      case "bbb":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, i, n) {
    return r.setHours(JE(n), 0, 0, 0), r;
  }
}
class mhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 80);
    me(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, i, n) {
    return r.setHours(JE(n), 0, 0, 0), r;
  }
}
class vhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 70);
    me(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "h":
        return kt(Xt.hour12h, r);
      case "ho":
        return n.ordinalNumber(r, { unit: "hour" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 12;
  }
  set(r, i, n) {
    const o = r.getHours() >= 12;
    return o && n < 12 ? r.setHours(n + 12, 0, 0, 0) : !o && n === 12 ? r.setHours(0, 0, 0, 0) : r.setHours(n, 0, 0, 0), r;
  }
}
class Che extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 70);
    me(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "H":
        return kt(Xt.hour23h, r);
      case "Ho":
        return n.ordinalNumber(r, { unit: "hour" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 23;
  }
  set(r, i, n) {
    return r.setHours(n, 0, 0, 0), r;
  }
}
class yhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 70);
    me(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "K":
        return kt(Xt.hour11h, r);
      case "Ko":
        return n.ordinalNumber(r, { unit: "hour" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 11;
  }
  set(r, i, n) {
    return r.getHours() >= 12 && n < 12 ? r.setHours(n + 12, 0, 0, 0) : r.setHours(n, 0, 0, 0), r;
  }
}
class bhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 70);
    me(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "k":
        return kt(Xt.hour24h, r);
      case "ko":
        return n.ordinalNumber(r, { unit: "hour" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 1 && i <= 24;
  }
  set(r, i, n) {
    const o = n <= 24 ? n % 24 : n;
    return r.setHours(o, 0, 0, 0), r;
  }
}
class whe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 60);
    me(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "m":
        return kt(Xt.minute, r);
      case "mo":
        return n.ordinalNumber(r, { unit: "minute" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 59;
  }
  set(r, i, n) {
    return r.setMinutes(n, 0, 0), r;
  }
}
class She extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 50);
    me(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, i, n) {
    switch (i) {
      case "s":
        return kt(Xt.second, r);
      case "so":
        return n.ordinalNumber(r, { unit: "second" });
      default:
        return Wt(i.length, r);
    }
  }
  validate(r, i) {
    return i >= 0 && i <= 59;
  }
  set(r, i, n) {
    return r.setSeconds(n, 0), r;
  }
}
class Ehe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 30);
    me(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, i) {
    const n = (o) => Math.trunc(o * Math.pow(10, -i.length + 3));
    return Kt(Wt(i.length, r), n);
  }
  set(r, i, n) {
    return r.setMilliseconds(n), r;
  }
}
class xhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 10);
    me(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(r, i) {
    switch (i) {
      case "X":
        return Pn(
          Rn.basicOptionalMinutes,
          r
        );
      case "XX":
        return Pn(Rn.basic, r);
      case "XXXX":
        return Pn(
          Rn.basicOptionalSeconds,
          r
        );
      case "XXXXX":
        return Pn(
          Rn.extendedOptionalSeconds,
          r
        );
      case "XXX":
      default:
        return Pn(Rn.extended, r);
    }
  }
  set(r, i, n) {
    return i.timestampIsSet ? r : pt(
      r,
      r.getTime() - xg(r) - n
    );
  }
}
class Ahe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 10);
    me(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(r, i) {
    switch (i) {
      case "x":
        return Pn(
          Rn.basicOptionalMinutes,
          r
        );
      case "xx":
        return Pn(Rn.basic, r);
      case "xxxx":
        return Pn(
          Rn.basicOptionalSeconds,
          r
        );
      case "xxxxx":
        return Pn(
          Rn.extendedOptionalSeconds,
          r
        );
      case "xxx":
      default:
        return Pn(Rn.extended, r);
    }
  }
  set(r, i, n) {
    return i.timestampIsSet ? r : pt(
      r,
      r.getTime() - xg(r) - n
    );
  }
}
class Dhe extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 40);
    me(this, "incompatibleTokens", "*");
  }
  parse(r) {
    return qL(r);
  }
  set(r, i, n) {
    return [pt(r, n * 1e3), { timestampIsSet: !0 }];
  }
}
class The extends it {
  constructor() {
    super(...arguments);
    me(this, "priority", 20);
    me(this, "incompatibleTokens", "*");
  }
  parse(r) {
    return qL(r);
  }
  set(r, i, n) {
    return [pt(r, n), { timestampIsSet: !0 }];
  }
}
const Rhe = {
  G: new Ude(),
  y: new Yde(),
  Y: new Xde(),
  R: new Kde(),
  u: new qde(),
  Q: new Zde(),
  q: new Jde(),
  M: new Qde(),
  L: new ehe(),
  w: new rhe(),
  I: new nhe(),
  d: new ahe(),
  D: new lhe(),
  E: new uhe(),
  e: new che(),
  c: new dhe(),
  i: new phe(),
  a: new fhe(),
  b: new ghe(),
  B: new mhe(),
  h: new vhe(),
  H: new Che(),
  K: new yhe(),
  k: new bhe(),
  m: new whe(),
  s: new She(),
  S: new Ehe(),
  X: new xhe(),
  x: new Ahe(),
  t: new Dhe(),
  T: new The()
}, Phe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Ihe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Ohe = /^'([^]*?)'?$/, Mhe = /''/g, Fhe = /\S/, _he = /[a-zA-Z]/;
function OC(e, t, r, i) {
  var m, f, C, w, E, b, y, S;
  const n = Vde(), o = (i == null ? void 0 : i.locale) ?? n.locale ?? jL, s = (i == null ? void 0 : i.firstWeekContainsDate) ?? ((f = (m = i == null ? void 0 : i.locale) == null ? void 0 : m.options) == null ? void 0 : f.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((w = (C = n.locale) == null ? void 0 : C.options) == null ? void 0 : w.firstWeekContainsDate) ?? 1, a = (i == null ? void 0 : i.weekStartsOn) ?? ((b = (E = i == null ? void 0 : i.locale) == null ? void 0 : E.options) == null ? void 0 : b.weekStartsOn) ?? n.weekStartsOn ?? ((S = (y = n.locale) == null ? void 0 : y.options) == null ? void 0 : S.weekStartsOn) ?? 0;
  if (t === "")
    return e === "" ? ge(r) : pt(r, NaN);
  const l = {
    firstWeekContainsDate: s,
    weekStartsOn: a,
    locale: o
  }, u = [new zde()], c = t.match(Ihe).map((x) => {
    const R = x[0];
    if (R in Ig) {
      const P = Ig[R];
      return P(x, o.formatLong);
    }
    return x;
  }).join("").match(Phe), d = [];
  for (let x of c) {
    !(i != null && i.useAdditionalWeekYearTokens) && XL(x) && cw(x, t, e), !(i != null && i.useAdditionalDayOfYearTokens) && YL(x) && cw(x, t, e);
    const R = x[0], P = Rhe[R];
    if (P) {
      const { incompatibleTokens: O } = P;
      if (Array.isArray(O)) {
        const M = d.find(
          (_) => O.includes(_.token) || _.token === R
        );
        if (M)
          throw new RangeError(
            `The format string mustn't contain \`${M.fullToken}\` and \`${x}\` at the same time`
          );
      } else if (P.incompatibleTokens === "*" && d.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${x}\` and any other token at the same time`
        );
      d.push({ token: R, fullToken: x });
      const I = P.run(
        e,
        x,
        o.match,
        l
      );
      if (!I)
        return pt(r, NaN);
      u.push(I.setter), e = I.rest;
    } else {
      if (R.match(_he))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + R + "`"
        );
      if (x === "''" ? x = "'" : R === "'" && (x = Nhe(x)), e.indexOf(x) === 0)
        e = e.slice(x.length);
      else
        return pt(r, NaN);
    }
  }
  if (e.length > 0 && Fhe.test(e))
    return pt(r, NaN);
  const h = u.map((x) => x.priority).sort((x, R) => R - x).filter((x, R, P) => P.indexOf(x) === R).map(
    (x) => u.filter((R) => R.priority === x).sort((R, P) => P.subPriority - R.subPriority)
  ).map((x) => x[0]);
  let p = ge(r);
  if (isNaN(p.getTime()))
    return pt(r, NaN);
  const g = {};
  for (const x of h) {
    if (!x.validate(p, l))
      return pt(r, NaN);
    const R = x.set(p, g, l);
    Array.isArray(R) ? (p = R[0], Object.assign(g, R[1])) : p = R;
  }
  return pt(r, p);
}
function Nhe(e) {
  return e.match(Ohe)[1].replace(Mhe, "'");
}
function Lhe(e, t) {
  const r = ge(e), i = ge(t);
  return r.getFullYear() === i.getFullYear() && r.getMonth() === i.getMonth();
}
function Ghe(e, t) {
  const r = uw(e), i = uw(t);
  return +r == +i;
}
function khe(e, t) {
  const r = ge(e), i = ge(t);
  return r.getFullYear() === i.getFullYear();
}
function rh(e, t) {
  const r = +ge(e), [i, n] = [
    +ge(t.start),
    +ge(t.end)
  ].sort((o, s) => o - s);
  return r >= i && r <= n;
}
function Vhe(e, t) {
  return pn(e, -1);
}
function Hhe(e, t) {
  const i = jhe(e);
  let n;
  if (i.date) {
    const l = zhe(i.date, 2);
    n = Uhe(l.restDateString, l.year);
  }
  if (!n || isNaN(n.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  const o = n.getTime();
  let s = 0, a;
  if (i.time && (s = Yhe(i.time), isNaN(s)))
    return /* @__PURE__ */ new Date(NaN);
  if (i.timezone) {
    if (a = Xhe(i.timezone), isNaN(a))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    const l = new Date(o + s), u = /* @__PURE__ */ new Date(0);
    return u.setFullYear(
      l.getUTCFullYear(),
      l.getUTCMonth(),
      l.getUTCDate()
    ), u.setHours(
      l.getUTCHours(),
      l.getUTCMinutes(),
      l.getUTCSeconds(),
      l.getUTCMilliseconds()
    ), u;
  }
  return new Date(o + s + a);
}
const mp = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, Bhe = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, Whe = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, $he = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function jhe(e) {
  const t = {}, r = e.split(mp.dateTimeDelimiter);
  let i;
  if (r.length > 2)
    return t;
  if (/:/.test(r[0]) ? i = r[0] : (t.date = r[0], i = r[1], mp.timeZoneDelimiter.test(t.date) && (t.date = e.split(mp.timeZoneDelimiter)[0], i = e.substr(
    t.date.length,
    e.length
  ))), i) {
    const n = mp.timezone.exec(i);
    n ? (t.time = i.replace(n[1], ""), t.timezone = n[1]) : t.time = i;
  }
  return t;
}
function zhe(e, t) {
  const r = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"
  ), i = e.match(r);
  if (!i) return { year: NaN, restDateString: "" };
  const n = i[1] ? parseInt(i[1]) : null, o = i[2] ? parseInt(i[2]) : null;
  return {
    year: o === null ? n : o * 100,
    restDateString: e.slice((i[1] || i[2]).length)
  };
}
function Uhe(e, t) {
  if (t === null) return /* @__PURE__ */ new Date(NaN);
  const r = e.match(Bhe);
  if (!r) return /* @__PURE__ */ new Date(NaN);
  const i = !!r[4], n = yc(r[1]), o = yc(r[2]) - 1, s = yc(r[3]), a = yc(r[4]), l = yc(r[5]) - 1;
  if (i)
    return Qhe(t, a, l) ? Khe(t, a, l) : /* @__PURE__ */ new Date(NaN);
  {
    const u = /* @__PURE__ */ new Date(0);
    return !Zhe(t, o, s) || !Jhe(t, n) ? /* @__PURE__ */ new Date(NaN) : (u.setUTCFullYear(t, o, Math.max(n, s)), u);
  }
}
function yc(e) {
  return e ? parseInt(e) : 1;
}
function Yhe(e) {
  const t = e.match(Whe);
  if (!t) return NaN;
  const r = MC(t[1]), i = MC(t[2]), n = MC(t[3]);
  return epe(r, i, n) ? r * cv + i * uv + n * 1e3 : NaN;
}
function MC(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function Xhe(e) {
  if (e === "Z") return 0;
  const t = e.match($he);
  if (!t) return 0;
  const r = t[1] === "+" ? -1 : 1, i = parseInt(t[2]), n = t[3] && parseInt(t[3]) || 0;
  return tpe(i, n) ? r * (i * cv + n * uv) : NaN;
}
function Khe(e, t, r) {
  const i = /* @__PURE__ */ new Date(0);
  i.setUTCFullYear(e, 0, 4);
  const n = i.getUTCDay() || 7, o = (t - 1) * 7 + r + 1 - n;
  return i.setUTCDate(i.getUTCDate() + o), i;
}
const qhe = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function QL(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Zhe(e, t, r) {
  return t >= 0 && t <= 11 && r >= 1 && r <= (qhe[t] || (QL(e) ? 29 : 28));
}
function Jhe(e, t) {
  return t >= 1 && t <= (QL(e) ? 366 : 365);
}
function Qhe(e, t, r) {
  return t >= 1 && t <= 53 && r >= 0 && r <= 6;
}
function epe(e, t, r) {
  return e === 24 ? t === 0 && r === 0 : r >= 0 && r < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function tpe(e, t) {
  return t >= 0 && t <= 59;
}
function pi(e, t) {
  const r = ge(e), i = r.getFullYear(), n = r.getDate(), o = pt(e, 0);
  o.setFullYear(i, t, 15), o.setHours(0, 0, 0, 0);
  const s = kde(o);
  return r.setMonth(t, Math.min(n, s)), r;
}
function rpe(e, t) {
  let r = ge(e);
  return isNaN(+r) ? pt(e, NaN) : (t.year != null && r.setFullYear(t.year), t.month != null && (r = pi(r, t.month)), t.date != null && r.setDate(t.date), t.hours != null && r.setHours(t.hours), t.minutes != null && r.setMinutes(t.minutes), t.seconds != null && r.setSeconds(t.seconds), t.milliseconds != null && r.setMilliseconds(t.milliseconds), r);
}
function kp(e, t) {
  const r = ge(e);
  return r.setHours(t), r;
}
function Vp(e, t) {
  const r = ge(e);
  return r.setMinutes(t), r;
}
function ol(e, t) {
  const r = ge(e), i = Math.trunc(r.getMonth() / 3) + 1, n = t - i;
  return pi(r, r.getMonth() + n * 3);
}
function Hp(e, t) {
  const r = ge(e);
  return r.setSeconds(t), r;
}
function En(e, t) {
  const r = ge(e);
  return isNaN(+r) ? pt(e, NaN) : (r.setFullYear(t), r);
}
function ea(e, t) {
  return mn(e, -t);
}
function eG(e, t) {
  return KE(e, -1);
}
function _R(e, t) {
  return Ag(e, -1);
}
function mu(e, t) {
  return fo(e, -t);
}
function hv() {
  return typeof window < "u";
}
function ec(e) {
  return tG(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function bi(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Qn(e) {
  var t;
  return (t = (tG(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function tG(e) {
  return hv() ? e instanceof Node || e instanceof bi(e).Node : !1;
}
function Rr(e) {
  return hv() ? e instanceof Element || e instanceof bi(e).Element : !1;
}
function qn(e) {
  return hv() ? e instanceof HTMLElement || e instanceof bi(e).HTMLElement : !1;
}
function NR(e) {
  return !hv() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof bi(e).ShadowRoot;
}
const ipe = /* @__PURE__ */ new Set(["inline", "contents"]);
function Bh(e) {
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
    display: n
  } = Ki(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + r) && !ipe.has(n);
}
const npe = /* @__PURE__ */ new Set(["table", "td", "th"]);
function ope(e) {
  return npe.has(ec(e));
}
const spe = [":popover-open", ":modal"];
function pv(e) {
  return spe.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const ape = ["transform", "translate", "scale", "rotate", "perspective"], lpe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], upe = ["paint", "layout", "strict", "content"];
function ex(e) {
  const t = tx(), r = Rr(e) ? Ki(e) : e;
  return ape.some((i) => r[i] ? r[i] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || lpe.some((i) => (r.willChange || "").includes(i)) || upe.some((i) => (r.contain || "").includes(i));
}
function cpe(e) {
  let t = is(e);
  for (; qn(t) && !vu(t); ) {
    if (ex(t))
      return t;
    if (pv(t))
      return null;
    t = is(t);
  }
  return null;
}
function tx() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const dpe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function vu(e) {
  return dpe.has(ec(e));
}
function Ki(e) {
  return bi(e).getComputedStyle(e);
}
function fv(e) {
  return Rr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function is(e) {
  if (ec(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    NR(e) && e.host || // Fallback.
    Qn(e)
  );
  return NR(t) ? t.host : t;
}
function rG(e) {
  const t = is(e);
  return vu(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : qn(t) && Bh(t) ? t : rG(t);
}
function ih(e, t, r) {
  var i;
  t === void 0 && (t = []), r === void 0 && (r = !0);
  const n = rG(e), o = n === ((i = e.ownerDocument) == null ? void 0 : i.body), s = bi(n);
  if (o) {
    const a = hw(s);
    return t.concat(s, s.visualViewport || [], Bh(n) ? n : [], a && r ? ih(a) : []);
  }
  return t.concat(n, ih(n, [], r));
}
function hw(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
const Cu = Math.min, ta = Math.max, Mg = Math.round, vp = Math.floor, Hn = (e) => ({
  x: e,
  y: e
}), hpe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, ppe = {
  start: "end",
  end: "start"
};
function fpe(e, t, r) {
  return ta(e, Cu(t, r));
}
function gv(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function yu(e) {
  return e.split("-")[0];
}
function Wh(e) {
  return e.split("-")[1];
}
function gpe(e) {
  return e === "x" ? "y" : "x";
}
function rx(e) {
  return e === "y" ? "height" : "width";
}
const mpe = /* @__PURE__ */ new Set(["top", "bottom"]);
function Hs(e) {
  return mpe.has(yu(e)) ? "y" : "x";
}
function ix(e) {
  return gpe(Hs(e));
}
function vpe(e, t, r) {
  r === void 0 && (r = !1);
  const i = Wh(e), n = ix(e), o = rx(n);
  let s = n === "x" ? i === (r ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = Fg(s)), [s, Fg(s)];
}
function Cpe(e) {
  const t = Fg(e);
  return [pw(e), t, pw(t)];
}
function pw(e) {
  return e.replace(/start|end/g, (t) => ppe[t]);
}
const LR = ["left", "right"], GR = ["right", "left"], ype = ["top", "bottom"], bpe = ["bottom", "top"];
function wpe(e, t, r) {
  switch (e) {
    case "top":
    case "bottom":
      return r ? t ? GR : LR : t ? LR : GR;
    case "left":
    case "right":
      return t ? ype : bpe;
    default:
      return [];
  }
}
function Spe(e, t, r, i) {
  const n = Wh(e);
  let o = wpe(yu(e), r === "start", i);
  return n && (o = o.map((s) => s + "-" + n), t && (o = o.concat(o.map(pw)))), o;
}
function Fg(e) {
  return e.replace(/left|right|bottom|top/g, (t) => hpe[t]);
}
function Epe(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function iG(e) {
  return typeof e != "number" ? Epe(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function _g(e) {
  const {
    x: t,
    y: r,
    width: i,
    height: n
  } = e;
  return {
    width: i,
    height: n,
    top: r,
    left: t,
    right: t + i,
    bottom: r + n,
    x: t,
    y: r
  };
}
var xpe = typeof document < "u", Ape = function() {
}, Ng = xpe ? Vi : Ape;
const Dpe = {
  ...Y
}, Tpe = Dpe.useInsertionEffect, Rpe = Tpe || ((e) => e());
function Ppe(e) {
  const t = Y.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return Rpe(() => {
    t.current = e;
  }), Y.useCallback(function() {
    for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
      i[n] = arguments[n];
    return t.current == null ? void 0 : t.current(...i);
  }, []);
}
function kR(e, t, r) {
  let {
    reference: i,
    floating: n
  } = e;
  const o = Hs(t), s = ix(t), a = rx(s), l = yu(t), u = o === "y", c = i.x + i.width / 2 - n.width / 2, d = i.y + i.height / 2 - n.height / 2, h = i[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: c,
        y: i.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: i.y + i.height
      };
      break;
    case "right":
      p = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: i.x - n.width,
        y: d
      };
      break;
    default:
      p = {
        x: i.x,
        y: i.y
      };
  }
  switch (Wh(t)) {
    case "start":
      p[s] -= h * (r && u ? -1 : 1);
      break;
    case "end":
      p[s] += h * (r && u ? -1 : 1);
      break;
  }
  return p;
}
const Ipe = async (e, t, r) => {
  const {
    placement: i = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: s
  } = r, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: n
  }), {
    x: c,
    y: d
  } = kR(u, i, l), h = i, p = {}, g = 0;
  for (let m = 0; m < a.length; m++) {
    const {
      name: f,
      fn: C
    } = a[m], {
      x: w,
      y: E,
      data: b,
      reset: y
    } = await C({
      x: c,
      y: d,
      initialPlacement: i,
      placement: h,
      strategy: n,
      middlewareData: p,
      rects: u,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = w ?? c, d = E ?? d, p = {
      ...p,
      [f]: {
        ...p[f],
        ...b
      }
    }, y && g <= 50 && (g++, typeof y == "object" && (y.placement && (h = y.placement), y.rects && (u = y.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: n
    }) : y.rects), {
      x: c,
      y: d
    } = kR(u, h, l)), m = -1);
  }
  return {
    x: c,
    y: d,
    placement: h,
    strategy: n,
    middlewareData: p
  };
};
async function Ope(e, t) {
  var r;
  t === void 0 && (t = {});
  const {
    x: i,
    y: n,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: p = 0
  } = gv(t, e), g = iG(p), f = a[h ? d === "floating" ? "reference" : "floating" : d], C = _g(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(f))) == null || r ? f : f.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), w = d === "floating" ? {
    x: i,
    y: n,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), b = await (o.isElement == null ? void 0 : o.isElement(E)) ? await (o.getScale == null ? void 0 : o.getScale(E)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, y = _g(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: w,
    offsetParent: E,
    strategy: l
  }) : w);
  return {
    top: (C.top - y.top + g.top) / b.y,
    bottom: (y.bottom - C.bottom + g.bottom) / b.y,
    left: (C.left - y.left + g.left) / b.x,
    right: (y.right - C.right + g.right) / b.x
  };
}
const Mpe = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: r,
      y: i,
      placement: n,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: l
    } = t, {
      element: u,
      padding: c = 0
    } = gv(e, t) || {};
    if (u == null)
      return {};
    const d = iG(c), h = {
      x: r,
      y: i
    }, p = ix(n), g = rx(p), m = await s.getDimensions(u), f = p === "y", C = f ? "top" : "left", w = f ? "bottom" : "right", E = f ? "clientHeight" : "clientWidth", b = o.reference[g] + o.reference[p] - h[p] - o.floating[g], y = h[p] - o.reference[p], S = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let x = S ? S[E] : 0;
    (!x || !await (s.isElement == null ? void 0 : s.isElement(S))) && (x = a.floating[E] || o.floating[g]);
    const R = b / 2 - y / 2, P = x / 2 - m[g] / 2 - 1, O = Cu(d[C], P), I = Cu(d[w], P), M = O, _ = x - m[g] - I, G = x / 2 - m[g] / 2 + R, F = fpe(M, G, _), N = !l.arrow && Wh(n) != null && G !== F && o.reference[g] / 2 - (G < M ? O : I) - m[g] / 2 < 0, V = N ? G < M ? G - M : G - _ : 0;
    return {
      [p]: h[p] + V,
      data: {
        [p]: F,
        centerOffset: G - F - V,
        ...N && {
          alignmentOffset: V
        }
      },
      reset: N
    };
  }
}), Fpe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var r, i;
      const {
        placement: n,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: u
      } = t, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: m = !0,
        ...f
      } = gv(e, t);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const C = yu(n), w = Hs(a), E = yu(a) === a, b = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), y = h || (E || !m ? [Fg(a)] : Cpe(a)), S = g !== "none";
      !h && S && y.push(...Spe(a, m, g, b));
      const x = [a, ...y], R = await Ope(t, f), P = [];
      let O = ((i = o.flip) == null ? void 0 : i.overflows) || [];
      if (c && P.push(R[C]), d) {
        const G = vpe(n, s, b);
        P.push(R[G[0]], R[G[1]]);
      }
      if (O = [...O, {
        placement: n,
        overflows: P
      }], !P.every((G) => G <= 0)) {
        var I, M;
        const G = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, F = x[G];
        if (F && (!(d === "alignment" ? w !== Hs(F) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        O.every((B) => Hs(B.placement) === w ? B.overflows[0] > 0 : !0)))
          return {
            data: {
              index: G,
              overflows: O
            },
            reset: {
              placement: F
            }
          };
        let N = (M = O.filter((V) => V.overflows[0] <= 0).sort((V, B) => V.overflows[1] - B.overflows[1])[0]) == null ? void 0 : M.placement;
        if (!N)
          switch (p) {
            case "bestFit": {
              var _;
              const V = (_ = O.filter((B) => {
                if (S) {
                  const $ = Hs(B.placement);
                  return $ === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  $ === "y";
                }
                return !0;
              }).map((B) => [B.placement, B.overflows.filter(($) => $ > 0).reduce(($, L) => $ + L, 0)]).sort((B, $) => B[1] - $[1])[0]) == null ? void 0 : _[0];
              V && (N = V);
              break;
            }
            case "initialPlacement":
              N = a;
              break;
          }
        if (n !== N)
          return {
            reset: {
              placement: N
            }
          };
      }
      return {};
    }
  };
}, _pe = /* @__PURE__ */ new Set(["left", "top"]);
async function Npe(e, t) {
  const {
    placement: r,
    platform: i,
    elements: n
  } = e, o = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), s = yu(r), a = Wh(r), l = Hs(r) === "y", u = _pe.has(s) ? -1 : 1, c = o && l ? -1 : 1, d = gv(t, e);
  let {
    mainAxis: h,
    crossAxis: p,
    alignmentAxis: g
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof g == "number" && (p = a === "end" ? g * -1 : g), l ? {
    x: p * c,
    y: h * u
  } : {
    x: h * u,
    y: p * c
  };
}
const Lpe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var r, i;
      const {
        x: n,
        y: o,
        placement: s,
        middlewareData: a
      } = t, l = await Npe(t, e);
      return s === ((r = a.offset) == null ? void 0 : r.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: n + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
};
function nG(e) {
  const t = Ki(e);
  let r = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const n = qn(e), o = n ? e.offsetWidth : r, s = n ? e.offsetHeight : i, a = Mg(r) !== o || Mg(i) !== s;
  return a && (r = o, i = s), {
    width: r,
    height: i,
    $: a
  };
}
function nx(e) {
  return Rr(e) ? e : e.contextElement;
}
function yl(e) {
  const t = nx(e);
  if (!qn(t))
    return Hn(1);
  const r = t.getBoundingClientRect(), {
    width: i,
    height: n,
    $: o
  } = nG(t);
  let s = (o ? Mg(r.width) : r.width) / i, a = (o ? Mg(r.height) : r.height) / n;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const Gpe = /* @__PURE__ */ Hn(0);
function oG(e) {
  const t = bi(e);
  return !tx() || !t.visualViewport ? Gpe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function kpe(e, t, r) {
  return t === void 0 && (t = !1), !r || t && r !== bi(e) ? !1 : t;
}
function Sa(e, t, r, i) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const n = e.getBoundingClientRect(), o = nx(e);
  let s = Hn(1);
  t && (i ? Rr(i) && (s = yl(i)) : s = yl(e));
  const a = kpe(o, r, i) ? oG(o) : Hn(0);
  let l = (n.left + a.x) / s.x, u = (n.top + a.y) / s.y, c = n.width / s.x, d = n.height / s.y;
  if (o) {
    const h = bi(o), p = i && Rr(i) ? bi(i) : i;
    let g = h, m = hw(g);
    for (; m && i && p !== g; ) {
      const f = yl(m), C = m.getBoundingClientRect(), w = Ki(m), E = C.left + (m.clientLeft + parseFloat(w.paddingLeft)) * f.x, b = C.top + (m.clientTop + parseFloat(w.paddingTop)) * f.y;
      l *= f.x, u *= f.y, c *= f.x, d *= f.y, l += E, u += b, g = bi(m), m = hw(g);
    }
  }
  return _g({
    width: c,
    height: d,
    x: l,
    y: u
  });
}
function ox(e, t) {
  const r = fv(e).scrollLeft;
  return t ? t.left + r : Sa(Qn(e)).left + r;
}
function sG(e, t, r) {
  r === void 0 && (r = !1);
  const i = e.getBoundingClientRect(), n = i.left + t.scrollLeft - (r ? 0 : (
    // RTL <body> scrollbar.
    ox(e, i)
  )), o = i.top + t.scrollTop;
  return {
    x: n,
    y: o
  };
}
function Vpe(e) {
  let {
    elements: t,
    rect: r,
    offsetParent: i,
    strategy: n
  } = e;
  const o = n === "fixed", s = Qn(i), a = t ? pv(t.floating) : !1;
  if (i === s || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Hn(1);
  const c = Hn(0), d = qn(i);
  if ((d || !d && !o) && ((ec(i) !== "body" || Bh(s)) && (l = fv(i)), qn(i))) {
    const p = Sa(i);
    u = yl(i), c.x = p.x + i.clientLeft, c.y = p.y + i.clientTop;
  }
  const h = s && !d && !o ? sG(s, l, !0) : Hn(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + h.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + h.y
  };
}
function Hpe(e) {
  return Array.from(e.getClientRects());
}
function Bpe(e) {
  const t = Qn(e), r = fv(e), i = e.ownerDocument.body, n = ta(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), o = ta(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -r.scrollLeft + ox(e);
  const a = -r.scrollTop;
  return Ki(i).direction === "rtl" && (s += ta(t.clientWidth, i.clientWidth) - n), {
    width: n,
    height: o,
    x: s,
    y: a
  };
}
function Wpe(e, t) {
  const r = bi(e), i = Qn(e), n = r.visualViewport;
  let o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, s = n.height;
    const u = tx();
    (!u || u && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
const $pe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function jpe(e, t) {
  const r = Sa(e, !0, t === "fixed"), i = r.top + e.clientTop, n = r.left + e.clientLeft, o = qn(e) ? yl(e) : Hn(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, l = n * o.x, u = i * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: u
  };
}
function VR(e, t, r) {
  let i;
  if (t === "viewport")
    i = Wpe(e, r);
  else if (t === "document")
    i = Bpe(Qn(e));
  else if (Rr(t))
    i = jpe(t, r);
  else {
    const n = oG(e);
    i = {
      x: t.x - n.x,
      y: t.y - n.y,
      width: t.width,
      height: t.height
    };
  }
  return _g(i);
}
function aG(e, t) {
  const r = is(e);
  return r === t || !Rr(r) || vu(r) ? !1 : Ki(r).position === "fixed" || aG(r, t);
}
function zpe(e, t) {
  const r = t.get(e);
  if (r)
    return r;
  let i = ih(e, [], !1).filter((a) => Rr(a) && ec(a) !== "body"), n = null;
  const o = Ki(e).position === "fixed";
  let s = o ? is(e) : e;
  for (; Rr(s) && !vu(s); ) {
    const a = Ki(s), l = ex(s);
    !l && a.position === "fixed" && (n = null), (o ? !l && !n : !l && a.position === "static" && !!n && $pe.has(n.position) || Bh(s) && !l && aG(e, s)) ? i = i.filter((c) => c !== s) : n = a, s = is(s);
  }
  return t.set(e, i), i;
}
function Upe(e) {
  let {
    element: t,
    boundary: r,
    rootBoundary: i,
    strategy: n
  } = e;
  const s = [...r === "clippingAncestors" ? pv(t) ? [] : zpe(t, this._c) : [].concat(r), i], a = s[0], l = s.reduce((u, c) => {
    const d = VR(t, c, n);
    return u.top = ta(d.top, u.top), u.right = Cu(d.right, u.right), u.bottom = Cu(d.bottom, u.bottom), u.left = ta(d.left, u.left), u;
  }, VR(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Ype(e) {
  const {
    width: t,
    height: r
  } = nG(e);
  return {
    width: t,
    height: r
  };
}
function Xpe(e, t, r) {
  const i = qn(t), n = Qn(t), o = r === "fixed", s = Sa(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Hn(0);
  function u() {
    l.x = ox(n);
  }
  if (i || !i && !o)
    if ((ec(t) !== "body" || Bh(n)) && (a = fv(t)), i) {
      const p = Sa(t, !0, o, t);
      l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop;
    } else n && u();
  o && !i && n && u();
  const c = n && !i && !o ? sG(n, a) : Hn(0), d = s.left + a.scrollLeft - l.x - c.x, h = s.top + a.scrollTop - l.y - c.y;
  return {
    x: d,
    y: h,
    width: s.width,
    height: s.height
  };
}
function FC(e) {
  return Ki(e).position === "static";
}
function HR(e, t) {
  if (!qn(e) || Ki(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let r = e.offsetParent;
  return Qn(e) === r && (r = r.ownerDocument.body), r;
}
function lG(e, t) {
  const r = bi(e);
  if (pv(e))
    return r;
  if (!qn(e)) {
    let n = is(e);
    for (; n && !vu(n); ) {
      if (Rr(n) && !FC(n))
        return n;
      n = is(n);
    }
    return r;
  }
  let i = HR(e, t);
  for (; i && ope(i) && FC(i); )
    i = HR(i, t);
  return i && vu(i) && FC(i) && !ex(i) ? r : i || cpe(e) || r;
}
const Kpe = async function(e) {
  const t = this.getOffsetParent || lG, r = this.getDimensions, i = await r(e.floating);
  return {
    reference: Xpe(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function qpe(e) {
  return Ki(e).direction === "rtl";
}
const Zpe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Vpe,
  getDocumentElement: Qn,
  getClippingRect: Upe,
  getOffsetParent: lG,
  getElementRects: Kpe,
  getClientRects: Hpe,
  getDimensions: Ype,
  getScale: yl,
  isElement: Rr,
  isRTL: qpe
};
function uG(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Jpe(e, t) {
  let r = null, i;
  const n = Qn(e);
  function o() {
    var a;
    clearTimeout(i), (a = r) == null || a.disconnect(), r = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = e.getBoundingClientRect(), {
      left: c,
      top: d,
      width: h,
      height: p
    } = u;
    if (a || t(), !h || !p)
      return;
    const g = vp(d), m = vp(n.clientWidth - (c + h)), f = vp(n.clientHeight - (d + p)), C = vp(c), E = {
      rootMargin: -g + "px " + -m + "px " + -f + "px " + -C + "px",
      threshold: ta(0, Cu(1, l)) || 1
    };
    let b = !0;
    function y(S) {
      const x = S[0].intersectionRatio;
      if (x !== l) {
        if (!b)
          return s();
        x ? s(!1, x) : i = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      x === 1 && !uG(u, e.getBoundingClientRect()) && s(), b = !1;
    }
    try {
      r = new IntersectionObserver(y, {
        ...E,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(y, E);
    }
    r.observe(e);
  }
  return s(!0), o;
}
function cG(e, t, r, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, u = nx(e), c = n || o ? [...u ? ih(u) : [], ...ih(t)] : [];
  c.forEach((C) => {
    n && C.addEventListener("scroll", r, {
      passive: !0
    }), o && C.addEventListener("resize", r);
  });
  const d = u && a ? Jpe(u, r) : null;
  let h = -1, p = null;
  s && (p = new ResizeObserver((C) => {
    let [w] = C;
    w && w.target === u && p && (p.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var E;
      (E = p) == null || E.observe(t);
    })), r();
  }), u && !l && p.observe(u), p.observe(t));
  let g, m = l ? Sa(e) : null;
  l && f();
  function f() {
    const C = Sa(e);
    m && !uG(m, C) && r(), m = C, g = requestAnimationFrame(f);
  }
  return r(), () => {
    var C;
    c.forEach((w) => {
      n && w.removeEventListener("scroll", r), o && w.removeEventListener("resize", r);
    }), d == null || d(), (C = p) == null || C.disconnect(), p = null, l && cancelAnimationFrame(g);
  };
}
const Qpe = Lpe, efe = Fpe, BR = Mpe, tfe = (e, t, r) => {
  const i = /* @__PURE__ */ new Map(), n = {
    platform: Zpe,
    ...r
  }, o = {
    ...n.platform,
    _c: i
  };
  return Ipe(e, t, {
    ...n,
    platform: o
  });
};
var rfe = typeof document < "u", ife = function() {
}, Bp = rfe ? Vi : ife;
function Lg(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let r, i, n;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (r = e.length, r !== t.length) return !1;
      for (i = r; i-- !== 0; )
        if (!Lg(e[i], t[i]))
          return !1;
      return !0;
    }
    if (n = Object.keys(e), r = n.length, r !== Object.keys(t).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!{}.hasOwnProperty.call(t, n[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      const o = n[i];
      if (!(o === "_owner" && e.$$typeof) && !Lg(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function dG(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function WR(e, t) {
  const r = dG(e);
  return Math.round(t * r) / r;
}
function _C(e) {
  const t = Y.useRef(e);
  return Bp(() => {
    t.current = e;
  }), t;
}
function nfe(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: n,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: u
  } = e, [c, d] = Y.useState({
    x: 0,
    y: 0,
    strategy: r,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, p] = Y.useState(i);
  Lg(h, i) || p(i);
  const [g, m] = Y.useState(null), [f, C] = Y.useState(null), w = Y.useCallback((B) => {
    B !== S.current && (S.current = B, m(B));
  }, []), E = Y.useCallback((B) => {
    B !== x.current && (x.current = B, C(B));
  }, []), b = o || g, y = s || f, S = Y.useRef(null), x = Y.useRef(null), R = Y.useRef(c), P = l != null, O = _C(l), I = _C(n), M = _C(u), _ = Y.useCallback(() => {
    if (!S.current || !x.current)
      return;
    const B = {
      placement: t,
      strategy: r,
      middleware: h
    };
    I.current && (B.platform = I.current), tfe(S.current, x.current, B).then(($) => {
      const L = {
        ...$,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: M.current !== !1
      };
      G.current && !Lg(R.current, L) && (R.current = L, A1.flushSync(() => {
        d(L);
      }));
    });
  }, [h, t, r, I, M]);
  Bp(() => {
    u === !1 && R.current.isPositioned && (R.current.isPositioned = !1, d((B) => ({
      ...B,
      isPositioned: !1
    })));
  }, [u]);
  const G = Y.useRef(!1);
  Bp(() => (G.current = !0, () => {
    G.current = !1;
  }), []), Bp(() => {
    if (b && (S.current = b), y && (x.current = y), b && y) {
      if (O.current)
        return O.current(b, y, _);
      _();
    }
  }, [b, y, _, O, P]);
  const F = Y.useMemo(() => ({
    reference: S,
    floating: x,
    setReference: w,
    setFloating: E
  }), [w, E]), N = Y.useMemo(() => ({
    reference: b,
    floating: y
  }), [b, y]), V = Y.useMemo(() => {
    const B = {
      position: r,
      left: 0,
      top: 0
    };
    if (!N.floating)
      return B;
    const $ = WR(N.floating, c.x), L = WR(N.floating, c.y);
    return a ? {
      ...B,
      transform: "translate(" + $ + "px, " + L + "px)",
      ...dG(N.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r,
      left: $,
      top: L
    };
  }, [r, a, N.floating, c.x, c.y]);
  return Y.useMemo(() => ({
    ...c,
    update: _,
    refs: F,
    elements: N,
    floatingStyles: V
  }), [c, _, F, N, V]);
}
const ofe = (e) => {
  function t(r) {
    return {}.hasOwnProperty.call(r, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(r) {
      const {
        element: i,
        padding: n
      } = typeof e == "function" ? e(r) : e;
      return i && t(i) ? i.current != null ? BR({
        element: i.current,
        padding: n
      }).fn(r) : {} : i ? BR({
        element: i,
        padding: n
      }).fn(r) : {};
    }
  };
}, sfe = (e, t) => ({
  ...Qpe(e),
  options: [e, t]
}), afe = (e, t) => ({
  ...efe(e),
  options: [e, t]
}), lfe = (e, t) => ({
  ...ofe(e),
  options: [e, t]
}), ufe = {
  ...Y
};
let $R = !1, cfe = 0;
const jR = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + cfe++
);
function dfe() {
  const [e, t] = Y.useState(() => $R ? jR() : void 0);
  return Ng(() => {
    e == null && t(jR());
  }, []), Y.useEffect(() => {
    $R = !0;
  }, []), e;
}
const hfe = ufe.useId, hG = hfe || dfe;
let nh;
process.env.NODE_ENV !== "production" && (nh = /* @__PURE__ */ new Set());
function pfe() {
  for (var e, t = arguments.length, r = new Array(t), i = 0; i < t; i++)
    r[i] = arguments[i];
  const n = "Floating UI: " + r.join(" ");
  if (!((e = nh) != null && e.has(n))) {
    var o;
    (o = nh) == null || o.add(n), console.warn(n);
  }
}
function ffe() {
  for (var e, t = arguments.length, r = new Array(t), i = 0; i < t; i++)
    r[i] = arguments[i];
  const n = "Floating UI: " + r.join(" ");
  if (!((e = nh) != null && e.has(n))) {
    var o;
    (o = nh) == null || o.add(n), console.error(n);
  }
}
const gfe = /* @__PURE__ */ Y.forwardRef(function(t, r) {
  const {
    context: {
      placement: i,
      elements: {
        floating: n
      },
      middlewareData: {
        arrow: o,
        shift: s
      }
    },
    width: a = 14,
    height: l = 7,
    tipRadius: u = 0,
    strokeWidth: c = 0,
    staticOffset: d,
    stroke: h,
    d: p,
    style: {
      transform: g,
      ...m
    } = {},
    ...f
  } = t;
  process.env.NODE_ENV !== "production" && (r || pfe("The `ref` prop is required for `FloatingArrow`."));
  const C = hG(), [w, E] = Y.useState(!1);
  if (Ng(() => {
    if (!n) return;
    Ki(n).direction === "rtl" && E(!0);
  }, [n]), !n)
    return null;
  const [b, y] = i.split("-"), S = b === "top" || b === "bottom";
  let x = d;
  (S && s != null && s.x || !S && s != null && s.y) && (x = null);
  const R = c * 2, P = R / 2, O = a / 2 * (u / -8 + 1), I = l / 2 * u / 4, M = !!p, _ = x && y === "end" ? "bottom" : "top";
  let G = x && y === "end" ? "right" : "left";
  x && w && (G = y === "end" ? "left" : "right");
  const F = (o == null ? void 0 : o.x) != null ? x || o.x : "", N = (o == null ? void 0 : o.y) != null ? x || o.y : "", V = p || "M0,0" + (" H" + a) + (" L" + (a - O) + "," + (l - I)) + (" Q" + a / 2 + "," + l + " " + O + "," + (l - I)) + " Z", B = {
    top: M ? "rotate(180deg)" : "",
    left: M ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: M ? "" : "rotate(180deg)",
    right: M ? "rotate(-90deg)" : "rotate(90deg)"
  }[b];
  return /* @__PURE__ */ ve("svg", {
    ...f,
    "aria-hidden": !0,
    ref: r,
    width: M ? a : a + R,
    height: a,
    viewBox: "0 0 " + a + " " + (l > a ? l : a),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [G]: F,
      [_]: N,
      [b]: S || M ? "100%" : "calc(100% - " + R / 2 + "px)",
      transform: [B, g].filter(($) => !!$).join(" "),
      ...m
    },
    children: [R > 0 && /* @__PURE__ */ H("path", {
      clipPath: "url(#" + C + ")",
      fill: "none",
      stroke: h,
      strokeWidth: R + (p ? 0 : 1),
      d: V
    }), /* @__PURE__ */ H("path", {
      stroke: R && !p ? f.fill : "none",
      d: V
    }), /* @__PURE__ */ H("clipPath", {
      id: C,
      children: /* @__PURE__ */ H("rect", {
        x: -P,
        y: P * (M ? -1 : 1),
        width: a + R,
        height: a
      })
    })]
  });
});
function mfe() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, r) {
      var i;
      (i = e.get(t)) == null || i.forEach((n) => n(r));
    },
    on(t, r) {
      e.has(t) || e.set(t, /* @__PURE__ */ new Set()), e.get(t).add(r);
    },
    off(t, r) {
      var i;
      (i = e.get(t)) == null || i.delete(r);
    }
  };
}
const vfe = /* @__PURE__ */ Y.createContext(null), Cfe = /* @__PURE__ */ Y.createContext(null), yfe = () => {
  var e;
  return ((e = Y.useContext(vfe)) == null ? void 0 : e.id) || null;
}, bfe = () => Y.useContext(Cfe);
function wfe(e) {
  const {
    open: t = !1,
    onOpenChange: r,
    elements: i
  } = e, n = hG(), o = Y.useRef({}), [s] = Y.useState(() => mfe()), a = yfe() != null;
  if (process.env.NODE_ENV !== "production") {
    const p = i.reference;
    p && !Rr(p) && ffe("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [l, u] = Y.useState(i.reference), c = Ppe((p, g, m) => {
    o.current.openEvent = p ? g : void 0, s.emit("openchange", {
      open: p,
      event: g,
      reason: m,
      nested: a
    }), r == null || r(p, g, m);
  }), d = Y.useMemo(() => ({
    setPositionReference: u
  }), []), h = Y.useMemo(() => ({
    reference: l || i.reference || null,
    floating: i.floating || null,
    domReference: i.reference
  }), [l, i.reference, i.floating]);
  return Y.useMemo(() => ({
    dataRef: o,
    open: t,
    onOpenChange: c,
    elements: h,
    events: s,
    floatingId: n,
    refs: d
  }), [t, c, h, s, n, d]);
}
function Sfe(e) {
  e === void 0 && (e = {});
  const {
    nodeId: t
  } = e, r = wfe({
    ...e,
    elements: {
      reference: null,
      floating: null,
      ...e.elements
    }
  }), i = e.rootContext || r, n = i.elements, [o, s] = Y.useState(null), [a, l] = Y.useState(null), c = (n == null ? void 0 : n.domReference) || o, d = Y.useRef(null), h = bfe();
  Ng(() => {
    c && (d.current = c);
  }, [c]);
  const p = nfe({
    ...e,
    elements: {
      ...n,
      ...a && {
        reference: a
      }
    }
  }), g = Y.useCallback((E) => {
    const b = Rr(E) ? {
      getBoundingClientRect: () => E.getBoundingClientRect(),
      getClientRects: () => E.getClientRects(),
      contextElement: E
    } : E;
    l(b), p.refs.setReference(b);
  }, [p.refs]), m = Y.useCallback((E) => {
    (Rr(E) || E === null) && (d.current = E, s(E)), (Rr(p.refs.reference.current) || p.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    E !== null && !Rr(E)) && p.refs.setReference(E);
  }, [p.refs]), f = Y.useMemo(() => ({
    ...p.refs,
    setReference: m,
    setPositionReference: g,
    domReference: d
  }), [p.refs, m, g]), C = Y.useMemo(() => ({
    ...p.elements,
    domReference: c
  }), [p.elements, c]), w = Y.useMemo(() => ({
    ...p,
    ...i,
    refs: f,
    elements: C,
    nodeId: t
  }), [p, f, C, t, i]);
  return Ng(() => {
    i.dataRef.current.floatingContext = w;
    const E = h == null ? void 0 : h.nodesRef.current.find((b) => b.id === t);
    E && (E.context = w);
  }), Y.useMemo(() => ({
    ...p,
    context: w,
    refs: f,
    elements: C
  }), [p, f, C, w]);
}
/*!
  react-datepicker v7.6.0
  https://github.com/Hacker0x01/react-datepicker
  Released under the MIT License.
*/
var fw = function(t, r) {
  return fw = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
  }, fw(t, r);
};
function br(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  fw(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var qe = function() {
  return qe = Object.assign || function(r) {
    for (var i, n = 1, o = arguments.length; n < o; n++) {
      i = arguments[n];
      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
    }
    return r;
  }, qe.apply(this, arguments);
};
function Mn(e, t, r) {
  if (r || arguments.length === 2) for (var i = 0, n = t.length, o; i < n; i++)
    (o || !(i in t)) && (o || (o = Array.prototype.slice.call(t, 0, i)), o[i] = t[i]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var Efe = function(e) {
  var t = e.showTimeSelectOnly, r = t === void 0 ? !1 : t, i = e.showTime, n = i === void 0 ? !1 : i, o = e.className, s = e.children, a = r ? "Choose Time" : "Choose Date".concat(n ? " and Time" : "");
  return D.createElement("div", { className: o, role: "dialog", "aria-label": a, "aria-modal": "true" }, s);
}, xfe = function(e, t) {
  var r = re(null), i = re(e);
  i.current = e;
  var n = fe(function(o) {
    var s;
    r.current && !r.current.contains(o.target) && (t && o.target instanceof HTMLElement && o.target.classList.contains(t) || (s = i.current) === null || s === void 0 || s.call(i, o));
  }, [t]);
  return gt(function() {
    return document.addEventListener("mousedown", n), function() {
      document.removeEventListener("mousedown", n);
    };
  }, [n]), r;
}, mv = function(e) {
  var t = e.children, r = e.onClickOutside, i = e.className, n = e.containerRef, o = e.style, s = e.ignoreClass, a = xfe(r, s);
  return D.createElement("div", { className: i, style: o, ref: function(l) {
    a.current = l, n && (n.current = l);
  } }, t);
}, pe;
(function(e) {
  e.ArrowUp = "ArrowUp", e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Home = "Home", e.End = "End", e.Enter = "Enter", e.Space = " ", e.Tab = "Tab", e.Escape = "Escape", e.Backspace = "Backspace", e.X = "x";
})(pe || (pe = {}));
function pG() {
  var e = typeof window < "u" ? window : globalThis;
  return e;
}
var $h = 12, Afe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function ft(e) {
  if (e == null)
    return /* @__PURE__ */ new Date();
  var t = typeof e == "string" ? Hhe(e) : ge(e);
  return no(t) ? t : /* @__PURE__ */ new Date();
}
function NC(e, t, r, i, n) {
  var o, s = null, a = ra(r) || ra(jc()), l = !0;
  if (Array.isArray(t))
    return t.forEach(function(c) {
      var d = OC(e, c, /* @__PURE__ */ new Date(), {
        locale: a,
        useAdditionalWeekYearTokens: !0,
        useAdditionalDayOfYearTokens: !0
      });
      i && (l = no(d, n) && e === Ot(d, c, r)), no(d, n) && l && (s = d);
    }), s;
  if (s = OC(e, t, /* @__PURE__ */ new Date(), {
    locale: a,
    useAdditionalWeekYearTokens: !0,
    useAdditionalDayOfYearTokens: !0
  }), i)
    l = no(s) && e === Ot(s, t, r);
  else if (!no(s)) {
    var u = ((o = t.match(Afe)) !== null && o !== void 0 ? o : []).map(function(c) {
      var d = c[0];
      if (d === "p" || d === "P") {
        var h = Ig[d];
        return a ? h(c, a.formatLong) : d;
      }
      return c;
    }).join("");
    e.length > 0 && (s = OC(e, u.slice(0, e.length), /* @__PURE__ */ new Date(), {
      useAdditionalWeekYearTokens: !0,
      useAdditionalDayOfYearTokens: !0
    })), no(s) || (s = new Date(e));
  }
  return no(s) && l ? s : null;
}
function no(e, t) {
  return Dg(e) && !wa(e, t ?? /* @__PURE__ */ new Date("1/1/1800"));
}
function Ot(e, t, r) {
  if (r === "en")
    return MR(e, t, {
      useAdditionalWeekYearTokens: !0,
      useAdditionalDayOfYearTokens: !0
    });
  var i = r ? ra(r) : void 0;
  return r && !i && console.warn('A locale object was not found for the provided string ["'.concat(r, '"].')), !i && jc() && ra(jc()) && (i = ra(jc())), MR(e, t, {
    locale: i,
    useAdditionalWeekYearTokens: !0,
    useAdditionalDayOfYearTokens: !0
  });
}
function Oi(e, t) {
  var r = t.dateFormat, i = t.locale, n = Array.isArray(r) && r.length > 0 ? r[0] : r;
  return e && Ot(e, n, i) || "";
}
function Dfe(e, t, r) {
  if (!e)
    return "";
  var i = Oi(e, r), n = t ? Oi(t, r) : "";
  return "".concat(i, " - ").concat(n);
}
function Tfe(e, t) {
  if (!(e != null && e.length))
    return "";
  var r = e[0] ? Oi(e[0], t) : "";
  if (e.length === 1)
    return r;
  if (e.length === 2 && e[1]) {
    var i = Oi(e[1], t);
    return "".concat(r, ", ").concat(i);
  }
  var n = e.length - 1;
  return "".concat(r, " (+").concat(n, ")");
}
function LC(e, t) {
  var r = t.hour, i = r === void 0 ? 0 : r, n = t.minute, o = n === void 0 ? 0 : n, s = t.second, a = s === void 0 ? 0 : s;
  return kp(Vp(Hp(e, a), o), i);
}
function Rfe(e) {
  return qE(e);
}
function Pfe(e, t) {
  return Ot(e, "ddd", t);
}
function Wp(e) {
  return ba(e);
}
function Xo(e, t, r) {
  var i = ra(t || jc());
  return Ao(e, {
    locale: i,
    weekStartsOn: r
  });
}
function vo(e) {
  return WL(e);
}
function Ic(e) {
  return dv(e);
}
function zR(e) {
  return uw(e);
}
function UR() {
  return ba(ft());
}
function YR(e) {
  return HL(e);
}
function Ife(e) {
  return zce(e);
}
function Ofe(e) {
  return BL(e);
}
function An(e, t) {
  return e && t ? khe(e, t) : !e && !t;
}
function _r(e, t) {
  return e && t ? Lhe(e, t) : !e && !t;
}
function Gg(e, t) {
  return e && t ? Ghe(e, t) : !e && !t;
}
function Ue(e, t) {
  return e && t ? $ce(e, t) : !e && !t;
}
function Bs(e, t) {
  return e && t ? Bde(e, t) : !e && !t;
}
function Oc(e, t, r) {
  var i, n = ba(t), o = HL(r);
  try {
    i = rh(e, { start: n, end: o });
  } catch {
    i = !1;
  }
  return i;
}
function jc() {
  var e = pG();
  return e.__localeId__;
}
function ra(e) {
  if (typeof e == "string") {
    var t = pG();
    return t.__localeData__ ? t.__localeData__[e] : void 0;
  } else
    return e;
}
function Mfe(e, t, r) {
  return t(Ot(e, "EEEE", r));
}
function Ffe(e, t) {
  return Ot(e, "EEEEEE", t);
}
function _fe(e, t) {
  return Ot(e, "EEE", t);
}
function sx(e, t) {
  return Ot(pi(ft(), e), "LLLL", t);
}
function fG(e, t) {
  return Ot(pi(ft(), e), "LLL", t);
}
function Nfe(e, t) {
  return Ot(ol(ft(), e), "QQQ", t);
}
function Fi(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.maxDate, o = r.excludeDates, s = r.excludeDateIntervals, a = r.includeDates, l = r.includeDateIntervals, u = r.filterDate;
  return jh(e, { minDate: i, maxDate: n }) || o && o.some(function(c) {
    return c instanceof Date ? Ue(e, c) : Ue(e, c.date);
  }) || s && s.some(function(c) {
    var d = c.start, h = c.end;
    return rh(e, { start: d, end: h });
  }) || a && !a.some(function(c) {
    return Ue(e, c);
  }) || l && !l.some(function(c) {
    var d = c.start, h = c.end;
    return rh(e, { start: d, end: h });
  }) || u && !u(ft(e)) || !1;
}
function ax(e, t) {
  var r = t === void 0 ? {} : t, i = r.excludeDates, n = r.excludeDateIntervals;
  return n && n.length > 0 ? n.some(function(o) {
    var s = o.start, a = o.end;
    return rh(e, { start: s, end: a });
  }) : i && i.some(function(o) {
    var s;
    return o instanceof Date ? Ue(e, o) : Ue(e, (s = o.date) !== null && s !== void 0 ? s : /* @__PURE__ */ new Date());
  }) || !1;
}
function gG(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.maxDate, o = r.excludeDates, s = r.includeDates, a = r.filterDate;
  return jh(e, {
    minDate: i ? WL(i) : void 0,
    maxDate: n ? BL(n) : void 0
  }) || (o == null ? void 0 : o.some(function(l) {
    return _r(e, l instanceof Date ? l : l.date);
  })) || s && !s.some(function(l) {
    return _r(e, l);
  }) || a && !a(ft(e)) || !1;
}
function Cp(e, t, r, i) {
  var n = $e(e), o = Vr(e), s = $e(t), a = Vr(t), l = $e(i);
  return n === s && n === l ? o <= r && r <= a : n < s ? l === n && o <= r || l === s && a >= r || l < s && l > n : !1;
}
function Lfe(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.maxDate, o = r.excludeDates, s = r.includeDates;
  return jh(e, { minDate: i, maxDate: n }) || o && o.some(function(a) {
    return _r(a instanceof Date ? a : a.date, e);
  }) || s && !s.some(function(a) {
    return _r(a, e);
  }) || !1;
}
function yp(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.maxDate, o = r.excludeDates, s = r.includeDates, a = r.filterDate;
  return jh(e, { minDate: i, maxDate: n }) || (o == null ? void 0 : o.some(function(l) {
    return Gg(e, l instanceof Date ? l : l.date);
  })) || s && !s.some(function(l) {
    return Gg(e, l);
  }) || a && !a(ft(e)) || !1;
}
function bp(e, t, r) {
  if (!t || !r || !Dg(t) || !Dg(r))
    return !1;
  var i = $e(t), n = $e(r);
  return i <= e && n >= e;
}
function $p(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.maxDate, o = r.excludeDates, s = r.includeDates, a = r.filterDate, l = new Date(e, 0, 1);
  return jh(l, {
    minDate: i ? dv(i) : void 0,
    maxDate: n ? $L(n) : void 0
  }) || (o == null ? void 0 : o.some(function(u) {
    return An(l, u instanceof Date ? u : u.date);
  })) || s && !s.some(function(u) {
    return An(l, u);
  }) || a && !a(ft(l)) || !1;
}
function wp(e, t, r, i) {
  var n = $e(e), o = Qs(e), s = $e(t), a = Qs(t), l = $e(i);
  return n === s && n === l ? o <= r && r <= a : n < s ? l === n && o <= r || l === s && a >= r || l < s && l > n : !1;
}
function jh(e, t) {
  var r, i = t === void 0 ? {} : t, n = i.minDate, o = i.maxDate;
  return (r = n && gu(e, n) < 0 || o && gu(e, o) > 0) !== null && r !== void 0 ? r : !1;
}
function XR(e, t) {
  return t.some(function(r) {
    return kn(r) === kn(e) && Vn(r) === Vn(e) && mo(r) === mo(e);
  });
}
function KR(e, t) {
  var r = t === void 0 ? {} : t, i = r.excludeTimes, n = r.includeTimes, o = r.filterTime;
  return i && XR(e, i) || n && !XR(e, n) || o && !o(e) || !1;
}
function qR(e, t) {
  var r = t.minTime, i = t.maxTime;
  if (!r || !i)
    throw new Error("Both minTime and maxTime props required");
  var n = ft();
  n = kp(n, kn(e)), n = Vp(n, Vn(e)), n = Hp(n, mo(e));
  var o = ft();
  o = kp(o, kn(r)), o = Vp(o, Vn(r)), o = Hp(o, mo(r));
  var s = ft();
  s = kp(s, kn(i)), s = Vp(s, Vn(i)), s = Hp(s, mo(i));
  var a;
  try {
    a = !rh(n, { start: o, end: s });
  } catch {
    a = !1;
  }
  return a;
}
function ZR(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.includeDates, o = ea(e, 1);
  return i && Tg(i, o) > 0 || n && n.every(function(s) {
    return Tg(s, o) > 0;
  }) || !1;
}
function JR(e, t) {
  var r = t === void 0 ? {} : t, i = r.maxDate, n = r.includeDates, o = mn(e, 1);
  return i && Tg(o, i) > 0 || n && n.every(function(s) {
    return Tg(o, s) > 0;
  }) || !1;
}
function Gfe(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.includeDates, o = dv(e), s = eG(o);
  return i && Rg(i, s) > 0 || n && n.every(function(a) {
    return Rg(a, s) > 0;
  }) || !1;
}
function kfe(e, t) {
  var r = t === void 0 ? {} : t, i = r.maxDate, n = r.includeDates, o = $L(e), s = KE(o, 1);
  return i && Rg(s, i) > 0 || n && n.every(function(a) {
    return Rg(s, a) > 0;
  }) || !1;
}
function QR(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.includeDates, o = mu(e, 1);
  return i && Pg(i, o) > 0 || n && n.every(function(s) {
    return Pg(s, o) > 0;
  }) || !1;
}
function Vfe(e, t) {
  var r = t === void 0 ? {} : t, i = r.minDate, n = r.yearItemNumber, o = n === void 0 ? $h : n, s = Ic(mu(e, o)), a = jo(s, o).endPeriod, l = i && $e(i);
  return l && l > a || !1;
}
function eP(e, t) {
  var r = t === void 0 ? {} : t, i = r.maxDate, n = r.includeDates, o = fo(e, 1);
  return i && Pg(o, i) > 0 || n && n.every(function(s) {
    return Pg(o, s) > 0;
  }) || !1;
}
function Hfe(e, t) {
  var r = t === void 0 ? {} : t, i = r.maxDate, n = r.yearItemNumber, o = n === void 0 ? $h : n, s = fo(e, o), a = jo(s, o).startPeriod, l = i && $e(i);
  return l && l < a || !1;
}
function mG(e) {
  var t = e.minDate, r = e.includeDates;
  if (r && t) {
    var i = r.filter(function(n) {
      return gu(n, t) >= 0;
    });
    return DR(i);
  } else return r ? DR(r) : t;
}
function vG(e) {
  var t = e.maxDate, r = e.includeDates;
  if (r && t) {
    var i = r.filter(function(n) {
      return gu(n, t) <= 0;
    });
    return AR(i);
  } else return r ? AR(r) : t;
}
function tP(e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = "react-datepicker__day--highlighted");
  for (var i = /* @__PURE__ */ new Map(), n = 0, o = e.length; n < o; n++) {
    var s = e[n];
    if (go(s)) {
      var a = Ot(s, "MM.dd.yyyy"), l = i.get(a) || [];
      l.includes(t) || (l.push(t), i.set(a, l));
    } else if (typeof s == "object") {
      var u = Object.keys(s), c = (r = u[0]) !== null && r !== void 0 ? r : "", d = s[c];
      if (typeof c == "string" && Array.isArray(d))
        for (var h = 0, p = d.length; h < p; h++) {
          var g = d[h];
          if (g) {
            var a = Ot(g, "MM.dd.yyyy"), l = i.get(a) || [];
            l.includes(c) || (l.push(c), i.set(a, l));
          }
        }
    }
  }
  return i;
}
function Bfe(e, t) {
  return e.length !== t.length ? !1 : e.every(function(r, i) {
    return r === t[i];
  });
}
function Wfe(e, t) {
  e === void 0 && (e = []), t === void 0 && (t = "react-datepicker__day--holidays");
  var r = /* @__PURE__ */ new Map();
  return e.forEach(function(i) {
    var n = i.date, o = i.holidayName;
    if (go(n)) {
      var s = Ot(n, "MM.dd.yyyy"), a = r.get(s) || {
        className: "",
        holidayNames: []
      };
      if (!("className" in a && a.className === t && Bfe(a.holidayNames, [o]))) {
        a.className = t;
        var l = a.holidayNames;
        a.holidayNames = l ? Mn(Mn([], l, !0), [o], !1) : [o], r.set(s, a);
      }
    }
  }), r;
}
function $fe(e, t, r, i, n) {
  for (var o = n.length, s = [], a = 0; a < o; a++) {
    var l = e, u = n[a];
    u && (l = Vce(l, kn(u)), l = lw(l, Vn(u)), l = Wce(l, mo(u)));
    var c = lw(e, (r + 1) * i);
    rs(l, t) && wa(l, c) && u != null && s.push(u);
  }
  return s;
}
function rP(e) {
  return e < 10 ? "0".concat(e) : "".concat(e);
}
function jo(e, t) {
  t === void 0 && (t = $h);
  var r = Math.ceil($e(e) / t) * t, i = r - (t - 1);
  return { startPeriod: i, endPeriod: r };
}
function jfe(e) {
  var t = new Date(e.getFullYear(), e.getMonth(), e.getDate()), r = new Date(e.getFullYear(), e.getMonth(), e.getDate(), 24);
  return Math.round((+r - +t) / 36e5);
}
function iP(e) {
  var t = e.getSeconds(), r = e.getMilliseconds();
  return ge(e.getTime() - t * 1e3 - r);
}
function zfe(e, t) {
  return iP(e).getTime() === iP(t).getTime();
}
function nP(e) {
  if (!go(e))
    throw new Error("Invalid date");
  var t = new Date(e);
  return t.setHours(0, 0, 0, 0), t;
}
function oP(e, t) {
  if (!go(e) || !go(t))
    throw new Error("Invalid date received");
  var r = nP(e), i = nP(t);
  return wa(r, i);
}
function CG(e) {
  return e.key === pe.Space;
}
var Ufe = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.inputRef = D.createRef(), i.onTimeChange = function(n) {
        var o, s;
        i.setState({ time: n });
        var a = i.props.date, l = a instanceof Date && !isNaN(+a), u = l ? a : /* @__PURE__ */ new Date();
        if (n != null && n.includes(":")) {
          var c = n.split(":"), d = c[0], h = c[1];
          u.setHours(Number(d)), u.setMinutes(Number(h));
        }
        (s = (o = i.props).onChange) === null || s === void 0 || s.call(o, u);
      }, i.renderTimeInput = function() {
        var n = i.state.time, o = i.props, s = o.date, a = o.timeString, l = o.customTimeInput;
        return l ? Gt(l, {
          date: s,
          value: n,
          onChange: i.onTimeChange
        }) : D.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", ref: i.inputRef, onClick: function() {
          var u;
          (u = i.inputRef.current) === null || u === void 0 || u.focus();
        }, required: !0, value: n, onChange: function(u) {
          i.onTimeChange(u.target.value || a);
        } });
      }, i.state = {
        time: i.props.timeString
      }, i;
    }
    return t.getDerivedStateFromProps = function(r, i) {
      return r.timeString !== i.time ? {
        time: r.timeString
      } : null;
    }, t.prototype.render = function() {
      return D.createElement(
        "div",
        { className: "react-datepicker__input-time-container" },
        D.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel),
        D.createElement(
          "div",
          { className: "react-datepicker-time__input-container" },
          D.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())
        )
      );
    }, t;
  }($t)
), Yfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.dayEl = Ko(), r.handleClick = function(i) {
        !r.isDisabled() && r.props.onClick && r.props.onClick(i);
      }, r.handleMouseEnter = function(i) {
        !r.isDisabled() && r.props.onMouseEnter && r.props.onMouseEnter(i);
      }, r.handleOnKeyDown = function(i) {
        var n, o, s = i.key;
        s === pe.Space && (i.preventDefault(), i.key = pe.Enter), (o = (n = r.props).handleOnKeyDown) === null || o === void 0 || o.call(n, i);
      }, r.isSameDay = function(i) {
        return Ue(r.props.day, i);
      }, r.isKeyboardSelected = function() {
        var i;
        if (r.props.disabledKeyboardNavigation)
          return !1;
        var n = r.props.selectsMultiple ? (i = r.props.selectedDates) === null || i === void 0 ? void 0 : i.some(function(s) {
          return r.isSameDayOrWeek(s);
        }) : r.isSameDayOrWeek(r.props.selected), o = r.props.preSelection && r.isDisabled(r.props.preSelection);
        return !n && r.isSameDayOrWeek(r.props.preSelection) && !o;
      }, r.isDisabled = function(i) {
        return i === void 0 && (i = r.props.day), Fi(i, {
          minDate: r.props.minDate,
          maxDate: r.props.maxDate,
          excludeDates: r.props.excludeDates,
          excludeDateIntervals: r.props.excludeDateIntervals,
          includeDateIntervals: r.props.includeDateIntervals,
          includeDates: r.props.includeDates,
          filterDate: r.props.filterDate
        });
      }, r.isExcluded = function() {
        return ax(r.props.day, {
          excludeDates: r.props.excludeDates,
          excludeDateIntervals: r.props.excludeDateIntervals
        });
      }, r.isStartOfWeek = function() {
        return Ue(r.props.day, Xo(r.props.day, r.props.locale, r.props.calendarStartDay));
      }, r.isSameWeek = function(i) {
        return r.props.showWeekPicker && Ue(i, Xo(r.props.day, r.props.locale, r.props.calendarStartDay));
      }, r.isSameDayOrWeek = function(i) {
        return r.isSameDay(i) || r.isSameWeek(i);
      }, r.getHighLightedClass = function() {
        var i = r.props, n = i.day, o = i.highlightDates;
        if (!o)
          return !1;
        var s = Ot(n, "MM.dd.yyyy");
        return o.get(s);
      }, r.getHolidaysClass = function() {
        var i, n = r.props, o = n.day, s = n.holidays;
        if (!s)
          return [void 0];
        var a = Ot(o, "MM.dd.yyyy");
        return s.has(a) ? [(i = s.get(a)) === null || i === void 0 ? void 0 : i.className] : [void 0];
      }, r.isInRange = function() {
        var i = r.props, n = i.day, o = i.startDate, s = i.endDate;
        return !o || !s ? !1 : Oc(n, o, s);
      }, r.isInSelectingRange = function() {
        var i, n = r.props, o = n.day, s = n.selectsStart, a = n.selectsEnd, l = n.selectsRange, u = n.selectsDisabledDaysInRange, c = n.startDate, d = n.endDate, h = (i = r.props.selectingDate) !== null && i !== void 0 ? i : r.props.preSelection;
        return !(s || a || l) || !h || !u && r.isDisabled() ? !1 : s && d && (wa(h, d) || Bs(h, d)) ? Oc(o, h, d) : a && c && (rs(h, c) || Bs(h, c)) || l && c && !d && (rs(h, c) || Bs(h, c)) ? Oc(o, c, h) : !1;
      }, r.isSelectingRangeStart = function() {
        var i;
        if (!r.isInSelectingRange())
          return !1;
        var n = r.props, o = n.day, s = n.startDate, a = n.selectsStart, l = (i = r.props.selectingDate) !== null && i !== void 0 ? i : r.props.preSelection;
        return a ? Ue(o, l) : Ue(o, s);
      }, r.isSelectingRangeEnd = function() {
        var i;
        if (!r.isInSelectingRange())
          return !1;
        var n = r.props, o = n.day, s = n.endDate, a = n.selectsEnd, l = n.selectsRange, u = (i = r.props.selectingDate) !== null && i !== void 0 ? i : r.props.preSelection;
        return a || l ? Ue(o, u) : Ue(o, s);
      }, r.isRangeStart = function() {
        var i = r.props, n = i.day, o = i.startDate, s = i.endDate;
        return !o || !s ? !1 : Ue(o, n);
      }, r.isRangeEnd = function() {
        var i = r.props, n = i.day, o = i.startDate, s = i.endDate;
        return !o || !s ? !1 : Ue(s, n);
      }, r.isWeekend = function() {
        var i = Gde(r.props.day);
        return i === 0 || i === 6;
      }, r.isAfterMonth = function() {
        return r.props.month !== void 0 && (r.props.month + 1) % 12 === Vr(r.props.day);
      }, r.isBeforeMonth = function() {
        return r.props.month !== void 0 && (Vr(r.props.day) + 1) % 12 === r.props.month;
      }, r.isCurrentDay = function() {
        return r.isSameDay(ft());
      }, r.isSelected = function() {
        var i;
        return r.props.selectsMultiple ? (i = r.props.selectedDates) === null || i === void 0 ? void 0 : i.some(function(n) {
          return r.isSameDayOrWeek(n);
        }) : r.isSameDayOrWeek(r.props.selected);
      }, r.getClassNames = function(i) {
        var n = r.props.dayClassName ? r.props.dayClassName(i) : void 0;
        return xe("react-datepicker__day", n, "react-datepicker__day--" + Pfe(r.props.day), {
          "react-datepicker__day--disabled": r.isDisabled(),
          "react-datepicker__day--excluded": r.isExcluded(),
          "react-datepicker__day--selected": r.isSelected(),
          "react-datepicker__day--keyboard-selected": r.isKeyboardSelected(),
          "react-datepicker__day--range-start": r.isRangeStart(),
          "react-datepicker__day--range-end": r.isRangeEnd(),
          "react-datepicker__day--in-range": r.isInRange(),
          "react-datepicker__day--in-selecting-range": r.isInSelectingRange(),
          "react-datepicker__day--selecting-range-start": r.isSelectingRangeStart(),
          "react-datepicker__day--selecting-range-end": r.isSelectingRangeEnd(),
          "react-datepicker__day--today": r.isCurrentDay(),
          "react-datepicker__day--weekend": r.isWeekend(),
          "react-datepicker__day--outside-month": r.isAfterMonth() || r.isBeforeMonth()
        }, r.getHighLightedClass(), r.getHolidaysClass());
      }, r.getAriaLabel = function() {
        var i = r.props, n = i.day, o = i.ariaLabelPrefixWhenEnabled, s = o === void 0 ? "Choose" : o, a = i.ariaLabelPrefixWhenDisabled, l = a === void 0 ? "Not available" : a, u = r.isDisabled() || r.isExcluded() ? l : s;
        return "".concat(u, " ").concat(Ot(n, "PPPP", r.props.locale));
      }, r.getTitle = function() {
        var i = r.props, n = i.day, o = i.holidays, s = o === void 0 ? /* @__PURE__ */ new Map() : o, a = i.excludeDates, l = Ot(n, "MM.dd.yyyy"), u = [];
        return s.has(l) && u.push.apply(u, s.get(l).holidayNames), r.isExcluded() && u.push(a == null ? void 0 : a.filter(function(c) {
          return c instanceof Date ? Ue(c, n) : Ue(c == null ? void 0 : c.date, n);
        }).map(function(c) {
          if (!(c instanceof Date))
            return c == null ? void 0 : c.message;
        })), u.join(", ");
      }, r.getTabIndex = function() {
        var i = r.props.selected, n = r.props.preSelection, o = !(r.props.showWeekPicker && (r.props.showWeekNumber || !r.isStartOfWeek())) && (r.isKeyboardSelected() || r.isSameDay(i) && Ue(n, i)) ? 0 : -1;
        return o;
      }, r.handleFocusDay = function() {
        var i;
        r.shouldFocusDay() && ((i = r.dayEl.current) === null || i === void 0 || i.focus({ preventScroll: !0 }));
      }, r.renderDayContents = function() {
        return r.props.monthShowsDuplicateDaysEnd && r.isAfterMonth() || r.props.monthShowsDuplicateDaysStart && r.isBeforeMonth() ? null : r.props.renderDayContents ? r.props.renderDayContents(FR(r.props.day), r.props.day) : FR(r.props.day);
      }, r.render = function() {
        return (
          // TODO: Use <option> instead of the "option" role to ensure accessibility across all devices.
          D.createElement(
            "div",
            { ref: r.dayEl, className: r.getClassNames(r.props.day), onKeyDown: r.handleOnKeyDown, onClick: r.handleClick, onMouseEnter: r.props.usePointerEvent ? void 0 : r.handleMouseEnter, onPointerEnter: r.props.usePointerEvent ? r.handleMouseEnter : void 0, tabIndex: r.getTabIndex(), "aria-label": r.getAriaLabel(), role: "option", title: r.getTitle(), "aria-disabled": r.isDisabled(), "aria-current": r.isCurrentDay() ? "date" : void 0, "aria-selected": r.isSelected() || r.isInRange() },
            r.renderDayContents(),
            r.getTitle() !== "" && D.createElement("span", { className: "overlay" }, r.getTitle())
          )
        );
      }, r;
    }
    return t.prototype.componentDidMount = function() {
      this.handleFocusDay();
    }, t.prototype.componentDidUpdate = function() {
      this.handleFocusDay();
    }, t.prototype.shouldFocusDay = function() {
      var r = !1;
      return this.getTabIndex() === 0 && this.isSameDay(this.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (r = !0), this.props.inline && !this.props.shouldFocusDayInline && (r = !1), this.isDayActiveElement() && (r = !0), this.isDuplicateDay() && (r = !1)), r;
    }, t.prototype.isDayActiveElement = function() {
      var r, i, n;
      return ((i = (r = this.props.containerRef) === null || r === void 0 ? void 0 : r.current) === null || i === void 0 ? void 0 : i.contains(document.activeElement)) && ((n = document.activeElement) === null || n === void 0 ? void 0 : n.classList.contains("react-datepicker__day"));
    }, t.prototype.isDuplicateDay = function() {
      return (
        //day is one of the non rendered duplicate days
        this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth() || this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth()
      );
    }, t;
  }($t)
), Xfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.weekNumberEl = Ko(), r.handleClick = function(i) {
        r.props.onClick && r.props.onClick(i);
      }, r.handleOnKeyDown = function(i) {
        var n, o, s = i.key;
        s === pe.Space && (i.preventDefault(), i.key = pe.Enter), (o = (n = r.props).handleOnKeyDown) === null || o === void 0 || o.call(n, i);
      }, r.isKeyboardSelected = function() {
        return !r.props.disabledKeyboardNavigation && !Ue(r.props.date, r.props.selected) && Ue(r.props.date, r.props.preSelection);
      }, r.getTabIndex = function() {
        return r.props.showWeekPicker && r.props.showWeekNumber && (r.isKeyboardSelected() || Ue(r.props.date, r.props.selected) && Ue(r.props.preSelection, r.props.selected)) ? 0 : -1;
      }, r.handleFocusWeekNumber = function(i) {
        var n = !1;
        r.getTabIndex() === 0 && !(i != null && i.isInputFocused) && Ue(r.props.date, r.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (n = !0), r.props.inline && !r.props.shouldFocusDayInline && (n = !1), r.props.containerRef && r.props.containerRef.current && r.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number") && (n = !0)), n && r.weekNumberEl.current && r.weekNumberEl.current.focus({ preventScroll: !0 });
      }, r;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          ariaLabelPrefix: "week "
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.componentDidMount = function() {
      this.handleFocusWeekNumber();
    }, t.prototype.componentDidUpdate = function(r) {
      this.handleFocusWeekNumber(r);
    }, t.prototype.render = function() {
      var r = this.props, i = r.weekNumber, n = r.isWeekDisabled, o = r.ariaLabelPrefix, s = o === void 0 ? t.defaultProps.ariaLabelPrefix : o, a = r.onClick, l = {
        "react-datepicker__week-number": !0,
        "react-datepicker__week-number--clickable": !!a && !n,
        "react-datepicker__week-number--selected": !!a && Ue(this.props.date, this.props.selected)
      };
      return D.createElement("div", { ref: this.weekNumberEl, className: xe(l), "aria-label": "".concat(s, " ").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex() }, i);
    }, t;
  }($t)
), Kfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.isDisabled = function(i) {
        return Fi(i, {
          minDate: r.props.minDate,
          maxDate: r.props.maxDate,
          excludeDates: r.props.excludeDates,
          excludeDateIntervals: r.props.excludeDateIntervals,
          includeDateIntervals: r.props.includeDateIntervals,
          includeDates: r.props.includeDates,
          filterDate: r.props.filterDate
        });
      }, r.handleDayClick = function(i, n) {
        r.props.onDayClick && r.props.onDayClick(i, n);
      }, r.handleDayMouseEnter = function(i) {
        r.props.onDayMouseEnter && r.props.onDayMouseEnter(i);
      }, r.handleWeekClick = function(i, n, o) {
        for (var s, a, l, u = new Date(i), c = 0; c < 7; c++) {
          var d = new Date(i);
          d.setDate(d.getDate() + c);
          var h = !r.isDisabled(d);
          if (h) {
            u = d;
            break;
          }
        }
        typeof r.props.onWeekSelect == "function" && r.props.onWeekSelect(u, n, o), r.props.showWeekPicker && r.handleDayClick(u, o), ((s = r.props.shouldCloseOnSelect) !== null && s !== void 0 ? s : t.defaultProps.shouldCloseOnSelect) && ((l = (a = r.props).setOpen) === null || l === void 0 || l.call(a, !1));
      }, r.formatWeekNumber = function(i) {
        return r.props.formatWeekNumber ? r.props.formatWeekNumber(i) : Rfe(i);
      }, r.isWeekDisabled = function() {
        for (var i = r.startOfWeek(), n = pn(i, 6), o = new Date(i); o <= n; ) {
          if (!r.isDisabled(o))
            return !1;
          o = pn(o, 1);
        }
        return !0;
      }, r.renderDays = function() {
        var i = r.startOfWeek(), n = [], o = r.formatWeekNumber(i);
        if (r.props.showWeekNumber) {
          var s = r.props.onWeekSelect || r.props.showWeekPicker ? r.handleWeekClick.bind(r, i, o) : void 0;
          n.push(D.createElement(Xfe, qe({ key: "W" }, t.defaultProps, r.props, { weekNumber: o, isWeekDisabled: r.isWeekDisabled(), date: i, onClick: s })));
        }
        return n.concat([0, 1, 2, 3, 4, 5, 6].map(function(a) {
          var l = pn(i, a);
          return D.createElement(Yfe, qe({}, t.defaultProps, r.props, { ariaLabelPrefixWhenEnabled: r.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: r.props.disabledDayAriaLabelPrefix, key: l.valueOf(), day: l, onClick: r.handleDayClick.bind(r, l), onMouseEnter: r.handleDayMouseEnter.bind(r, l) }));
        }));
      }, r.startOfWeek = function() {
        return Xo(r.props.day, r.props.locale, r.props.calendarStartDay);
      }, r.isKeyboardSelected = function() {
        return !r.props.disabledKeyboardNavigation && !Ue(r.startOfWeek(), r.props.selected) && Ue(r.startOfWeek(), r.props.preSelection);
      }, r;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          shouldCloseOnSelect: !0
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.render = function() {
      var r = {
        "react-datepicker__week": !0,
        "react-datepicker__week--selected": Ue(this.startOfWeek(), this.props.selected),
        "react-datepicker__week--keyboard-selected": this.isKeyboardSelected()
      };
      return D.createElement("div", { className: xe(r) }, this.renderDays());
    }, t;
  }($t)
), bc, qfe = 6, bl = {
  TWO_COLUMNS: "two_columns",
  THREE_COLUMNS: "three_columns",
  FOUR_COLUMNS: "four_columns"
}, GC = (bc = {}, bc[bl.TWO_COLUMNS] = {
  grid: [
    [0, 1],
    [2, 3],
    [4, 5],
    [6, 7],
    [8, 9],
    [10, 11]
  ],
  verticalNavigationOffset: 2
}, bc[bl.THREE_COLUMNS] = {
  grid: [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [9, 10, 11]
  ],
  verticalNavigationOffset: 3
}, bc[bl.FOUR_COLUMNS] = {
  grid: [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11]
  ],
  verticalNavigationOffset: 4
}, bc), Sp = 1;
function sP(e, t) {
  return e ? bl.FOUR_COLUMNS : t ? bl.TWO_COLUMNS : bl.THREE_COLUMNS;
}
var Zfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.MONTH_REFS = Mn([], Array(12), !0).map(function() {
        return Ko();
      }), r.QUARTER_REFS = Mn([], Array(4), !0).map(function() {
        return Ko();
      }), r.isDisabled = function(i) {
        return Fi(i, {
          minDate: r.props.minDate,
          maxDate: r.props.maxDate,
          excludeDates: r.props.excludeDates,
          excludeDateIntervals: r.props.excludeDateIntervals,
          includeDateIntervals: r.props.includeDateIntervals,
          includeDates: r.props.includeDates,
          filterDate: r.props.filterDate
        });
      }, r.isExcluded = function(i) {
        return ax(i, {
          excludeDates: r.props.excludeDates,
          excludeDateIntervals: r.props.excludeDateIntervals
        });
      }, r.handleDayClick = function(i, n) {
        var o, s;
        (s = (o = r.props).onDayClick) === null || s === void 0 || s.call(o, i, n, r.props.orderInDisplay);
      }, r.handleDayMouseEnter = function(i) {
        var n, o;
        (o = (n = r.props).onDayMouseEnter) === null || o === void 0 || o.call(n, i);
      }, r.handleMouseLeave = function() {
        var i, n;
        (n = (i = r.props).onMouseLeave) === null || n === void 0 || n.call(i);
      }, r.isRangeStartMonth = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate;
        return !s || !a ? !1 : _r(pi(o, i), s);
      }, r.isRangeStartQuarter = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate;
        return !s || !a ? !1 : Gg(ol(o, i), s);
      }, r.isRangeEndMonth = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate;
        return !s || !a ? !1 : _r(pi(o, i), a);
      }, r.isRangeEndQuarter = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate;
        return !s || !a ? !1 : Gg(ol(o, i), a);
      }, r.isInSelectingRangeMonth = function(i) {
        var n, o = r.props, s = o.day, a = o.selectsStart, l = o.selectsEnd, u = o.selectsRange, c = o.startDate, d = o.endDate, h = (n = r.props.selectingDate) !== null && n !== void 0 ? n : r.props.preSelection;
        return !(a || l || u) || !h ? !1 : a && d ? Cp(h, d, i, s) : l && c || u && c && !d ? Cp(c, h, i, s) : !1;
      }, r.isSelectingMonthRangeStart = function(i) {
        var n;
        if (!r.isInSelectingRangeMonth(i))
          return !1;
        var o = r.props, s = o.day, a = o.startDate, l = o.selectsStart, u = pi(s, i), c = (n = r.props.selectingDate) !== null && n !== void 0 ? n : r.props.preSelection;
        return l ? _r(u, c) : _r(u, a);
      }, r.isSelectingMonthRangeEnd = function(i) {
        var n;
        if (!r.isInSelectingRangeMonth(i))
          return !1;
        var o = r.props, s = o.day, a = o.endDate, l = o.selectsEnd, u = o.selectsRange, c = pi(s, i), d = (n = r.props.selectingDate) !== null && n !== void 0 ? n : r.props.preSelection;
        return l || u ? _r(c, d) : _r(c, a);
      }, r.isInSelectingRangeQuarter = function(i) {
        var n, o = r.props, s = o.day, a = o.selectsStart, l = o.selectsEnd, u = o.selectsRange, c = o.startDate, d = o.endDate, h = (n = r.props.selectingDate) !== null && n !== void 0 ? n : r.props.preSelection;
        return !(a || l || u) || !h ? !1 : a && d ? wp(h, d, i, s) : l && c || u && c && !d ? wp(c, h, i, s) : !1;
      }, r.isWeekInMonth = function(i) {
        var n = r.props.day, o = pn(i, 6);
        return _r(i, n) || _r(o, n);
      }, r.isCurrentMonth = function(i, n) {
        return $e(i) === $e(ft()) && n === Vr(ft());
      }, r.isCurrentQuarter = function(i, n) {
        return $e(i) === $e(ft()) && n === Qs(ft());
      }, r.isSelectedMonth = function(i, n, o) {
        return Vr(o) === n && $e(i) === $e(o);
      }, r.isSelectMonthInList = function(i, n, o) {
        return o.some(function(s) {
          return r.isSelectedMonth(i, n, s);
        });
      }, r.isSelectedQuarter = function(i, n, o) {
        return Qs(i) === n && $e(i) === $e(o);
      }, r.renderWeeks = function() {
        for (var i = [], n = r.props.fixedHeight, o = 0, s = !1, a = Xo(vo(r.props.day), r.props.locale, r.props.calendarStartDay), l = function(g) {
          return r.props.showWeekPicker ? Xo(g, r.props.locale, r.props.calendarStartDay) : r.props.preSelection;
        }, u = function(g) {
          return r.props.showWeekPicker ? Xo(g, r.props.locale, r.props.calendarStartDay) : r.props.selected;
        }, c = r.props.selected ? u(r.props.selected) : void 0, d = r.props.preSelection ? l(r.props.preSelection) : void 0; i.push(D.createElement(Kfe, qe({}, r.props, { ariaLabelPrefix: r.props.weekAriaLabelPrefix, key: o, day: a, month: Vr(r.props.day), onDayClick: r.handleDayClick, onDayMouseEnter: r.handleDayMouseEnter, selected: c, preSelection: d, showWeekNumber: r.props.showWeekNumbers }))), !s; ) {
          o++, a = Ag(a, 1);
          var h = n && o >= qfe, p = !n && !r.isWeekInMonth(a);
          if (h || p)
            if (r.props.peekNextMonth)
              s = !0;
            else
              break;
        }
        return i;
      }, r.onMonthClick = function(i, n) {
        var o = r.isMonthDisabledForLabelDate(n), s = o.isDisabled, a = o.labelDate;
        s || r.handleDayClick(vo(a), i);
      }, r.onMonthMouseEnter = function(i) {
        var n = r.isMonthDisabledForLabelDate(i), o = n.isDisabled, s = n.labelDate;
        o || r.handleDayMouseEnter(vo(s));
      }, r.handleMonthNavigation = function(i, n) {
        var o, s, a, l;
        (s = (o = r.props).setPreSelection) === null || s === void 0 || s.call(o, n), (l = (a = r.MONTH_REFS[i]) === null || a === void 0 ? void 0 : a.current) === null || l === void 0 || l.focus();
      }, r.handleKeyboardNavigation = function(i, n, o) {
        var s, a = r.props, l = a.selected, u = a.preSelection, c = a.setPreSelection, d = a.minDate, h = a.maxDate, p = a.showFourColumnMonthYearPicker, g = a.showTwoColumnMonthYearPicker;
        if (u) {
          var m = sP(p, g), f = r.getVerticalOffset(m), C = (s = GC[m]) === null || s === void 0 ? void 0 : s.grid, w = function(x, R, P) {
            var O, I, M = R, _ = P;
            switch (x) {
              case pe.ArrowRight:
                M = mn(R, Sp), _ = P === 11 ? 0 : P + Sp;
                break;
              case pe.ArrowLeft:
                M = ea(R, Sp), _ = P === 0 ? 11 : P - Sp;
                break;
              case pe.ArrowUp:
                M = ea(R, f), _ = !((O = C == null ? void 0 : C[0]) === null || O === void 0) && O.includes(P) ? P + 12 - f : P - f;
                break;
              case pe.ArrowDown:
                M = mn(R, f), _ = !((I = C == null ? void 0 : C[C.length - 1]) === null || I === void 0) && I.includes(P) ? P - 12 + f : P + f;
                break;
            }
            return { newCalculatedDate: M, newCalculatedMonth: _ };
          }, E = function(x, R, P) {
            for (var O = 40, I = x, M = !1, _ = 0, G = w(I, R, P), F = G.newCalculatedDate, N = G.newCalculatedMonth; !M; ) {
              if (_ >= O) {
                F = R, N = P;
                break;
              }
              if (d && F < d) {
                I = pe.ArrowRight;
                var V = w(I, F, N);
                F = V.newCalculatedDate, N = V.newCalculatedMonth;
              }
              if (h && F > h) {
                I = pe.ArrowLeft;
                var V = w(I, F, N);
                F = V.newCalculatedDate, N = V.newCalculatedMonth;
              }
              if (Lfe(F, r.props)) {
                var V = w(I, F, N);
                F = V.newCalculatedDate, N = V.newCalculatedMonth;
              } else
                M = !0;
              _++;
            }
            return { newCalculatedDate: F, newCalculatedMonth: N };
          };
          if (n === pe.Enter) {
            r.isMonthDisabled(o) || (r.onMonthClick(i, o), c == null || c(l));
            return;
          }
          var b = E(n, u, o), y = b.newCalculatedDate, S = b.newCalculatedMonth;
          switch (n) {
            case pe.ArrowRight:
            case pe.ArrowLeft:
            case pe.ArrowUp:
            case pe.ArrowDown:
              r.handleMonthNavigation(S, y);
              break;
          }
        }
      }, r.getVerticalOffset = function(i) {
        var n, o;
        return (o = (n = GC[i]) === null || n === void 0 ? void 0 : n.verticalNavigationOffset) !== null && o !== void 0 ? o : 0;
      }, r.onMonthKeyDown = function(i, n) {
        var o = r.props, s = o.disabledKeyboardNavigation, a = o.handleOnMonthKeyDown, l = i.key;
        l !== pe.Tab && i.preventDefault(), s || r.handleKeyboardNavigation(i, l, n), a && a(i);
      }, r.onQuarterClick = function(i, n) {
        var o = ol(r.props.day, n);
        yp(o, r.props) || r.handleDayClick(zR(o), i);
      }, r.onQuarterMouseEnter = function(i) {
        var n = ol(r.props.day, i);
        yp(n, r.props) || r.handleDayMouseEnter(zR(n));
      }, r.handleQuarterNavigation = function(i, n) {
        var o, s, a, l;
        r.isDisabled(n) || r.isExcluded(n) || ((s = (o = r.props).setPreSelection) === null || s === void 0 || s.call(o, n), (l = (a = r.QUARTER_REFS[i - 1]) === null || a === void 0 ? void 0 : a.current) === null || l === void 0 || l.focus());
      }, r.onQuarterKeyDown = function(i, n) {
        var o, s, a = i.key;
        if (!r.props.disabledKeyboardNavigation)
          switch (a) {
            case pe.Enter:
              r.onQuarterClick(i, n), (s = (o = r.props).setPreSelection) === null || s === void 0 || s.call(o, r.props.selected);
              break;
            case pe.ArrowRight:
              if (!r.props.preSelection)
                break;
              r.handleQuarterNavigation(n === 4 ? 1 : n + 1, KE(r.props.preSelection, 1));
              break;
            case pe.ArrowLeft:
              if (!r.props.preSelection)
                break;
              r.handleQuarterNavigation(n === 1 ? 4 : n - 1, eG(r.props.preSelection));
              break;
          }
      }, r.isMonthDisabledForLabelDate = function(i) {
        var n, o = r.props, s = o.day, a = o.minDate, l = o.maxDate, u = o.excludeDates, c = o.includeDates, d = pi(s, i);
        return {
          isDisabled: (n = (a || l || u || c) && gG(d, r.props)) !== null && n !== void 0 ? n : !1,
          labelDate: d
        };
      }, r.isMonthDisabled = function(i) {
        var n = r.isMonthDisabledForLabelDate(i).isDisabled;
        return n;
      }, r.getMonthClassNames = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate, l = n.preSelection, u = n.monthClassName, c = u ? u(pi(o, i)) : void 0, d = r.getSelection();
        return xe("react-datepicker__month-text", "react-datepicker__month-".concat(i), c, {
          "react-datepicker__month-text--disabled": r.isMonthDisabled(i),
          "react-datepicker__month-text--selected": d ? r.isSelectMonthInList(o, i, d) : void 0,
          "react-datepicker__month-text--keyboard-selected": !r.props.disabledKeyboardNavigation && l && r.isSelectedMonth(o, i, l) && !r.isMonthDisabled(i),
          "react-datepicker__month-text--in-selecting-range": r.isInSelectingRangeMonth(i),
          "react-datepicker__month-text--in-range": s && a ? Cp(s, a, i, o) : void 0,
          "react-datepicker__month-text--range-start": r.isRangeStartMonth(i),
          "react-datepicker__month-text--range-end": r.isRangeEndMonth(i),
          "react-datepicker__month-text--selecting-range-start": r.isSelectingMonthRangeStart(i),
          "react-datepicker__month-text--selecting-range-end": r.isSelectingMonthRangeEnd(i),
          "react-datepicker__month-text--today": r.isCurrentMonth(o, i)
        });
      }, r.getTabIndex = function(i) {
        if (r.props.preSelection == null)
          return "-1";
        var n = Vr(r.props.preSelection), o = r.isMonthDisabledForLabelDate(n).isDisabled, s = i === n && !(o || r.props.disabledKeyboardNavigation) ? "0" : "-1";
        return s;
      }, r.getQuarterTabIndex = function(i) {
        if (r.props.preSelection == null)
          return "-1";
        var n = Qs(r.props.preSelection), o = yp(r.props.day, r.props), s = i === n && !(o || r.props.disabledKeyboardNavigation) ? "0" : "-1";
        return s;
      }, r.getAriaLabel = function(i) {
        var n = r.props, o = n.chooseDayAriaLabelPrefix, s = o === void 0 ? "Choose" : o, a = n.disabledDayAriaLabelPrefix, l = a === void 0 ? "Not available" : a, u = n.day, c = n.locale, d = pi(u, i), h = r.isDisabled(d) || r.isExcluded(d) ? l : s;
        return "".concat(h, " ").concat(Ot(d, "MMMM yyyy", c));
      }, r.getQuarterClassNames = function(i) {
        var n = r.props, o = n.day, s = n.startDate, a = n.endDate, l = n.selected, u = n.minDate, c = n.maxDate, d = n.excludeDates, h = n.includeDates, p = n.filterDate, g = n.preSelection, m = n.disabledKeyboardNavigation, f = (u || c || d || h || p) && yp(ol(o, i), r.props);
        return xe("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(i), {
          "react-datepicker__quarter-text--disabled": f,
          "react-datepicker__quarter-text--selected": l ? r.isSelectedQuarter(o, i, l) : void 0,
          "react-datepicker__quarter-text--keyboard-selected": !m && g && r.isSelectedQuarter(o, i, g) && !f,
          "react-datepicker__quarter-text--in-selecting-range": r.isInSelectingRangeQuarter(i),
          "react-datepicker__quarter-text--in-range": s && a ? wp(s, a, i, o) : void 0,
          "react-datepicker__quarter-text--range-start": r.isRangeStartQuarter(i),
          "react-datepicker__quarter-text--range-end": r.isRangeEndQuarter(i)
        });
      }, r.getMonthContent = function(i) {
        var n = r.props, o = n.showFullMonthYearPicker, s = n.renderMonthContent, a = n.locale, l = n.day, u = fG(i, a), c = sx(i, a);
        return s ? s(i, u, c, l) : o ? c : u;
      }, r.getQuarterContent = function(i) {
        var n, o = r.props, s = o.renderQuarterContent, a = o.locale, l = Nfe(i, a);
        return (n = s == null ? void 0 : s(i, l)) !== null && n !== void 0 ? n : l;
      }, r.renderMonths = function() {
        var i, n = r.props, o = n.showTwoColumnMonthYearPicker, s = n.showFourColumnMonthYearPicker, a = n.day, l = n.selected, u = (i = GC[sP(s, o)]) === null || i === void 0 ? void 0 : i.grid;
        return u == null ? void 0 : u.map(function(c, d) {
          return D.createElement("div", { className: "react-datepicker__month-wrapper", key: d }, c.map(function(h, p) {
            return D.createElement("div", { ref: r.MONTH_REFS[h], key: p, onClick: function(g) {
              r.onMonthClick(g, h);
            }, onKeyDown: function(g) {
              CG(g) && (g.preventDefault(), g.key = pe.Enter), r.onMonthKeyDown(g, h);
            }, onMouseEnter: r.props.usePointerEvent ? void 0 : function() {
              return r.onMonthMouseEnter(h);
            }, onPointerEnter: r.props.usePointerEvent ? function() {
              return r.onMonthMouseEnter(h);
            } : void 0, tabIndex: Number(r.getTabIndex(h)), className: r.getMonthClassNames(h), "aria-disabled": r.isMonthDisabled(h), role: "option", "aria-label": r.getAriaLabel(h), "aria-current": r.isCurrentMonth(a, h) ? "date" : void 0, "aria-selected": l ? r.isSelectedMonth(a, h, l) : void 0 }, r.getMonthContent(h));
          }));
        });
      }, r.renderQuarters = function() {
        var i = r.props, n = i.day, o = i.selected, s = [1, 2, 3, 4];
        return D.createElement("div", { className: "react-datepicker__quarter-wrapper" }, s.map(function(a, l) {
          return D.createElement("div", { key: l, ref: r.QUARTER_REFS[l], role: "option", onClick: function(u) {
            r.onQuarterClick(u, a);
          }, onKeyDown: function(u) {
            r.onQuarterKeyDown(u, a);
          }, onMouseEnter: r.props.usePointerEvent ? void 0 : function() {
            return r.onQuarterMouseEnter(a);
          }, onPointerEnter: r.props.usePointerEvent ? function() {
            return r.onQuarterMouseEnter(a);
          } : void 0, className: r.getQuarterClassNames(a), "aria-selected": o ? r.isSelectedQuarter(n, a, o) : void 0, tabIndex: Number(r.getQuarterTabIndex(a)), "aria-current": r.isCurrentQuarter(n, a) ? "date" : void 0 }, r.getQuarterContent(a));
        }));
      }, r.getClassNames = function() {
        var i = r.props, n = i.selectingDate, o = i.selectsStart, s = i.selectsEnd, a = i.showMonthYearPicker, l = i.showQuarterYearPicker, u = i.showWeekPicker;
        return xe("react-datepicker__month", {
          "react-datepicker__month--selecting-range": n && (o || s)
        }, { "react-datepicker__monthPicker": a }, { "react-datepicker__quarterPicker": l }, { "react-datepicker__weekPicker": u });
      }, r;
    }
    return t.prototype.getSelection = function() {
      var r = this.props, i = r.selected, n = r.selectedDates, o = r.selectsMultiple;
      if (o)
        return n;
      if (i)
        return [i];
    }, t.prototype.render = function() {
      var r = this.props, i = r.showMonthYearPicker, n = r.showQuarterYearPicker, o = r.day, s = r.ariaLabelPrefix, a = s === void 0 ? "Month " : s, l = a ? a.trim() + " " : "";
      return D.createElement("div", { className: this.getClassNames(), onMouseLeave: this.props.usePointerEvent ? void 0 : this.handleMouseLeave, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0, "aria-label": "".concat(l).concat(Ot(o, "MMMM, yyyy", this.props.locale)), role: "listbox" }, i ? this.renderMonths() : n ? this.renderQuarters() : this.renderWeeks());
    }, t;
  }($t)
), Jfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.isSelectedMonth = function(i) {
        return r.props.month === i;
      }, r.renderOptions = function() {
        return r.props.monthNames.map(function(i, n) {
          return D.createElement(
            "div",
            { className: r.isSelectedMonth(n) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: i, onClick: r.onChange.bind(r, n), "aria-selected": r.isSelectedMonth(n) ? "true" : void 0 },
            r.isSelectedMonth(n) ? D.createElement("span", { className: "react-datepicker__month-option--selected" }, "") : "",
            i
          );
        });
      }, r.onChange = function(i) {
        return r.props.onChange(i);
      }, r.handleClickOutside = function() {
        return r.props.onCancel();
      }, r;
    }
    return t.prototype.render = function() {
      return D.createElement(mv, { className: "react-datepicker__month-dropdown", onClickOutside: this.handleClickOutside }, this.renderOptions());
    }, t;
  }($t)
), Qfe = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.state = {
        dropdownVisible: !1
      }, r.renderSelectOptions = function(i) {
        return i.map(function(n, o) {
          return D.createElement("option", { key: n, value: o }, n);
        });
      }, r.renderSelectMode = function(i) {
        return D.createElement("select", { value: r.props.month, className: "react-datepicker__month-select", onChange: function(n) {
          return r.onChange(parseInt(n.target.value));
        } }, r.renderSelectOptions(i));
      }, r.renderReadView = function(i, n) {
        return D.createElement(
          "div",
          { key: "read", style: { visibility: i ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: r.toggleDropdown },
          D.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }),
          D.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, n[r.props.month])
        );
      }, r.renderDropdown = function(i) {
        return D.createElement(Jfe, qe({ key: "dropdown" }, r.props, { monthNames: i, onChange: r.onChange, onCancel: r.toggleDropdown }));
      }, r.renderScrollMode = function(i) {
        var n = r.state.dropdownVisible, o = [r.renderReadView(!n, i)];
        return n && o.unshift(r.renderDropdown(i)), o;
      }, r.onChange = function(i) {
        r.toggleDropdown(), i !== r.props.month && r.props.onChange(i);
      }, r.toggleDropdown = function() {
        return r.setState({
          dropdownVisible: !r.state.dropdownVisible
        });
      }, r;
    }
    return t.prototype.render = function() {
      var r = this, i = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(o) {
        return fG(o, r.props.locale);
      } : function(o) {
        return sx(o, r.props.locale);
      }), n;
      switch (this.props.dropdownMode) {
        case "scroll":
          n = this.renderScrollMode(i);
          break;
        case "select":
          n = this.renderSelectMode(i);
          break;
      }
      return D.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, n);
    }, t;
  }($t)
);
function ege(e, t) {
  for (var r = [], i = vo(e), n = vo(t); !rs(i, n); )
    r.push(ft(i)), i = mn(i, 1);
  return r;
}
var tge = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.renderOptions = function() {
        return i.state.monthYearsList.map(function(n) {
          var o = dw(n), s = An(i.props.date, n) && _r(i.props.date, n);
          return D.createElement(
            "div",
            { className: s ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: o, onClick: i.onChange.bind(i, o), "aria-selected": s ? "true" : void 0 },
            s ? D.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "") : "",
            Ot(n, i.props.dateFormat, i.props.locale)
          );
        });
      }, i.onChange = function(n) {
        return i.props.onChange(n);
      }, i.handleClickOutside = function() {
        i.props.onCancel();
      }, i.state = {
        monthYearsList: ege(i.props.minDate, i.props.maxDate)
      }, i;
    }
    return t.prototype.render = function() {
      var r = xe({
        "react-datepicker__month-year-dropdown": !0,
        "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
      });
      return D.createElement(mv, { className: r, onClickOutside: this.handleClickOutside }, this.renderOptions());
    }, t;
  }($t)
), rge = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.state = {
        dropdownVisible: !1
      }, r.renderSelectOptions = function() {
        for (var i = vo(r.props.minDate), n = vo(r.props.maxDate), o = []; !rs(i, n); ) {
          var s = dw(i);
          o.push(D.createElement("option", { key: s, value: s }, Ot(i, r.props.dateFormat, r.props.locale))), i = mn(i, 1);
        }
        return o;
      }, r.onSelectChange = function(i) {
        r.onChange(parseInt(i.target.value));
      }, r.renderSelectMode = function() {
        return D.createElement("select", { value: dw(vo(r.props.date)), className: "react-datepicker__month-year-select", onChange: r.onSelectChange }, r.renderSelectOptions());
      }, r.renderReadView = function(i) {
        var n = Ot(r.props.date, r.props.dateFormat, r.props.locale);
        return D.createElement(
          "div",
          { key: "read", style: { visibility: i ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: r.toggleDropdown },
          D.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }),
          D.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, n)
        );
      }, r.renderDropdown = function() {
        return D.createElement(tge, qe({ key: "dropdown" }, r.props, { onChange: r.onChange, onCancel: r.toggleDropdown }));
      }, r.renderScrollMode = function() {
        var i = r.state.dropdownVisible, n = [r.renderReadView(!i)];
        return i && n.unshift(r.renderDropdown()), n;
      }, r.onChange = function(i) {
        r.toggleDropdown();
        var n = ft(i);
        An(r.props.date, n) && _r(r.props.date, n) || r.props.onChange(n);
      }, r.toggleDropdown = function() {
        return r.setState({
          dropdownVisible: !r.state.dropdownVisible
        });
      }, r;
    }
    return t.prototype.render = function() {
      var r;
      switch (this.props.dropdownMode) {
        case "scroll":
          r = this.renderScrollMode();
          break;
        case "select":
          r = this.renderSelectMode();
          break;
      }
      return D.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, r);
    }, t;
  }($t)
), ige = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.state = {
        height: null
      }, r.scrollToTheSelectedTime = function() {
        requestAnimationFrame(function() {
          var i, n, o;
          r.list && (r.list.scrollTop = (o = r.centerLi && t.calcCenterPosition(r.props.monthRef ? r.props.monthRef.clientHeight - ((n = (i = r.header) === null || i === void 0 ? void 0 : i.clientHeight) !== null && n !== void 0 ? n : 0) : r.list.clientHeight, r.centerLi)) !== null && o !== void 0 ? o : 0);
        });
      }, r.handleClick = function(i) {
        var n, o;
        (r.props.minTime || r.props.maxTime) && qR(i, r.props) || (r.props.excludeTimes || r.props.includeTimes || r.props.filterTime) && KR(i, r.props) || (o = (n = r.props).onChange) === null || o === void 0 || o.call(n, i);
      }, r.isSelectedTime = function(i) {
        return r.props.selected && zfe(r.props.selected, i);
      }, r.isDisabledTime = function(i) {
        return (r.props.minTime || r.props.maxTime) && qR(i, r.props) || (r.props.excludeTimes || r.props.includeTimes || r.props.filterTime) && KR(i, r.props);
      }, r.liClasses = function(i) {
        var n, o = [
          "react-datepicker__time-list-item",
          r.props.timeClassName ? r.props.timeClassName(i) : void 0
        ];
        return r.isSelectedTime(i) && o.push("react-datepicker__time-list-item--selected"), r.isDisabledTime(i) && o.push("react-datepicker__time-list-item--disabled"), r.props.injectTimes && (kn(i) * 3600 + Vn(i) * 60 + mo(i)) % (((n = r.props.intervals) !== null && n !== void 0 ? n : t.defaultProps.intervals) * 60) !== 0 && o.push("react-datepicker__time-list-item--injected"), o.join(" ");
      }, r.handleOnKeyDown = function(i, n) {
        var o, s;
        i.key === pe.Space && (i.preventDefault(), i.key = pe.Enter), (i.key === pe.ArrowUp || i.key === pe.ArrowLeft) && i.target instanceof HTMLElement && i.target.previousSibling && (i.preventDefault(), i.target.previousSibling instanceof HTMLElement && i.target.previousSibling.focus()), (i.key === pe.ArrowDown || i.key === pe.ArrowRight) && i.target instanceof HTMLElement && i.target.nextSibling && (i.preventDefault(), i.target.nextSibling instanceof HTMLElement && i.target.nextSibling.focus()), i.key === pe.Enter && r.handleClick(n), (s = (o = r.props).handleOnKeyDown) === null || s === void 0 || s.call(o, i);
      }, r.renderTimes = function() {
        for (var i, n = [], o = typeof r.props.format == "string" ? r.props.format : "p", s = (i = r.props.intervals) !== null && i !== void 0 ? i : t.defaultProps.intervals, a = r.props.selected || r.props.openToDate || ft(), l = Wp(a), u = r.props.injectTimes && r.props.injectTimes.sort(function(f, C) {
          return f.getTime() - C.getTime();
        }), c = 60 * jfe(a), d = c / s, h = 0; h < d; h++) {
          var p = lw(l, h * s);
          if (n.push(p), u) {
            var g = $fe(l, p, h, s, u);
            n = n.concat(g);
          }
        }
        var m = n.reduce(function(f, C) {
          return C.getTime() <= a.getTime() ? C : f;
        }, n[0]);
        return n.map(function(f) {
          return D.createElement("li", { key: f.valueOf(), onClick: r.handleClick.bind(r, f), className: r.liClasses(f), ref: function(C) {
            f === m && (r.centerLi = C);
          }, onKeyDown: function(C) {
            r.handleOnKeyDown(C, f);
          }, tabIndex: f === m ? 0 : -1, role: "option", "aria-selected": r.isSelectedTime(f) ? "true" : void 0, "aria-disabled": r.isDisabledTime(f) ? "true" : void 0 }, Ot(f, o, r.props.locale));
        });
      }, r.renderTimeCaption = function() {
        return r.props.showTimeCaption === !1 ? D.createElement(D.Fragment, null) : D.createElement(
          "div",
          { className: "react-datepicker__header react-datepicker__header--time ".concat(r.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(i) {
            r.header = i;
          } },
          D.createElement("div", { className: "react-datepicker-time__header" }, r.props.timeCaption)
        );
      }, r;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          intervals: 30,
          todayButton: null,
          timeCaption: "Time",
          showTimeCaption: !0
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.componentDidMount = function() {
      this.scrollToTheSelectedTime(), this.props.monthRef && this.header && this.setState({
        height: this.props.monthRef.clientHeight - this.header.clientHeight
      });
    }, t.prototype.render = function() {
      var r = this, i, n = this.state.height;
      return D.createElement(
        "div",
        { className: "react-datepicker__time-container ".concat(((i = this.props.todayButton) !== null && i !== void 0 ? i : t.defaultProps.todayButton) ? "react-datepicker__time-container--with-today-button" : "") },
        this.renderTimeCaption(),
        D.createElement(
          "div",
          { className: "react-datepicker__time" },
          D.createElement(
            "div",
            { className: "react-datepicker__time-box" },
            D.createElement("ul", { className: "react-datepicker__time-list", ref: function(o) {
              r.list = o;
            }, style: n ? { height: n } : {}, role: "listbox", "aria-label": this.props.timeCaption }, this.renderTimes())
          )
        )
      );
    }, t.calcCenterPosition = function(r, i) {
      return i.offsetTop - (r / 2 - i.clientHeight / 2);
    }, t;
  }($t)
), aP = 3, nge = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.YEAR_REFS = Mn([], Array(i.props.yearItemNumber), !0).map(function() {
        return Ko();
      }), i.isDisabled = function(n) {
        return Fi(n, {
          minDate: i.props.minDate,
          maxDate: i.props.maxDate,
          excludeDates: i.props.excludeDates,
          includeDates: i.props.includeDates,
          filterDate: i.props.filterDate
        });
      }, i.isExcluded = function(n) {
        return ax(n, {
          excludeDates: i.props.excludeDates
        });
      }, i.selectingDate = function() {
        var n;
        return (n = i.props.selectingDate) !== null && n !== void 0 ? n : i.props.preSelection;
      }, i.updateFocusOnPaginate = function(n) {
        var o = function() {
          var s, a;
          (a = (s = i.YEAR_REFS[n]) === null || s === void 0 ? void 0 : s.current) === null || a === void 0 || a.focus();
        };
        window.requestAnimationFrame(o);
      }, i.handleYearClick = function(n, o) {
        i.props.onDayClick && i.props.onDayClick(n, o);
      }, i.handleYearNavigation = function(n, o) {
        var s, a, l, u, c = i.props, d = c.date, h = c.yearItemNumber;
        if (!(d === void 0 || h === void 0)) {
          var p = jo(d, h).startPeriod;
          i.isDisabled(o) || i.isExcluded(o) || ((a = (s = i.props).setPreSelection) === null || a === void 0 || a.call(s, o), n - p < 0 ? i.updateFocusOnPaginate(h - (p - n)) : n - p >= h ? i.updateFocusOnPaginate(Math.abs(h - (n - p))) : (u = (l = i.YEAR_REFS[n - p]) === null || l === void 0 ? void 0 : l.current) === null || u === void 0 || u.focus());
        }
      }, i.isSameDay = function(n, o) {
        return Ue(n, o);
      }, i.isCurrentYear = function(n) {
        return n === $e(ft());
      }, i.isRangeStart = function(n) {
        return i.props.startDate && i.props.endDate && An(En(ft(), n), i.props.startDate);
      }, i.isRangeEnd = function(n) {
        return i.props.startDate && i.props.endDate && An(En(ft(), n), i.props.endDate);
      }, i.isInRange = function(n) {
        return bp(n, i.props.startDate, i.props.endDate);
      }, i.isInSelectingRange = function(n) {
        var o = i.props, s = o.selectsStart, a = o.selectsEnd, l = o.selectsRange, u = o.startDate, c = o.endDate;
        return !(s || a || l) || !i.selectingDate() ? !1 : s && c ? bp(n, i.selectingDate(), c) : a && u || l && u && !c ? bp(n, u, i.selectingDate()) : !1;
      }, i.isSelectingRangeStart = function(n) {
        var o;
        if (!i.isInSelectingRange(n))
          return !1;
        var s = i.props, a = s.startDate, l = s.selectsStart, u = En(ft(), n);
        return l ? An(u, (o = i.selectingDate()) !== null && o !== void 0 ? o : null) : An(u, a ?? null);
      }, i.isSelectingRangeEnd = function(n) {
        var o;
        if (!i.isInSelectingRange(n))
          return !1;
        var s = i.props, a = s.endDate, l = s.selectsEnd, u = s.selectsRange, c = En(ft(), n);
        return l || u ? An(c, (o = i.selectingDate()) !== null && o !== void 0 ? o : null) : An(c, a ?? null);
      }, i.isKeyboardSelected = function(n) {
        if (!(i.props.date === void 0 || i.props.selected == null || i.props.preSelection == null)) {
          var o = i.props, s = o.minDate, a = o.maxDate, l = o.excludeDates, u = o.includeDates, c = o.filterDate, d = Ic(En(i.props.date, n)), h = (s || a || l || u || c) && $p(n, i.props);
          return !i.props.disabledKeyboardNavigation && !i.props.inline && !Ue(d, Ic(i.props.selected)) && Ue(d, Ic(i.props.preSelection)) && !h;
        }
      }, i.onYearClick = function(n, o) {
        var s = i.props.date;
        s !== void 0 && i.handleYearClick(Ic(En(s, o)), n);
      }, i.onYearKeyDown = function(n, o) {
        var s, a, l = n.key, u = i.props, c = u.date, d = u.yearItemNumber, h = u.handleOnKeyDown;
        if (l !== pe.Tab && n.preventDefault(), !i.props.disabledKeyboardNavigation)
          switch (l) {
            case pe.Enter:
              if (i.props.selected == null)
                break;
              i.onYearClick(n, o), (a = (s = i.props).setPreSelection) === null || a === void 0 || a.call(s, i.props.selected);
              break;
            case pe.ArrowRight:
              if (i.props.preSelection == null)
                break;
              i.handleYearNavigation(o + 1, fo(i.props.preSelection, 1));
              break;
            case pe.ArrowLeft:
              if (i.props.preSelection == null)
                break;
              i.handleYearNavigation(o - 1, mu(i.props.preSelection, 1));
              break;
            case pe.ArrowUp: {
              if (c === void 0 || d === void 0 || i.props.preSelection == null)
                break;
              var p = jo(c, d).startPeriod, g = aP, m = o - g;
              if (m < p) {
                var f = d % g;
                o >= p && o < p + f ? g = f : g += f, m = o - g;
              }
              i.handleYearNavigation(m, mu(i.props.preSelection, g));
              break;
            }
            case pe.ArrowDown: {
              if (c === void 0 || d === void 0 || i.props.preSelection == null)
                break;
              var C = jo(c, d).endPeriod, g = aP, m = o + g;
              if (m > C) {
                var f = d % g;
                o <= C && o > C - f ? g = f : g += f, m = o + g;
              }
              i.handleYearNavigation(m, fo(i.props.preSelection, g));
              break;
            }
          }
        h && h(n);
      }, i.getYearClassNames = function(n) {
        var o = i.props, s = o.date, a = o.minDate, l = o.maxDate, u = o.selected, c = o.excludeDates, d = o.includeDates, h = o.filterDate, p = o.yearClassName;
        return xe("react-datepicker__year-text", "react-datepicker__year-".concat(n), s ? p == null ? void 0 : p(En(s, n)) : void 0, {
          "react-datepicker__year-text--selected": u ? n === $e(u) : void 0,
          "react-datepicker__year-text--disabled": (a || l || c || d || h) && $p(n, i.props),
          "react-datepicker__year-text--keyboard-selected": i.isKeyboardSelected(n),
          "react-datepicker__year-text--range-start": i.isRangeStart(n),
          "react-datepicker__year-text--range-end": i.isRangeEnd(n),
          "react-datepicker__year-text--in-range": i.isInRange(n),
          "react-datepicker__year-text--in-selecting-range": i.isInSelectingRange(n),
          "react-datepicker__year-text--selecting-range-start": i.isSelectingRangeStart(n),
          "react-datepicker__year-text--selecting-range-end": i.isSelectingRangeEnd(n),
          "react-datepicker__year-text--today": i.isCurrentYear(n)
        });
      }, i.getYearTabIndex = function(n) {
        if (i.props.disabledKeyboardNavigation || i.props.preSelection == null)
          return "-1";
        var o = $e(i.props.preSelection), s = $p(n, i.props);
        return n === o && !s ? "0" : "-1";
      }, i.getYearContent = function(n) {
        return i.props.renderYearContent ? i.props.renderYearContent(n) : n;
      }, i;
    }
    return t.prototype.render = function() {
      var r = this, i = [], n = this.props, o = n.date, s = n.yearItemNumber, a = n.onYearMouseEnter, l = n.onYearMouseLeave;
      if (o === void 0)
        return null;
      for (var u = jo(o, s), c = u.startPeriod, d = u.endPeriod, h = function(m) {
        i.push(D.createElement("div", { ref: p.YEAR_REFS[m - c], onClick: function(f) {
          r.onYearClick(f, m);
        }, onKeyDown: function(f) {
          CG(f) && (f.preventDefault(), f.key = pe.Enter), r.onYearKeyDown(f, m);
        }, tabIndex: Number(p.getYearTabIndex(m)), className: p.getYearClassNames(m), onMouseEnter: p.props.usePointerEvent ? void 0 : function(f) {
          return a(f, m);
        }, onPointerEnter: p.props.usePointerEvent ? function(f) {
          return a(f, m);
        } : void 0, onMouseLeave: p.props.usePointerEvent ? void 0 : function(f) {
          return l(f, m);
        }, onPointerLeave: p.props.usePointerEvent ? function(f) {
          return l(f, m);
        } : void 0, key: m, "aria-current": p.isCurrentYear(m) ? "date" : void 0 }, p.getYearContent(m)));
      }, p = this, g = c; g <= d; g++)
        h(g);
      return D.createElement(
        "div",
        { className: "react-datepicker__year" },
        D.createElement("div", { className: "react-datepicker__year-wrapper", onMouseLeave: this.props.usePointerEvent ? void 0 : this.props.clearSelectingDate, onPointerLeave: this.props.usePointerEvent ? this.props.clearSelectingDate : void 0 }, i)
      );
    }, t;
  }($t)
);
function oge(e, t, r, i) {
  for (var n = [], o = 0; o < 2 * t + 1; o++) {
    var s = e + t - o, a = !0;
    r && (a = $e(r) <= s), i && a && (a = $e(i) >= s), a && n.push(s);
  }
  return n;
}
var sge = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      i.renderOptions = function() {
        var a = i.props.year, l = i.state.yearsList.map(function(d) {
          return D.createElement(
            "div",
            { className: a === d ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: d, onClick: i.onChange.bind(i, d), "aria-selected": a === d ? "true" : void 0 },
            a === d ? D.createElement("span", { className: "react-datepicker__year-option--selected" }, "") : "",
            d
          );
        }), u = i.props.minDate ? $e(i.props.minDate) : null, c = i.props.maxDate ? $e(i.props.maxDate) : null;
        return (!c || !i.state.yearsList.find(function(d) {
          return d === c;
        })) && l.unshift(D.createElement(
          "div",
          { className: "react-datepicker__year-option", key: "upcoming", onClick: i.incrementYears },
          D.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" })
        )), (!u || !i.state.yearsList.find(function(d) {
          return d === u;
        })) && l.push(D.createElement(
          "div",
          { className: "react-datepicker__year-option", key: "previous", onClick: i.decrementYears },
          D.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" })
        )), l;
      }, i.onChange = function(a) {
        i.props.onChange(a);
      }, i.handleClickOutside = function() {
        i.props.onCancel();
      }, i.shiftYears = function(a) {
        var l = i.state.yearsList.map(function(u) {
          return u + a;
        });
        i.setState({
          yearsList: l
        });
      }, i.incrementYears = function() {
        return i.shiftYears(1);
      }, i.decrementYears = function() {
        return i.shiftYears(-1);
      };
      var n = r.yearDropdownItemNumber, o = r.scrollableYearDropdown, s = n || (o ? 10 : 5);
      return i.state = {
        yearsList: oge(i.props.year, s, i.props.minDate, i.props.maxDate)
      }, i.dropdownRef = Ko(), i;
    }
    return t.prototype.componentDidMount = function() {
      var r = this.dropdownRef.current;
      if (r) {
        var i = r.children ? Array.from(r.children) : null, n = i ? i.find(function(o) {
          return o.ariaSelected;
        }) : null;
        r.scrollTop = n && n instanceof HTMLElement ? n.offsetTop + (n.clientHeight - r.clientHeight) / 2 : (r.scrollHeight - r.clientHeight) / 2;
      }
    }, t.prototype.render = function() {
      var r = xe({
        "react-datepicker__year-dropdown": !0,
        "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
      });
      return D.createElement(mv, { className: r, containerRef: this.dropdownRef, onClickOutside: this.handleClickOutside }, this.renderOptions());
    }, t;
  }($t)
), age = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.state = {
        dropdownVisible: !1
      }, r.renderSelectOptions = function() {
        for (var i = r.props.minDate ? $e(r.props.minDate) : 1900, n = r.props.maxDate ? $e(r.props.maxDate) : 2100, o = [], s = i; s <= n; s++)
          o.push(D.createElement("option", { key: s, value: s }, s));
        return o;
      }, r.onSelectChange = function(i) {
        r.onChange(parseInt(i.target.value));
      }, r.renderSelectMode = function() {
        return D.createElement("select", { value: r.props.year, className: "react-datepicker__year-select", onChange: r.onSelectChange }, r.renderSelectOptions());
      }, r.renderReadView = function(i) {
        return D.createElement(
          "div",
          { key: "read", style: { visibility: i ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(n) {
            return r.toggleDropdown(n);
          } },
          D.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }),
          D.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, r.props.year)
        );
      }, r.renderDropdown = function() {
        return D.createElement(sge, qe({ key: "dropdown" }, r.props, { onChange: r.onChange, onCancel: r.toggleDropdown }));
      }, r.renderScrollMode = function() {
        var i = r.state.dropdownVisible, n = [r.renderReadView(!i)];
        return i && n.unshift(r.renderDropdown()), n;
      }, r.onChange = function(i) {
        r.toggleDropdown(), i !== r.props.year && r.props.onChange(i);
      }, r.toggleDropdown = function(i) {
        r.setState({
          dropdownVisible: !r.state.dropdownVisible
        }, function() {
          r.props.adjustDateOnChange && r.handleYearChange(r.props.date, i);
        });
      }, r.handleYearChange = function(i, n) {
        var o;
        (o = r.onSelect) === null || o === void 0 || o.call(r, i, n), r.setOpen();
      }, r.onSelect = function(i, n) {
        var o, s;
        (s = (o = r.props).onSelect) === null || s === void 0 || s.call(o, i, n);
      }, r.setOpen = function() {
        var i, n;
        (n = (i = r.props).setOpen) === null || n === void 0 || n.call(i, !0);
      }, r;
    }
    return t.prototype.render = function() {
      var r;
      switch (this.props.dropdownMode) {
        case "scroll":
          r = this.renderScrollMode();
          break;
        case "select":
          r = this.renderSelectMode();
          break;
      }
      return D.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, r);
    }, t;
  }($t)
), lge = [
  "react-datepicker__year-select",
  "react-datepicker__month-select",
  "react-datepicker__month-year-select"
], uge = function(e) {
  var t = (e.className || "").split(/\s+/);
  return lge.some(function(r) {
    return t.indexOf(r) >= 0;
  });
}, cge = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.monthContainer = void 0, i.handleClickOutside = function(n) {
        i.props.onClickOutside(n);
      }, i.setClickOutsideRef = function() {
        return i.containerRef.current;
      }, i.handleDropdownFocus = function(n) {
        var o, s;
        uge(n.target) && ((s = (o = i.props).onDropdownFocus) === null || s === void 0 || s.call(o, n));
      }, i.getDateInView = function() {
        var n = i.props, o = n.preSelection, s = n.selected, a = n.openToDate, l = mG(i.props), u = vG(i.props), c = ft(), d = a || s || o;
        return d || (l && wa(c, l) ? l : u && rs(c, u) ? u : c);
      }, i.increaseMonth = function() {
        i.setState(function(n) {
          var o = n.date;
          return {
            date: mn(o, 1)
          };
        }, function() {
          return i.handleMonthChange(i.state.date);
        });
      }, i.decreaseMonth = function() {
        i.setState(function(n) {
          var o = n.date;
          return {
            date: ea(o, 1)
          };
        }, function() {
          return i.handleMonthChange(i.state.date);
        });
      }, i.handleDayClick = function(n, o, s) {
        i.props.onSelect(n, o, s), i.props.setPreSelection && i.props.setPreSelection(n);
      }, i.handleDayMouseEnter = function(n) {
        i.setState({ selectingDate: n }), i.props.onDayMouseEnter && i.props.onDayMouseEnter(n);
      }, i.handleMonthMouseLeave = function() {
        i.setState({ selectingDate: void 0 }), i.props.onMonthMouseLeave && i.props.onMonthMouseLeave();
      }, i.handleYearMouseEnter = function(n, o) {
        i.setState({ selectingDate: En(ft(), o) }), i.props.onYearMouseEnter && i.props.onYearMouseEnter(n, o);
      }, i.handleYearMouseLeave = function(n, o) {
        i.props.onYearMouseLeave && i.props.onYearMouseLeave(n, o);
      }, i.handleYearChange = function(n) {
        var o, s, a, l;
        (s = (o = i.props).onYearChange) === null || s === void 0 || s.call(o, n), i.setState({ isRenderAriaLiveMessage: !0 }), i.props.adjustDateOnChange && (i.props.onSelect(n), (l = (a = i.props).setOpen) === null || l === void 0 || l.call(a, !0)), i.props.setPreSelection && i.props.setPreSelection(n);
      }, i.getEnabledPreSelectionDateForMonth = function(n) {
        if (!Fi(n, i.props))
          return n;
        for (var o = vo(n), s = Ofe(n), a = jce(s, o), l = null, u = 0; u <= a; u++) {
          var c = pn(o, u);
          if (!Fi(c, i.props)) {
            l = c;
            break;
          }
        }
        return l;
      }, i.handleMonthChange = function(n) {
        var o, s, a, l = (o = i.getEnabledPreSelectionDateForMonth(n)) !== null && o !== void 0 ? o : n;
        i.handleCustomMonthChange(l), i.props.adjustDateOnChange && (i.props.onSelect(l), (a = (s = i.props).setOpen) === null || a === void 0 || a.call(s, !0)), i.props.setPreSelection && i.props.setPreSelection(l);
      }, i.handleCustomMonthChange = function(n) {
        var o, s;
        (s = (o = i.props).onMonthChange) === null || s === void 0 || s.call(o, n), i.setState({ isRenderAriaLiveMessage: !0 });
      }, i.handleMonthYearChange = function(n) {
        i.handleYearChange(n), i.handleMonthChange(n);
      }, i.changeYear = function(n) {
        i.setState(function(o) {
          var s = o.date;
          return {
            date: En(s, Number(n))
          };
        }, function() {
          return i.handleYearChange(i.state.date);
        });
      }, i.changeMonth = function(n) {
        i.setState(function(o) {
          var s = o.date;
          return {
            date: pi(s, Number(n))
          };
        }, function() {
          return i.handleMonthChange(i.state.date);
        });
      }, i.changeMonthYear = function(n) {
        i.setState(function(o) {
          var s = o.date;
          return {
            date: En(pi(s, Vr(n)), $e(n))
          };
        }, function() {
          return i.handleMonthYearChange(i.state.date);
        });
      }, i.header = function(n) {
        n === void 0 && (n = i.state.date);
        var o = Xo(n, i.props.locale, i.props.calendarStartDay), s = [];
        return i.props.showWeekNumbers && s.push(D.createElement("div", { key: "W", className: "react-datepicker__day-name" }, i.props.weekLabel || "#")), s.concat([0, 1, 2, 3, 4, 5, 6].map(function(a) {
          var l = pn(o, a), u = i.formatWeekday(l, i.props.locale), c = i.props.weekDayClassName ? i.props.weekDayClassName(l) : void 0;
          return D.createElement("div", { key: a, "aria-label": Ot(l, "EEEE", i.props.locale), className: xe("react-datepicker__day-name", c) }, u);
        }));
      }, i.formatWeekday = function(n, o) {
        return i.props.formatWeekDay ? Mfe(n, i.props.formatWeekDay, o) : i.props.useWeekdaysShort ? _fe(n, o) : Ffe(n, o);
      }, i.decreaseYear = function() {
        i.setState(function(n) {
          var o, s = n.date;
          return {
            date: mu(s, i.props.showYearPicker ? (o = i.props.yearItemNumber) !== null && o !== void 0 ? o : t.defaultProps.yearItemNumber : 1)
          };
        }, function() {
          return i.handleYearChange(i.state.date);
        });
      }, i.clearSelectingDate = function() {
        i.setState({ selectingDate: void 0 });
      }, i.renderPreviousButton = function() {
        var n, o, s;
        if (!i.props.renderCustomHeader) {
          var a = (n = i.props.monthsShown) !== null && n !== void 0 ? n : t.defaultProps.monthsShown, l = i.props.showPreviousMonths ? a - 1 : 0, u = (o = i.props.monthSelectedIn) !== null && o !== void 0 ? o : l, c = ea(i.state.date, u), d;
          switch (!0) {
            case i.props.showMonthYearPicker:
              d = QR(i.state.date, i.props);
              break;
            case i.props.showYearPicker:
              d = Vfe(i.state.date, i.props);
              break;
            case i.props.showQuarterYearPicker:
              d = Gfe(i.state.date, i.props);
              break;
            default:
              d = ZR(c, i.props);
              break;
          }
          if (!(!((s = i.props.forceShowMonthNavigation) !== null && s !== void 0 ? s : t.defaultProps.forceShowMonthNavigation) && !i.props.showDisabledMonthNavigation && d || i.props.showTimeSelectOnly)) {
            var h = [
              "react-datepicker__navigation-icon",
              "react-datepicker__navigation-icon--previous"
            ], p = [
              "react-datepicker__navigation",
              "react-datepicker__navigation--previous"
            ], g = i.decreaseMonth;
            (i.props.showMonthYearPicker || i.props.showQuarterYearPicker || i.props.showYearPicker) && (g = i.decreaseYear), d && i.props.showDisabledMonthNavigation && (p.push("react-datepicker__navigation--previous--disabled"), g = void 0);
            var m = i.props.showMonthYearPicker || i.props.showQuarterYearPicker || i.props.showYearPicker, f = i.props, C = f.previousMonthButtonLabel, w = C === void 0 ? t.defaultProps.previousMonthButtonLabel : C, E = f.previousYearButtonLabel, b = E === void 0 ? t.defaultProps.previousYearButtonLabel : E, y = i.props, S = y.previousMonthAriaLabel, x = S === void 0 ? typeof w == "string" ? w : "Previous Month" : S, R = y.previousYearAriaLabel, P = R === void 0 ? typeof b == "string" ? b : "Previous Year" : R;
            return D.createElement(
              "button",
              { type: "button", className: p.join(" "), onClick: g, onKeyDown: i.props.handleOnKeyDown, "aria-label": m ? P : x },
              D.createElement("span", { className: h.join(" ") }, m ? b : w)
            );
          }
        }
      }, i.increaseYear = function() {
        i.setState(function(n) {
          var o, s = n.date;
          return {
            date: fo(s, i.props.showYearPicker ? (o = i.props.yearItemNumber) !== null && o !== void 0 ? o : t.defaultProps.yearItemNumber : 1)
          };
        }, function() {
          return i.handleYearChange(i.state.date);
        });
      }, i.renderNextButton = function() {
        var n;
        if (!i.props.renderCustomHeader) {
          var o;
          switch (!0) {
            case i.props.showMonthYearPicker:
              o = eP(i.state.date, i.props);
              break;
            case i.props.showYearPicker:
              o = Hfe(i.state.date, i.props);
              break;
            case i.props.showQuarterYearPicker:
              o = kfe(i.state.date, i.props);
              break;
            default:
              o = JR(i.state.date, i.props);
              break;
          }
          if (!(!((n = i.props.forceShowMonthNavigation) !== null && n !== void 0 ? n : t.defaultProps.forceShowMonthNavigation) && !i.props.showDisabledMonthNavigation && o || i.props.showTimeSelectOnly)) {
            var s = [
              "react-datepicker__navigation",
              "react-datepicker__navigation--next"
            ], a = [
              "react-datepicker__navigation-icon",
              "react-datepicker__navigation-icon--next"
            ];
            i.props.showTimeSelect && s.push("react-datepicker__navigation--next--with-time"), i.props.todayButton && s.push("react-datepicker__navigation--next--with-today-button");
            var l = i.increaseMonth;
            (i.props.showMonthYearPicker || i.props.showQuarterYearPicker || i.props.showYearPicker) && (l = i.increaseYear), o && i.props.showDisabledMonthNavigation && (s.push("react-datepicker__navigation--next--disabled"), l = void 0);
            var u = i.props.showMonthYearPicker || i.props.showQuarterYearPicker || i.props.showYearPicker, c = i.props, d = c.nextMonthButtonLabel, h = d === void 0 ? t.defaultProps.nextMonthButtonLabel : d, p = c.nextYearButtonLabel, g = p === void 0 ? t.defaultProps.nextYearButtonLabel : p, m = i.props, f = m.nextMonthAriaLabel, C = f === void 0 ? typeof h == "string" ? h : "Next Month" : f, w = m.nextYearAriaLabel, E = w === void 0 ? typeof g == "string" ? g : "Next Year" : w;
            return D.createElement(
              "button",
              { type: "button", className: s.join(" "), onClick: l, onKeyDown: i.props.handleOnKeyDown, "aria-label": u ? E : C },
              D.createElement("span", { className: a.join(" ") }, u ? g : h)
            );
          }
        }
      }, i.renderCurrentMonth = function(n) {
        n === void 0 && (n = i.state.date);
        var o = ["react-datepicker__current-month"];
        return i.props.showYearDropdown && o.push("react-datepicker__current-month--hasYearDropdown"), i.props.showMonthDropdown && o.push("react-datepicker__current-month--hasMonthDropdown"), i.props.showMonthYearDropdown && o.push("react-datepicker__current-month--hasMonthYearDropdown"), D.createElement("h2", { className: o.join(" ") }, Ot(n, i.props.dateFormat, i.props.locale));
      }, i.renderYearDropdown = function(n) {
        if (n === void 0 && (n = !1), !(!i.props.showYearDropdown || n))
          return D.createElement(age, qe({}, t.defaultProps, i.props, { date: i.state.date, onChange: i.changeYear, year: $e(i.state.date) }));
      }, i.renderMonthDropdown = function(n) {
        if (n === void 0 && (n = !1), !(!i.props.showMonthDropdown || n))
          return D.createElement(Qfe, qe({}, t.defaultProps, i.props, { month: Vr(i.state.date), onChange: i.changeMonth }));
      }, i.renderMonthYearDropdown = function(n) {
        if (n === void 0 && (n = !1), !(!i.props.showMonthYearDropdown || n))
          return D.createElement(rge, qe({}, t.defaultProps, i.props, { date: i.state.date, onChange: i.changeMonthYear }));
      }, i.handleTodayButtonClick = function(n) {
        i.props.onSelect(UR(), n), i.props.setPreSelection && i.props.setPreSelection(UR());
      }, i.renderTodayButton = function() {
        if (!(!i.props.todayButton || i.props.showTimeSelectOnly))
          return D.createElement("div", { className: "react-datepicker__today-button", onClick: i.handleTodayButtonClick }, i.props.todayButton);
      }, i.renderDefaultHeader = function(n) {
        var o = n.monthDate, s = n.i;
        return D.createElement(
          "div",
          { className: "react-datepicker__header ".concat(i.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") },
          i.renderCurrentMonth(o),
          D.createElement(
            "div",
            { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(i.props.dropdownMode), onFocus: i.handleDropdownFocus },
            i.renderMonthDropdown(s !== 0),
            i.renderMonthYearDropdown(s !== 0),
            i.renderYearDropdown(s !== 0)
          ),
          D.createElement("div", { className: "react-datepicker__day-names" }, i.header(o))
        );
      }, i.renderCustomHeader = function(n) {
        var o, s, a = n.monthDate, l = n.i;
        if (i.props.showTimeSelect && !i.state.monthContainer || i.props.showTimeSelectOnly)
          return null;
        var u = ZR(i.state.date, i.props), c = JR(i.state.date, i.props), d = QR(i.state.date, i.props), h = eP(i.state.date, i.props), p = !i.props.showMonthYearPicker && !i.props.showQuarterYearPicker && !i.props.showYearPicker;
        return D.createElement(
          "div",
          { className: "react-datepicker__header react-datepicker__header--custom", onFocus: i.props.onDropdownFocus },
          (s = (o = i.props).renderCustomHeader) === null || s === void 0 ? void 0 : s.call(o, qe(qe({}, i.state), { customHeaderCount: l, monthDate: a, changeMonth: i.changeMonth, changeYear: i.changeYear, decreaseMonth: i.decreaseMonth, increaseMonth: i.increaseMonth, decreaseYear: i.decreaseYear, increaseYear: i.increaseYear, prevMonthButtonDisabled: u, nextMonthButtonDisabled: c, prevYearButtonDisabled: d, nextYearButtonDisabled: h })),
          p && D.createElement("div", { className: "react-datepicker__day-names" }, i.header(a))
        );
      }, i.renderYearHeader = function(n) {
        var o = n.monthDate, s = i.props, a = s.showYearPicker, l = s.yearItemNumber, u = l === void 0 ? t.defaultProps.yearItemNumber : l, c = jo(o, u), d = c.startPeriod, h = c.endPeriod;
        return D.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, a ? "".concat(d, " - ").concat(h) : $e(o));
      }, i.renderHeader = function(n) {
        var o = n.monthDate, s = n.i, a = s === void 0 ? 0 : s, l = { monthDate: o, i: a };
        switch (!0) {
          case i.props.renderCustomHeader !== void 0:
            return i.renderCustomHeader(l);
          case (i.props.showMonthYearPicker || i.props.showQuarterYearPicker || i.props.showYearPicker):
            return i.renderYearHeader(l);
          default:
            return i.renderDefaultHeader(l);
        }
      }, i.renderMonths = function() {
        var n, o;
        if (!(i.props.showTimeSelectOnly || i.props.showYearPicker)) {
          for (var s = [], a = (n = i.props.monthsShown) !== null && n !== void 0 ? n : t.defaultProps.monthsShown, l = i.props.showPreviousMonths ? a - 1 : 0, u = i.props.showMonthYearPicker || i.props.showQuarterYearPicker ? fo(i.state.date, l) : ea(i.state.date, l), c = (o = i.props.monthSelectedIn) !== null && o !== void 0 ? o : l, d = 0; d < a; ++d) {
            var h = d - c + l, p = i.props.showMonthYearPicker || i.props.showQuarterYearPicker ? fo(u, h) : mn(u, h), g = "month-".concat(d), m = d < a - 1, f = d > 0;
            s.push(D.createElement(
              "div",
              { key: g, ref: function(C) {
                i.monthContainer = C ?? void 0;
              }, className: "react-datepicker__month-container" },
              i.renderHeader({ monthDate: p, i: d }),
              D.createElement(Zfe, qe({}, t.defaultProps, i.props, { ariaLabelPrefix: i.props.monthAriaLabelPrefix, day: p, onDayClick: i.handleDayClick, handleOnKeyDown: i.props.handleOnDayKeyDown, handleOnMonthKeyDown: i.props.handleOnKeyDown, onDayMouseEnter: i.handleDayMouseEnter, onMouseLeave: i.handleMonthMouseLeave, orderInDisplay: d, selectingDate: i.state.selectingDate, monthShowsDuplicateDaysEnd: m, monthShowsDuplicateDaysStart: f }))
            ));
          }
          return s;
        }
      }, i.renderYears = function() {
        if (!i.props.showTimeSelectOnly && i.props.showYearPicker)
          return D.createElement(
            "div",
            { className: "react-datepicker__year--container" },
            i.renderHeader({ monthDate: i.state.date }),
            D.createElement(nge, qe({}, t.defaultProps, i.props, { selectingDate: i.state.selectingDate, date: i.state.date, onDayClick: i.handleDayClick, clearSelectingDate: i.clearSelectingDate, onYearMouseEnter: i.handleYearMouseEnter, onYearMouseLeave: i.handleYearMouseLeave }))
          );
      }, i.renderTimeSection = function() {
        if (i.props.showTimeSelect && (i.state.monthContainer || i.props.showTimeSelectOnly))
          return D.createElement(ige, qe({}, t.defaultProps, i.props, { onChange: i.props.onTimeChange, format: i.props.timeFormat, intervals: i.props.timeIntervals, monthRef: i.state.monthContainer }));
      }, i.renderInputTimeSection = function() {
        var n = i.props.selected ? new Date(i.props.selected) : void 0, o = n && no(n) && !!i.props.selected, s = o ? "".concat(rP(n.getHours()), ":").concat(rP(n.getMinutes())) : "";
        if (i.props.showTimeInput)
          return D.createElement(Ufe, qe({}, t.defaultProps, i.props, { date: n, timeString: s, onChange: i.props.onTimeChange }));
      }, i.renderAriaLiveRegion = function() {
        var n, o = jo(i.state.date, (n = i.props.yearItemNumber) !== null && n !== void 0 ? n : t.defaultProps.yearItemNumber), s = o.startPeriod, a = o.endPeriod, l;
        return i.props.showYearPicker ? l = "".concat(s, " - ").concat(a) : i.props.showMonthYearPicker || i.props.showQuarterYearPicker ? l = $e(i.state.date) : l = "".concat(sx(Vr(i.state.date), i.props.locale), " ").concat($e(i.state.date)), D.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, i.state.isRenderAriaLiveMessage && l);
      }, i.renderChildren = function() {
        if (i.props.children)
          return D.createElement("div", { className: "react-datepicker__children-container" }, i.props.children);
      }, i.containerRef = Ko(), i.state = {
        date: i.getDateInView(),
        selectingDate: void 0,
        monthContainer: void 0,
        isRenderAriaLiveMessage: !1
      }, i;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          monthsShown: 1,
          forceShowMonthNavigation: !1,
          timeCaption: "Time",
          previousYearButtonLabel: "Previous Year",
          nextYearButtonLabel: "Next Year",
          previousMonthButtonLabel: "Previous Month",
          nextMonthButtonLabel: "Next Month",
          yearItemNumber: $h
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.componentDidMount = function() {
      var r = this;
      this.props.showTimeSelect && (this.assignMonthContainer = function() {
        r.setState({ monthContainer: r.monthContainer });
      }());
    }, t.prototype.componentDidUpdate = function(r) {
      var i = this;
      if (this.props.preSelection && (!Ue(this.props.preSelection, r.preSelection) || this.props.monthSelectedIn !== r.monthSelectedIn)) {
        var n = !_r(this.state.date, this.props.preSelection);
        this.setState({
          date: this.props.preSelection
        }, function() {
          return n && i.handleCustomMonthChange(i.state.date);
        });
      } else this.props.openToDate && !Ue(this.props.openToDate, r.openToDate) && this.setState({
        date: this.props.openToDate
      });
    }, t.prototype.render = function() {
      var r = this.props.container || Efe;
      return D.createElement(
        mv,
        { onClickOutside: this.handleClickOutside, style: { display: "contents" }, containerRef: this.containerRef, ignoreClass: this.props.outsideClickIgnoreClass },
        D.createElement(
          r,
          { className: xe("react-datepicker", this.props.className, {
            "react-datepicker--time-only": this.props.showTimeSelectOnly
          }), showTime: this.props.showTimeSelect || this.props.showTimeInput, showTimeSelectOnly: this.props.showTimeSelectOnly },
          this.renderAriaLiveRegion(),
          this.renderPreviousButton(),
          this.renderNextButton(),
          this.renderMonths(),
          this.renderYears(),
          this.renderTodayButton(),
          this.renderTimeSection(),
          this.renderInputTimeSection(),
          this.renderChildren()
        )
      );
    }, t;
  }($t)
), dge = function(e) {
  var t = e.icon, r = e.className, i = r === void 0 ? "" : r, n = e.onClick, o = "react-datepicker__calendar-icon";
  return typeof t == "string" ? D.createElement("i", { className: "".concat(o, " ").concat(t, " ").concat(i), "aria-hidden": "true", onClick: n }) : D.isValidElement(t) ? D.cloneElement(t, {
    className: "".concat(t.props.className || "", " ").concat(o, " ").concat(i),
    onClick: function(s) {
      typeof t.props.onClick == "function" && t.props.onClick(s), typeof n == "function" && n(s);
    }
  }) : D.createElement(
    "svg",
    { className: "".concat(o, " ").concat(i), xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 448 512", onClick: n },
    D.createElement("path", { d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z" })
  );
}, yG = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.portalRoot = null, i.el = document.createElement("div"), i;
    }
    return t.prototype.componentDidMount = function() {
      this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
    }, t.prototype.componentWillUnmount = function() {
      this.portalRoot && this.portalRoot.removeChild(this.el);
    }, t.prototype.render = function() {
      return qp.createPortal(this.props.children, this.el);
    }, t;
  }($t)
), hge = "[tabindex], a, button, input, select, textarea", pge = function(e) {
  return (e instanceof HTMLAnchorElement || !e.disabled) && e.tabIndex !== -1;
}, bG = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.getTabChildren = function() {
        var n;
        return Array.prototype.slice.call((n = i.tabLoopRef.current) === null || n === void 0 ? void 0 : n.querySelectorAll(hge), 1, -1).filter(pge);
      }, i.handleFocusStart = function() {
        var n = i.getTabChildren();
        n && n.length > 1 && n[n.length - 1].focus();
      }, i.handleFocusEnd = function() {
        var n = i.getTabChildren();
        n && n.length > 1 && n[0].focus();
      }, i.tabLoopRef = Ko(), i;
    }
    return t.prototype.render = function() {
      var r;
      return ((r = this.props.enableTabLoop) !== null && r !== void 0 ? r : t.defaultProps.enableTabLoop) ? D.createElement(
        "div",
        { className: "react-datepicker__tab-loop", ref: this.tabLoopRef },
        D.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: 0, onFocus: this.handleFocusStart }),
        this.props.children,
        D.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: 0, onFocus: this.handleFocusEnd })
      ) : this.props.children;
    }, t.defaultProps = {
      enableTabLoop: !0
    }, t;
  }($t)
);
function fge(e) {
  var t = function(r) {
    var i, n = typeof r.hidePopper == "boolean" ? r.hidePopper : !0, o = re(null), s = Sfe(qe({ open: !n, whileElementsMounted: cG, placement: r.popperPlacement, middleware: Mn([
      afe({ padding: 15 }),
      sfe(10),
      lfe({ element: o })
    ], (i = r.popperModifiers) !== null && i !== void 0 ? i : [], !0) }, r.popperProps)), a = qe(qe({}, r), { hidePopper: n, popperProps: qe(qe({}, s), { arrowRef: o }) });
    return D.createElement(e, qe({}, a));
  };
  return t;
}
var gge = (
  /** @class */
  function(e) {
    br(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          hidePopper: !0
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.render = function() {
      var r = this.props, i = r.className, n = r.wrapperClassName, o = r.hidePopper, s = o === void 0 ? t.defaultProps.hidePopper : o, a = r.popperComponent, l = r.targetComponent, u = r.enableTabLoop, c = r.popperOnKeyDown, d = r.portalId, h = r.portalHost, p = r.popperProps, g = r.showArrow, m = void 0;
      if (!s) {
        var f = xe("react-datepicker-popper", i);
        m = D.createElement(
          bG,
          { enableTabLoop: u },
          D.createElement(
            "div",
            { ref: p.refs.setFloating, style: p.floatingStyles, className: f, "data-placement": p.placement, onKeyDown: c },
            a,
            g && D.createElement(gfe, { ref: p.arrowRef, context: p.context, fill: "currentColor", strokeWidth: 1, height: 8, width: 16, style: { transform: "translateY(-1px)" }, className: "react-datepicker__triangle" })
          )
        );
      }
      this.props.popperContainer && (m = zc(this.props.popperContainer, {}, m)), d && !s && (m = D.createElement(yG, { portalId: d, portalHost: h }, m));
      var C = xe("react-datepicker-wrapper", n);
      return D.createElement(
        D.Fragment,
        null,
        D.createElement("div", { ref: p.refs.setReference, className: C }, l),
        m
      );
    }, t;
  }($t)
), mge = fge(gge), lP = "react-datepicker-ignore-onclickoutside";
function vge(e, t) {
  return e && t ? Vr(e) !== Vr(t) || $e(e) !== $e(t) : e !== t;
}
var kC = "Date input not valid.", Cge = (
  /** @class */
  function(e) {
    br(t, e);
    function t(r) {
      var i = e.call(this, r) || this;
      return i.calendar = null, i.input = null, i.getPreSelection = function() {
        return i.props.openToDate ? i.props.openToDate : i.props.selectsEnd && i.props.startDate ? i.props.startDate : i.props.selectsStart && i.props.endDate ? i.props.endDate : ft();
      }, i.modifyHolidays = function() {
        var n;
        return (n = i.props.holidays) === null || n === void 0 ? void 0 : n.reduce(function(o, s) {
          var a = new Date(s.date);
          return no(a) ? Mn(Mn([], o, !0), [qe(qe({}, s), { date: a })], !1) : o;
        }, []);
      }, i.calcInitialState = function() {
        var n, o = i.getPreSelection(), s = mG(i.props), a = vG(i.props), l = s && wa(o, Wp(s)) ? s : a && rs(o, YR(a)) ? a : o;
        return {
          open: i.props.startOpen || !1,
          preventFocus: !1,
          inputValue: null,
          preSelection: (n = i.props.selectsRange ? i.props.startDate : i.props.selected) !== null && n !== void 0 ? n : l,
          // transforming highlighted days (perhaps nested array)
          // to flat Map for faster access in day.jsx
          highlightDates: tP(i.props.highlightDates),
          focused: !1,
          // used to focus day in inline version after month has changed, but not on
          // initial render
          shouldFocusDayInline: !1,
          isRenderAriaLiveMessage: !1,
          wasHidden: !1
        };
      }, i.resetHiddenStatus = function() {
        i.setState(qe(qe({}, i.state), { wasHidden: !1 }));
      }, i.setHiddenStatus = function() {
        i.setState(qe(qe({}, i.state), { wasHidden: !0 }));
      }, i.setHiddenStateOnVisibilityHidden = function() {
        document.visibilityState === "hidden" && i.setHiddenStatus();
      }, i.clearPreventFocusTimeout = function() {
        i.preventFocusTimeout && clearTimeout(i.preventFocusTimeout);
      }, i.safeFocus = function() {
        setTimeout(function() {
          var n, o;
          (o = (n = i.input) === null || n === void 0 ? void 0 : n.focus) === null || o === void 0 || o.call(n, { preventScroll: !0 });
        }, 0);
      }, i.safeBlur = function() {
        setTimeout(function() {
          var n, o;
          (o = (n = i.input) === null || n === void 0 ? void 0 : n.blur) === null || o === void 0 || o.call(n);
        }, 0);
      }, i.setFocus = function() {
        i.safeFocus();
      }, i.setBlur = function() {
        i.safeBlur(), i.cancelFocusInput();
      }, i.setOpen = function(n, o) {
        o === void 0 && (o = !1), i.setState({
          open: n,
          preSelection: n && i.state.open ? i.state.preSelection : i.calcInitialState().preSelection,
          lastPreSelectChange: VC
        }, function() {
          n || i.setState(function(s) {
            return {
              focused: o ? s.focused : !1
            };
          }, function() {
            !o && i.setBlur(), i.setState({ inputValue: null });
          });
        });
      }, i.inputOk = function() {
        return go(i.state.preSelection);
      }, i.isCalendarOpen = function() {
        return i.props.open === void 0 ? i.state.open && !i.props.disabled && !i.props.readOnly : i.props.open;
      }, i.handleFocus = function(n) {
        var o, s, a = i.state.wasHidden, l = a ? i.state.open : !0;
        a && i.resetHiddenStatus(), !i.state.preventFocus && l && ((s = (o = i.props).onFocus) === null || s === void 0 || s.call(o, n), !i.props.preventOpenOnFocus && !i.props.readOnly && i.setOpen(!0)), i.setState({ focused: !0 });
      }, i.sendFocusBackToInput = function() {
        i.preventFocusTimeout && i.clearPreventFocusTimeout(), i.setState({ preventFocus: !0 }, function() {
          i.preventFocusTimeout = setTimeout(function() {
            i.setFocus(), i.setState({ preventFocus: !1 });
          });
        });
      }, i.cancelFocusInput = function() {
        clearTimeout(i.inputFocusTimeout), i.inputFocusTimeout = void 0;
      }, i.deferFocusInput = function() {
        i.cancelFocusInput(), i.inputFocusTimeout = setTimeout(function() {
          return i.setFocus();
        }, 1);
      }, i.handleDropdownFocus = function() {
        i.cancelFocusInput();
      }, i.handleBlur = function(n) {
        var o, s;
        (!i.state.open || i.props.withPortal || i.props.showTimeInput) && ((s = (o = i.props).onBlur) === null || s === void 0 || s.call(o, n)), i.setState({ focused: !1 });
      }, i.handleCalendarClickOutside = function(n) {
        var o, s;
        i.props.inline || i.setOpen(!1), (s = (o = i.props).onClickOutside) === null || s === void 0 || s.call(o, n), i.props.withPortal && n.preventDefault();
      }, i.handleChange = function() {
        for (var n, o, s = [], a = 0; a < arguments.length; a++)
          s[a] = arguments[a];
        var l = s[0];
        if (!(i.props.onChangeRaw && (i.props.onChangeRaw.apply(i, s), !l || typeof l.isDefaultPrevented != "function" || l.isDefaultPrevented()))) {
          i.setState({
            inputValue: (l == null ? void 0 : l.target) instanceof HTMLInputElement ? l.target.value : null,
            lastPreSelectChange: yge
          });
          var u = i.props, c = u.dateFormat, d = c === void 0 ? t.defaultProps.dateFormat : c, h = u.strictParsing, p = h === void 0 ? t.defaultProps.strictParsing : h, g = u.selectsRange, m = u.startDate, f = u.endDate, C = (l == null ? void 0 : l.target) instanceof HTMLInputElement ? l.target.value : "";
          if (g) {
            var w = C.split("-", 2).map(function(O) {
              return O.trim();
            }), E = w[0], b = w[1], y = NC(E ?? "", d, i.props.locale, p), S = NC(b ?? "", d, i.props.locale, p), x = (m == null ? void 0 : m.getTime()) !== (y == null ? void 0 : y.getTime()), R = (f == null ? void 0 : f.getTime()) !== (S == null ? void 0 : S.getTime());
            if (!x && !R || y && Fi(y, i.props) || S && Fi(S, i.props))
              return;
            (o = (n = i.props).onChange) === null || o === void 0 || o.call(n, [y, S], l);
          } else {
            var P = NC(C, d, i.props.locale, p, i.props.minDate);
            i.props.showTimeSelectOnly && i.props.selected && P && !Ue(P, i.props.selected) && (P = rpe(i.props.selected, {
              hours: kn(P),
              minutes: Vn(P),
              seconds: mo(P)
            })), (P || !C) && i.setSelected(P, l, !0);
          }
        }
      }, i.handleSelect = function(n, o, s) {
        if (i.props.shouldCloseOnSelect && !i.props.showTimeSelect && i.sendFocusBackToInput(), i.props.onChangeRaw && i.props.onChangeRaw(o), i.setSelected(n, o, !1, s), i.props.showDateSelect && i.setState({ isRenderAriaLiveMessage: !0 }), !i.props.shouldCloseOnSelect || i.props.showTimeSelect)
          i.setPreSelection(n);
        else if (!i.props.inline) {
          i.props.selectsRange || i.setOpen(!1);
          var a = i.props, l = a.startDate, u = a.endDate;
          l && !u && (i.props.swapRange || !oP(n, l)) && i.setOpen(!1);
        }
      }, i.setSelected = function(n, o, s, a) {
        var l, u, c = n;
        if (i.props.showYearPicker) {
          if (c !== null && $p($e(c), i.props))
            return;
        } else if (i.props.showMonthYearPicker) {
          if (c !== null && gG(c, i.props))
            return;
        } else if (c !== null && Fi(c, i.props))
          return;
        var d = i.props, h = d.onChange, p = d.selectsRange, g = d.startDate, m = d.endDate, f = d.selectsMultiple, C = d.selectedDates, w = d.minTime, E = d.swapRange;
        if (!Bs(i.props.selected, c) || i.props.allowSameDay || p || f)
          if (c !== null && (i.props.selected && (!s || !i.props.showTimeSelect && !i.props.showTimeSelectOnly && !i.props.showTimeInput) && (c = LC(c, {
            hour: kn(i.props.selected),
            minute: Vn(i.props.selected),
            second: mo(i.props.selected)
          })), !s && (i.props.showTimeSelect || i.props.showTimeSelectOnly) && w && (c = LC(c, {
            hour: w.getHours(),
            minute: w.getMinutes(),
            second: w.getSeconds()
          })), i.props.inline || i.setState({
            preSelection: c
          }), i.props.focusSelectedMonth || i.setState({ monthSelectedIn: a })), p) {
            var b = !g && !m, y = g && !m, S = g && m;
            b ? h == null || h([c, null], o) : y && (c === null ? h == null || h([null, null], o) : oP(c, g) ? E ? h == null || h([c, g], o) : h == null || h([c, null], o) : h == null || h([g, c], o)), S && (h == null || h([c, null], o));
          } else if (f) {
            if (c !== null)
              if (!(C != null && C.length))
                h == null || h([c], o);
              else {
                var x = C.some(function(P) {
                  return Ue(P, c);
                });
                if (x) {
                  var R = C.filter(function(P) {
                    return !Ue(P, c);
                  });
                  h == null || h(R, o);
                } else
                  h == null || h(Mn(Mn([], C, !0), [c], !1), o);
              }
          } else
            h == null || h(c, o);
        s || ((u = (l = i.props).onSelect) === null || u === void 0 || u.call(l, c, o), i.setState({ inputValue: null }));
      }, i.setPreSelection = function(n) {
        var o = go(i.props.minDate), s = go(i.props.maxDate), a = !0;
        if (n) {
          var l = Wp(n);
          if (o && s)
            a = Oc(n, i.props.minDate, i.props.maxDate);
          else if (o) {
            var u = Wp(i.props.minDate);
            a = rs(n, u) || Bs(l, u);
          } else if (s) {
            var c = YR(i.props.maxDate);
            a = wa(n, c) || Bs(l, c);
          }
        }
        a && i.setState({
          preSelection: n
        });
      }, i.toggleCalendar = function() {
        i.setOpen(!i.state.open);
      }, i.handleTimeChange = function(n) {
        var o, s;
        if (!(i.props.selectsRange || i.props.selectsMultiple)) {
          var a = i.props.selected ? i.props.selected : i.getPreSelection(), l = i.props.selected ? n : LC(a, {
            hour: kn(n),
            minute: Vn(n)
          });
          i.setState({
            preSelection: l
          }), (s = (o = i.props).onChange) === null || s === void 0 || s.call(o, l), i.props.shouldCloseOnSelect && !i.props.showTimeInput && (i.sendFocusBackToInput(), i.setOpen(!1)), i.props.showTimeInput && i.setOpen(!0), (i.props.showTimeSelectOnly || i.props.showTimeSelect) && i.setState({ isRenderAriaLiveMessage: !0 }), i.setState({ inputValue: null });
        }
      }, i.onInputClick = function() {
        var n, o;
        !i.props.disabled && !i.props.readOnly && i.setOpen(!0), (o = (n = i.props).onInputClick) === null || o === void 0 || o.call(n);
      }, i.onInputKeyDown = function(n) {
        var o, s, a, l, u, c;
        (s = (o = i.props).onKeyDown) === null || s === void 0 || s.call(o, n);
        var d = n.key;
        if (!i.state.open && !i.props.inline && !i.props.preventOpenOnFocus) {
          (d === pe.ArrowDown || d === pe.ArrowUp || d === pe.Enter) && ((a = i.onInputClick) === null || a === void 0 || a.call(i));
          return;
        }
        if (i.state.open) {
          if (d === pe.ArrowDown || d === pe.ArrowUp) {
            n.preventDefault();
            var h = i.props.showTimeSelectOnly ? ".react-datepicker__time-list-item[tabindex='0']" : i.props.showWeekPicker && i.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : i.props.showFullMonthYearPicker || i.props.showMonthYearPicker ? '.react-datepicker__month-text[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]', p = ((l = i.calendar) === null || l === void 0 ? void 0 : l.containerRef.current) instanceof Element && i.calendar.containerRef.current.querySelector(h);
            p instanceof HTMLElement && p.focus({ preventScroll: !0 });
            return;
          }
          var g = ft(i.state.preSelection);
          d === pe.Enter ? (n.preventDefault(), n.target.blur(), i.inputOk() && i.state.lastPreSelectChange === VC ? (i.handleSelect(g, n), !i.props.shouldCloseOnSelect && i.setPreSelection(g)) : i.setOpen(!1)) : d === pe.Escape ? (n.preventDefault(), n.target.blur(), i.sendFocusBackToInput(), i.setOpen(!1)) : d === pe.Tab && i.setOpen(!1), i.inputOk() || (c = (u = i.props).onInputError) === null || c === void 0 || c.call(u, { code: 1, msg: kC });
        }
      }, i.onPortalKeyDown = function(n) {
        var o = n.key;
        o === pe.Escape && (n.preventDefault(), i.setState({
          preventFocus: !0
        }, function() {
          i.setOpen(!1), setTimeout(function() {
            i.setFocus(), i.setState({ preventFocus: !1 });
          });
        }));
      }, i.onDayKeyDown = function(n) {
        var o, s, a, l, u, c, d = i.props, h = d.minDate, p = d.maxDate, g = d.disabledKeyboardNavigation, m = d.showWeekPicker, f = d.shouldCloseOnSelect, C = d.locale, w = d.calendarStartDay, E = d.adjustDateOnChange, b = d.inline;
        if ((s = (o = i.props).onKeyDown) === null || s === void 0 || s.call(o, n), !g) {
          var y = n.key, S = n.shiftKey, x = ft(i.state.preSelection), R = function(F, N) {
            var V = N;
            switch (F) {
              case pe.ArrowRight:
                V = m ? Ag(N, 1) : pn(N, 1);
                break;
              case pe.ArrowLeft:
                V = m ? _R(N) : Vhe(N);
                break;
              case pe.ArrowUp:
                V = _R(N);
                break;
              case pe.ArrowDown:
                V = Ag(N, 1);
                break;
              case pe.PageUp:
                V = S ? mu(N, 1) : ea(N, 1);
                break;
              case pe.PageDown:
                V = S ? fo(N, 1) : mn(N, 1);
                break;
              case pe.Home:
                V = Xo(N, C, w);
                break;
              case pe.End:
                V = Ife(N);
                break;
            }
            return V;
          }, P = function(F, N) {
            for (var V = 40, B = F, $ = !1, L = 0, z = R(F, N); !$; ) {
              if (L >= V) {
                z = N;
                break;
              }
              h && z < h && (B = pe.ArrowRight, z = Fi(h, i.props) ? R(B, z) : h), p && z > p && (B = pe.ArrowLeft, z = Fi(p, i.props) ? R(B, z) : p), Fi(z, i.props) ? ((B === pe.PageUp || B === pe.Home) && (B = pe.ArrowRight), (B === pe.PageDown || B === pe.End) && (B = pe.ArrowLeft), z = R(B, z)) : $ = !0, L++;
            }
            return z;
          };
          if (y === pe.Enter) {
            n.preventDefault(), i.handleSelect(x, n), !f && i.setPreSelection(x);
            return;
          } else if (y === pe.Escape) {
            n.preventDefault(), i.setOpen(!1), i.inputOk() || (l = (a = i.props).onInputError) === null || l === void 0 || l.call(a, { code: 1, msg: kC });
            return;
          }
          var O = null;
          switch (y) {
            case pe.ArrowLeft:
            case pe.ArrowRight:
            case pe.ArrowUp:
            case pe.ArrowDown:
            case pe.PageUp:
            case pe.PageDown:
            case pe.Home:
            case pe.End:
              O = P(y, x);
              break;
          }
          if (!O) {
            (c = (u = i.props).onInputError) === null || c === void 0 || c.call(u, { code: 1, msg: kC });
            return;
          }
          if (n.preventDefault(), i.setState({ lastPreSelectChange: VC }), E && i.setSelected(O), i.setPreSelection(O), b) {
            var I = Vr(x), M = Vr(O), _ = $e(x), G = $e(O);
            I !== M || _ !== G ? i.setState({ shouldFocusDayInline: !0 }) : i.setState({ shouldFocusDayInline: !1 });
          }
        }
      }, i.onPopperKeyDown = function(n) {
        var o = n.key;
        o === pe.Escape && (n.preventDefault(), i.sendFocusBackToInput());
      }, i.onClearClick = function(n) {
        n && n.preventDefault && n.preventDefault(), i.sendFocusBackToInput();
        var o = i.props, s = o.selectsRange, a = o.onChange;
        s ? a == null || a([null, null], n) : a == null || a(null, n), i.setState({ inputValue: null });
      }, i.clear = function() {
        i.onClearClick();
      }, i.onScroll = function(n) {
        typeof i.props.closeOnScroll == "boolean" && i.props.closeOnScroll ? (n.target === document || n.target === document.documentElement || n.target === document.body) && i.setOpen(!1) : typeof i.props.closeOnScroll == "function" && i.props.closeOnScroll(n) && i.setOpen(!1);
      }, i.renderCalendar = function() {
        var n, o;
        return !i.props.inline && !i.isCalendarOpen() ? null : D.createElement(cge, qe({ showMonthYearDropdown: void 0, ref: function(s) {
          i.calendar = s;
        } }, i.props, i.state, { setOpen: i.setOpen, dateFormat: (n = i.props.dateFormatCalendar) !== null && n !== void 0 ? n : t.defaultProps.dateFormatCalendar, onSelect: i.handleSelect, onClickOutside: i.handleCalendarClickOutside, holidays: Wfe(i.modifyHolidays()), outsideClickIgnoreClass: lP, onDropdownFocus: i.handleDropdownFocus, onTimeChange: i.handleTimeChange, className: i.props.calendarClassName, container: i.props.calendarContainer, handleOnKeyDown: i.props.onKeyDown, handleOnDayKeyDown: i.onDayKeyDown, setPreSelection: i.setPreSelection, dropdownMode: (o = i.props.dropdownMode) !== null && o !== void 0 ? o : t.defaultProps.dropdownMode }), i.props.children);
      }, i.renderAriaLiveRegion = function() {
        var n = i.props, o = n.dateFormat, s = o === void 0 ? t.defaultProps.dateFormat : o, a = n.locale, l = i.props.showTimeInput || i.props.showTimeSelect, u = l ? "PPPPp" : "PPPP", c;
        return i.props.selectsRange ? c = "Selected start date: ".concat(Oi(i.props.startDate, {
          dateFormat: u,
          locale: a
        }), ". ").concat(i.props.endDate ? "End date: " + Oi(i.props.endDate, {
          dateFormat: u,
          locale: a
        }) : "") : i.props.showTimeSelectOnly ? c = "Selected time: ".concat(Oi(i.props.selected, { dateFormat: s, locale: a })) : i.props.showYearPicker ? c = "Selected year: ".concat(Oi(i.props.selected, { dateFormat: "yyyy", locale: a })) : i.props.showMonthYearPicker ? c = "Selected month: ".concat(Oi(i.props.selected, { dateFormat: "MMMM yyyy", locale: a })) : i.props.showQuarterYearPicker ? c = "Selected quarter: ".concat(Oi(i.props.selected, {
          dateFormat: "yyyy, QQQ",
          locale: a
        })) : c = "Selected date: ".concat(Oi(i.props.selected, {
          dateFormat: u,
          locale: a
        })), D.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, c);
      }, i.renderDateInput = function() {
        var n, o, s, a = xe(i.props.className, (n = {}, n[lP] = i.state.open, n)), l = i.props.customInput || D.createElement("input", { type: "text" }), u = i.props.customInputRef || "ref", c = i.props, d = c.dateFormat, h = d === void 0 ? t.defaultProps.dateFormat : d, p = c.locale, g = typeof i.props.value == "string" ? i.props.value : typeof i.state.inputValue == "string" ? i.state.inputValue : i.props.selectsRange ? Dfe(i.props.startDate, i.props.endDate, {
          dateFormat: h,
          locale: p
        }) : i.props.selectsMultiple ? Tfe((s = i.props.selectedDates) !== null && s !== void 0 ? s : [], {
          dateFormat: h,
          locale: p
        }) : Oi(i.props.selected, {
          dateFormat: h,
          locale: p
        });
        return Gt(l, (o = {}, o[u] = function(m) {
          i.input = m;
        }, o.value = g, o.onBlur = i.handleBlur, o.onChange = i.handleChange, o.onClick = i.onInputClick, o.onFocus = i.handleFocus, o.onKeyDown = i.onInputKeyDown, o.id = i.props.id, o.name = i.props.name, o.form = i.props.form, o.autoFocus = i.props.autoFocus, o.placeholder = i.props.placeholderText, o.disabled = i.props.disabled, o.autoComplete = i.props.autoComplete, o.className = xe(l.props.className, a), o.title = i.props.title, o.readOnly = i.props.readOnly, o.required = i.props.required, o.tabIndex = i.props.tabIndex, o["aria-describedby"] = i.props.ariaDescribedBy, o["aria-invalid"] = i.props.ariaInvalid, o["aria-labelledby"] = i.props.ariaLabelledBy, o["aria-required"] = i.props.ariaRequired, o));
      }, i.renderClearButton = function() {
        var n = i.props, o = n.isClearable, s = n.disabled, a = n.selected, l = n.startDate, u = n.endDate, c = n.clearButtonTitle, d = n.clearButtonClassName, h = d === void 0 ? "" : d, p = n.ariaLabelClose, g = p === void 0 ? "Close" : p, m = n.selectedDates;
        return o && (a != null || l != null || u != null || m != null && m.length) ? D.createElement("button", { type: "button", className: xe("react-datepicker__close-icon", h, { "react-datepicker__close-icon--disabled": s }), disabled: s, "aria-label": g, onClick: i.onClearClick, title: c, tabIndex: -1 }) : null;
      }, i.state = i.calcInitialState(), i.preventFocusTimeout = void 0, i;
    }
    return Object.defineProperty(t, "defaultProps", {
      get: function() {
        return {
          allowSameDay: !1,
          dateFormat: "MM/dd/yyyy",
          dateFormatCalendar: "LLLL yyyy",
          disabled: !1,
          disabledKeyboardNavigation: !1,
          dropdownMode: "scroll",
          preventOpenOnFocus: !1,
          monthsShown: 1,
          readOnly: !1,
          withPortal: !1,
          selectsDisabledDaysInRange: !1,
          shouldCloseOnSelect: !0,
          showTimeSelect: !1,
          showTimeInput: !1,
          showPreviousMonths: !1,
          showMonthYearPicker: !1,
          showFullMonthYearPicker: !1,
          showTwoColumnMonthYearPicker: !1,
          showFourColumnMonthYearPicker: !1,
          showYearPicker: !1,
          showQuarterYearPicker: !1,
          showWeekPicker: !1,
          strictParsing: !1,
          swapRange: !1,
          timeIntervals: 30,
          timeCaption: "Time",
          previousMonthAriaLabel: "Previous Month",
          previousMonthButtonLabel: "Previous Month",
          nextMonthAriaLabel: "Next Month",
          nextMonthButtonLabel: "Next Month",
          previousYearAriaLabel: "Previous Year",
          previousYearButtonLabel: "Previous Year",
          nextYearAriaLabel: "Next Year",
          nextYearButtonLabel: "Next Year",
          timeInputLabel: "Time",
          enableTabLoop: !0,
          yearItemNumber: $h,
          focusSelectedMonth: !1,
          showPopperArrow: !0,
          excludeScrollbar: !0,
          customTimeInput: null,
          calendarStartDay: void 0,
          toggleCalendarOnIconClick: !1,
          usePointerEvent: !1
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.componentDidMount = function() {
      window.addEventListener("scroll", this.onScroll, !0), document.addEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden);
    }, t.prototype.componentDidUpdate = function(r, i) {
      var n, o, s, a;
      r.inline && vge(r.selected, this.props.selected) && this.setPreSelection(this.props.selected), this.state.monthSelectedIn !== void 0 && r.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), r.highlightDates !== this.props.highlightDates && this.setState({
        highlightDates: tP(this.props.highlightDates)
      }), !i.focused && !Bs(r.selected, this.props.selected) && this.setState({ inputValue: null }), i.open !== this.state.open && (i.open === !1 && this.state.open === !0 && ((o = (n = this.props).onCalendarOpen) === null || o === void 0 || o.call(n)), i.open === !0 && this.state.open === !1 && ((a = (s = this.props).onCalendarClose) === null || a === void 0 || a.call(s)));
    }, t.prototype.componentWillUnmount = function() {
      this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, !0), document.removeEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden);
    }, t.prototype.renderInputContainer = function() {
      var r = this.props, i = r.showIcon, n = r.icon, o = r.calendarIconClassname, s = r.calendarIconClassName, a = r.toggleCalendarOnIconClick, l = this.state.open;
      return o && console.warn("calendarIconClassname props is deprecated. should use calendarIconClassName props."), D.createElement(
        "div",
        { className: "react-datepicker__input-container".concat(i ? " react-datepicker__view-calendar-icon" : "") },
        i && D.createElement(dge, qe({ icon: n, className: xe(s, !s && o, l && "react-datepicker-ignore-onclickoutside") }, a ? {
          onClick: this.toggleCalendar
        } : null)),
        this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(),
        this.renderDateInput(),
        this.renderClearButton()
      );
    }, t.prototype.render = function() {
      var r = this.renderCalendar();
      if (this.props.inline)
        return r;
      if (this.props.withPortal) {
        var i = this.state.open ? D.createElement(
          bG,
          { enableTabLoop: this.props.enableTabLoop },
          D.createElement("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, r)
        ) : null;
        return this.state.open && this.props.portalId && (i = D.createElement(yG, qe({ portalId: this.props.portalId }, this.props), i)), D.createElement(
          "div",
          null,
          this.renderInputContainer(),
          i
        );
      }
      return D.createElement(mge, qe({}, this.props, { className: this.props.popperClassName, hidePopper: !this.isCalendarOpen(), targetComponent: this.renderInputContainer(), popperComponent: r, popperOnKeyDown: this.onPopperKeyDown, showArrow: this.props.showPopperArrow }));
    }, t;
  }($t)
), yge = "input", VC = "navigate";
const wbe = ({
  label: e,
  selected: t,
  onChange: r,
  className: i,
  ...n
}) => {
  const { theme: o } = ku(), s = `react-datepicker-portal-${o}`;
  return /* @__PURE__ */ ve("div", { className: i, children: [
    e && /* @__PURE__ */ H("label", { className: "block text-sm font-medium text-text mb-1", children: e }),
    /* @__PURE__ */ H(
      Cge,
      {
        selected: t,
        onChange: (a) => r(a),
        customInput: /* @__PURE__ */ H(Hh, {}),
        popperClassName: s,
        calendarClassName: "bg-card text-text border border-border rounded-md shadow-lg",
        ...n
      }
    )
  ] });
}, Sbe = ({
  onFileUpload: e,
  multiple: t = !1,
  acceptedFileTypes: r,
  label: i,
  className: n
}) => {
  const [o, s] = ee(!1), a = D.useRef(null), l = fe((h) => {
    h.preventDefault(), h.stopPropagation(), h.type === "dragenter" || h.type === "dragover" ? s(!0) : h.type === "dragleave" && s(!1);
  }, []), u = fe((h) => {
    h.preventDefault(), h.stopPropagation(), s(!1), h.dataTransfer.files && h.dataTransfer.files.length > 0 && (e(Array.from(h.dataTransfer.files)), h.dataTransfer.clearData());
  }, [e]), c = fe((h) => {
    h.preventDefault(), h.target.files && h.target.files.length > 0 && e(Array.from(h.target.files));
  }, [e]), d = () => {
    var h;
    (h = a.current) == null || h.click();
  };
  return /* @__PURE__ */ ve(Oa, { className: `p-6 border-dashed border-2 ${o ? "border-primary" : "border-border"} ${n || ""}`, children: [
    i && /* @__PURE__ */ H("label", { className: "block text-sm font-medium text-text mb-2", children: i }),
    /* @__PURE__ */ ve(
      "div",
      {
        className: `flex flex-col items-center justify-center p-6 text-center cursor-pointer rounded-md ${o ? "bg-primary/10" : "bg-background/50"}`,
        onDragEnter: l,
        onDragLeave: l,
        onDragOver: l,
        onDrop: u,
        children: [
          /* @__PURE__ */ H(
            "input",
            {
              type: "file",
              id: "file-upload-input",
              ref: a,
              multiple: t,
              accept: r,
              onChange: c,
              className: "hidden"
            }
          ),
          /* @__PURE__ */ H("p", { className: "text-text mb-2", children: "Drag & Drop files here or" }),
          /* @__PURE__ */ H(Uo, { onClick: d, variant: "secondary", children: "Browse Files" }),
          r && /* @__PURE__ */ ve("p", { className: "text-sm text-text-light mt-2", children: [
            "Accepted: ",
            r
          ] })
        ]
      }
    )
  ] });
}, bge = ({ options: e, label: t, id: r, className: i, ...n }) => {
  const o = r || `select-${Math.random().toString(36).substr(2, 9)}`;
  return /* @__PURE__ */ ve("div", { children: [
    t && /* @__PURE__ */ H("label", { htmlFor: o, className: "block text-sm font-medium text-text mb-1", children: t }),
    /* @__PURE__ */ H("div", { className: "relative", children: /* @__PURE__ */ H(
      "select",
      {
        id: o,
        className: `block w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary appearance-none bg-card border-border text-text bg-[url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3' stroke='%236B7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E")] bg-no-repeat bg-[right_0.75rem_center] bg-[length:1.5em_1.5em] ${i || ""}`,
        ...n,
        children: e.map((u) => /* @__PURE__ */ H("option", { value: u.value, children: u.label }, u.value))
      }
    ) })
  ] });
}, wge = ({ label: e, id: t, className: r, ...i }) => {
  const n = t || `radio-${Math.random().toString(36).substr(2, 9)}`;
  return /* @__PURE__ */ ve("div", { className: "flex items-center", children: [
    /* @__PURE__ */ H(
      "input",
      {
        id: n,
        type: "radio",
        className: `form-radio h-4 w-4 transition-colors duration-200 ease-in-out cursor-pointer text-primary border-border bg-card focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed ${r || ""}`,
        ...i
      }
    ),
    e && /* @__PURE__ */ H("label", { htmlFor: n, className: "ml-2 text-sm text-text cursor-pointer", children: e })
  ] });
}, Sge = ({ title: e, className: t }) => /* @__PURE__ */ H("div", { className: `pb-2 border-b border-border ${t || ""}`, children: /* @__PURE__ */ H("h2", { className: "text-xl font-semibold text-text", children: e }) }), Ege = ({ children: e, className: t }) => /* @__PURE__ */ H("div", { className: `flex items-center justify-end gap-4 p-4 bg-background-alt border-t border-border ${t || ""}`, children: e }), Ebe = ({
  title: e,
  fields: t,
  onSubmit: r,
  onCancel: i,
  submitButtonText: n = "Submit",
  cancelButtonText: o = "Cancel",
  className: s
}) => {
  const [a, l] = ee(() => {
    const h = {};
    return t.forEach((p) => {
      p.type === "checkbox" ? h[p.name] = p.checked || !1 : p.type === "radio" ? p.checked && (h[p.radioGroup] = p.value) : h[p.name] = p.value || "";
    }), h;
  }), u = (h) => {
    const { name: p, value: g, type: m } = h.target;
    l(m === "checkbox" ? (f) => ({ ...f, [p]: h.target.checked }) : (f) => ({ ...f, [p]: g }));
  }, c = (h) => {
    h.preventDefault(), r(a);
  }, d = (h) => {
    const p = { id: h.name, label: h.label, className: h.className, disabled: h.disabled };
    switch (h.type) {
      case "text":
      case "email":
      case "password":
      case "number":
        return /* @__PURE__ */ H(Hh, { ...p, name: h.name, type: h.type, placeholder: h.placeholder, value: a[h.name], onChange: u });
      case "select":
        return /* @__PURE__ */ H(bge, { ...p, name: h.name, options: h.options, value: a[h.name], onChange: u });
      case "checkbox":
        return /* @__PURE__ */ H(Lce, { ...p, name: h.name, checked: a[h.name], onChange: u });
      case "radio":
        return /* @__PURE__ */ H(wge, { ...p, name: h.radioGroup, value: h.value, checked: a[h.radioGroup] === h.value, onChange: u });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ H(Oa, { className: s, padding: "p-0", children: /* @__PURE__ */ ve("form", { onSubmit: c, children: [
    /* @__PURE__ */ ve("div", { className: "p-6", children: [
      /* @__PURE__ */ H(Sge, { title: e }),
      /* @__PURE__ */ H("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 mt-6", children: t.map((h) => /* @__PURE__ */ H("div", { children: d(h) }, h.name + (h.type === "radio" ? h.value : ""))) })
    ] }),
    /* @__PURE__ */ ve(Ege, { children: [
      i && /* @__PURE__ */ H(Uo, { type: "button", variant: "outline", onClick: i, children: o }),
      /* @__PURE__ */ H(Uo, { type: "submit", variant: "primary", children: n })
    ] })
  ] }) });
};
function Ea(e) {
  "@babel/helpers - typeof";
  return Ea = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ea(e);
}
function xge(e, t) {
  if (Ea(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ea(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function wG(e) {
  var t = xge(e, "string");
  return Ea(t) == "symbol" ? t : t + "";
}
function Mc(e, t, r) {
  return (t = wG(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function uP(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Pe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uP(Object(r), !0).forEach(function(i) {
      Mc(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : uP(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function Age(e) {
  if (Array.isArray(e)) return e;
}
function Dge(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); l = !0) ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw n;
      }
    }
    return a;
  }
}
function gw(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function SG(e, t) {
  if (e) {
    if (typeof e == "string") return gw(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? gw(e, t) : void 0;
  }
}
function Tge() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Co(e, t) {
  return Age(e) || Dge(e, t) || SG(e, t) || Tge();
}
function Lo(e, t) {
  if (e == null) return {};
  var r, i, n = x8(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++) r = o[i], t.indexOf(r) === -1 && {}.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Rge = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Pge(e) {
  var t = e.defaultInputValue, r = t === void 0 ? "" : t, i = e.defaultMenuIsOpen, n = i === void 0 ? !1 : i, o = e.defaultValue, s = o === void 0 ? null : o, a = e.inputValue, l = e.menuIsOpen, u = e.onChange, c = e.onInputChange, d = e.onMenuClose, h = e.onMenuOpen, p = e.value, g = Lo(e, Rge), m = ee(a !== void 0 ? a : r), f = Co(m, 2), C = f[0], w = f[1], E = ee(l !== void 0 ? l : n), b = Co(E, 2), y = b[0], S = b[1], x = ee(p !== void 0 ? p : s), R = Co(x, 2), P = R[0], O = R[1], I = fe(function(B, $) {
    typeof u == "function" && u(B, $), O(B);
  }, [u]), M = fe(function(B, $) {
    var L;
    typeof c == "function" && (L = c(B, $)), w(L !== void 0 ? L : B);
  }, [c]), _ = fe(function() {
    typeof h == "function" && h(), S(!0);
  }, [h]), G = fe(function() {
    typeof d == "function" && d(), S(!1);
  }, [d]), F = a !== void 0 ? a : C, N = l !== void 0 ? l : y, V = p !== void 0 ? p : P;
  return Pe(Pe({}, g), {}, {
    inputValue: F,
    menuIsOpen: N,
    onChange: I,
    onInputChange: M,
    onMenuClose: G,
    onMenuOpen: _,
    value: V
  });
}
function Ige(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function cP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, wG(i.key), i);
  }
}
function Oge(e, t, r) {
  return t && cP(e.prototype, t), r && cP(e, r), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Mge(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && eb(e, t);
}
function kg(e) {
  return kg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, kg(e);
}
function EG() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (EG = function() {
    return !!e;
  })();
}
function Fge(e, t) {
  if (t && (Ea(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return A8(e);
}
function _ge(e) {
  var t = EG();
  return function() {
    var r, i = kg(e);
    if (t) {
      var n = kg(this).constructor;
      r = Reflect.construct(i, arguments, n);
    } else r = i.apply(this, arguments);
    return Fge(this, r);
  };
}
function Nge(e) {
  if (Array.isArray(e)) return gw(e);
}
function Lge(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Gge() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lx(e) {
  return Nge(e) || Lge(e) || SG(e) || Gge();
}
function kge(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Vge(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var Hge = /* @__PURE__ */ function() {
  function e(r) {
    var i = this;
    this._insertTag = function(n) {
      var o;
      i.tags.length === 0 ? i.insertionPoint ? o = i.insertionPoint.nextSibling : i.prepend ? o = i.container.firstChild : o = i.before : o = i.tags[i.tags.length - 1].nextSibling, i.container.insertBefore(n, o), i.tags.push(n);
    }, this.isSpeedy = r.speedy === void 0 ? !0 : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(i) {
    i.forEach(this._insertTag);
  }, t.insert = function(i) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Vge(this));
    var n = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = kge(n);
      try {
        o.insertRule(i, o.cssRules.length);
      } catch {
      }
    } else
      n.appendChild(document.createTextNode(i));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(i) {
      var n;
      return (n = i.parentNode) == null ? void 0 : n.removeChild(i);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), xr = "-ms-", Vg = "-moz-", tt = "-webkit-", xG = "comm", ux = "rule", cx = "decl", Bge = "@import", AG = "@keyframes", Wge = "@layer", $ge = Math.abs, vv = String.fromCharCode, jge = Object.assign;
function zge(e, t) {
  return Sr(e, 0) ^ 45 ? (((t << 2 ^ Sr(e, 0)) << 2 ^ Sr(e, 1)) << 2 ^ Sr(e, 2)) << 2 ^ Sr(e, 3) : 0;
}
function DG(e) {
  return e.trim();
}
function Uge(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function rt(e, t, r) {
  return e.replace(t, r);
}
function mw(e, t) {
  return e.indexOf(t);
}
function Sr(e, t) {
  return e.charCodeAt(t) | 0;
}
function oh(e, t, r) {
  return e.slice(t, r);
}
function Dn(e) {
  return e.length;
}
function dx(e) {
  return e.length;
}
function Ep(e, t) {
  return t.push(e), e;
}
function Yge(e, t) {
  return e.map(t).join("");
}
var Cv = 1, bu = 1, TG = 0, ni = 0, nr = 0, tc = "";
function yv(e, t, r, i, n, o, s) {
  return { value: e, root: t, parent: r, type: i, props: n, children: o, line: Cv, column: bu, length: s, return: "" };
}
function wc(e, t) {
  return jge(yv("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Xge() {
  return nr;
}
function Kge() {
  return nr = ni > 0 ? Sr(tc, --ni) : 0, bu--, nr === 10 && (bu = 1, Cv--), nr;
}
function wi() {
  return nr = ni < TG ? Sr(tc, ni++) : 0, bu++, nr === 10 && (bu = 1, Cv++), nr;
}
function Bn() {
  return Sr(tc, ni);
}
function jp() {
  return ni;
}
function zh(e, t) {
  return oh(tc, e, t);
}
function sh(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function RG(e) {
  return Cv = bu = 1, TG = Dn(tc = e), ni = 0, [];
}
function PG(e) {
  return tc = "", e;
}
function zp(e) {
  return DG(zh(ni - 1, vw(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function qge(e) {
  for (; (nr = Bn()) && nr < 33; )
    wi();
  return sh(e) > 2 || sh(nr) > 3 ? "" : " ";
}
function Zge(e, t) {
  for (; --t && wi() && !(nr < 48 || nr > 102 || nr > 57 && nr < 65 || nr > 70 && nr < 97); )
    ;
  return zh(e, jp() + (t < 6 && Bn() == 32 && wi() == 32));
}
function vw(e) {
  for (; wi(); )
    switch (nr) {
      case e:
        return ni;
      case 34:
      case 39:
        e !== 34 && e !== 39 && vw(nr);
        break;
      case 40:
        e === 41 && vw(e);
        break;
      case 92:
        wi();
        break;
    }
  return ni;
}
function Jge(e, t) {
  for (; wi() && e + nr !== 57; )
    if (e + nr === 84 && Bn() === 47)
      break;
  return "/*" + zh(t, ni - 1) + "*" + vv(e === 47 ? e : wi());
}
function Qge(e) {
  for (; !sh(Bn()); )
    wi();
  return zh(e, ni);
}
function eme(e) {
  return PG(Up("", null, null, null, [""], e = RG(e), 0, [0], e));
}
function Up(e, t, r, i, n, o, s, a, l) {
  for (var u = 0, c = 0, d = s, h = 0, p = 0, g = 0, m = 1, f = 1, C = 1, w = 0, E = "", b = n, y = o, S = i, x = E; f; )
    switch (g = w, w = wi()) {
      case 40:
        if (g != 108 && Sr(x, d - 1) == 58) {
          mw(x += rt(zp(w), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        x += zp(w);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        x += qge(g);
        break;
      case 92:
        x += Zge(jp() - 1, 7);
        continue;
      case 47:
        switch (Bn()) {
          case 42:
          case 47:
            Ep(tme(Jge(wi(), jp()), t, r), l);
            break;
          default:
            x += "/";
        }
        break;
      case 123 * m:
        a[u++] = Dn(x) * C;
      case 125 * m:
      case 59:
      case 0:
        switch (w) {
          case 0:
          case 125:
            f = 0;
          case 59 + c:
            C == -1 && (x = rt(x, /\f/g, "")), p > 0 && Dn(x) - d && Ep(p > 32 ? hP(x + ";", i, r, d - 1) : hP(rt(x, " ", "") + ";", i, r, d - 2), l);
            break;
          case 59:
            x += ";";
          default:
            if (Ep(S = dP(x, t, r, u, c, n, a, E, b = [], y = [], d), o), w === 123)
              if (c === 0)
                Up(x, t, S, S, b, o, d, a, y);
              else
                switch (h === 99 && Sr(x, 3) === 110 ? 100 : h) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Up(e, S, S, i && Ep(dP(e, S, S, 0, 0, n, a, E, n, b = [], d), y), n, y, d, a, i ? b : y);
                    break;
                  default:
                    Up(x, S, S, S, [""], y, 0, a, y);
                }
        }
        u = c = p = 0, m = C = 1, E = x = "", d = s;
        break;
      case 58:
        d = 1 + Dn(x), p = g;
      default:
        if (m < 1) {
          if (w == 123)
            --m;
          else if (w == 125 && m++ == 0 && Kge() == 125)
            continue;
        }
        switch (x += vv(w), w * m) {
          case 38:
            C = c > 0 ? 1 : (x += "\f", -1);
            break;
          case 44:
            a[u++] = (Dn(x) - 1) * C, C = 1;
            break;
          case 64:
            Bn() === 45 && (x += zp(wi())), h = Bn(), c = d = Dn(E = x += Qge(jp())), w++;
            break;
          case 45:
            g === 45 && Dn(x) == 2 && (m = 0);
        }
    }
  return o;
}
function dP(e, t, r, i, n, o, s, a, l, u, c) {
  for (var d = n - 1, h = n === 0 ? o : [""], p = dx(h), g = 0, m = 0, f = 0; g < i; ++g)
    for (var C = 0, w = oh(e, d + 1, d = $ge(m = s[g])), E = e; C < p; ++C)
      (E = DG(m > 0 ? h[C] + " " + w : rt(w, /&\f/g, h[C]))) && (l[f++] = E);
  return yv(e, t, r, n === 0 ? ux : a, l, u, c);
}
function tme(e, t, r) {
  return yv(e, t, r, xG, vv(Xge()), oh(e, 2, -2), 0);
}
function hP(e, t, r, i) {
  return yv(e, t, r, cx, oh(e, 0, i), oh(e, i + 1, -1), i);
}
function wl(e, t) {
  for (var r = "", i = dx(e), n = 0; n < i; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function rme(e, t, r, i) {
  switch (e.type) {
    case Wge:
      if (e.children.length) break;
    case Bge:
    case cx:
      return e.return = e.return || e.value;
    case xG:
      return "";
    case AG:
      return e.return = e.value + "{" + wl(e.children, i) + "}";
    case ux:
      e.value = e.props.join(",");
  }
  return Dn(r = wl(e.children, i)) ? e.return = e.value + "{" + r + "}" : "";
}
function ime(e) {
  var t = dx(e);
  return function(r, i, n, o) {
    for (var s = "", a = 0; a < t; a++)
      s += e[a](r, i, n, o) || "";
    return s;
  };
}
function nme(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function ome(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] === void 0 && (t[r] = e(r)), t[r];
  };
}
var sme = function(t, r, i) {
  for (var n = 0, o = 0; n = o, o = Bn(), n === 38 && o === 12 && (r[i] = 1), !sh(o); )
    wi();
  return zh(t, ni);
}, ame = function(t, r) {
  var i = -1, n = 44;
  do
    switch (sh(n)) {
      case 0:
        n === 38 && Bn() === 12 && (r[i] = 1), t[i] += sme(ni - 1, r, i);
        break;
      case 2:
        t[i] += zp(n);
        break;
      case 4:
        if (n === 44) {
          t[++i] = Bn() === 58 ? "&\f" : "", r[i] = t[i].length;
          break;
        }
      default:
        t[i] += vv(n);
    }
  while (n = wi());
  return t;
}, lme = function(t, r) {
  return PG(ame(RG(t), r));
}, pP = /* @__PURE__ */ new WeakMap(), ume = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var r = t.value, i = t.parent, n = t.column === i.column && t.line === i.line; i.type !== "rule"; )
      if (i = i.parent, !i) return;
    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !pP.get(i)) && !n) {
      pP.set(t, !0);
      for (var o = [], s = lme(r, o), a = i.props, l = 0, u = 0; l < s.length; l++)
        for (var c = 0; c < a.length; c++, u++)
          t.props[u] = o[l] ? s[l].replace(/&\f/g, a[c]) : a[c] + " " + s[l];
    }
  }
}, cme = function(t) {
  if (t.type === "decl") {
    var r = t.value;
    // charcode for l
    r.charCodeAt(0) === 108 && // charcode for b
    r.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function IG(e, t) {
  switch (zge(e, t)) {
    case 5103:
      return tt + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return tt + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return tt + e + Vg + e + xr + e + e;
    case 6828:
    case 4268:
      return tt + e + xr + e + e;
    case 6165:
      return tt + e + xr + "flex-" + e + e;
    case 5187:
      return tt + e + rt(e, /(\w+).+(:[^]+)/, tt + "box-$1$2" + xr + "flex-$1$2") + e;
    case 5443:
      return tt + e + xr + "flex-item-" + rt(e, /flex-|-self/, "") + e;
    case 4675:
      return tt + e + xr + "flex-line-pack" + rt(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return tt + e + xr + rt(e, "shrink", "negative") + e;
    case 5292:
      return tt + e + xr + rt(e, "basis", "preferred-size") + e;
    case 6060:
      return tt + "box-" + rt(e, "-grow", "") + tt + e + xr + rt(e, "grow", "positive") + e;
    case 4554:
      return tt + rt(e, /([^-])(transform)/g, "$1" + tt + "$2") + e;
    case 6187:
      return rt(rt(rt(e, /(zoom-|grab)/, tt + "$1"), /(image-set)/, tt + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return rt(e, /(image-set\([^]*)/, tt + "$1$`$1");
    case 4968:
      return rt(rt(e, /(.+:)(flex-)?(.*)/, tt + "box-pack:$3" + xr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + tt + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return rt(e, /(.+)-inline(.+)/, tt + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Dn(e) - 1 - t > 6) switch (Sr(e, t + 1)) {
        case 109:
          if (Sr(e, t + 4) !== 45) break;
        case 102:
          return rt(e, /(.+:)(.+)-([^]+)/, "$1" + tt + "$2-$3$1" + Vg + (Sr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~mw(e, "stretch") ? IG(rt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (Sr(e, t + 1) !== 115) break;
    case 6444:
      switch (Sr(e, Dn(e) - 3 - (~mw(e, "!important") && 10))) {
        case 107:
          return rt(e, ":", ":" + tt) + e;
        case 101:
          return rt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + tt + (Sr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + tt + "$2$3$1" + xr + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (Sr(e, t + 11)) {
        case 114:
          return tt + e + xr + rt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return tt + e + xr + rt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return tt + e + xr + rt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return tt + e + xr + e + e;
  }
  return e;
}
var dme = function(t, r, i, n) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case cx:
      t.return = IG(t.value, t.length);
      break;
    case AG:
      return wl([wc(t, {
        value: rt(t.value, "@", "@" + tt)
      })], n);
    case ux:
      if (t.length) return Yge(t.props, function(o) {
        switch (Uge(o, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return wl([wc(t, {
              props: [rt(o, /:(read-\w+)/, ":" + Vg + "$1")]
            })], n);
          case "::placeholder":
            return wl([wc(t, {
              props: [rt(o, /:(plac\w+)/, ":" + tt + "input-$1")]
            }), wc(t, {
              props: [rt(o, /:(plac\w+)/, ":" + Vg + "$1")]
            }), wc(t, {
              props: [rt(o, /:(plac\w+)/, xr + "input-$1")]
            })], n);
        }
        return "";
      });
  }
}, hme = [dme], pme = function(t) {
  var r = t.key;
  if (r === "css") {
    var i = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(i, function(m) {
      var f = m.getAttribute("data-emotion");
      f.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""));
    });
  }
  var n = t.stylisPlugins || hme, o = {}, s, a = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
    function(m) {
      for (var f = m.getAttribute("data-emotion").split(" "), C = 1; C < f.length; C++)
        o[f[C]] = !0;
      a.push(m);
    }
  );
  var l, u = [ume, cme];
  {
    var c, d = [rme, nme(function(m) {
      c.insert(m);
    })], h = ime(u.concat(n, d)), p = function(f) {
      return wl(eme(f), h);
    };
    l = function(f, C, w, E) {
      c = w, p(f ? f + "{" + C.styles + "}" : C.styles), E && (g.inserted[C.name] = !0);
    };
  }
  var g = {
    key: r,
    sheet: new Hge({
      key: r,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return g.sheet.hydrate(a), g;
}, OG = yS, fme = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, gme = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, MG = {};
MG[OG.ForwardRef] = fme;
MG[OG.Memo] = gme;
var mme = !0;
function vme(e, t, r) {
  var i = "";
  return r.split(" ").forEach(function(n) {
    e[n] !== void 0 ? t.push(e[n] + ";") : n && (i += n + " ");
  }), i;
}
var FG = function(t, r, i) {
  var n = t.key + "-" + r.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (i === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  mme === !1) && t.registered[n] === void 0 && (t.registered[n] = r.styles);
}, Cme = function(t, r, i) {
  FG(t, r, i);
  var n = t.key + "-" + r.name;
  if (t.inserted[r.name] === void 0) {
    var o = r;
    do
      t.insert(r === o ? "." + n : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function yme(e) {
  for (var t = 0, r, i = 0, n = e.length; n >= 4; ++i, n -= 4)
    r = e.charCodeAt(i) & 255 | (e.charCodeAt(++i) & 255) << 8 | (e.charCodeAt(++i) & 255) << 16 | (e.charCodeAt(++i) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (n) {
    case 3:
      t ^= (e.charCodeAt(i + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(i + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(i) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var bme = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, wme = /[A-Z]|^ms/g, Sme = /_EMO_([^_]+?)_([^]*?)_EMO_/g, _G = function(t) {
  return t.charCodeAt(1) === 45;
}, fP = function(t) {
  return t != null && typeof t != "boolean";
}, HC = /* @__PURE__ */ ome(function(e) {
  return _G(e) ? e : e.replace(wme, "-$&").toLowerCase();
}), gP = function(t, r) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof r == "string")
        return r.replace(Sme, function(i, n, o) {
          return Tn = {
            name: n,
            styles: o,
            next: Tn
          }, n;
        });
  }
  return bme[t] !== 1 && !_G(t) && typeof r == "number" && r !== 0 ? r + "px" : r;
};
function ah(e, t, r) {
  if (r == null)
    return "";
  var i = r;
  if (i.__emotion_styles !== void 0)
    return i;
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      var n = r;
      if (n.anim === 1)
        return Tn = {
          name: n.name,
          styles: n.styles,
          next: Tn
        }, n.name;
      var o = r;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Tn = {
              name: s.name,
              styles: s.styles,
              next: Tn
            }, s = s.next;
        var a = o.styles + ";";
        return a;
      }
      return Eme(e, t, r);
    }
    case "function": {
      if (e !== void 0) {
        var l = Tn, u = r(e);
        return Tn = l, ah(e, t, u);
      }
      break;
    }
  }
  var c = r;
  return c;
}
function Eme(e, t, r) {
  var i = "";
  if (Array.isArray(r))
    for (var n = 0; n < r.length; n++)
      i += ah(e, t, r[n]) + ";";
  else
    for (var o in r) {
      var s = r[o];
      if (typeof s != "object") {
        var a = s;
        fP(a) && (i += HC(o) + ":" + gP(o, a) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && t == null)
        for (var l = 0; l < s.length; l++)
          fP(s[l]) && (i += HC(o) + ":" + gP(o, s[l]) + ";");
      else {
        var u = ah(e, t, s);
        switch (o) {
          case "animation":
          case "animationName": {
            i += HC(o) + ":" + u + ";";
            break;
          }
          default:
            i += o + "{" + u + "}";
        }
      }
    }
  return i;
}
var mP = /label:\s*([^\s;{]+)\s*(;|$)/g, Tn;
function NG(e, t, r) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var i = !0, n = "";
  Tn = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    i = !1, n += ah(r, t, o);
  else {
    var s = o;
    n += s[0];
  }
  for (var a = 1; a < e.length; a++)
    if (n += ah(r, t, e[a]), i) {
      var l = o;
      n += l[a];
    }
  mP.lastIndex = 0;
  for (var u = "", c; (c = mP.exec(n)) !== null; )
    u += "-" + c[1];
  var d = yme(n) + u;
  return {
    name: d,
    styles: n,
    next: Tn
  };
}
var xme = function(t) {
  return t();
}, Ame = Y.useInsertionEffect ? Y.useInsertionEffect : !1, Dme = Ame || xme, LG = /* @__PURE__ */ Y.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ pme({
    key: "css"
  }) : null
);
LG.Provider;
var Tme = function(t) {
  return /* @__PURE__ */ ns(function(r, i) {
    var n = bt(LG);
    return t(r, n, i);
  });
}, Rme = /* @__PURE__ */ Y.createContext({}), hx = {}.hasOwnProperty, Cw = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Pme = function(t, r) {
  var i = {};
  for (var n in r)
    hx.call(r, n) && (i[n] = r[n]);
  return i[Cw] = t, i;
}, Ime = function(t) {
  var r = t.cache, i = t.serialized, n = t.isStringTag;
  return FG(r, i, n), Dme(function() {
    return Cme(r, i, n);
  }), null;
}, Ome = /* @__PURE__ */ Tme(function(e, t, r) {
  var i = e.css;
  typeof i == "string" && t.registered[i] !== void 0 && (i = t.registered[i]);
  var n = e[Cw], o = [i], s = "";
  typeof e.className == "string" ? s = vme(t.registered, o, e.className) : e.className != null && (s = e.className + " ");
  var a = NG(o, void 0, Y.useContext(Rme));
  s += t.key + "-" + a.name;
  var l = {};
  for (var u in e)
    hx.call(e, u) && u !== "css" && u !== Cw && (l[u] = e[u]);
  return l.className = s, r && (l.ref = r), /* @__PURE__ */ Y.createElement(Y.Fragment, null, /* @__PURE__ */ Y.createElement(Ime, {
    cache: t,
    serialized: a,
    isStringTag: typeof n == "string"
  }), /* @__PURE__ */ Y.createElement(n, l));
}), Mme = Ome, De = function(t, r) {
  var i = arguments;
  if (r == null || !hx.call(r, "css"))
    return Y.createElement.apply(void 0, i);
  var n = i.length, o = new Array(n);
  o[0] = Mme, o[1] = Pme(t, r);
  for (var s = 2; s < n; s++)
    o[s] = i[s];
  return Y.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(De || (De = {}));
function px() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return NG(t);
}
function Fme() {
  var e = px.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
function _me(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var yw = Vi, Nme = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], Hg = function() {
};
function Lme(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Gme(e, t) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), n = 2; n < r; n++)
    i[n - 2] = arguments[n];
  var o = [].concat(i);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && o.push("".concat(Lme(e, s)));
  return o.filter(function(a) {
    return a;
  }).map(function(a) {
    return String(a).trim();
  }).join(" ");
}
var vP = function(t) {
  return Ume(t) ? t.filter(Boolean) : Ea(t) === "object" && t !== null ? [t] : [];
}, GG = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var r = Lo(t, Nme);
  return Pe({}, r);
}, Bt = function(t, r, i) {
  var n = t.cx, o = t.getStyles, s = t.getClassNames, a = t.className;
  return {
    css: o(r, t),
    className: n(i ?? {}, s(r, t), a)
  };
};
function bv(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function kme(e) {
  return bv(e) ? window.innerHeight : e.clientHeight;
}
function kG(e) {
  return bv(e) ? window.pageYOffset : e.scrollTop;
}
function Bg(e, t) {
  if (bv(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Vme(e) {
  var t = getComputedStyle(e), r = t.position === "absolute", i = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var n = e; n = n.parentElement; )
    if (t = getComputedStyle(n), !(r && t.position === "static") && i.test(t.overflow + t.overflowY + t.overflowX))
      return n;
  return document.documentElement;
}
function Hme(e, t, r, i) {
  return r * ((e = e / i - 1) * e * e + 1) + t;
}
function xp(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Hg, n = kG(e), o = t - n, s = 10, a = 0;
  function l() {
    a += s;
    var u = Hme(a, n, o, r);
    Bg(e, u), a < r ? window.requestAnimationFrame(l) : i(e);
  }
  l();
}
function CP(e, t) {
  var r = e.getBoundingClientRect(), i = t.getBoundingClientRect(), n = t.offsetHeight / 3;
  i.bottom + n > r.bottom ? Bg(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + n, e.scrollHeight)) : i.top - n < r.top && Bg(e, Math.max(t.offsetTop - n, 0));
}
function Bme(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function yP() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Wme() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var VG = !1, $me = {
  get passive() {
    return VG = !0;
  }
}, Ap = typeof window < "u" ? window : {};
Ap.addEventListener && Ap.removeEventListener && (Ap.addEventListener("p", Hg, $me), Ap.removeEventListener("p", Hg, !1));
var jme = VG;
function zme(e) {
  return e != null;
}
function Ume(e) {
  return Array.isArray(e);
}
function Dp(e, t, r) {
  return e ? t : r;
}
var Yme = function(t) {
  for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)
    i[n - 1] = arguments[n];
  var o = Object.entries(t).filter(function(s) {
    var a = Co(s, 1), l = a[0];
    return !i.includes(l);
  });
  return o.reduce(function(s, a) {
    var l = Co(a, 2), u = l[0], c = l[1];
    return s[u] = c, s;
  }, {});
}, Xme = ["children", "innerProps"], Kme = ["children", "innerProps"];
function qme(e) {
  var t = e.maxHeight, r = e.menuEl, i = e.minHeight, n = e.placement, o = e.shouldScroll, s = e.isFixedPosition, a = e.controlHeight, l = Vme(r), u = {
    placement: "bottom",
    maxHeight: t
  };
  if (!r || !r.offsetParent) return u;
  var c = l.getBoundingClientRect(), d = c.height, h = r.getBoundingClientRect(), p = h.bottom, g = h.height, m = h.top, f = r.offsetParent.getBoundingClientRect(), C = f.top, w = s ? window.innerHeight : kme(l), E = kG(l), b = parseInt(getComputedStyle(r).marginBottom, 10), y = parseInt(getComputedStyle(r).marginTop, 10), S = C - y, x = w - m, R = S + E, P = d - E - m, O = p - w + E + b, I = E + m - y, M = 160;
  switch (n) {
    case "auto":
    case "bottom":
      if (x >= g)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (P >= g && !s)
        return o && xp(l, O, M), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && P >= i || s && x >= i) {
        o && xp(l, O, M);
        var _ = s ? x - b : P - b;
        return {
          placement: "bottom",
          maxHeight: _
        };
      }
      if (n === "auto" || s) {
        var G = t, F = s ? S : R;
        return F >= i && (G = Math.min(F - b - a, t)), {
          placement: "top",
          maxHeight: G
        };
      }
      if (n === "bottom")
        return o && Bg(l, O), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (S >= g)
        return {
          placement: "top",
          maxHeight: t
        };
      if (R >= g && !s)
        return o && xp(l, I, M), {
          placement: "top",
          maxHeight: t
        };
      if (!s && R >= i || s && S >= i) {
        var N = t;
        return (!s && R >= i || s && S >= i) && (N = s ? S - y : R - y), o && xp(l, I, M), {
          placement: "top",
          maxHeight: N
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(n, '".'));
  }
  return u;
}
function Zme(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var HG = function(t) {
  return t === "auto" ? "bottom" : t;
}, Jme = function(t, r) {
  var i, n = t.placement, o = t.theme, s = o.borderRadius, a = o.spacing, l = o.colors;
  return Pe((i = {
    label: "menu"
  }, Mc(i, Zme(n), "100%"), Mc(i, "position", "absolute"), Mc(i, "width", "100%"), Mc(i, "zIndex", 1), i), r ? {} : {
    backgroundColor: l.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: a.menuGutter,
    marginTop: a.menuGutter
  });
}, BG = /* @__PURE__ */ Cn(null), Qme = function(t) {
  var r = t.children, i = t.minMenuHeight, n = t.maxMenuHeight, o = t.menuPlacement, s = t.menuPosition, a = t.menuShouldScrollIntoView, l = t.theme, u = bt(BG) || {}, c = u.setPortalPlacement, d = re(null), h = ee(n), p = Co(h, 2), g = p[0], m = p[1], f = ee(null), C = Co(f, 2), w = C[0], E = C[1], b = l.spacing.controlHeight;
  return yw(function() {
    var y = d.current;
    if (y) {
      var S = s === "fixed", x = a && !S, R = qme({
        maxHeight: n,
        menuEl: y,
        minHeight: i,
        placement: o,
        shouldScroll: x,
        isFixedPosition: S,
        controlHeight: b
      });
      m(R.maxHeight), E(R.placement), c == null || c(R.placement);
    }
  }, [n, o, s, a, i, c, b]), r({
    ref: d,
    placerProps: Pe(Pe({}, t), {}, {
      placement: w || HG(o),
      maxHeight: g
    })
  });
}, eve = function(t) {
  var r = t.children, i = t.innerRef, n = t.innerProps;
  return De("div", Fe({}, Bt(t, "menu", {
    menu: !0
  }), {
    ref: i
  }, n), r);
}, tve = eve, rve = function(t, r) {
  var i = t.maxHeight, n = t.theme.spacing.baseUnit;
  return Pe({
    maxHeight: i,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, r ? {} : {
    paddingBottom: n,
    paddingTop: n
  });
}, ive = function(t) {
  var r = t.children, i = t.innerProps, n = t.innerRef, o = t.isMulti;
  return De("div", Fe({}, Bt(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": o
  }), {
    ref: n
  }, i), r);
}, WG = function(t, r) {
  var i = t.theme, n = i.spacing.baseUnit, o = i.colors;
  return Pe({
    textAlign: "center"
  }, r ? {} : {
    color: o.neutral40,
    padding: "".concat(n * 2, "px ").concat(n * 3, "px")
  });
}, nve = WG, ove = WG, sve = function(t) {
  var r = t.children, i = r === void 0 ? "No options" : r, n = t.innerProps, o = Lo(t, Xme);
  return De("div", Fe({}, Bt(Pe(Pe({}, o), {}, {
    children: i,
    innerProps: n
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), n), i);
}, ave = function(t) {
  var r = t.children, i = r === void 0 ? "Loading..." : r, n = t.innerProps, o = Lo(t, Kme);
  return De("div", Fe({}, Bt(Pe(Pe({}, o), {}, {
    children: i,
    innerProps: n
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), n), i);
}, lve = function(t) {
  var r = t.rect, i = t.offset, n = t.position;
  return {
    left: r.left,
    position: n,
    top: i,
    width: r.width,
    zIndex: 1
  };
}, uve = function(t) {
  var r = t.appendTo, i = t.children, n = t.controlElement, o = t.innerProps, s = t.menuPlacement, a = t.menuPosition, l = re(null), u = re(null), c = ee(HG(s)), d = Co(c, 2), h = d[0], p = d[1], g = Ee(function() {
    return {
      setPortalPlacement: p
    };
  }, []), m = ee(null), f = Co(m, 2), C = f[0], w = f[1], E = fe(function() {
    if (n) {
      var x = Bme(n), R = a === "fixed" ? 0 : window.pageYOffset, P = x[h] + R;
      (P !== (C == null ? void 0 : C.offset) || x.left !== (C == null ? void 0 : C.rect.left) || x.width !== (C == null ? void 0 : C.rect.width)) && w({
        offset: P,
        rect: x
      });
    }
  }, [n, a, h, C == null ? void 0 : C.offset, C == null ? void 0 : C.rect.left, C == null ? void 0 : C.rect.width]);
  yw(function() {
    E();
  }, [E]);
  var b = fe(function() {
    typeof u.current == "function" && (u.current(), u.current = null), n && l.current && (u.current = cG(n, l.current, E, {
      elementResize: "ResizeObserver" in window
    }));
  }, [n, E]);
  yw(function() {
    b();
  }, [b]);
  var y = fe(function(x) {
    l.current = x, b();
  }, [b]);
  if (!r && a !== "fixed" || !C) return null;
  var S = De("div", Fe({
    ref: y
  }, Bt(Pe(Pe({}, t), {}, {
    offset: C.offset,
    position: a,
    rect: C.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), o), i);
  return De(BG.Provider, {
    value: g
  }, r ? /* @__PURE__ */ xa(S, r) : S);
}, cve = function(t) {
  var r = t.isDisabled, i = t.isRtl;
  return {
    label: "container",
    direction: i ? "rtl" : void 0,
    pointerEvents: r ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, dve = function(t) {
  var r = t.children, i = t.innerProps, n = t.isDisabled, o = t.isRtl;
  return De("div", Fe({}, Bt(t, "container", {
    "--is-disabled": n,
    "--is-rtl": o
  }), i), r);
}, hve = function(t, r) {
  var i = t.theme.spacing, n = t.isMulti, o = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return Pe({
    alignItems: "center",
    display: n && o && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, r ? {} : {
    padding: "".concat(i.baseUnit / 2, "px ").concat(i.baseUnit * 2, "px")
  });
}, pve = function(t) {
  var r = t.children, i = t.innerProps, n = t.isMulti, o = t.hasValue;
  return De("div", Fe({}, Bt(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": n,
    "value-container--has-value": o
  }), i), r);
}, fve = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, gve = function(t) {
  var r = t.children, i = t.innerProps;
  return De("div", Fe({}, Bt(t, "indicatorsContainer", {
    indicators: !0
  }), i), r);
}, bP, mve = ["size"], vve = ["innerProps", "isRtl", "size"];
function Cve() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var yve = process.env.NODE_ENV === "production" ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */",
  toString: Cve
}, $G = function(t) {
  var r = t.size, i = Lo(t, mve);
  return De("svg", Fe({
    height: r,
    width: r,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: yve
  }, i));
}, fx = function(t) {
  return De($G, Fe({
    size: 20
  }, t), De("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, jG = function(t) {
  return De($G, Fe({
    size: 20
  }, t), De("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, zG = function(t, r) {
  var i = t.isFocused, n = t.theme, o = n.spacing.baseUnit, s = n.colors;
  return Pe({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, r ? {} : {
    color: i ? s.neutral60 : s.neutral20,
    padding: o * 2,
    ":hover": {
      color: i ? s.neutral80 : s.neutral40
    }
  });
}, bve = zG, wve = function(t) {
  var r = t.children, i = t.innerProps;
  return De("div", Fe({}, Bt(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), i), r || De(jG, null));
}, Sve = zG, Eve = function(t) {
  var r = t.children, i = t.innerProps;
  return De("div", Fe({}, Bt(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), i), r || De(fx, null));
}, xve = function(t, r) {
  var i = t.isDisabled, n = t.theme, o = n.spacing.baseUnit, s = n.colors;
  return Pe({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, r ? {} : {
    backgroundColor: i ? s.neutral10 : s.neutral20,
    marginBottom: o * 2,
    marginTop: o * 2
  });
}, Ave = function(t) {
  var r = t.innerProps;
  return De("span", Fe({}, r, Bt(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, Dve = Fme(bP || (bP = _me([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Tve = function(t, r) {
  var i = t.isFocused, n = t.size, o = t.theme, s = o.colors, a = o.spacing.baseUnit;
  return Pe({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: n,
    lineHeight: 1,
    marginRight: n,
    textAlign: "center",
    verticalAlign: "middle"
  }, r ? {} : {
    color: i ? s.neutral60 : s.neutral20,
    padding: a * 2
  });
}, BC = function(t) {
  var r = t.delay, i = t.offset;
  return De("span", {
    css: /* @__PURE__ */ px({
      animation: "".concat(Dve, " 1s ease-in-out ").concat(r, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: i ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, process.env.NODE_ENV === "production" ? "" : ";label:LoadingDot;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */")
  });
}, Rve = function(t) {
  var r = t.innerProps, i = t.isRtl, n = t.size, o = n === void 0 ? 4 : n, s = Lo(t, vve);
  return De("div", Fe({}, Bt(Pe(Pe({}, s), {}, {
    innerProps: r,
    isRtl: i,
    size: o
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), r), De(BC, {
    delay: 0,
    offset: i
  }), De(BC, {
    delay: 160,
    offset: !0
  }), De(BC, {
    delay: 320,
    offset: !i
  }));
}, Pve = function(t, r) {
  var i = t.isDisabled, n = t.isFocused, o = t.theme, s = o.colors, a = o.borderRadius, l = o.spacing;
  return Pe({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: l.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, r ? {} : {
    backgroundColor: i ? s.neutral5 : s.neutral0,
    borderColor: i ? s.neutral10 : n ? s.primary : s.neutral20,
    borderRadius: a,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: n ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: n ? s.primary : s.neutral30
    }
  });
}, Ive = function(t) {
  var r = t.children, i = t.isDisabled, n = t.isFocused, o = t.innerRef, s = t.innerProps, a = t.menuIsOpen;
  return De("div", Fe({
    ref: o
  }, Bt(t, "control", {
    control: !0,
    "control--is-disabled": i,
    "control--is-focused": n,
    "control--menu-is-open": a
  }), s, {
    "aria-disabled": i || void 0
  }), r);
}, Ove = Ive, Mve = ["data"], Fve = function(t, r) {
  var i = t.theme.spacing;
  return r ? {} : {
    paddingBottom: i.baseUnit * 2,
    paddingTop: i.baseUnit * 2
  };
}, _ve = function(t) {
  var r = t.children, i = t.cx, n = t.getStyles, o = t.getClassNames, s = t.Heading, a = t.headingProps, l = t.innerProps, u = t.label, c = t.theme, d = t.selectProps;
  return De("div", Fe({}, Bt(t, "group", {
    group: !0
  }), l), De(s, Fe({}, a, {
    selectProps: d,
    theme: c,
    getStyles: n,
    getClassNames: o,
    cx: i
  }), u), De("div", null, r));
}, Nve = function(t, r) {
  var i = t.theme, n = i.colors, o = i.spacing;
  return Pe({
    label: "group",
    cursor: "default",
    display: "block"
  }, r ? {} : {
    color: n.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: o.baseUnit * 3,
    paddingRight: o.baseUnit * 3,
    textTransform: "uppercase"
  });
}, Lve = function(t) {
  var r = GG(t);
  r.data;
  var i = Lo(r, Mve);
  return De("div", Fe({}, Bt(t, "groupHeading", {
    "group-heading": !0
  }), i));
}, Gve = _ve, kve = ["innerRef", "isDisabled", "isHidden", "inputClassName"], Vve = function(t, r) {
  var i = t.isDisabled, n = t.value, o = t.theme, s = o.spacing, a = o.colors;
  return Pe(Pe({
    visibility: i ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: n ? "translateZ(0)" : ""
  }, Hve), r ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: a.neutral80
  });
}, UG = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, Hve = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Pe({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, UG)
}, Bve = function(t) {
  return Pe({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, UG);
}, Wve = function(t) {
  var r = t.cx, i = t.value, n = GG(t), o = n.innerRef, s = n.isDisabled, a = n.isHidden, l = n.inputClassName, u = Lo(n, kve);
  return De("div", Fe({}, Bt(t, "input", {
    "input-container": !0
  }), {
    "data-value": i || ""
  }), De("input", Fe({
    className: r({
      input: !0
    }, l),
    ref: o,
    style: Bve(a),
    disabled: s
  }, u)));
}, $ve = Wve, jve = function(t, r) {
  var i = t.theme, n = i.spacing, o = i.borderRadius, s = i.colors;
  return Pe({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, r ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: o / 2,
    margin: n.baseUnit / 2
  });
}, zve = function(t, r) {
  var i = t.theme, n = i.borderRadius, o = i.colors, s = t.cropWithEllipsis;
  return Pe({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, r ? {} : {
    borderRadius: n / 2,
    color: o.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, Uve = function(t, r) {
  var i = t.theme, n = i.spacing, o = i.borderRadius, s = i.colors, a = t.isFocused;
  return Pe({
    alignItems: "center",
    display: "flex"
  }, r ? {} : {
    borderRadius: o / 2,
    backgroundColor: a ? s.dangerLight : void 0,
    paddingLeft: n.baseUnit,
    paddingRight: n.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, YG = function(t) {
  var r = t.children, i = t.innerProps;
  return De("div", i, r);
}, Yve = YG, Xve = YG;
function Kve(e) {
  var t = e.children, r = e.innerProps;
  return De("div", Fe({
    role: "button"
  }, r), t || De(fx, {
    size: 14
  }));
}
var qve = function(t) {
  var r = t.children, i = t.components, n = t.data, o = t.innerProps, s = t.isDisabled, a = t.removeProps, l = t.selectProps, u = i.Container, c = i.Label, d = i.Remove;
  return De(u, {
    data: n,
    innerProps: Pe(Pe({}, Bt(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), o),
    selectProps: l
  }, De(c, {
    data: n,
    innerProps: Pe({}, Bt(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: l
  }, r), De(d, {
    data: n,
    innerProps: Pe(Pe({}, Bt(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(r || "option")
    }, a),
    selectProps: l
  }));
}, Zve = qve, Jve = function(t, r) {
  var i = t.isDisabled, n = t.isFocused, o = t.isSelected, s = t.theme, a = s.spacing, l = s.colors;
  return Pe({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, r ? {} : {
    backgroundColor: o ? l.primary : n ? l.primary25 : "transparent",
    color: i ? l.neutral20 : o ? l.neutral0 : "inherit",
    padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: i ? void 0 : o ? l.primary : l.primary50
    }
  });
}, Qve = function(t) {
  var r = t.children, i = t.isDisabled, n = t.isFocused, o = t.isSelected, s = t.innerRef, a = t.innerProps;
  return De("div", Fe({}, Bt(t, "option", {
    option: !0,
    "option--is-disabled": i,
    "option--is-focused": n,
    "option--is-selected": o
  }), {
    ref: s,
    "aria-disabled": i
  }, a), r);
}, eCe = Qve, tCe = function(t, r) {
  var i = t.theme, n = i.spacing, o = i.colors;
  return Pe({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, r ? {} : {
    color: o.neutral50,
    marginLeft: n.baseUnit / 2,
    marginRight: n.baseUnit / 2
  });
}, rCe = function(t) {
  var r = t.children, i = t.innerProps;
  return De("div", Fe({}, Bt(t, "placeholder", {
    placeholder: !0
  }), i), r);
}, iCe = rCe, nCe = function(t, r) {
  var i = t.isDisabled, n = t.theme, o = n.spacing, s = n.colors;
  return Pe({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, r ? {} : {
    color: i ? s.neutral40 : s.neutral80,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, oCe = function(t) {
  var r = t.children, i = t.isDisabled, n = t.innerProps;
  return De("div", Fe({}, Bt(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": i
  }), n), r);
}, sCe = oCe, aCe = {
  ClearIndicator: Eve,
  Control: Ove,
  DropdownIndicator: wve,
  DownChevron: jG,
  CrossIcon: fx,
  Group: Gve,
  GroupHeading: Lve,
  IndicatorsContainer: gve,
  IndicatorSeparator: Ave,
  Input: $ve,
  LoadingIndicator: Rve,
  Menu: tve,
  MenuList: ive,
  MenuPortal: uve,
  LoadingMessage: ave,
  NoOptionsMessage: sve,
  MultiValue: Zve,
  MultiValueContainer: Yve,
  MultiValueLabel: Xve,
  MultiValueRemove: Kve,
  Option: eCe,
  Placeholder: iCe,
  SelectContainer: dve,
  SingleValue: sCe,
  ValueContainer: pve
}, lCe = function(t) {
  return Pe(Pe({}, aCe), t.components);
}, wP = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function uCe(e, t) {
  return !!(e === t || wP(e) && wP(t));
}
function cCe(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var r = 0; r < e.length; r++)
    if (!uCe(e[r], t[r]))
      return !1;
  return !0;
}
function dCe(e, t) {
  t === void 0 && (t = cCe);
  var r = null;
  function i() {
    for (var n = [], o = 0; o < arguments.length; o++)
      n[o] = arguments[o];
    if (r && r.lastThis === this && t(n, r.lastArgs))
      return r.lastResult;
    var s = e.apply(this, n);
    return r = {
      lastResult: s,
      lastArgs: n,
      lastThis: this
    }, s;
  }
  return i.clear = function() {
    r = null;
  }, i;
}
function hCe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var pCe = process.env.NODE_ENV === "production" ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IEpTWCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: hCe
}, fCe = function(t) {
  return De("span", Fe({
    css: pCe
  }, t));
}, SP = fCe, gCe = {
  guidance: function(t) {
    var r = t.isSearchable, i = t.isMulti, n = t.tabSelectsValue, o = t.context, s = t.isInitialFocus;
    switch (o) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(n ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(r ? ",type to refine list" : "", ", press Down to open the menu, ").concat(i ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var r = t.action, i = t.label, n = i === void 0 ? "" : i, o = t.labels, s = t.isDisabled;
    switch (r) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(n, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(o.length > 1 ? "s" : "", " ").concat(o.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(n, " is disabled. Select another option.") : "option ".concat(n, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var r = t.context, i = t.focused, n = t.options, o = t.label, s = o === void 0 ? "" : o, a = t.selectValue, l = t.isDisabled, u = t.isSelected, c = t.isAppleDevice, d = function(m, f) {
      return m && m.length ? "".concat(m.indexOf(f) + 1, " of ").concat(m.length) : "";
    };
    if (r === "value" && a)
      return "value ".concat(s, " focused, ").concat(d(a, i), ".");
    if (r === "menu" && c) {
      var h = l ? " disabled" : "", p = "".concat(u ? " selected" : "").concat(h);
      return "".concat(s).concat(p, ", ").concat(d(n, i), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var r = t.inputValue, i = t.resultsMessage;
    return "".concat(i).concat(r ? " for search term " + r : "", ".");
  }
}, mCe = function(t) {
  var r = t.ariaSelection, i = t.focusedOption, n = t.focusedValue, o = t.focusableOptions, s = t.isFocused, a = t.selectValue, l = t.selectProps, u = t.id, c = t.isAppleDevice, d = l.ariaLiveMessages, h = l.getOptionLabel, p = l.inputValue, g = l.isMulti, m = l.isOptionDisabled, f = l.isSearchable, C = l.menuIsOpen, w = l.options, E = l.screenReaderStatus, b = l.tabSelectsValue, y = l.isLoading, S = l["aria-label"], x = l["aria-live"], R = Ee(function() {
    return Pe(Pe({}, gCe), d || {});
  }, [d]), P = Ee(function() {
    var F = "";
    if (r && R.onChange) {
      var N = r.option, V = r.options, B = r.removedValue, $ = r.removedValues, L = r.value, z = function(he) {
        return Array.isArray(he) ? null : he;
      }, j = B || N || z(L), U = j ? h(j) : "", oe = V || $ || void 0, ie = oe ? oe.map(h) : [], le = Pe({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: j && m(j, a),
        label: U,
        labels: ie
      }, r);
      F = R.onChange(le);
    }
    return F;
  }, [r, R, m, a, h]), O = Ee(function() {
    var F = "", N = i || n, V = !!(i && a && a.includes(i));
    if (N && R.onFocus) {
      var B = {
        focused: N,
        label: h(N),
        isDisabled: m(N, a),
        isSelected: V,
        options: o,
        context: N === i ? "menu" : "value",
        selectValue: a,
        isAppleDevice: c
      };
      F = R.onFocus(B);
    }
    return F;
  }, [i, n, h, m, R, o, a, c]), I = Ee(function() {
    var F = "";
    if (C && w.length && !y && R.onFilter) {
      var N = E({
        count: o.length
      });
      F = R.onFilter({
        inputValue: p,
        resultsMessage: N
      });
    }
    return F;
  }, [o, p, C, R, w, E, y]), M = (r == null ? void 0 : r.action) === "initial-input-focus", _ = Ee(function() {
    var F = "";
    if (R.guidance) {
      var N = n ? "value" : C ? "menu" : "input";
      F = R.guidance({
        "aria-label": S,
        context: N,
        isDisabled: i && m(i, a),
        isMulti: g,
        isSearchable: f,
        tabSelectsValue: b,
        isInitialFocus: M
      });
    }
    return F;
  }, [S, i, n, g, m, f, C, R, a, b, M]), G = De(KC, null, De("span", {
    id: "aria-selection"
  }, P), De("span", {
    id: "aria-focused"
  }, O), De("span", {
    id: "aria-results"
  }, I), De("span", {
    id: "aria-guidance"
  }, _));
  return De(KC, null, De(SP, {
    id: u
  }, M && G), De(SP, {
    "aria-live": x,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !M && G));
}, vCe = mCe, bw = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], CCe = new RegExp("[" + bw.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), XG = {};
for (var WC = 0; WC < bw.length; WC++)
  for (var $C = bw[WC], jC = 0; jC < $C.letters.length; jC++)
    XG[$C.letters[jC]] = $C.base;
var KG = function(t) {
  return t.replace(CCe, function(r) {
    return XG[r];
  });
}, yCe = dCe(KG), EP = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, bCe = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, wCe = function(t) {
  return function(r, i) {
    if (r.data.__isNew__) return !0;
    var n = Pe({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: bCe,
      trim: !0,
      matchFrom: "any"
    }, t), o = n.ignoreCase, s = n.ignoreAccents, a = n.stringify, l = n.trim, u = n.matchFrom, c = l ? EP(i) : i, d = l ? EP(a(r)) : a(r);
    return o && (c = c.toLowerCase(), d = d.toLowerCase()), s && (c = yCe(c), d = KG(d)), u === "start" ? d.substr(0, c.length) === c : d.indexOf(c) > -1;
  };
}, SCe = ["innerRef"];
function ECe(e) {
  var t = e.innerRef, r = Lo(e, SCe), i = Yme(r, "onExited", "in", "enter", "exit", "appear");
  return De("input", Fe({
    ref: t
  }, i, {
    css: /* @__PURE__ */ px({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, process.env.NODE_ENV === "production" ? "" : ";label:DummyInput;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyByZW1vdmVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGlubmVyUmVmLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbnB1dCddICYge1xuICByZWFkb25seSBpbm5lclJlZjogUmVmPEhUTUxJbnB1dEVsZW1lbnQ+O1xufSkge1xuICAvLyBSZW1vdmUgYW5pbWF0aW9uIHByb3BzIG5vdCBtZWFudCBmb3IgSFRNTCBlbGVtZW50c1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0gcmVtb3ZlUHJvcHMoXG4gICAgcHJvcHMsXG4gICAgJ29uRXhpdGVkJyxcbiAgICAnaW4nLFxuICAgICdlbnRlcicsXG4gICAgJ2V4aXQnLFxuICAgICdhcHBlYXInXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8aW5wdXRcbiAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICB7Li4uZmlsdGVyZWRQcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgdGhpcyBoaWRlcyB0aGUgZmxhc2hpbmcgY3Vyc29yXG4gICAgICAgIGNhcmV0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGdyaWRBcmVhOiAnMSAvIDEgLyAyIC8gMycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSguMDEpJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}
var xCe = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function ACe(e) {
  var t = e.isEnabled, r = e.onBottomArrive, i = e.onBottomLeave, n = e.onTopArrive, o = e.onTopLeave, s = re(!1), a = re(!1), l = re(0), u = re(null), c = fe(function(f, C) {
    if (u.current !== null) {
      var w = u.current, E = w.scrollTop, b = w.scrollHeight, y = w.clientHeight, S = u.current, x = C > 0, R = b - y - E, P = !1;
      R > C && s.current && (i && i(f), s.current = !1), x && a.current && (o && o(f), a.current = !1), x && C > R ? (r && !s.current && r(f), S.scrollTop = b, P = !0, s.current = !0) : !x && -C > E && (n && !a.current && n(f), S.scrollTop = 0, P = !0, a.current = !0), P && xCe(f);
    }
  }, [r, i, n, o]), d = fe(function(f) {
    c(f, f.deltaY);
  }, [c]), h = fe(function(f) {
    l.current = f.changedTouches[0].clientY;
  }, []), p = fe(function(f) {
    var C = l.current - f.changedTouches[0].clientY;
    c(f, C);
  }, [c]), g = fe(function(f) {
    if (f) {
      var C = jme ? {
        passive: !1
      } : !1;
      f.addEventListener("wheel", d, C), f.addEventListener("touchstart", h, C), f.addEventListener("touchmove", p, C);
    }
  }, [p, h, d]), m = fe(function(f) {
    f && (f.removeEventListener("wheel", d, !1), f.removeEventListener("touchstart", h, !1), f.removeEventListener("touchmove", p, !1));
  }, [p, h, d]);
  return gt(function() {
    if (t) {
      var f = u.current;
      return g(f), function() {
        m(f);
      };
    }
  }, [t, g, m]), function(f) {
    u.current = f;
  };
}
var xP = ["boxSizing", "height", "overflow", "paddingRight", "position"], AP = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function DP(e) {
  e.cancelable && e.preventDefault();
}
function TP(e) {
  e.stopPropagation();
}
function RP() {
  var e = this.scrollTop, t = this.scrollHeight, r = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : r === t && (this.scrollTop = e - 1);
}
function PP() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var IP = !!(typeof window < "u" && window.document && window.document.createElement), Sc = 0, Qa = {
  capture: !1,
  passive: !1
};
function DCe(e) {
  var t = e.isEnabled, r = e.accountForScrollbars, i = r === void 0 ? !0 : r, n = re({}), o = re(null), s = fe(function(l) {
    if (IP) {
      var u = document.body, c = u && u.style;
      if (i && xP.forEach(function(g) {
        var m = c && c[g];
        n.current[g] = m;
      }), i && Sc < 1) {
        var d = parseInt(n.current.paddingRight, 10) || 0, h = document.body ? document.body.clientWidth : 0, p = window.innerWidth - h + d || 0;
        Object.keys(AP).forEach(function(g) {
          var m = AP[g];
          c && (c[g] = m);
        }), c && (c.paddingRight = "".concat(p, "px"));
      }
      u && PP() && (u.addEventListener("touchmove", DP, Qa), l && (l.addEventListener("touchstart", RP, Qa), l.addEventListener("touchmove", TP, Qa))), Sc += 1;
    }
  }, [i]), a = fe(function(l) {
    if (IP) {
      var u = document.body, c = u && u.style;
      Sc = Math.max(Sc - 1, 0), i && Sc < 1 && xP.forEach(function(d) {
        var h = n.current[d];
        c && (c[d] = h);
      }), u && PP() && (u.removeEventListener("touchmove", DP, Qa), l && (l.removeEventListener("touchstart", RP, Qa), l.removeEventListener("touchmove", TP, Qa)));
    }
  }, [i]);
  return gt(function() {
    if (t) {
      var l = o.current;
      return s(l), function() {
        a(l);
      };
    }
  }, [t, s, a]), function(l) {
    o.current = l;
  };
}
function TCe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var RCe = function(t) {
  var r = t.target;
  return r.ownerDocument.activeElement && r.ownerDocument.activeElement.blur();
}, PCe = process.env.NODE_ENV === "production" ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: TCe
};
function ICe(e) {
  var t = e.children, r = e.lockEnabled, i = e.captureEnabled, n = i === void 0 ? !0 : i, o = e.onBottomArrive, s = e.onBottomLeave, a = e.onTopArrive, l = e.onTopLeave, u = ACe({
    isEnabled: n,
    onBottomArrive: o,
    onBottomLeave: s,
    onTopArrive: a,
    onTopLeave: l
  }), c = DCe({
    isEnabled: r
  }), d = function(p) {
    u(p), c(p);
  };
  return De(KC, null, r && De("div", {
    onClick: RCe,
    css: PCe
  }), t(d));
}
function OCe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var MCe = process.env.NODE_ENV === "production" ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: OCe
}, FCe = function(t) {
  var r = t.name, i = t.onFocus;
  return De("input", {
    required: !0,
    name: r,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: i,
    css: MCe,
    value: "",
    onChange: function() {
    }
  });
}, _Ce = FCe;
function gx(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function NCe() {
  return gx(/^iPhone/i);
}
function qG() {
  return gx(/^Mac/i);
}
function LCe() {
  return gx(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  qG() && navigator.maxTouchPoints > 1;
}
function GCe() {
  return NCe() || LCe();
}
function kCe() {
  return qG() || GCe();
}
var VCe = function(t) {
  return t.label;
}, HCe = function(t) {
  return t.label;
}, BCe = function(t) {
  return t.value;
}, WCe = function(t) {
  return !!t.isDisabled;
}, $Ce = {
  clearIndicator: Sve,
  container: cve,
  control: Pve,
  dropdownIndicator: bve,
  group: Fve,
  groupHeading: Nve,
  indicatorsContainer: fve,
  indicatorSeparator: xve,
  input: Vve,
  loadingIndicator: Tve,
  loadingMessage: ove,
  menu: Jme,
  menuList: rve,
  menuPortal: lve,
  multiValue: jve,
  multiValueLabel: zve,
  multiValueRemove: Uve,
  noOptionsMessage: nve,
  option: Jve,
  placeholder: tCe,
  singleValue: nCe,
  valueContainer: hve
}, jCe = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, zCe = 4, ZG = 4, UCe = 38, YCe = ZG * 2, XCe = {
  baseUnit: ZG,
  controlHeight: UCe,
  menuGutter: YCe
}, zC = {
  borderRadius: zCe,
  colors: jCe,
  spacing: XCe
}, KCe = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: yP(),
  captureMenuScroll: !yP(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: wCe(),
  formatGroupLabel: VCe,
  getOptionLabel: HCe,
  getOptionValue: BCe,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: WCe,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Wme(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var r = t.count;
    return "".concat(r, " result").concat(r !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function OP(e, t, r, i) {
  var n = e1(e, t, r), o = t1(e, t, r), s = QG(e, t), a = Wg(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: n,
    isSelected: o,
    label: s,
    value: a,
    index: i
  };
}
function Yp(e, t) {
  return e.options.map(function(r, i) {
    if ("options" in r) {
      var n = r.options.map(function(s, a) {
        return OP(e, s, t, a);
      }).filter(function(s) {
        return FP(e, s);
      });
      return n.length > 0 ? {
        type: "group",
        data: r,
        options: n,
        index: i
      } : void 0;
    }
    var o = OP(e, r, t, i);
    return FP(e, o) ? o : void 0;
  }).filter(zme);
}
function JG(e) {
  return e.reduce(function(t, r) {
    return r.type === "group" ? t.push.apply(t, lx(r.options.map(function(i) {
      return i.data;
    }))) : t.push(r.data), t;
  }, []);
}
function MP(e, t) {
  return e.reduce(function(r, i) {
    return i.type === "group" ? r.push.apply(r, lx(i.options.map(function(n) {
      return {
        data: n.data,
        id: "".concat(t, "-").concat(i.index, "-").concat(n.index)
      };
    }))) : r.push({
      data: i.data,
      id: "".concat(t, "-").concat(i.index)
    }), r;
  }, []);
}
function qCe(e, t) {
  return JG(Yp(e, t));
}
function FP(e, t) {
  var r = e.inputValue, i = r === void 0 ? "" : r, n = t.data, o = t.isSelected, s = t.label, a = t.value;
  return (!i1(e) || !o) && r1(e, {
    label: s,
    value: a,
    data: n
  }, i);
}
function ZCe(e, t) {
  var r = e.focusedValue, i = e.selectValue, n = i.indexOf(r);
  if (n > -1) {
    var o = t.indexOf(r);
    if (o > -1)
      return r;
    if (n < t.length)
      return t[n];
  }
  return null;
}
function JCe(e, t) {
  var r = e.focusedOption;
  return r && t.indexOf(r) > -1 ? r : t[0];
}
var UC = function(t, r) {
  var i, n = (i = t.find(function(o) {
    return o.data === r;
  })) === null || i === void 0 ? void 0 : i.id;
  return n || null;
}, QG = function(t, r) {
  return t.getOptionLabel(r);
}, Wg = function(t, r) {
  return t.getOptionValue(r);
};
function e1(e, t, r) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, r) : !1;
}
function t1(e, t, r) {
  if (r.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, r);
  var i = Wg(e, t);
  return r.some(function(n) {
    return Wg(e, n) === i;
  });
}
function r1(e, t, r) {
  return e.filterOption ? e.filterOption(t, r) : !0;
}
var i1 = function(t) {
  var r = t.hideSelectedOptions, i = t.isMulti;
  return r === void 0 ? i : r;
}, QCe = 1, n1 = /* @__PURE__ */ function(e) {
  Mge(r, e);
  var t = _ge(r);
  function r(i) {
    var n;
    if (Ige(this, r), n = t.call(this, i), n.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: !1
    }, n.blockOptionHover = !1, n.isComposing = !1, n.commonProps = void 0, n.initialTouchX = 0, n.initialTouchY = 0, n.openAfterFocus = !1, n.scrollToFocusedOptionOnUpdate = !1, n.userIsDragging = void 0, n.controlRef = null, n.getControlRef = function(l) {
      n.controlRef = l;
    }, n.focusedOptionRef = null, n.getFocusedOptionRef = function(l) {
      n.focusedOptionRef = l;
    }, n.menuListRef = null, n.getMenuListRef = function(l) {
      n.menuListRef = l;
    }, n.inputRef = null, n.getInputRef = function(l) {
      n.inputRef = l;
    }, n.focus = n.focusInput, n.blur = n.blurInput, n.onChange = function(l, u) {
      var c = n.props, d = c.onChange, h = c.name;
      u.name = h, n.ariaOnChange(l, u), d(l, u);
    }, n.setValue = function(l, u, c) {
      var d = n.props, h = d.closeMenuOnSelect, p = d.isMulti, g = d.inputValue;
      n.onInputChange("", {
        action: "set-value",
        prevInputValue: g
      }), h && (n.setState({
        inputIsHiddenAfterUpdate: !p
      }), n.onMenuClose()), n.setState({
        clearFocusValueOnUpdate: !0
      }), n.onChange(l, {
        action: u,
        option: c
      });
    }, n.selectOption = function(l) {
      var u = n.props, c = u.blurInputOnSelect, d = u.isMulti, h = u.name, p = n.state.selectValue, g = d && n.isOptionSelected(l, p), m = n.isOptionDisabled(l, p);
      if (g) {
        var f = n.getOptionValue(l);
        n.setValue(p.filter(function(C) {
          return n.getOptionValue(C) !== f;
        }), "deselect-option", l);
      } else if (!m)
        d ? n.setValue([].concat(lx(p), [l]), "select-option", l) : n.setValue(l, "select-option");
      else {
        n.ariaOnChange(l, {
          action: "select-option",
          option: l,
          name: h
        });
        return;
      }
      c && n.blurInput();
    }, n.removeValue = function(l) {
      var u = n.props.isMulti, c = n.state.selectValue, d = n.getOptionValue(l), h = c.filter(function(g) {
        return n.getOptionValue(g) !== d;
      }), p = Dp(u, h, h[0] || null);
      n.onChange(p, {
        action: "remove-value",
        removedValue: l
      }), n.focusInput();
    }, n.clearValue = function() {
      var l = n.state.selectValue;
      n.onChange(Dp(n.props.isMulti, [], null), {
        action: "clear",
        removedValues: l
      });
    }, n.popValue = function() {
      var l = n.props.isMulti, u = n.state.selectValue, c = u[u.length - 1], d = u.slice(0, u.length - 1), h = Dp(l, d, d[0] || null);
      c && n.onChange(h, {
        action: "pop-value",
        removedValue: c
      });
    }, n.getFocusedOptionId = function(l) {
      return UC(n.state.focusableOptionsWithIds, l);
    }, n.getFocusableOptionsWithIds = function() {
      return MP(Yp(n.props, n.state.selectValue), n.getElementId("option"));
    }, n.getValue = function() {
      return n.state.selectValue;
    }, n.cx = function() {
      for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
        u[c] = arguments[c];
      return Gme.apply(void 0, [n.props.classNamePrefix].concat(u));
    }, n.getOptionLabel = function(l) {
      return QG(n.props, l);
    }, n.getOptionValue = function(l) {
      return Wg(n.props, l);
    }, n.getStyles = function(l, u) {
      var c = n.props.unstyled, d = $Ce[l](u, c);
      d.boxSizing = "border-box";
      var h = n.props.styles[l];
      return h ? h(d, u) : d;
    }, n.getClassNames = function(l, u) {
      var c, d;
      return (c = (d = n.props.classNames)[l]) === null || c === void 0 ? void 0 : c.call(d, u);
    }, n.getElementId = function(l) {
      return "".concat(n.state.instancePrefix, "-").concat(l);
    }, n.getComponents = function() {
      return lCe(n.props);
    }, n.buildCategorizedOptions = function() {
      return Yp(n.props, n.state.selectValue);
    }, n.getCategorizedOptions = function() {
      return n.props.menuIsOpen ? n.buildCategorizedOptions() : [];
    }, n.buildFocusableOptions = function() {
      return JG(n.buildCategorizedOptions());
    }, n.getFocusableOptions = function() {
      return n.props.menuIsOpen ? n.buildFocusableOptions() : [];
    }, n.ariaOnChange = function(l, u) {
      n.setState({
        ariaSelection: Pe({
          value: l
        }, u)
      });
    }, n.onMenuMouseDown = function(l) {
      l.button === 0 && (l.stopPropagation(), l.preventDefault(), n.focusInput());
    }, n.onMenuMouseMove = function(l) {
      n.blockOptionHover = !1;
    }, n.onControlMouseDown = function(l) {
      if (!l.defaultPrevented) {
        var u = n.props.openMenuOnClick;
        n.state.isFocused ? n.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && n.onMenuClose() : u && n.openMenu("first") : (u && (n.openAfterFocus = !0), n.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault();
      }
    }, n.onDropdownIndicatorMouseDown = function(l) {
      if (!(l && l.type === "mousedown" && l.button !== 0) && !n.props.isDisabled) {
        var u = n.props, c = u.isMulti, d = u.menuIsOpen;
        n.focusInput(), d ? (n.setState({
          inputIsHiddenAfterUpdate: !c
        }), n.onMenuClose()) : n.openMenu("first"), l.preventDefault();
      }
    }, n.onClearIndicatorMouseDown = function(l) {
      l && l.type === "mousedown" && l.button !== 0 || (n.clearValue(), l.preventDefault(), n.openAfterFocus = !1, l.type === "touchend" ? n.focusInput() : setTimeout(function() {
        return n.focusInput();
      }));
    }, n.onScroll = function(l) {
      typeof n.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && bv(l.target) && n.props.onMenuClose() : typeof n.props.closeMenuOnScroll == "function" && n.props.closeMenuOnScroll(l) && n.props.onMenuClose();
    }, n.onCompositionStart = function() {
      n.isComposing = !0;
    }, n.onCompositionEnd = function() {
      n.isComposing = !1;
    }, n.onTouchStart = function(l) {
      var u = l.touches, c = u && u.item(0);
      c && (n.initialTouchX = c.clientX, n.initialTouchY = c.clientY, n.userIsDragging = !1);
    }, n.onTouchMove = function(l) {
      var u = l.touches, c = u && u.item(0);
      if (c) {
        var d = Math.abs(c.clientX - n.initialTouchX), h = Math.abs(c.clientY - n.initialTouchY), p = 5;
        n.userIsDragging = d > p || h > p;
      }
    }, n.onTouchEnd = function(l) {
      n.userIsDragging || (n.controlRef && !n.controlRef.contains(l.target) && n.menuListRef && !n.menuListRef.contains(l.target) && n.blurInput(), n.initialTouchX = 0, n.initialTouchY = 0);
    }, n.onControlTouchEnd = function(l) {
      n.userIsDragging || n.onControlMouseDown(l);
    }, n.onClearIndicatorTouchEnd = function(l) {
      n.userIsDragging || n.onClearIndicatorMouseDown(l);
    }, n.onDropdownIndicatorTouchEnd = function(l) {
      n.userIsDragging || n.onDropdownIndicatorMouseDown(l);
    }, n.handleInputChange = function(l) {
      var u = n.props.inputValue, c = l.currentTarget.value;
      n.setState({
        inputIsHiddenAfterUpdate: !1
      }), n.onInputChange(c, {
        action: "input-change",
        prevInputValue: u
      }), n.props.menuIsOpen || n.onMenuOpen();
    }, n.onInputFocus = function(l) {
      n.props.onFocus && n.props.onFocus(l), n.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (n.openAfterFocus || n.props.openMenuOnFocus) && n.openMenu("first"), n.openAfterFocus = !1;
    }, n.onInputBlur = function(l) {
      var u = n.props.inputValue;
      if (n.menuListRef && n.menuListRef.contains(document.activeElement)) {
        n.inputRef.focus();
        return;
      }
      n.props.onBlur && n.props.onBlur(l), n.onInputChange("", {
        action: "input-blur",
        prevInputValue: u
      }), n.onMenuClose(), n.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, n.onOptionHover = function(l) {
      if (!(n.blockOptionHover || n.state.focusedOption === l)) {
        var u = n.getFocusableOptions(), c = u.indexOf(l);
        n.setState({
          focusedOption: l,
          focusedOptionId: c > -1 ? n.getFocusedOptionId(l) : null
        });
      }
    }, n.shouldHideSelectedOptions = function() {
      return i1(n.props);
    }, n.onValueInputFocus = function(l) {
      l.preventDefault(), l.stopPropagation(), n.focus();
    }, n.onKeyDown = function(l) {
      var u = n.props, c = u.isMulti, d = u.backspaceRemovesValue, h = u.escapeClearsValue, p = u.inputValue, g = u.isClearable, m = u.isDisabled, f = u.menuIsOpen, C = u.onKeyDown, w = u.tabSelectsValue, E = u.openMenuOnFocus, b = n.state, y = b.focusedOption, S = b.focusedValue, x = b.selectValue;
      if (!m && !(typeof C == "function" && (C(l), l.defaultPrevented))) {
        switch (n.blockOptionHover = !0, l.key) {
          case "ArrowLeft":
            if (!c || p) return;
            n.focusValue("previous");
            break;
          case "ArrowRight":
            if (!c || p) return;
            n.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (p) return;
            if (S)
              n.removeValue(S);
            else {
              if (!d) return;
              c ? n.popValue() : g && n.clearValue();
            }
            break;
          case "Tab":
            if (n.isComposing || l.shiftKey || !f || !w || !y || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            E && n.isOptionSelected(y, x))
              return;
            n.selectOption(y);
            break;
          case "Enter":
            if (l.keyCode === 229)
              break;
            if (f) {
              if (!y || n.isComposing) return;
              n.selectOption(y);
              break;
            }
            return;
          case "Escape":
            f ? (n.setState({
              inputIsHiddenAfterUpdate: !1
            }), n.onInputChange("", {
              action: "menu-close",
              prevInputValue: p
            }), n.onMenuClose()) : g && h && n.clearValue();
            break;
          case " ":
            if (p)
              return;
            if (!f) {
              n.openMenu("first");
              break;
            }
            if (!y) return;
            n.selectOption(y);
            break;
          case "ArrowUp":
            f ? n.focusOption("up") : n.openMenu("last");
            break;
          case "ArrowDown":
            f ? n.focusOption("down") : n.openMenu("first");
            break;
          case "PageUp":
            if (!f) return;
            n.focusOption("pageup");
            break;
          case "PageDown":
            if (!f) return;
            n.focusOption("pagedown");
            break;
          case "Home":
            if (!f) return;
            n.focusOption("first");
            break;
          case "End":
            if (!f) return;
            n.focusOption("last");
            break;
          default:
            return;
        }
        l.preventDefault();
      }
    }, n.state.instancePrefix = "react-select-" + (n.props.instanceId || ++QCe), n.state.selectValue = vP(i.value), i.menuIsOpen && n.state.selectValue.length) {
      var o = n.getFocusableOptionsWithIds(), s = n.buildFocusableOptions(), a = s.indexOf(n.state.selectValue[0]);
      n.state.focusableOptionsWithIds = o, n.state.focusedOption = s[a], n.state.focusedOptionId = UC(o, s[a]);
    }
    return n;
  }
  return Oge(r, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && CP(this.menuListRef, this.focusedOptionRef), kCe() && this.setState({
        isAppleDevice: !0
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function(n) {
      var o = this.props, s = o.isDisabled, a = o.menuIsOpen, l = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (l && !s && n.isDisabled || // ensure focus is on the Input when the menu opens
      l && a && !n.menuIsOpen) && this.focusInput(), l && s && !n.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !l && !s && n.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (CP(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(n, o) {
      this.props.onInputChange(n, o);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(n) {
      var o = this, s = this.state, a = s.selectValue, l = s.isFocused, u = this.buildFocusableOptions(), c = n === "first" ? 0 : u.length - 1;
      if (!this.props.isMulti) {
        var d = u.indexOf(a[0]);
        d > -1 && (c = d);
      }
      this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: u[c],
        focusedOptionId: this.getFocusedOptionId(u[c])
      }, function() {
        return o.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(n) {
      var o = this.state, s = o.selectValue, a = o.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var l = s.indexOf(a);
        a || (l = -1);
        var u = s.length - 1, c = -1;
        if (s.length) {
          switch (n) {
            case "previous":
              l === 0 ? c = 0 : l === -1 ? c = u : c = l - 1;
              break;
            case "next":
              l > -1 && l < u && (c = l + 1);
              break;
          }
          this.setState({
            inputIsHidden: c !== -1,
            focusedValue: s[c]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", o = this.props.pageSize, s = this.state.focusedOption, a = this.getFocusableOptions();
      if (a.length) {
        var l = 0, u = a.indexOf(s);
        s || (u = -1), n === "up" ? l = u > 0 ? u - 1 : a.length - 1 : n === "down" ? l = (u + 1) % a.length : n === "pageup" ? (l = u - o, l < 0 && (l = 0)) : n === "pagedown" ? (l = u + o, l > a.length - 1 && (l = a.length - 1)) : n === "last" && (l = a.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: a[l],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(a[l])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(zC) : Pe(Pe({}, zC), this.props.theme) : zC;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var n = this.clearValue, o = this.cx, s = this.getStyles, a = this.getClassNames, l = this.getValue, u = this.selectOption, c = this.setValue, d = this.props, h = d.isMulti, p = d.isRtl, g = d.options, m = this.hasValue();
      return {
        clearValue: n,
        cx: o,
        getStyles: s,
        getClassNames: a,
        getValue: l,
        hasValue: m,
        isMulti: h,
        isRtl: p,
        options: g,
        selectOption: u,
        selectProps: d,
        setValue: c,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var n = this.state.selectValue;
      return n.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var n = this.props, o = n.isClearable, s = n.isMulti;
      return o === void 0 ? s : o;
    }
  }, {
    key: "isOptionDisabled",
    value: function(n, o) {
      return e1(this.props, n, o);
    }
  }, {
    key: "isOptionSelected",
    value: function(n, o) {
      return t1(this.props, n, o);
    }
  }, {
    key: "filterOption",
    value: function(n, o) {
      return r1(this.props, n, o);
    }
  }, {
    key: "formatOptionLabel",
    value: function(n, o) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, a = this.state.selectValue;
        return this.props.formatOptionLabel(n, {
          context: o,
          inputValue: s,
          selectValue: a
        });
      } else
        return this.getOptionLabel(n);
    }
  }, {
    key: "formatGroupLabel",
    value: function(n) {
      return this.props.formatGroupLabel(n);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var n = this.props, o = n.isDisabled, s = n.isSearchable, a = n.inputId, l = n.inputValue, u = n.tabIndex, c = n.form, d = n.menuIsOpen, h = n.required, p = this.getComponents(), g = p.Input, m = this.state, f = m.inputIsHidden, C = m.ariaSelection, w = this.commonProps, E = a || this.getElementId("input"), b = Pe(Pe(Pe({
          "aria-autocomplete": "list",
          "aria-expanded": d,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": h,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, d && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? (C == null ? void 0 : C.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ Y.createElement(g, Fe({}, w, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: E,
          innerRef: this.getInputRef,
          isDisabled: o,
          isHidden: f,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: u,
          form: c,
          type: "text",
          value: l
        }, b)) : /* @__PURE__ */ Y.createElement(ECe, Fe({
          id: E,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: Hg,
          onFocus: this.onInputFocus,
          disabled: o,
          tabIndex: u,
          inputMode: "none",
          form: c,
          value: ""
        }, b));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var n = this, o = this.getComponents(), s = o.MultiValue, a = o.MultiValueContainer, l = o.MultiValueLabel, u = o.MultiValueRemove, c = o.SingleValue, d = o.Placeholder, h = this.commonProps, p = this.props, g = p.controlShouldRenderValue, m = p.isDisabled, f = p.isMulti, C = p.inputValue, w = p.placeholder, E = this.state, b = E.selectValue, y = E.focusedValue, S = E.isFocused;
      if (!this.hasValue() || !g)
        return C ? null : /* @__PURE__ */ Y.createElement(d, Fe({}, h, {
          key: "placeholder",
          isDisabled: m,
          isFocused: S,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), w);
      if (f)
        return b.map(function(R, P) {
          var O = R === y, I = "".concat(n.getOptionLabel(R), "-").concat(n.getOptionValue(R));
          return /* @__PURE__ */ Y.createElement(s, Fe({}, h, {
            components: {
              Container: a,
              Label: l,
              Remove: u
            },
            isFocused: O,
            isDisabled: m,
            key: I,
            index: P,
            removeProps: {
              onClick: function() {
                return n.removeValue(R);
              },
              onTouchEnd: function() {
                return n.removeValue(R);
              },
              onMouseDown: function(_) {
                _.preventDefault();
              }
            },
            data: R
          }), n.formatOptionLabel(R, "value"));
        });
      if (C)
        return null;
      var x = b[0];
      return /* @__PURE__ */ Y.createElement(c, Fe({}, h, {
        data: x,
        isDisabled: m
      }), this.formatOptionLabel(x, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var n = this.getComponents(), o = n.ClearIndicator, s = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused;
      if (!this.isClearable() || !o || l || !this.hasValue() || u)
        return null;
      var d = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Y.createElement(o, Fe({}, s, {
        innerProps: d,
        isFocused: c
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var n = this.getComponents(), o = n.LoadingIndicator, s = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused;
      if (!o || !u) return null;
      var d = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Y.createElement(o, Fe({}, s, {
        innerProps: d,
        isDisabled: l,
        isFocused: c
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var n = this.getComponents(), o = n.DropdownIndicator, s = n.IndicatorSeparator;
      if (!o || !s) return null;
      var a = this.commonProps, l = this.props.isDisabled, u = this.state.isFocused;
      return /* @__PURE__ */ Y.createElement(s, Fe({}, a, {
        isDisabled: l,
        isFocused: u
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var n = this.getComponents(), o = n.DropdownIndicator;
      if (!o) return null;
      var s = this.commonProps, a = this.props.isDisabled, l = this.state.isFocused, u = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Y.createElement(o, Fe({}, s, {
        innerProps: u,
        isDisabled: a,
        isFocused: l
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var n = this, o = this.getComponents(), s = o.Group, a = o.GroupHeading, l = o.Menu, u = o.MenuList, c = o.MenuPortal, d = o.LoadingMessage, h = o.NoOptionsMessage, p = o.Option, g = this.commonProps, m = this.state.focusedOption, f = this.props, C = f.captureMenuScroll, w = f.inputValue, E = f.isLoading, b = f.loadingMessage, y = f.minMenuHeight, S = f.maxMenuHeight, x = f.menuIsOpen, R = f.menuPlacement, P = f.menuPosition, O = f.menuPortalTarget, I = f.menuShouldBlockScroll, M = f.menuShouldScrollIntoView, _ = f.noOptionsMessage, G = f.onMenuScrollToTop, F = f.onMenuScrollToBottom;
      if (!x) return null;
      var N = function(U, oe) {
        var ie = U.type, le = U.data, ce = U.isDisabled, he = U.isSelected, Z = U.label, se = U.value, ae = m === le, W = ce ? void 0 : function() {
          return n.onOptionHover(le);
        }, be = ce ? void 0 : function() {
          return n.selectOption(le);
        }, X = "".concat(n.getElementId("option"), "-").concat(oe), Te = {
          id: X,
          onClick: be,
          onMouseMove: W,
          onMouseOver: W,
          tabIndex: -1,
          role: "option",
          "aria-selected": n.state.isAppleDevice ? void 0 : he
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ Y.createElement(p, Fe({}, g, {
          innerProps: Te,
          data: le,
          isDisabled: ce,
          isSelected: he,
          key: X,
          label: Z,
          type: ie,
          value: se,
          isFocused: ae,
          innerRef: ae ? n.getFocusedOptionRef : void 0
        }), n.formatOptionLabel(U.data, "menu"));
      }, V;
      if (this.hasOptions())
        V = this.getCategorizedOptions().map(function(j) {
          if (j.type === "group") {
            var U = j.data, oe = j.options, ie = j.index, le = "".concat(n.getElementId("group"), "-").concat(ie), ce = "".concat(le, "-heading");
            return /* @__PURE__ */ Y.createElement(s, Fe({}, g, {
              key: le,
              data: U,
              options: oe,
              Heading: a,
              headingProps: {
                id: ce,
                data: j.data
              },
              label: n.formatGroupLabel(j.data)
            }), j.options.map(function(he) {
              return N(he, "".concat(ie, "-").concat(he.index));
            }));
          } else if (j.type === "option")
            return N(j, "".concat(j.index));
        });
      else if (E) {
        var B = b({
          inputValue: w
        });
        if (B === null) return null;
        V = /* @__PURE__ */ Y.createElement(d, g, B);
      } else {
        var $ = _({
          inputValue: w
        });
        if ($ === null) return null;
        V = /* @__PURE__ */ Y.createElement(h, g, $);
      }
      var L = {
        minMenuHeight: y,
        maxMenuHeight: S,
        menuPlacement: R,
        menuPosition: P,
        menuShouldScrollIntoView: M
      }, z = /* @__PURE__ */ Y.createElement(Qme, Fe({}, g, L), function(j) {
        var U = j.ref, oe = j.placerProps, ie = oe.placement, le = oe.maxHeight;
        return /* @__PURE__ */ Y.createElement(l, Fe({}, g, L, {
          innerRef: U,
          innerProps: {
            onMouseDown: n.onMenuMouseDown,
            onMouseMove: n.onMenuMouseMove
          },
          isLoading: E,
          placement: ie
        }), /* @__PURE__ */ Y.createElement(ICe, {
          captureEnabled: C,
          onTopArrive: G,
          onBottomArrive: F,
          lockEnabled: I
        }, function(ce) {
          return /* @__PURE__ */ Y.createElement(u, Fe({}, g, {
            innerRef: function(Z) {
              n.getMenuListRef(Z), ce(Z);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": g.isMulti,
              id: n.getElementId("listbox")
            },
            isLoading: E,
            maxHeight: le,
            focusedOption: m
          }), V);
        }));
      });
      return O || P === "fixed" ? /* @__PURE__ */ Y.createElement(c, Fe({}, g, {
        appendTo: O,
        controlElement: this.controlRef,
        menuPlacement: R,
        menuPosition: P
      }), z) : z;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var n = this, o = this.props, s = o.delimiter, a = o.isDisabled, l = o.isMulti, u = o.name, c = o.required, d = this.state.selectValue;
      if (c && !this.hasValue() && !a)
        return /* @__PURE__ */ Y.createElement(_Ce, {
          name: u,
          onFocus: this.onValueInputFocus
        });
      if (!(!u || a))
        if (l)
          if (s) {
            var h = d.map(function(m) {
              return n.getOptionValue(m);
            }).join(s);
            return /* @__PURE__ */ Y.createElement("input", {
              name: u,
              type: "hidden",
              value: h
            });
          } else {
            var p = d.length > 0 ? d.map(function(m, f) {
              return /* @__PURE__ */ Y.createElement("input", {
                key: "i-".concat(f),
                name: u,
                type: "hidden",
                value: n.getOptionValue(m)
              });
            }) : /* @__PURE__ */ Y.createElement("input", {
              name: u,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ Y.createElement("div", null, p);
          }
        else {
          var g = d[0] ? this.getOptionValue(d[0]) : "";
          return /* @__PURE__ */ Y.createElement("input", {
            name: u,
            type: "hidden",
            value: g
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var n = this.commonProps, o = this.state, s = o.ariaSelection, a = o.focusedOption, l = o.focusedValue, u = o.isFocused, c = o.selectValue, d = this.getFocusableOptions();
      return /* @__PURE__ */ Y.createElement(vCe, Fe({}, n, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: a,
        focusedValue: l,
        isFocused: u,
        selectValue: c,
        focusableOptions: d,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var n = this.getComponents(), o = n.Control, s = n.IndicatorsContainer, a = n.SelectContainer, l = n.ValueContainer, u = this.props, c = u.className, d = u.id, h = u.isDisabled, p = u.menuIsOpen, g = this.state.isFocused, m = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ Y.createElement(a, Fe({}, m, {
        className: c,
        innerProps: {
          id: d,
          onKeyDown: this.onKeyDown
        },
        isDisabled: h,
        isFocused: g
      }), this.renderLiveRegion(), /* @__PURE__ */ Y.createElement(o, Fe({}, m, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: h,
        isFocused: g,
        menuIsOpen: p
      }), /* @__PURE__ */ Y.createElement(l, Fe({}, m, {
        isDisabled: h
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ Y.createElement(s, Fe({}, m, {
        isDisabled: h
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(n, o) {
      var s = o.prevProps, a = o.clearFocusValueOnUpdate, l = o.inputIsHiddenAfterUpdate, u = o.ariaSelection, c = o.isFocused, d = o.prevWasFocused, h = o.instancePrefix, p = n.options, g = n.value, m = n.menuIsOpen, f = n.inputValue, C = n.isMulti, w = vP(g), E = {};
      if (s && (g !== s.value || p !== s.options || m !== s.menuIsOpen || f !== s.inputValue)) {
        var b = m ? qCe(n, w) : [], y = m ? MP(Yp(n, w), "".concat(h, "-option")) : [], S = a ? ZCe(o, w) : null, x = JCe(o, b), R = UC(y, x);
        E = {
          selectValue: w,
          focusedOption: x,
          focusedOptionId: R,
          focusableOptionsWithIds: y,
          focusedValue: S,
          clearFocusValueOnUpdate: !1
        };
      }
      var P = l != null && n !== s ? {
        inputIsHidden: l,
        inputIsHiddenAfterUpdate: void 0
      } : {}, O = u, I = c && d;
      return c && !I && (O = {
        value: Dp(C, w, w[0] || null),
        options: w,
        action: "initial-input-focus"
      }, I = !d), (u == null ? void 0 : u.action) === "initial-input-focus" && (O = null), Pe(Pe(Pe({}, E), P), {}, {
        prevProps: n,
        ariaSelection: O,
        prevWasFocused: I
      });
    }
  }]), r;
}($t);
n1.defaultProps = KCe;
var eye = /* @__PURE__ */ ns(function(e, t) {
  var r = Pge(e);
  return /* @__PURE__ */ Y.createElement(n1, Fe({
    ref: t
  }, r));
}), tye = eye;
const xbe = ({
  options: e,
  value: t,
  onChange: r,
  placeholder: i = "Select...",
  isClearable: n = !0,
  isDisabled: o = !1,
  isLoading: s = !1,
  isSearchable: a = !0,
  label: l
}) => {
  const { theme: u } = ku(), c = "var(--app-primary-color)", d = "var(--app-accent-color)", h = "var(--app-text-color)", p = "var(--app-card-bg-color)", g = "var(--app-border-color)", m = "var(--app-card-bg-color)", f = "var(--app-primary-color)", C = "rgba(var(--app-primary-color-raw), 0.1)", w = "rgba(var(--app-primary-color-raw), 0.2)", E = "rgba(var(--app-text-color-raw), 0.5)";
  return /* @__PURE__ */ ve("div", { className: "w-full", children: [
    l && /* @__PURE__ */ H("label", { className: "block text-sm font-medium text-text mb-1", children: l }),
    /* @__PURE__ */ H(
      tye,
      {
        options: e,
        value: t,
        onChange: (S, x) => {
          const R = S ? Array.from(S) : null;
          r(R);
        },
        isMulti: !0,
        isClearable: n,
        isDisabled: o,
        isLoading: s,
        isSearchable: a,
        placeholder: i,
        styles: {
          control: (S, x) => ({
            ...S,
            backgroundColor: m,
            borderColor: x.isFocused ? c : g,
            boxShadow: x.isFocused ? `0 0 0 1px ${c}` : "none",
            "&:hover": {
              borderColor: f
            },
            color: h,
            minHeight: "40px"
            // Match height of our Input component
          }),
          input: (S) => ({
            ...S,
            color: h
          }),
          placeholder: (S) => ({
            ...S,
            color: E
            // Placeholder should be a muted text color
          }),
          singleValue: (S) => ({
            ...S,
            color: h
          }),
          multiValue: (S) => ({
            ...S,
            backgroundColor: w,
            color: h,
            borderRadius: "4px"
          }),
          multiValueLabel: (S) => ({
            ...S,
            color: h
          }),
          multiValueRemove: (S) => ({
            ...S,
            color: h,
            "&:hover": {
              backgroundColor: d,
              color: "white"
            }
          }),
          menu: (S) => ({
            ...S,
            backgroundColor: p,
            borderColor: g,
            boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
            zIndex: 9999
            // Ensure it's above other elements
          }),
          option: (S, x) => ({
            ...S,
            backgroundColor: x.isSelected ? w : x.isFocused ? C : p,
            color: x.isSelected ? c : h,
            "&:active": {
              backgroundColor: w
            }
          }),
          dropdownIndicator: (S) => ({
            ...S,
            color: h,
            "&:hover": {
              color: c
            }
          }),
          clearIndicator: (S) => ({
            ...S,
            color: h,
            "&:hover": {
              color: c
            }
          }),
          loadingIndicator: (S) => ({
            ...S,
            "& > span": {
              backgroundColor: c
            }
          }),
          noOptionsMessage: (S) => ({
            ...S,
            color: h,
            backgroundColor: p
          })
        },
        classNamePrefix: "react-select"
      }
    )
  ] });
}, Abe = ({ className: e, containerClassName: t, ...r }) => /* @__PURE__ */ ve("div", { className: `relative ${t || ""}`, children: [
  /* @__PURE__ */ H("div", { className: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none", children: /* @__PURE__ */ H(Hi, { name: "search", size: 16, className: "text-text-light" }) }),
  /* @__PURE__ */ H(
    Hh,
    {
      type: "search",
      className: `pl-10 ${e || ""}`,
      ...r
    }
  )
] }), rye = D.forwardRef(
  ({ label: e, className: t, containerClassName: r, ...i }, n) => /* @__PURE__ */ ve("div", { className: `w-full ${r || ""}`, children: [
    e && /* @__PURE__ */ H("label", { htmlFor: i.id || i.name, className: "block text-sm font-medium text-text-light mb-1", children: e }),
    /* @__PURE__ */ H(
      "textarea",
      {
        ref: n,
        className: `w-full px-3 py-2 rounded-md bg-card border border-border transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-primary ${t || ""}`,
        ...i
      }
    )
  ] })
);
rye.displayName = "Textarea";
const Dbe = ({
  checked: e,
  onChange: t,
  label: r,
  className: i,
  disabled: n = !1
}) => {
  const o = () => {
    n || t(!e);
  }, s = D.useId();
  return /* @__PURE__ */ ve("label", { htmlFor: s, className: `flex items-center cursor-pointer ${i || ""} ${n ? "opacity-50 cursor-not-allowed" : ""}`, children: [
    /* @__PURE__ */ ve("div", { className: "relative", children: [
      /* @__PURE__ */ H(
        "input",
        {
          id: s,
          type: "checkbox",
          className: "sr-only",
          checked: e,
          onChange: o,
          disabled: n
        }
      ),
      /* @__PURE__ */ H("div", { className: `block w-12 h-6 rounded-full transition-colors duration-200 ease-in-out ${e ? "bg-primary" : "bg-border"}` }),
      /* @__PURE__ */ H(
        "div",
        {
          className: `dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full shadow-sm transition-transform duration-200 ease-in-out ${e ? "translate-x-6" : ""}`
        }
      )
    ] }),
    /* @__PURE__ */ H("div", { className: "ml-3 text-text font-medium select-none", children: r })
  ] });
}, Tbe = (e, t) => {
  const [r, i] = ee(e), [n, o] = ee(!0), [s, a] = ee(null), l = fe(async () => {
    o(!0), a(null);
    try {
      await new Promise((u) => setTimeout(u, 1e3)), i(t);
    } catch (u) {
      a("Failed to fetch data"), console.error(u);
    } finally {
      o(!1);
    }
  }, [t]);
  return ee(() => {
    l();
  }), { data: r, loading: n, error: s, fetchData: l };
}, Rbe = ({ id: e, header: t, children: r, isOpen: i, onToggle: n }) => {
  const [o, s] = ee(i !== void 0 ? i : !1), a = i !== void 0, l = a ? i : o, u = fe(() => {
    a && n ? n(e, !l) : s((d) => !d);
  }, [e, l, a, n]), c = `transform transition-transform duration-300 ${l ? "rotate-180" : "rotate-0"}`;
  return /* @__PURE__ */ ve("div", { className: "border border-border rounded-md overflow-hidden", children: [
    /* @__PURE__ */ ve(
      "button",
      {
        id: `accordion-header-${e}`,
        "aria-expanded": l,
        "aria-controls": `accordion-panel-${e}`,
        onClick: u,
        className: "flex items-center justify-between w-full p-4 text-text bg-background hover:bg-background/80 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2",
        role: "heading",
        "aria-level": 3,
        children: [
          /* @__PURE__ */ H("span", { className: "text-xl font-semibold", children: t }),
          /* @__PURE__ */ H("svg", { className: `w-6 h-6 text-text ${c}`, fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ H("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M19 9l-7 7-7-7" }) })
        ]
      }
    ),
    /* @__PURE__ */ H(
      "div",
      {
        id: `accordion-panel-${e}`,
        role: "region",
        "aria-labelledby": `accordion-header-${e}`,
        style: {
          maxHeight: l ? "1000px" : "0",
          // Arbitrary large height for transition
          overflow: "hidden",
          transition: "max-height 0.3s ease-in-out"
        },
        children: /* @__PURE__ */ H("div", { className: "p-4 bg-card", children: r })
      }
    )
  ] });
}, Pbe = ({ children: e, singleOpen: t = !1, className: r }) => {
  const [i, n] = ee(null), o = fe((s, a) => {
    t && n(a ? s : null);
  }, [t]);
  return /* @__PURE__ */ H("div", { className: `space-y-4 ${r || ""}`, children: D.Children.map(e, (s) => D.isValidElement(s) ? D.cloneElement(s, {
    isOpen: t ? s.props.id === i : void 0,
    onToggle: t ? o : void 0
  }) : s) });
}, Ibe = ({ children: e, className: t, ...r }) => /* @__PURE__ */ H("li", { className: `mb-1 last:mb-0 text-text ${t || ""}`, ...r, children: e }), Obe = ({ type: e = "ul", children: t, className: r, ...i }) => {
  const n = "space-y-1", o = "text-text", s = e === "ol" ? "ol" : "ul";
  return D.createElement(
    s,
    { className: `${n} ${o} ${r || ""}`, ...i },
    t
  );
}, Mbe = ({ children: e, className: t, ...r }) => /* @__PURE__ */ H("dt", { className: `font-semibold text-text ${t || ""}`, ...r, children: e }), Fbe = ({ children: e, className: t, ...r }) => /* @__PURE__ */ H("dd", { className: `ml-4 text-text ${t || ""}`, ...r, children: e }), _be = ({ children: e, className: t, ...r }) => /* @__PURE__ */ H("dl", { className: `space-y-2 ${t || ""}`, ...r, children: e }), Nbe = ({ isOpen: e, onClose: t, children: r, title: i, footer: n, className: o }) => {
  const s = re(null), a = fe((l) => {
    l.key === "Escape" && e && t();
  }, [e, t]);
  return gt(() => (document.addEventListener("keydown", a, !1), () => {
    document.removeEventListener("keydown", a, !1);
  }), [a]), e ? xa(
    /* @__PURE__ */ H("div", { className: "fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50", children: /* @__PURE__ */ ve(
      "div",
      {
        ref: s,
        className: `relative w-full max-w-lg mx-auto rounded-lg shadow-xl overflow-hidden bg-card border border-border text-text ${o || ""}`,
        role: "dialog",
        "aria-modal": "true",
        "aria-labelledby": i ? "modal-title" : void 0,
        children: [
          /* @__PURE__ */ ve("div", { className: "flex justify-between items-center p-4 border-b border-border", children: [
            i && /* @__PURE__ */ H("h3", { id: "modal-title", className: "text-xl font-semibold", children: i }),
            /* @__PURE__ */ H(
              "button",
              {
                onClick: t,
                className: "text-text hover:text-gray-500 transition-colors",
                "aria-label": "Close modal",
                children: /* @__PURE__ */ H("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ H("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M6 18L18 6M6 6l12 12" }) })
              }
            )
          ] }),
          /* @__PURE__ */ H("div", { className: "p-4", children: r }),
          n && /* @__PURE__ */ H("div", { className: "p-4 border-t border-border flex justify-end space-x-2", children: n })
        ]
      }
    ) }),
    document.body
    // Portal the modal to the body
  ) : null;
};
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ww() {
  return ww = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ww.apply(this, arguments);
}
var _P;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(_P || (_P = {}));
function Zt(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function Uh(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function Sw(e) {
  let {
    pathname: t = "/",
    search: r = "",
    hash: i = ""
  } = e;
  return r && r !== "?" && (t += r.charAt(0) === "?" ? r : "?" + r), i && i !== "#" && (t += i.charAt(0) === "#" ? i : "#" + i), t;
}
function o1(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substr(r), e = e.substr(0, r));
    let i = e.indexOf("?");
    i >= 0 && (t.search = e.substr(i), e = e.substr(0, i)), e && (t.pathname = e);
  }
  return t;
}
var NP;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(NP || (NP = {}));
function LP(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [r, i] = iye(e.path, e.caseSensitive, e.end), n = t.match(r);
  if (!n) return null;
  let o = n[0], s = o.replace(/(.)\/+$/, "$1"), a = n.slice(1);
  return {
    params: i.reduce((u, c, d) => {
      let {
        paramName: h,
        isOptional: p
      } = c;
      if (h === "*") {
        let m = a[d] || "";
        s = o.slice(0, o.length - m.length).replace(/(.)\/+$/, "$1");
      }
      const g = a[d];
      return p && !g ? u[h] = void 0 : u[h] = (g || "").replace(/%2F/g, "/"), u;
    }, {}),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function iye(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !0), Uh(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let i = [], n = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (i.push({
    paramName: a,
    isOptional: l != null
  }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (i.push({
    paramName: "*"
  }), n += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? n += "\\/*$" : e !== "" && e !== "/" && (n += "(?:(?=\\/|$))"), [new RegExp(n, t ? void 0 : "i"), i];
}
function wu(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, i = e.charAt(r);
  return i && i !== "/" ? null : e.slice(r) || "/";
}
function nye(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: r,
    search: i = "",
    hash: n = ""
  } = typeof e == "string" ? o1(e) : e;
  return {
    pathname: r ? r.startsWith("/") ? r : oye(r, t) : t,
    search: aye(i),
    hash: lye(n)
  };
}
function oye(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((n) => {
    n === ".." ? r.length > 1 && r.pop() : n !== "." && r.push(n);
  }), r.length > 1 ? r.join("/") : "/";
}
function YC(e, t, r, i) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + r + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function sye(e) {
  return e.filter((t, r) => r === 0 || t.route.path && t.route.path.length > 0);
}
function s1(e, t) {
  let r = sye(e);
  return t ? r.map((i, n) => n === r.length - 1 ? i.pathname : i.pathnameBase) : r.map((i) => i.pathnameBase);
}
function a1(e, t, r, i) {
  i === void 0 && (i = !1);
  let n;
  typeof e == "string" ? n = o1(e) : (n = ww({}, e), Zt(!n.pathname || !n.pathname.includes("?"), YC("?", "pathname", "search", n)), Zt(!n.pathname || !n.pathname.includes("#"), YC("#", "pathname", "hash", n)), Zt(!n.search || !n.search.includes("#"), YC("#", "search", "hash", n)));
  let o = e === "" || n.pathname === "", s = o ? "/" : n.pathname, a;
  if (s == null)
    a = r;
  else {
    let d = t.length - 1;
    if (!i && s.startsWith("..")) {
      let h = s.split("/");
      for (; h[0] === ".."; )
        h.shift(), d -= 1;
      n.pathname = h.join("/");
    }
    a = d >= 0 ? t[d] : "/";
  }
  let l = nye(n, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && r.endsWith("/");
  return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l;
}
const mx = (e) => e.join("/").replace(/\/\/+/g, "/"), aye = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, lye = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, l1 = ["post", "put", "patch", "delete"];
new Set(l1);
const uye = ["get", ...l1];
new Set(uye);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Ew() {
  return Ew = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Ew.apply(this, arguments);
}
const wv = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (wv.displayName = "DataRouter");
const u1 = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (u1.displayName = "DataRouterState");
const cye = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (cye.displayName = "Await");
const Go = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (Go.displayName = "Navigation");
const vx = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (vx.displayName = "Location");
const rc = /* @__PURE__ */ Y.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (rc.displayName = "Route");
const dye = /* @__PURE__ */ Y.createContext(null);
process.env.NODE_ENV !== "production" && (dye.displayName = "RouteError");
function hye(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t;
  Cx() || (process.env.NODE_ENV !== "production" ? Zt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Zt(!1));
  let {
    basename: i,
    navigator: n
  } = Y.useContext(Go), {
    hash: o,
    pathname: s,
    search: a
  } = Yh(e, {
    relative: r
  }), l = s;
  return i !== "/" && (l = s === "/" ? i : mx([i, s])), n.createHref({
    pathname: l,
    search: a,
    hash: o
  });
}
function Cx() {
  return Y.useContext(vx) != null;
}
function ic() {
  return Cx() || (process.env.NODE_ENV !== "production" ? Zt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Zt(!1)), Y.useContext(vx).location;
}
const c1 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function d1(e) {
  Y.useContext(Go).static || Y.useLayoutEffect(e);
}
function pye() {
  let {
    isDataRoute: e
  } = Y.useContext(rc);
  return e ? Cye() : fye();
}
function fye() {
  Cx() || (process.env.NODE_ENV !== "production" ? Zt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Zt(!1));
  let e = Y.useContext(wv), {
    basename: t,
    future: r,
    navigator: i
  } = Y.useContext(Go), {
    matches: n
  } = Y.useContext(rc), {
    pathname: o
  } = ic(), s = JSON.stringify(s1(n, r.v7_relativeSplatPath)), a = Y.useRef(!1);
  return d1(() => {
    a.current = !0;
  }), Y.useCallback(function(u, c) {
    if (c === void 0 && (c = {}), process.env.NODE_ENV !== "production" && Uh(a.current, c1), !a.current) return;
    if (typeof u == "number") {
      i.go(u);
      return;
    }
    let d = a1(u, JSON.parse(s), o, c.relative === "path");
    e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : mx([t, d.pathname])), (c.replace ? i.replace : i.push)(d, c.state, c);
  }, [t, i, s, o, e]);
}
function Yh(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    future: i
  } = Y.useContext(Go), {
    matches: n
  } = Y.useContext(rc), {
    pathname: o
  } = ic(), s = JSON.stringify(s1(n, i.v7_relativeSplatPath));
  return Y.useMemo(() => a1(e, JSON.parse(s), o, r === "path"), [e, s, o, r]);
}
var h1 = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(h1 || {}), yx = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(yx || {});
function p1(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function gye(e) {
  let t = Y.useContext(wv);
  return t || (process.env.NODE_ENV !== "production" ? Zt(!1, p1(e)) : Zt(!1)), t;
}
function mye(e) {
  let t = Y.useContext(rc);
  return t || (process.env.NODE_ENV !== "production" ? Zt(!1, p1(e)) : Zt(!1)), t;
}
function f1(e) {
  let t = mye(e), r = t.matches[t.matches.length - 1];
  return r.route.id || (process.env.NODE_ENV !== "production" ? Zt(!1, e + ' can only be used on routes that contain a unique "id"') : Zt(!1)), r.route.id;
}
function vye() {
  return f1(yx.UseRouteId);
}
function Cye() {
  let {
    router: e
  } = gye(h1.UseNavigateStable), t = f1(yx.UseNavigateStable), r = Y.useRef(!1);
  return d1(() => {
    r.current = !0;
  }), Y.useCallback(function(n, o) {
    o === void 0 && (o = {}), process.env.NODE_ENV !== "production" && Uh(r.current, c1), r.current && (typeof n == "number" ? e.navigate(n) : e.navigate(n, Ew({
      fromRouteId: t
    }, o)));
  }, [e, t]);
}
new Promise(() => {
});
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Su() {
  return Su = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Su.apply(this, arguments);
}
function bx(e, t) {
  if (e == null) return {};
  var r = {}, i = Object.keys(e), n, o;
  for (o = 0; o < i.length; o++)
    n = i[o], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
  return r;
}
const Xp = "get", Kp = "application/x-www-form-urlencoded";
function Sv(e) {
  return e != null && typeof e.tagName == "string";
}
function yye(e) {
  return Sv(e) && e.tagName.toLowerCase() === "button";
}
function bye(e) {
  return Sv(e) && e.tagName.toLowerCase() === "form";
}
function wye(e) {
  return Sv(e) && e.tagName.toLowerCase() === "input";
}
function Sye(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Eye(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Sye(e);
}
let Tp = null;
function xye() {
  if (Tp === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Tp = !1;
    } catch {
      Tp = !0;
    }
  return Tp;
}
const Aye = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function XC(e) {
  return e != null && !Aye.has(e) ? (process.env.NODE_ENV !== "production" && Uh(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + Kp + '"')), null) : e;
}
function Dye(e, t) {
  let r, i, n, o, s;
  if (bye(e)) {
    let a = e.getAttribute("action");
    i = a ? wu(a, t) : null, r = e.getAttribute("method") || Xp, n = XC(e.getAttribute("enctype")) || Kp, o = new FormData(e);
  } else if (yye(e) || wye(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let l = e.getAttribute("formaction") || a.getAttribute("action");
    if (i = l ? wu(l, t) : null, r = e.getAttribute("formmethod") || a.getAttribute("method") || Xp, n = XC(e.getAttribute("formenctype")) || XC(a.getAttribute("enctype")) || Kp, o = new FormData(a, e), !xye()) {
      let {
        name: u,
        type: c,
        value: d
      } = e;
      if (c === "image") {
        let h = u ? u + "." : "";
        o.append(h + "x", "0"), o.append(h + "y", "0");
      } else u && o.append(u, d);
    }
  } else {
    if (Sv(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    r = Xp, i = null, n = Kp, s = e;
  }
  return o && n === "text/plain" && (s = o, o = void 0), {
    action: i,
    method: r.toLowerCase(),
    encType: n,
    formData: o,
    body: s
  };
}
const Tye = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], Rye = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], Pye = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], Iye = "6";
try {
  window.__reactRouterVersion = Iye;
} catch {
}
const g1 = /* @__PURE__ */ Y.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (g1.displayName = "ViewTransition");
const Oye = /* @__PURE__ */ Y.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (Oye.displayName = "Fetchers");
process.env.NODE_ENV;
const Mye = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Fye = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ev = /* @__PURE__ */ Y.forwardRef(function(t, r) {
  let {
    onClick: i,
    relative: n,
    reloadDocument: o,
    replace: s,
    state: a,
    target: l,
    to: u,
    preventScrollReset: c,
    viewTransition: d
  } = t, h = bx(t, Tye), {
    basename: p
  } = Y.useContext(Go), g, m = !1;
  if (typeof u == "string" && Fye.test(u) && (g = u, Mye))
    try {
      let E = new URL(window.location.href), b = u.startsWith("//") ? new URL(E.protocol + u) : new URL(u), y = wu(b.pathname, p);
      b.origin === E.origin && y != null ? u = y + b.search + b.hash : m = !0;
    } catch {
      process.env.NODE_ENV !== "production" && Uh(!1, '<Link to="' + u + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let f = hye(u, {
    relative: n
  }), C = Gye(u, {
    replace: s,
    state: a,
    target: l,
    preventScrollReset: c,
    relative: n,
    viewTransition: d
  });
  function w(E) {
    i && i(E), E.defaultPrevented || C(E);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ Y.createElement("a", Su({}, h, {
      href: g || f,
      onClick: m || o ? i : w,
      ref: r,
      target: l
    }))
  );
});
process.env.NODE_ENV !== "production" && (Ev.displayName = "Link");
const _ye = /* @__PURE__ */ Y.forwardRef(function(t, r) {
  let {
    "aria-current": i = "page",
    caseSensitive: n = !1,
    className: o = "",
    end: s = !1,
    style: a,
    to: l,
    viewTransition: u,
    children: c
  } = t, d = bx(t, Rye), h = Yh(l, {
    relative: d.relative
  }), p = ic(), g = Y.useContext(u1), {
    navigator: m,
    basename: f
  } = Y.useContext(Go), C = g != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  $ye(h) && u === !0, w = m.encodeLocation ? m.encodeLocation(h).pathname : h.pathname, E = p.pathname, b = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
  n || (E = E.toLowerCase(), b = b ? b.toLowerCase() : null, w = w.toLowerCase()), b && f && (b = wu(b, f) || b);
  const y = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
  let S = E === w || !s && E.startsWith(w) && E.charAt(y) === "/", x = b != null && (b === w || !s && b.startsWith(w) && b.charAt(w.length) === "/"), R = {
    isActive: S,
    isPending: x,
    isTransitioning: C
  }, P = S ? i : void 0, O;
  typeof o == "function" ? O = o(R) : O = [o, S ? "active" : null, x ? "pending" : null, C ? "transitioning" : null].filter(Boolean).join(" ");
  let I = typeof a == "function" ? a(R) : a;
  return /* @__PURE__ */ Y.createElement(Ev, Su({}, d, {
    "aria-current": P,
    className: O,
    ref: r,
    style: I,
    to: l,
    viewTransition: u
  }), typeof c == "function" ? c(R) : c);
});
process.env.NODE_ENV !== "production" && (_ye.displayName = "NavLink");
const Nye = /* @__PURE__ */ Y.forwardRef((e, t) => {
  let {
    fetcherKey: r,
    navigate: i,
    reloadDocument: n,
    replace: o,
    state: s,
    method: a = Xp,
    action: l,
    onSubmit: u,
    relative: c,
    preventScrollReset: d,
    viewTransition: h
  } = e, p = bx(e, Pye), g = Bye(), m = Wye(l, {
    relative: c
  }), f = a.toLowerCase() === "get" ? "get" : "post", C = (w) => {
    if (u && u(w), w.defaultPrevented) return;
    w.preventDefault();
    let E = w.nativeEvent.submitter, b = (E == null ? void 0 : E.getAttribute("formmethod")) || a;
    g(E || w.currentTarget, {
      fetcherKey: r,
      method: b,
      navigate: i,
      replace: o,
      state: s,
      relative: c,
      preventScrollReset: d,
      viewTransition: h
    });
  };
  return /* @__PURE__ */ Y.createElement("form", Su({
    ref: t,
    method: f,
    action: m,
    onSubmit: n ? u : C
  }, p));
});
process.env.NODE_ENV !== "production" && (Nye.displayName = "Form");
process.env.NODE_ENV;
var $g;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState";
})($g || ($g = {}));
var GP;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(GP || (GP = {}));
function Lye(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function m1(e) {
  let t = Y.useContext(wv);
  return t || (process.env.NODE_ENV !== "production" ? Zt(!1, Lye(e)) : Zt(!1)), t;
}
function Gye(e, t) {
  let {
    target: r,
    replace: i,
    state: n,
    preventScrollReset: o,
    relative: s,
    viewTransition: a
  } = t === void 0 ? {} : t, l = pye(), u = ic(), c = Yh(e, {
    relative: s
  });
  return Y.useCallback((d) => {
    if (Eye(d, r)) {
      d.preventDefault();
      let h = i !== void 0 ? i : Sw(u) === Sw(c);
      l(e, {
        replace: h,
        state: n,
        preventScrollReset: o,
        relative: s,
        viewTransition: a
      });
    }
  }, [u, l, c, i, n, r, e, o, s, a]);
}
function kye() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let Vye = 0, Hye = () => "__" + String(++Vye) + "__";
function Bye() {
  let {
    router: e
  } = m1($g.UseSubmit), {
    basename: t
  } = Y.useContext(Go), r = vye();
  return Y.useCallback(function(i, n) {
    n === void 0 && (n = {}), kye();
    let {
      action: o,
      method: s,
      encType: a,
      formData: l,
      body: u
    } = Dye(i, t);
    if (n.navigate === !1) {
      let c = n.fetcherKey || Hye();
      e.fetch(c, r, n.action || o, {
        preventScrollReset: n.preventScrollReset,
        formData: l,
        body: u,
        formMethod: n.method || s,
        formEncType: n.encType || a,
        flushSync: n.flushSync
      });
    } else
      e.navigate(n.action || o, {
        preventScrollReset: n.preventScrollReset,
        formData: l,
        body: u,
        formMethod: n.method || s,
        formEncType: n.encType || a,
        replace: n.replace,
        state: n.state,
        fromRouteId: r,
        flushSync: n.flushSync,
        viewTransition: n.viewTransition
      });
  }, [e, t, r]);
}
function Wye(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    basename: i
  } = Y.useContext(Go), n = Y.useContext(rc);
  n || (process.env.NODE_ENV !== "production" ? Zt(!1, "useFormAction must be used inside a RouteContext") : Zt(!1));
  let [o] = n.matches.slice(-1), s = Su({}, Yh(e || ".", {
    relative: r
  })), a = ic();
  if (e == null) {
    s.search = a.search;
    let l = new URLSearchParams(s.search), u = l.getAll("index");
    if (u.some((d) => d === "")) {
      l.delete("index"), u.filter((h) => h).forEach((h) => l.append("index", h));
      let d = l.toString();
      s.search = d ? "?" + d : "";
    }
  }
  return (!e || e === ".") && o.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), i !== "/" && (s.pathname = s.pathname === "/" ? i : mx([i, s.pathname])), Sw(s);
}
function $ye(e, t) {
  t === void 0 && (t = {});
  let r = Y.useContext(g1);
  r == null && (process.env.NODE_ENV !== "production" ? Zt(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : Zt(!1));
  let {
    basename: i
  } = m1($g.useViewTransitionState), n = Yh(e, {
    relative: t.relative
  });
  if (!r.isTransitioning)
    return !1;
  let o = wu(r.currentLocation.pathname, i) || r.currentLocation.pathname, s = wu(r.nextLocation.pathname, i) || r.nextLocation.pathname;
  return LP(n.pathname, s) != null || LP(n.pathname, o) != null;
}
const Lbe = ({ label: e, to: t, isCurrent: r, className: i, icon: n }) => {
  const o = "inline-flex items-center text-sm font-medium", s = r ? "text-text" : "text-primary hover:text-secondary", a = "ml-2 text-muted-foreground", l = /* @__PURE__ */ ve(kP, { children: [
    n && /* @__PURE__ */ H("span", { className: "mr-2 h-4 w-4", children: n }),
    " ",
    e
  ] });
  return /* @__PURE__ */ ve("li", { className: `${o} ${s} ${i || ""}`, "aria-current": r ? "page" : void 0, children: [
    t && !r ? /* @__PURE__ */ H(Ev, { to: t, className: "inline-flex items-center hover:underline", children: l }) : /* @__PURE__ */ H("span", { className: "inline-flex items-center", children: l }),
    !r && /* @__PURE__ */ H("span", { className: a, children: "/" })
  ] });
}, Gbe = ({ children: e, className: t }) => /* @__PURE__ */ H("nav", { className: `flex ${t || ""}`, "aria-label": "Breadcrumb", children: /* @__PURE__ */ H("ol", { className: "inline-flex items-center space-x-1 md:space-x-2", children: e }) }), kbe = ({
  currentPage: e,
  totalPages: t,
  onPageChange: r,
  maxPageButtons: i = 5,
  className: n
}) => {
  const o = Ee(() => {
    const u = [];
    if (t <= i) {
      for (let p = 1; p <= t; p++)
        u.push(p);
      return u;
    }
    const c = Math.floor(i / 2);
    let d = Math.max(1, e - c), h = Math.min(t, e + c);
    e - c <= 1 && (h = i), e + c >= t && (d = t - i + 1), d > 1 && (u.push(1), d > 2 && u.push("..."));
    for (let p = d; p <= h; p++)
      u.push(p);
    return h < t && (h < t - 1 && u.push("..."), u.push(t)), u;
  }, [e, t, i]), s = fe((u) => {
    r(u);
  }, [r]), a = fe(() => {
    r(e - 1);
  }, [e, r]), l = fe(() => {
    r(e + 1);
  }, [e, r]);
  return t <= 1 ? null : /* @__PURE__ */ ve("nav", { className: `flex items-center justify-center gap-2 ${n || ""}`, "aria-label": "Pagination", children: [
    /* @__PURE__ */ H(
      Uo,
      {
        variant: "outline",
        size: "sm",
        onClick: a,
        disabled: e === 1,
        iconBefore: /* @__PURE__ */ H(Hi, { name: "chevron-left", size: 16 }),
        children: "Previous"
      }
    ),
    /* @__PURE__ */ H("div", { className: "flex items-center gap-1", children: o.map(
      (u, c) => typeof u == "number" ? /* @__PURE__ */ H(
        Uo,
        {
          variant: e === u ? "primary" : "ghost",
          size: "sm",
          onClick: () => s(u),
          className: "w-10",
          children: u
        },
        u
      ) : /* @__PURE__ */ H("span", { className: "px-2 py-1 text-sm text-text-light", children: "..." }, `ellipsis-${c}`)
    ) }),
    /* @__PURE__ */ H(
      Uo,
      {
        variant: "outline",
        size: "sm",
        onClick: l,
        disabled: e === t,
        iconAfter: /* @__PURE__ */ H(Hi, { name: "chevron-right", size: 16 }),
        children: "Next"
      }
    )
  ] });
}, jye = (e, t) => {
  const [r, i] = ee(null), n = re(null);
  return gt(() => {
    const o = e.map((s) => document.getElementById(s)).filter((s) => s != null);
    return n.current && n.current.disconnect(), n.current = new IntersectionObserver((s) => {
      s.forEach((a) => {
        a.isIntersecting && i(a.target.id);
      });
    }, t), o.forEach((s) => {
      var a;
      return (a = n.current) == null ? void 0 : a.observe(s);
    }), () => {
      var s;
      return (s = n.current) == null ? void 0 : s.disconnect();
    };
  }, [e, t]), r;
}, Vbe = ({ navItems: e, sectionIds: t, className: r }) => {
  const i = jye(t, { rootMargin: "0% 0% -80% 0%" }), n = ic(), o = (s, a = !1) => /* @__PURE__ */ H("ul", { className: a ? "pl-4 mt-2 space-y-2" : "space-y-4", children: s.map((l) => {
    const u = l.href.startsWith("/"), c = u ? n.pathname === l.href : i === l.href.substring(1), d = `block transition-colors duration-200 ${a ? `text-sm ${c ? "text-primary font-semibold" : "text-muted-foreground hover:text-text"}` : `font-medium ${c ? "text-primary" : "text-text hover:text-primary"}`}`;
    return /* @__PURE__ */ ve("li", { children: [
      u ? /* @__PURE__ */ H(Ev, { to: l.href, className: d, children: l.label }) : /* @__PURE__ */ H("a", { href: l.href, className: d, children: l.label }),
      l.children && o(l.children, !0)
    ] }, l.href);
  }) });
  return /* @__PURE__ */ H("nav", { className: `sticky top-24 w-56 h-[calc(100vh-7rem)] overflow-y-auto pr-4 ${r || ""}`, children: o(e) });
}, Hbe = ({ steps: e, currentStep: t, className: r }) => /* @__PURE__ */ H("div", { className: `flex justify-between items-start ${r || ""}`, children: e.map((i, n) => {
  const o = n < t, s = n === t, a = n > t;
  return /* @__PURE__ */ ve(D.Fragment, { children: [
    /* @__PURE__ */ ve("div", { className: "flex flex-col items-center text-center", children: [
      /* @__PURE__ */ H(
        "div",
        {
          className: `w-8 h-8 rounded-full flex items-center justify-center border-2 transition-all duration-300
                  ${o ? "bg-primary border-primary text-white" : ""}
                  ${s ? "bg-card border-primary text-primary" : ""}
                  ${a ? "bg-card border-border text-text-light" : ""}
                `,
          children: o ? /* @__PURE__ */ H(Hi, { name: "check", size: 16 }) : /* @__PURE__ */ H("span", { children: n + 1 })
        }
      ),
      /* @__PURE__ */ ve("div", { className: "mt-2", children: [
        /* @__PURE__ */ H("p", { className: `font-semibold text-sm ${s ? "text-primary" : "text-text"}`, children: i.label }),
        i.summary && /* @__PURE__ */ H("p", { className: "text-xs text-text-light mt-1", children: i.summary })
      ] })
    ] }),
    n < e.length - 1 && /* @__PURE__ */ H("div", { className: "flex-1 mt-4 mx-2 h-0.5", children: /* @__PURE__ */ H(
      "div",
      {
        className: `h-full w-full rounded-full transition-colors duration-300 ${n < t ? "bg-primary" : "bg-border"}`
      }
    ) })
  ] }, n);
}) }), Bbe = ({ children: e }) => /* @__PURE__ */ H("div", { role: "tabpanel", className: "p-4 bg-card rounded-b-lg border border-t-0 border-border", children: e }), Wbe = ({ children: e, defaultActiveTab: t, className: r }) => {
  const i = Ee(() => t || (e.length > 0 ? e[0].props.id : ""), [e, t]), [n, o] = ee(i), s = fe((a) => {
    o(a);
  }, []);
  return /* @__PURE__ */ ve("div", { className: r, children: [
    /* @__PURE__ */ H("div", { className: "flex border-b border-border mb-px", role: "tablist", children: e.map((a) => /* @__PURE__ */ ve(
      "button",
      {
        id: `tab-${a.props.id}`,
        role: "tab",
        "aria-controls": a.props.id,
        "aria-selected": n === a.props.id,
        onClick: () => s(a.props.id),
        className: `inline-flex items-center px-4 py-2 text-text text-lg font-medium border-b-2 transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 ${n === a.props.id ? "border-primary" : "border-transparent hover:border-border"}`,
        children: [
          a.props.icon && /* @__PURE__ */ H("span", { className: "mr-2 h-5 w-5", children: a.props.icon }),
          a.props.label
        ]
      },
      a.props.id
    )) }),
    e.find((a) => a.props.id === n)
  ] });
}, zye = (e) => {
  const r = Math.round(((/* @__PURE__ */ new Date()).getTime() - e.getTime()) / 1e3), i = Math.round(r / 60), n = Math.round(i / 60), o = Math.round(n / 24);
  return r < 60 ? `${r} seconds ago` : i < 60 ? `${i} minutes ago` : n < 24 ? `${n} hours ago` : o === 1 ? "Yesterday" : `${o} days ago`;
}, Uye = ({ item: e, isLast: t }) => /* @__PURE__ */ ve("div", { className: "flex gap-4", children: [
  /* @__PURE__ */ ve("div", { className: "relative flex flex-col items-center", children: [
    /* @__PURE__ */ H("div", { className: "relative z-10 h-3 w-3 rounded-full bg-border" }),
    !t && /* @__PURE__ */ H("div", { className: "absolute top-3 left-1/2 h-full w-px bg-border -translate-x-1/2" })
  ] }),
  /* @__PURE__ */ ve("div", { className: "flex-grow pb-8", children: [
    /* @__PURE__ */ ve("p", { className: "text-sm text-muted-foreground", children: [
      zye(e.timestamp),
      " by ",
      /* @__PURE__ */ H("span", { className: "font-medium text-text", children: e.author })
    ] }),
    /* @__PURE__ */ H("p", { className: "text-sm mt-1 font-semibold text-text", children: e.action })
  ] })
] }), $be = ({ items: e, title: t }) => /* @__PURE__ */ ve(Oa, { padding: "p-6", children: [
  /* @__PURE__ */ H("h3", { className: "text-xl font-bold text-text mb-4", children: t }),
  /* @__PURE__ */ H("div", { children: e.map((r, i) => /* @__PURE__ */ H(
    Uye,
    {
      item: r,
      isLast: i === e.length - 1
    },
    r.id
  )) }),
  /* @__PURE__ */ H("a", { href: "#", className: "text-sm font-semibold text-primary hover:underline", children: "View changelog " })
] }), jbe = ({ title: e, description: t, actions: r, className: i }) => /* @__PURE__ */ ve("div", { className: `flex flex-col md:flex-row md:items-center md:justify-between gap-4 py-4 border-b border-border ${i || ""}`, children: [
  /* @__PURE__ */ ve("div", { className: "flex-grow", children: [
    /* @__PURE__ */ H("h1", { className: "text-3xl font-bold text-text", children: e }),
    t && /* @__PURE__ */ H("p", { className: "mt-1 text-text-light", children: t })
  ] }),
  r && /* @__PURE__ */ H("div", { className: "flex-shrink-0", children: r })
] }), Yye = {
  primary: "bg-primary text-primary-foreground",
  secondary: "bg-secondary text-secondary-foreground",
  danger: "bg-danger text-danger-foreground",
  success: "bg-green-500 text-white",
  outline: "text-foreground border border-border"
}, Xye = ({
  children: e,
  variant: t = "primary",
  className: r = ""
}) => {
  const i = "inline-flex items-center rounded-md px-2.5 py-0.5 text-xs font-semibold", n = Yye[t];
  return /* @__PURE__ */ H("span", { className: `${i} ${n} ${r}`, children: e });
}, zbe = ({
  title: e,
  value: t,
  icon: r,
  changeText: i,
  changeDirection: n,
  footerText: o,
  className: s
}) => {
  const a = n === "positive" ? "success" : "danger";
  return /* @__PURE__ */ ve(Oa, { padding: "p-4", className: `flex flex-col ${s || ""}`, children: [
    /* @__PURE__ */ ve("div", { className: "flex items-center text-text-light mb-2", children: [
      /* @__PURE__ */ H(Hi, { name: r, size: 16, className: "mr-2" }),
      /* @__PURE__ */ H("span", { className: "text-sm font-medium", children: e })
    ] }),
    /* @__PURE__ */ ve("div", { className: "flex-grow", children: [
      /* @__PURE__ */ H("p", { className: "text-3xl font-bold text-text", children: t }),
      i && /* @__PURE__ */ ve("div", { className: "flex items-center mt-1 text-sm", children: [
        /* @__PURE__ */ H(Xye, { variant: a, children: n === "positive" ? "" : "" }),
        /* @__PURE__ */ H("span", { className: "ml-2 text-text-light", children: i })
      ] })
    ] }),
    o && /* @__PURE__ */ H("div", { className: "mt-4 pt-2 border-t border-border", children: /* @__PURE__ */ H("p", { className: "text-xs text-text-light", children: o }) })
  ] });
}, Ube = ({ src: e, name: t, size: r = "md", className: i }) => {
  const n = (s) => {
    const a = s.split(" ");
    return a.length > 1 ? `${a[0][0]}${a[a.length - 1][0]}`.toUpperCase() : s.substring(0, 2).toUpperCase();
  };
  return /* @__PURE__ */ H(
    "div",
    {
      className: `relative inline-flex items-center justify-center rounded-full bg-secondary text-white ${{
        sm: "h-8 w-8 text-xs",
        md: "h-12 w-12 text-base",
        lg: "h-16 w-16 text-xl"
      }[r]} ${i || ""}`,
      children: e ? /* @__PURE__ */ H("img", { src: e, alt: t, className: "h-full w-full rounded-full object-cover" }) : /* @__PURE__ */ H("span", { className: "font-semibold", children: n(t) })
    }
  );
}, Ybe = ({
  onClick: e,
  className: t = "",
  tooltipContent: r = "Open AI Assistant"
}) => /* @__PURE__ */ H(_ce, { content: r, placement: "left", children: /* @__PURE__ */ H(
  "button",
  {
    onClick: e,
    "aria-label": r,
    className: `
          w-14 h-14
          bg-primary text-primary-foreground 
          rounded-full
          flex items-center justify-center
          shadow-lg
          hover:bg-primary/90
          focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2
          transition-all duration-200 ease-in-out
          hover:scale-110
          active:scale-100
          ${t}
        `,
    children: /* @__PURE__ */ H(Hi, { name: "bot", size: 28 })
  }
) });
export {
  Pbe as Accordion,
  Rbe as AccordionItem,
  Ege as ActionBar,
  $be as ActivityFeed,
  mbe as Alert,
  Ube as Avatar,
  Xye as Badge,
  tbe as BarChart,
  Lbe as BreadcrumbItem,
  Gbe as Breadcrumbs,
  Uo as Button,
  ybe as ButtonGroup,
  Oa as Card,
  ibe as ChartWithTable,
  Ybe as ChatFAB,
  Lce as Checkbox,
  bbe as ComboBox,
  gbe as DataTable,
  wbe as DatePicker,
  Fbe as DefinitionDescription,
  _be as DefinitionList,
  Mbe as DefinitionTerm,
  mne as Drawer,
  bne as EmptyState,
  Sbe as FileUpload,
  Ebe as FormTemplate,
  Hi as Icon,
  Hh as Input,
  nbe as LineChart,
  Obe as List,
  Ibe as ListItem,
  yne as Menu,
  rbe as MenuDivider,
  FT as MenuItem,
  Nbe as Modal,
  xbe as MultiSelect,
  jbe as PageHeader,
  kbe as Pagination,
  obe as PieChart,
  wge as Radio,
  Abe as SearchInput,
  Sge as SectionHeader,
  bge as Select,
  Vbe as SideNav,
  zbe as StatCard,
  Hbe as Stepper,
  Bbe as TabPanel,
  wne as Table,
  Wbe as Tabs,
  rye as Textarea,
  ebe as ThemeProvider,
  _ce as TippyTooltip,
  Nce as Toast,
  Cbe as ToastProvider,
  Dbe as ToggleSwitch,
  fc as availableThemes,
  Tbe as useDataFetch,
  ku as useTheme,
  vbe as useToast
};
